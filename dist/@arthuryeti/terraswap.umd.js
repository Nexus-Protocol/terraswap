(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('crypto'), require('buffer'), require('util'), require('events'), require('string_decoder/'), require('https'), require('http'), require('net'), require('tls'), require('stream'), require('url'), require('zlib'), require('fs'), require('path'), require('os'), require('react/jsx-runtime'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'crypto', 'buffer', 'util', 'events', 'string_decoder/', 'https', 'http', 'net', 'tls', 'stream', 'url', 'zlib', 'fs', 'path', 'os', 'react/jsx-runtime', 'react-dom'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ArthuryetiTerraswap = {}, global.React, global.require$$0$5, global.require$$0$6, global.require$$0$7, global.require$$0$8, global.require$$10, global.require$$1$3, global.require$$2$3, global.require$$3$2, global.require$$4$1, global.require$$0$b, global.require$$7$1, global.require$$0$a, global.require$$0$9, global.require$$1$2, global.require$$2$2, global.jsxRuntime, global.ReactDom));
})(this, (function (exports, React$1, require$$0$5, require$$0$6, require$$0$7, require$$0$8, require$$10, require$$1$3, require$$2$3, require$$3$2, require$$4$1, require$$0$b, require$$7$1, require$$0$a, require$$0$9, require$$1$2, require$$2$2, jsxRuntime, ReactDOM) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React$1);
  var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$5);
  var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$6);
  var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$7);
  var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$8);
  var require$$10__default = /*#__PURE__*/_interopDefaultLegacy(require$$10);
  var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$3);
  var require$$2__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$2$3);
  var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3$2);
  var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4$1);
  var require$$0__default$6 = /*#__PURE__*/_interopDefaultLegacy(require$$0$b);
  var require$$7__default = /*#__PURE__*/_interopDefaultLegacy(require$$7$1);
  var require$$0__default$5 = /*#__PURE__*/_interopDefaultLegacy(require$$0$a);
  var require$$0__default$4 = /*#__PURE__*/_interopDefaultLegacy(require$$0$9);
  var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1$2);
  var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2$2);
  var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);

  function isNativeAssetInfo(value) {
    return value.hasOwnProperty("native_token");
  }
  var isNativeToken = function isNativeToken(token) {
    if (token === void 0) {
      token = "";
    }

    return token.startsWith("u");
  };
  var isNativeAsset = function isNativeAsset(info) {
    return "native_token" in info;
  };
  var toAssetInfo = function toAssetInfo(token) {
    if (isNativeToken(token)) {
      return {
        native_token: {
          denom: token
        }
      };
    }

    return {
      token: {
        contract_addr: token
      }
    };
  };
  var toAsset = function toAsset(_ref) {
    var amount = _ref.amount,
        token = _ref.token;
    return {
      amount: amount,
      info: toAssetInfo(token)
    };
  };
  var findAsset = function findAsset(infos, token) {
    var asset = infos.find(function (info) {
      if (isNativeAssetInfo(info)) {
        return info.native_token.denom === token;
      }

      return info.token.contract_addr === token;
    });

    if (!asset) {
      return null;
    }

    return asset;
  };
  var createAsset = function createAsset(amount, route) {
    var from = route[0].from;
    var info = toAssetInfo(from);
    return {
      info: info,
      amount: amount
    };
  };
  var getTokenDenom = function getTokenDenom(info) {
    if (isNativeAssetInfo(info)) {
      return info.native_token.denom;
    }

    return info.token.contract_addr;
  };
  var getTokenDenoms = function getTokenDenoms(infos) {
    return infos.map(function (info) {
      return getTokenDenom(info);
    });
  };

  /*
   *      bignumber.js v9.0.1
   *      A JavaScript library for arbitrary-precision arithmetic.
   *      https://github.com/MikeMcl/bignumber.js
   *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
   *      MIT Licensed.
   *
   *      BigNumber.prototype methods     |  BigNumber methods
   *                                      |
   *      absoluteValue            abs    |  clone
   *      comparedTo                      |  config               set
   *      decimalPlaces            dp     |      DECIMAL_PLACES
   *      dividedBy                div    |      ROUNDING_MODE
   *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
   *      exponentiatedBy          pow    |      RANGE
   *      integerValue                    |      CRYPTO
   *      isEqualTo                eq     |      MODULO_MODE
   *      isFinite                        |      POW_PRECISION
   *      isGreaterThan            gt     |      FORMAT
   *      isGreaterThanOrEqualTo   gte    |      ALPHABET
   *      isInteger                       |  isBigNumber
   *      isLessThan               lt     |  maximum              max
   *      isLessThanOrEqualTo      lte    |  minimum              min
   *      isNaN                           |  random
   *      isNegative                      |  sum
   *      isPositive                      |
   *      isZero                          |
   *      minus                           |
   *      modulo                   mod    |
   *      multipliedBy             times  |
   *      negated                         |
   *      plus                            |
   *      precision                sd     |
   *      shiftedBy                       |
   *      squareRoot               sqrt   |
   *      toExponential                   |
   *      toFixed                         |
   *      toFormat                        |
   *      toFraction                      |
   *      toJSON                          |
   *      toNumber                        |
   *      toPrecision                     |
   *      toString                        |
   *      valueOf                         |
   *
   */
  var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
      mathceil = Math.ceil,
      mathfloor$1 = Math.floor,
      bignumberError = '[BigNumber Error] ',
      tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',
      BASE$1 = 1e14,
      LOG_BASE$1 = 14,
      MAX_SAFE_INTEGER$1 = 0x1fffffffffffff,
      // 2^53 - 1
  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
      SQRT_BASE = 1e7,
      // EDITABLE
  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
  // the arguments to toExponential, toFixed, toFormat, and toPrecision.
  MAX = 1E9; // 0 to MAX_INT32

  /*
   * Create and return a BigNumber constructor.
   */

  function clone$1(configObject) {
    var div,
        convertBase,
        parseNumeric,
        P = BigNumber.prototype = {
      constructor: BigNumber,
      toString: null,
      valueOf: null
    },
        ONE = new BigNumber(1),
        //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------
    // The default values below must be integers within the inclusive ranges stated.
    // The values can also be changed at run-time using BigNumber.set.
    // The maximum number of decimal places for operations involving division.
    DECIMAL_PLACES = 20,
        // 0 to MAX
    // The rounding mode used when rounding to the above decimal places, and when using
    // toExponential, toFixed, toFormat and toPrecision, and round (default value).
    // UP         0 Away from zero.
    // DOWN       1 Towards zero.
    // CEIL       2 Towards +Infinity.
    // FLOOR      3 Towards -Infinity.
    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    ROUNDING_MODE = 4,
        // 0 to 8
    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
    // The exponent value at and beneath which toString returns exponential notation.
    // Number type: -7
    TO_EXP_NEG = -7,
        // 0 to -MAX
    // The exponent value at and above which toString returns exponential notation.
    // Number type: 21
    TO_EXP_POS = 21,
        // 0 to MAX
    // RANGE : [MIN_EXP, MAX_EXP]
    // The minimum exponent value, beneath which underflow to zero occurs.
    // Number type: -324  (5e-324)
    MIN_EXP = -1e7,
        // -1 to -MAX
    // The maximum exponent value, above which overflow to Infinity occurs.
    // Number type:  308  (1.7976931348623157e+308)
    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
    MAX_EXP = 1e7,
        // 1 to MAX
    // Whether to use cryptographically-secure random number generation, if available.
    CRYPTO = false,
        // true or false
    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP        0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN      1 The remainder has the same sign as the dividend.
    //             This modulo mode is commonly known as 'truncated division' and is
    //             equivalent to (a % n) in JavaScript.
    // FLOOR     3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
    //             The remainder is always positive.
    //
    // The truncated division, floored division, Euclidian division and IEEE 754 remainder
    // modes are commonly used for the modulus operation.
    // Although the other rounding modes can also be used, they may not give useful results.
    MODULO_MODE = 1,
        // 0 to 9
    // The maximum number of significant digits of the result of the exponentiatedBy operation.
    // If POW_PRECISION is 0, there will be unlimited significant digits.
    POW_PRECISION = 0,
        // 0 to MAX
    // The format specification used by the BigNumber.prototype.toFormat method.
    FORMAT = {
      prefix: '',
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ',',
      decimalSeparator: '.',
      fractionGroupSize: 0,
      fractionGroupSeparator: '\xA0',
      // non-breaking space
      suffix: ''
    },
        // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
    // '-', '.', whitespace, or repeated character.
    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz'; //------------------------------------------------------------------------------------------
    // CONSTRUCTOR

    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */

    function BigNumber(v, b) {
      var alphabet,
          c,
          caseChanged,
          e,
          i,
          isNum,
          len,
          str,
          x = this; // Enable constructor call without `new`.

      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {
        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {
          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1; // Fast path for integers, where n < 2147483648 (2**31).

          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++) {
            }

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {
          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        } // Decimal point?


        if ((e = str.indexOf('.')) > -1) str = str.replace('.', ''); // Exponential form?

        if ((i = str.search(/e/i)) > 0) {
          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          // Integer.
          e = str.length;
        }
      } else {
        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base'); // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.

        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {
          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1; // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'

          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error(tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0; // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.

        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {
              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {
              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        } // Prevent later check for length on converted number.


        isNum = false;
        str = convertBase(str, b, 10, x.s); // Decimal point?

        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');else e = str.length;
      } // Determine leading zeros.


      for (i = 0; str.charCodeAt(i) === 48; i++) {
      } // Determine trailing zeros.


      for (len = str.length; str.charCodeAt(--len) === 48;) {
      }

      if (str = str.slice(i, ++len)) {
        len -= i; // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'

        if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER$1 || v !== mathfloor$1(v))) {
          throw Error(tooManyDigits + x.s * v);
        } // Overflow?


        if ((e = e - i - 1) > MAX_EXP) {
          // Infinity.
          x.c = x.e = null; // Underflow?
        } else if (e < MIN_EXP) {
          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = []; // Transform base
          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.

          i = (e + 1) % LOG_BASE$1;
          if (e < 0) i += LOG_BASE$1; // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE$1; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE$1));
            }

            i = LOG_BASE$1 - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0') {
          }

          x.c.push(+str);
        }
      } else {
        // Zero.
        x.c = [x.e = 0];
      }
    } // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone$1;
    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;
    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                     not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */

    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {
        if (typeof obj == 'object') {
          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          } // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'


          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          } // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'


          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];

            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          } // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'


          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];

            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);

              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error(bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          } // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'


          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];

            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error(bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error(bignumberError + p + ' not true or false: ' + v);
            }
          } // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'


          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          } // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'


          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          } // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'


          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;else throw Error(bignumberError + p + ' not an object: ' + v);
          } // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'


          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p]; // Disallow if only one character,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.

            if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error(bignumberError + p + ' invalid: ' + v);
            }
          }
        } else {
          // '[BigNumber Error] Object expected: {v}'
          throw Error(bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };
    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */


    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;
      var i,
          n,
          c = v.c,
          e = v.e,
          s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor$1(e)) {
          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          } // Calculate number of digits that c[0] should have, based on the exponent.


          i = (e + 1) % LOG_BASE$1;
          if (i < 1) i += LOG_BASE$1; // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {

          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE$1 || n !== mathfloor$1(n)) break out;
            } // Last element cannot be zero, unless it is the only element.


            if (n !== 0) return true;
          }
        } // Infinity/NaN

      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error(bignumberError + 'Invalid BigNumber: ' + v);
    };
    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */


    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };
    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */


    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };
    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */


    BigNumber.random = function () {
      var pow2_53 = 0x20000000000000; // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.

      var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function () {
        return mathfloor$1(Math.random() * pow2_53);
      } : function () {
        return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
      };
      return function (dp) {
        var a,
            b,
            e,
            k,
            v,
            i = 0,
            c = [],
            rand = new BigNumber(ONE);
        if (dp == null) dp = DECIMAL_PLACES;else intCheck(dp, 0, MAX);
        k = mathceil(dp / LOG_BASE$1);

        if (CRYPTO) {
          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {
            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {
              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11); // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251

              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {
                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }

            i = k / 2; // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {
            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {
              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }

            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error(bignumberError + 'crypto unavailable');
          }
        } // Use Math.random.


        if (!CRYPTO) {
          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE$1; // Convert trailing digits to zeros according to dp.

        if (k && dp) {
          v = POWS_TEN[LOG_BASE$1 - dp];
          c[i] = mathfloor$1(k / v) * v;
        } // Remove trailing elements which are zero.


        for (; c[i] === 0; c.pop(), i--) {
        } // Zero?


        if (i < 0) {
          c = [e = 0];
        } else {
          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE$1) {
          } // Count the digits of the first element of c to determine leading zeros, and...


          for (i = 1, v = c[0]; v >= 10; v /= 10, i++) {
          } // adjust the exponent accordingly.


          if (i < LOG_BASE$1) e -= LOG_BASE$1 - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    }();
    /*
    * Return a BigNumber whose value is the sum of the arguments.
    *
    * arguments {number|string|BigNumber}
    */


    BigNumber.sum = function () {
      var i = 1,
          args = arguments,
          sum = new BigNumber(args[0]);

      for (; i < args.length;) {
        sum = sum.plus(args[i++]);
      }

      return sum;
    }; // PRIVATE FUNCTIONS
    // Called by BigNumber and BigNumber.prototype.toString.


    convertBase = function () {
      var decimal = '0123456789';
      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */

      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) {
          }

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      } // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.


      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet,
            d,
            e,
            k,
            r,
            x,
            xc,
            y,
            i = str.indexOf('.'),
            dp = DECIMAL_PLACES,
            rm = ROUNDING_MODE; // Non-integer.

        if (i >= 0) {
          k = POW_PRECISION; // Unlimited precision.

          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k; // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
          y.e = y.c.length;
        } // Convert the number as integer.


        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET)); // xc now represents str as an integer and converted to baseOut. e is the exponent.

        e = k = xc.length; // Remove trailing zeros.

        for (; xc[--k] == 0; xc.pop()) {
        } // Zero?


        if (!xc[0]) return alphabet.charAt(0); // Does str represent an integer? If so, no need for the division.

        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e; // The sign is needed for correct rounding.

          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        } // xc now represents str converted to baseOut.
        // THe index of the rounding digit.


        d = e + dp + 1; // The rounding digit: the digit to the right of the digit that may be rounded up.

        i = xc[d]; // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;
        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7)); // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.

        if (d < 1 || !xc[0]) {
          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {
          // Truncate xc to the required number of decimal places.
          xc.length = d; // Round up?

          if (r) {
            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          } // Determine trailing zeros.


          for (k = xc.length; !xc[--k];) {
          } // E.g. [4, 11, 15] becomes 4bf.


          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++])) {
          } // Add leading zeros, decimal point and trailing zeros as required.


          str = toFixedPoint(str, e, alphabet.charAt(0));
        } // The caller will add the sign.


        return str;
      };
    }(); // Perform division in the specified base. Called by div and convertBase.


    div = function () {
      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m,
            temp,
            xlo,
            xhi,
            carry = 0,
            i = x.length,
            klo = k % SQRT_BASE,
            khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);
        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {
          for (i = cmp = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0; // Subtract b from a.

        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        } // Remove leading zeros.


        for (; !a[0] && a.length > 1; a.splice(0, 1)) {
        }
      } // x: dividend, y: divisor.


      return function (x, y, dp, rm, base) {
        var cmp,
            e,
            i,
            more,
            n,
            prod,
            prodL,
            q,
            qc,
            rem,
            remL,
            rem0,
            xi,
            xL,
            yc0,
            yL,
            yz,
            s = x.s == y.s ? 1 : -1,
            xc = x.c,
            yc = y.c; // Either NaN, Infinity or 0?

        if (!xc || !xc[0] || !yc || !yc[0]) {
          return new BigNumber( // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
          xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE$1;
          e = bitFloor(x.e / LOG_BASE$1) - bitFloor(y.e / LOG_BASE$1);
          s = s / LOG_BASE$1 | 0;
        } // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.


        for (i = 0; yc[i] == (xc[i] || 0); i++) {
        }

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2; // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor$1(base / (yc[0] + 1)); // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {

          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length; // Add zeros to make remainder as long as divisor.

          for (; remL < yL; rem[remL++] = 0) {
          }

          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++; // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0; // Compare divisor and remainder.

            cmp = compare(yc, rem, yL, remL); // If divisor < remainder.

            if (cmp < 0) {
              // Calculate trial digit, n.
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0); // n is how many times the divisor goes into the current remainder.

              n = mathfloor$1(rem0 / yc0); //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {
                // n may be > base only when base is 3.
                if (n >= base) n = base - 1; // product = divisor * trial digit.

                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length; // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.

                while (compare(prod, rem, prodL, remL) == 1) {
                  n--; // Subtract divisor from product.

                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {
                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {
                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                } // product = divisor


                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod); // Subtract product from remainder.

              subtract(rem, prod, remL, base);
              remL = rem.length; // If product was < remainder.

              if (cmp == -1) {
                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++; // Subtract divisor from remainder.

                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0
            // Add the next digit, n, to the result array.


            qc[i++] = n; // Update the remainder.

            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null; // Leading zero?

          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE$1) {
          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) {
          }

          round(q, dp + (q.e = i + e * LOG_BASE$1 - 1) + 1, rm, more); // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    }();
    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */


    function format(n, i, rm, id) {
      var c0, e, ne, len, str;
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      if (!n.c) return n.toString();
      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm); // n.e may have changed if the value was rounded up.

        e = n.e;
        str = coeffToString(n.c);
        len = str.length; // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.
        // Exponential notation.

        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
          // Append zeros?
          for (; len < i; str += '0', len++) {
          }

          str = toExponential(str, e); // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0'); // Append zeros?

          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0') {
            }
          } else {
            i += e - len;

            if (i > 0) {
              if (e + 1 == len) str += '.';

              for (; i--; str += '0') {
              }
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    } // Handle BigNumber.max and BigNumber.min.


    function maxOrMin(args, method) {
      var n,
          i = 1,
          m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]); // If any number is NaN, return NaN.

        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }
    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */


    function normalise(n, c, e) {
      var i = 1,
          j = c.length; // Remove trailing zeros.

      for (; !c[--j]; c.pop()) {
      } // Calculate the base 10 exponent. First get the number of digits of c[0].


      for (j = c[0]; j >= 10; j /= 10, i++) {
      } // Overflow?


      if ((e = i + e * LOG_BASE$1 - 1) > MAX_EXP) {
        // Infinity.
        n.c = n.e = null; // Underflow?
      } else if (e < MIN_EXP) {
        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    } // Handle values that fail the validity test in BigNumber.


    parseNumeric = function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
          dotAfter = /^([^.]+)\.$/,
          dotBefore = /^\.([^.]+)$/,
          isInfinityOrNaN = /^-?(Infinity|NaN)$/,
          whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function (x, str, isNum, b) {
        var base,
            s = isNum ? str : str.replace(whitespaceOrPlus, ''); // No exception on ±Infinity or NaN.

        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {
            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b; // E.g. '1.' to '1', '.1' to '0.1'

              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          } // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'


          if (BigNumber.DEBUG) {
            throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          } // NaN


          x.s = null;
        }

        x.c = x.e = null;
      };
    }();
    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */


    function round(x, sd, rm, r) {
      var d,
          i,
          j,
          k,
          n,
          ni,
          rd,
          xc = x.c,
          pows10 = POWS_TEN; // if x is not Infinity or NaN...

      if (xc) {
        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {
          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) {
          }

          i = sd - d; // If the rounding digit is in the first element of xc...

          if (i < 0) {
            i += LOG_BASE$1;
            j = sd;
            n = xc[ni = 0]; // Get the rounding digit at index j of n.

            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE$1);

            if (ni >= xc.length) {
              if (r) {
                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0)) {
                }

                n = rd = 0;
                d = 1;
                i %= LOG_BASE$1;
                j = i - LOG_BASE$1 + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni]; // Get the number of digits of n.

              for (d = 1; k >= 10; k /= 10, d++) {
              } // Get the index of rd within n.


              i %= LOG_BASE$1; // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.

              j = i - LOG_BASE$1 + d; // Get the rounding digit at index j of n.

              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
          xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {
              // Convert sd to decimal places.
              sd -= x.e + 1; // 1, 0.1, 0.01, 0.001, 0.0001 etc.

              xc[0] = pows10[(LOG_BASE$1 - sd % LOG_BASE$1) % LOG_BASE$1];
              x.e = -sd || 0;
            } else {
              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          } // Remove excess digits.


          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE$1 - i]; // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.

            xc[ni] = j > 0 ? mathfloor$1(n / pows10[d - j] % pows10[j]) * k : 0;
          } // Round up?


          if (r) {
            for (;;) {
              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {
                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) {
                }

                j = xc[0] += k;

                for (k = 1; j >= 10; j /= 10, k++) {
                } // if i != k the length has increased.


                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE$1) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE$1) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          } // Remove trailing zeros.


          for (i = xc.length; xc[--i] === 0; xc.pop()) {
          }
        } // Overflow? Infinity.


        if (x.e > MAX_EXP) {
          x.c = x.e = null; // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }

    function valueOf(n) {
      var str,
          e = n.e;
      if (e === null) return n.toString();
      str = coeffToString(n.c);
      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
      return n.s < 0 ? '-' + str : str;
    } // PROTOTYPE/INSTANCE METHODS

    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */


    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };
    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */


    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };
    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */


    P.decimalPlaces = P.dp = function (dp, rm) {
      var c,
          n,
          v,
          x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE$1)) * LOG_BASE$1; // Subtract the number of trailing zeros of the last number.

      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) {
      }
      if (n < 0) n = 0;
      return n;
    };
    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */


    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };
    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */


    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };
    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */


    P.exponentiatedBy = P.pow = function (n, m) {
      var half,
          isModExp,
          i,
          k,
          more,
          nIsBig,
          nIsNeg,
          nIsOdd,
          y,
          x = this;
      n = new BigNumber(n); // Allow NaN and ±Infinity, but not other non-integers.

      if (n.c && !n.isInteger()) {
        throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m); // Exponent of MAX_SAFE_INTEGER is 15.

      nIsBig = n.e > 14; // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.

      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd$1(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {
        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
        if (isModExp) x = x.mod(m); // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
        // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 // [1, 240000000]
      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 // [80000000000000]  [99999750000000]
      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd$1(n) ? -0 : 0; // If x >= 1, k = ±Infinity.

        if (x.e > -1) k = 1 / k; // If n is negative return ±0, else return ±Infinity.

        return new BigNumber(nIsNeg ? 1 / k : k);
      } else if (POW_PRECISION) {
        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE$1 + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd$1(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE); // Performs 54 loop iterations for n of 9007199254740991.

      for (;;) {
        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor$1(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd$1(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);
      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };
    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */


    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };
    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */


    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };
    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */


    P.isFinite = function () {
      return !!this.c;
    };
    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */


    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };
    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */


    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
    };
    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */


    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE$1) > this.c.length - 2;
    };
    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */


    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };
    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */


    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };
    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */


    P.isNaN = function () {
      return !this.s;
    };
    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */


    P.isNegative = function () {
      return this.s < 0;
    };
    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */


    P.isPositive = function () {
      return this.s > 0;
    };
    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */


    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };
    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */


    P.minus = function (y, b) {
      var i,
          j,
          t,
          xLTy,
          x = this,
          a = x.s;
      y = new BigNumber(y, b);
      b = y.s; // Either NaN?

      if (!a || !b) return new BigNumber(NaN); // Signs differ?

      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE$1,
          ye = y.e / LOG_BASE$1,
          xc = x.c,
          yc = y.c;

      if (!xe || !ye) {
        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN); // Either zero?

        if (!xc[0] || !yc[0]) {
          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice(); // Determine which is the bigger number.

      if (a = xe - ye) {
        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse(); // Prepend zeros to equalise exponents.

        for (b = a; b--; t.push(0)) {
        }

        t.reverse();
      } else {
        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {
          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      } // x < y? Point xc to the array of the bigger number.


      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;
      b = (j = yc.length) - (i = xc.length); // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.

      if (b > 0) for (; b--; xc[i++] = 0) {
      }
      b = BASE$1 - 1; // Subtract yc from xc.

      for (; j > a;) {
        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b) {
          }

          --xc[i];
          xc[j] += BASE$1;
        }

        xc[j] -= yc[j];
      } // Remove leading zeros and adjust exponent accordingly.


      for (; xc[0] == 0; xc.splice(0, 1), --ye) {
      } // Zero?


      if (!xc[0]) {
        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      } // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.


      return normalise(y, xc, ye);
    };
    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */


    P.modulo = P.mod = function (y, b) {
      var q,
          s,
          x = this;
      y = new BigNumber(y, b); // Return NaN if x is Infinity or NaN, or y is NaN or zero.

      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN); // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {
        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y)); // To match JavaScript %, ensure sign of zero is sign of dividend.

      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
      return y;
    };
    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */


    P.multipliedBy = P.times = function (y, b) {
      var c,
          e,
          i,
          j,
          k,
          m,
          xcL,
          xlo,
          xhi,
          ycL,
          ylo,
          yhi,
          zc,
          base,
          sqrtBase,
          x = this,
          xc = x.c,
          yc = (y = new BigNumber(y, b)).c; // Either NaN, ±Infinity or ±0?

      if (!xc || !yc || !xc[0] || !yc[0]) {
        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s; // Return ±Infinity if either is ±Infinity.

          if (!xc || !yc) {
            y.c = y.e = null; // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE$1) + bitFloor(y.e / LOG_BASE$1);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length; // Ensure xc points to longer array and xcL to its length.

      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i; // Initialise the result array with zeros.

      for (i = xcL + ycL, zc = []; i--; zc.push(0)) {
      }

      base = BASE$1;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };
    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */


    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };
    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */


    P.plus = function (y, b) {
      var t,
          x = this,
          a = x.s;
      y = new BigNumber(y, b);
      b = y.s; // Either NaN?

      if (!a || !b) return new BigNumber(NaN); // Signs differ?

      if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE$1,
          ye = y.e / LOG_BASE$1,
          xc = x.c,
          yc = y.c;

      if (!xe || !ye) {
        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0); // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.

        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice(); // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.

      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();

        for (; a--; t.push(0)) {
        }

        t.reverse();
      }

      a = xc.length;
      b = yc.length; // Point xc to the longer array, and b to the shorter length.

      if (a - b < 0) t = yc, yc = xc, xc = t, b = a; // Only start adding at yc.length - 1 as the further digits of xc can be ignored.

      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE$1 | 0;
        xc[b] = BASE$1 === xc[b] ? 0 : xc[b] % BASE$1;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      } // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible


      return normalise(y, xc, ye);
    };
    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */


    P.precision = P.sd = function (sd, rm) {
      var c,
          n,
          v,
          x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE$1 + 1;

      if (v = c[v]) {
        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--) {
        } // Add the number of digits of the first element.


        for (v = c[0]; v >= 10; v /= 10, n++) {
        }
      }

      if (sd && x.e + 1 > n) n = x.e + 1;
      return n;
    };
    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */


    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER$1, MAX_SAFE_INTEGER$1);
      return this.times('1e' + k);
    };
    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */


    P.squareRoot = P.sqrt = function () {
      var m,
          n,
          r,
          rep,
          t,
          x = this,
          c = x.c,
          s = x.s,
          e = x.e,
          dp = DECIMAL_PLACES + 4,
          half = new BigNumber('0.5'); // Negative/NaN/Infinity/zero?

      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      } // Initial estimate.


      s = Math.sqrt(+valueOf(x)); // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.

      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      } // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.


      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0; // Newton-Raphson iteration.

        for (;;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.

            if (n == '9999' || !rep && n == '4999') {
              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {
              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };
    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */


    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }

      return format(this, dp, rm, 1);
    };
    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */


    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }

      return format(this, dp, rm);
    };
    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */


    P.toFormat = function (dp, rm, format) {
      var str,
          x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error(bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
            arr = str.split('.'),
            g1 = +format.groupSize,
            g2 = +format.secondaryGroupSize,
            groupSeparator = format.groupSeparator || '',
            intPart = arr[0],
            fractionPart = arr[1],
            isNeg = x.s < 0,
            intDigits = isNeg ? intPart.slice(1) : intPart,
            len = intDigits.length;
        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);

          for (; i < len; i += g1) {
            intPart += groupSeparator + intDigits.substr(i, g1);
          }

          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };
    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */


    P.toFraction = function (md) {
      var d,
          d0,
          d1,
          d2,
          e,
          exp,
          n,
          n0,
          n1,
          q,
          r,
          s,
          x = this,
          xc = x.c;

      if (md != null) {
        n = new BigNumber(md); // Throw if md is less than one or is not an integer, unless it is Infinity.

        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);
      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc); // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.

      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE$1) < 0 ? LOG_BASE$1 + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s); // n0 = d1 = 0

      n0.c[0] = 0;

      for (;;) {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2; // Determine which fraction is closer to x, n0/d0 or n1/d1

      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
      MAX_EXP = exp;
      return r;
    };
    /*
     * Return the value of this BigNumber converted to a number primitive.
     */


    P.toNumber = function () {
      return +valueOf(this);
    };
    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */


    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };
    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */


    P.toString = function (b) {
      var str,
          n = this,
          s = n.s,
          e = n.e; // Infinity or NaN?

      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };
    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */


    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };

    P._isBigNumber = true;
    P[Symbol.toStringTag] = 'BigNumber'; // Node.js v10.12.0+

    P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
    if (configObject != null) BigNumber.set(configObject);
    return BigNumber;
  } // PRIVATE HELPER FUNCTIONS
  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  } // Return a coefficient array as a string of base 10 digits.


  function coeffToString(a) {
    var s,
        z,
        i = 1,
        j = a.length,
        r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE$1 - s.length;

      for (; z--; s = '0' + s) {
      }

      r += s;
    } // Determine trailing zeros.


    for (j = r.length; r.charCodeAt(--j) === 48;) {
    }

    return r.slice(0, j + 1 || 1);
  } // Compare the value of BigNumbers x and y.


  function compare(x, y) {
    var a,
        b,
        xc = x.c,
        yc = y.c,
        i = x.s,
        j = y.s,
        k = x.e,
        l = y.e; // Either NaN?

    if (!i || !j) return null;
    a = xc && !xc[0];
    b = yc && !yc[0]; // Either zero?

    if (a || b) return a ? b ? 0 : -j : i; // Signs differ?

    if (i != j) return i;
    a = i < 0;
    b = k == l; // Either Infinity?

    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1; // Compare exponents.

    if (!b) return k > l ^ a ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l; // Compare digit by digit.

    for (i = 0; i < j; i++) {
      if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
    } // Compare lengths.


    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }
  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */


  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor$1(n)) {
      throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
    }
  } // Assumes finite n.


  function isOdd$1(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE$1) == k && n.c[k] % 2 != 0;
  }

  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
  }

  function toFixedPoint(str, e, z) {
    var len, zs; // Negative exponent?

    if (e < 0) {
      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z) {
      }

      str = zs + str; // Positive exponent
    } else {
      len = str.length; // Append zeros.

      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z) {
        }

        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  } // EXPORT


  var BigNumber = clone$1();

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  function commonjsRequire (path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  var numeral = {exports: {}};

  /*! @preserve
   * numeral.js
   * version : 2.0.6
   * author : Adam Draper
   * license : MIT
   * http://adamwdraper.github.com/Numeral-js/
   */

  (function (module) {
    (function (global, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        global.numeral = factory();
      }
    })(commonjsGlobal, function () {
      /************************************
          Variables
      ************************************/
      var _numeral,
          _,
          VERSION = '2.0.6',
          formats = {},
          locales = {},
          defaults = {
        currentLocale: 'en',
        zeroFormat: null,
        nullFormat: null,
        defaultFormat: '0,0',
        scalePercentBy100: true
      },
          options = {
        currentLocale: defaults.currentLocale,
        zeroFormat: defaults.zeroFormat,
        nullFormat: defaults.nullFormat,
        defaultFormat: defaults.defaultFormat,
        scalePercentBy100: defaults.scalePercentBy100
      };
      /************************************
          Constructors
      ************************************/
      // Numeral prototype object


      function Numeral(input, number) {
        this._input = input;
        this._value = number;
      }

      _numeral = function numeral(input) {
        var value, kind, unformatFunction, regexp;

        if (_numeral.isNumeral(input)) {
          value = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
          value = 0;
        } else if (input === null || _.isNaN(input)) {
          value = null;
        } else if (typeof input === 'string') {
          if (options.zeroFormat && input === options.zeroFormat) {
            value = 0;
          } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
            value = null;
          } else {
            for (kind in formats) {
              regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;

              if (regexp && input.match(regexp)) {
                unformatFunction = formats[kind].unformat;
                break;
              }
            }

            unformatFunction = unformatFunction || _numeral._.stringToNumber;
            value = unformatFunction(input);
          }
        } else {
          value = Number(input) || null;
        }

        return new Numeral(input, value);
      }; // version number


      _numeral.version = VERSION; // compare numeral object

      _numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
      }; // helper functions


      _numeral._ = _ = {
        // formats numbers separators, decimals places, signs, abbreviations
        numberToFormat: function numberToFormat(value, format, roundingFunction) {
          var locale = locales[_numeral.options.currentLocale],
              negP = false,
              optDec = false,
              leadingCount = 0,
              abbr = '',
              trillion = 1000000000000,
              billion = 1000000000,
              million = 1000000,
              thousand = 1000,
              decimal = '',
              neg = false,
              abbrForce,
              // force abbreviation
          abs,
              int,
              precision,
              signed,
              thousands,
              output; // make sure we never format a null value

          value = value || 0;
          abs = Math.abs(value); // see if we should use parentheses for negative number or if we should prefix with a sign
          // if both are present we default to parentheses

          if (_numeral._.includes(format, '(')) {
            negP = true;
            format = format.replace(/[\(|\)]/g, '');
          } else if (_numeral._.includes(format, '+') || _numeral._.includes(format, '-')) {
            signed = _numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
            format = format.replace(/[\+|\-]/g, '');
          } // see if abbreviation is wanted


          if (_numeral._.includes(format, 'a')) {
            abbrForce = format.match(/a(k|m|b|t)?/);
            abbrForce = abbrForce ? abbrForce[1] : false; // check for space before abbreviation

            if (_numeral._.includes(format, ' a')) {
              abbr = ' ';
            }

            format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

            if (abs >= trillion && !abbrForce || abbrForce === 't') {
              // trillion
              abbr += locale.abbreviations.trillion;
              value = value / trillion;
            } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {
              // billion
              abbr += locale.abbreviations.billion;
              value = value / billion;
            } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {
              // million
              abbr += locale.abbreviations.million;
              value = value / million;
            } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {
              // thousand
              abbr += locale.abbreviations.thousand;
              value = value / thousand;
            }
          } // check for optional decimals


          if (_numeral._.includes(format, '[.]')) {
            optDec = true;
            format = format.replace('[.]', '.');
          } // break number and format


          int = value.toString().split('.')[0];
          precision = format.split('.')[1];
          thousands = format.indexOf(',');
          leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

          if (precision) {
            if (_numeral._.includes(precision, '[')) {
              precision = precision.replace(']', '');
              precision = precision.split('[');
              decimal = _numeral._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
            } else {
              decimal = _numeral._.toFixed(value, precision.length, roundingFunction);
            }

            int = decimal.split('.')[0];

            if (_numeral._.includes(decimal, '.')) {
              decimal = locale.delimiters.decimal + decimal.split('.')[1];
            } else {
              decimal = '';
            }

            if (optDec && Number(decimal.slice(1)) === 0) {
              decimal = '';
            }
          } else {
            int = _numeral._.toFixed(value, 0, roundingFunction);
          } // check abbreviation again after rounding


          if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
            int = String(Number(int) / 1000);

            switch (abbr) {
              case locale.abbreviations.thousand:
                abbr = locale.abbreviations.million;
                break;

              case locale.abbreviations.million:
                abbr = locale.abbreviations.billion;
                break;

              case locale.abbreviations.billion:
                abbr = locale.abbreviations.trillion;
                break;
            }
          } // format number


          if (_numeral._.includes(int, '-')) {
            int = int.slice(1);
            neg = true;
          }

          if (int.length < leadingCount) {
            for (var i = leadingCount - int.length; i > 0; i--) {
              int = '0' + int;
            }
          }

          if (thousands > -1) {
            int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
          }

          if (format.indexOf('.') === 0) {
            int = '';
          }

          output = int + decimal + (abbr ? abbr : '');

          if (negP) {
            output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
          } else {
            if (signed >= 0) {
              output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
            } else if (neg) {
              output = '-' + output;
            }
          }

          return output;
        },
        // unformats numbers separators, decimals places, signs, abbreviations
        stringToNumber: function stringToNumber(string) {
          var locale = locales[options.currentLocale],
              stringOriginal = string,
              abbreviations = {
            thousand: 3,
            million: 6,
            billion: 9,
            trillion: 12
          },
              abbreviation,
              value,
              regexp;

          if (options.zeroFormat && string === options.zeroFormat) {
            value = 0;
          } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {
            value = null;
          } else {
            value = 1;

            if (locale.delimiters.decimal !== '.') {
              string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
            }

            for (abbreviation in abbreviations) {
              regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');

              if (stringOriginal.match(regexp)) {
                value *= Math.pow(10, abbreviations[abbreviation]);
                break;
              }
            } // check for negative number


            value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1; // remove non numbers

            string = string.replace(/[^0-9\.]+/g, '');
            value *= Number(string);
          }

          return value;
        },
        isNaN: function (_isNaN) {
          function isNaN(_x) {
            return _isNaN.apply(this, arguments);
          }

          isNaN.toString = function () {
            return _isNaN.toString();
          };

          return isNaN;
        }(function (value) {
          return typeof value === 'number' && isNaN(value);
        }),
        includes: function includes(string, search) {
          return string.indexOf(search) !== -1;
        },
        insert: function insert(string, subString, start) {
          return string.slice(0, start) + subString + string.slice(start);
        },
        reduce: function reduce(array, callback
        /*, initialValue*/
        ) {
          if (this === null) {
            throw new TypeError('Array.prototype.reduce called on null or undefined');
          }

          if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
          }

          var t = Object(array),
              len = t.length >>> 0,
              k = 0,
              value;

          if (arguments.length === 3) {
            value = arguments[2];
          } else {
            while (k < len && !(k in t)) {
              k++;
            }

            if (k >= len) {
              throw new TypeError('Reduce of empty array with no initial value');
            }

            value = t[k++];
          }

          for (; k < len; k++) {
            if (k in t) {
              value = callback(value, t[k], k, t);
            }
          }

          return value;
        },

        /**
         * Computes the multiplier necessary to make x >= 1,
         * effectively eliminating miscalculations caused by
         * finite precision.
         */
        multiplier: function multiplier(x) {
          var parts = x.toString().split('.');
          return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
        },

        /**
         * Given a variable number of arguments, returns the maximum
         * multiplier that must be used to normalize an operation involving
         * all of them.
         */
        correctionFactor: function correctionFactor() {
          var args = Array.prototype.slice.call(arguments);
          return args.reduce(function (accum, next) {
            var mn = _.multiplier(next);

            return accum > mn ? accum : mn;
          }, 1);
        },

        /**
         * Implementation of toFixed() that treats floats more like decimals
         *
         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
         * problems for accounting- and finance-related software.
         */
        toFixed: function toFixed(value, maxDecimals, roundingFunction, optionals) {
          var splitValue = value.toString().split('.'),
              minDecimals = maxDecimals - (optionals || 0),
              boundedPrecision,
              optionalsRegExp,
              power,
              output; // Use the smallest precision value possible to avoid errors from floating point representation

          if (splitValue.length === 2) {
            boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
          } else {
            boundedPrecision = minDecimals;
          }

          power = Math.pow(10, boundedPrecision); // Multiply up by precision, round accurately, then divide and use native toFixed():

          output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

          if (optionals > maxDecimals - boundedPrecision) {
            optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
            output = output.replace(optionalsRegExp, '');
          }

          return output;
        }
      }; // avaliable options

      _numeral.options = options; // avaliable formats

      _numeral.formats = formats; // avaliable formats

      _numeral.locales = locales; // This function sets the current locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.

      _numeral.locale = function (key) {
        if (key) {
          options.currentLocale = key.toLowerCase();
        }

        return options.currentLocale;
      }; // This function provides access to the loaded locale data.  If
      // no arguments are passed in, it will simply return the current
      // global locale object.


      _numeral.localeData = function (key) {
        if (!key) {
          return locales[options.currentLocale];
        }

        key = key.toLowerCase();

        if (!locales[key]) {
          throw new Error('Unknown locale : ' + key);
        }

        return locales[key];
      };

      _numeral.reset = function () {
        for (var property in defaults) {
          options[property] = defaults[property];
        }
      };

      _numeral.zeroFormat = function (format) {
        options.zeroFormat = typeof format === 'string' ? format : null;
      };

      _numeral.nullFormat = function (format) {
        options.nullFormat = typeof format === 'string' ? format : null;
      };

      _numeral.defaultFormat = function (format) {
        options.defaultFormat = typeof format === 'string' ? format : '0.0';
      };

      _numeral.register = function (type, name, format) {
        name = name.toLowerCase();

        if (this[type + 's'][name]) {
          throw new TypeError(name + ' ' + type + ' already registered.');
        }

        this[type + 's'][name] = format;
        return format;
      };

      _numeral.validate = function (val, culture) {
        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData, temp; //coerce val to string


        if (typeof val !== 'string') {
          val += '';

          if (console.warn) {
            console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
          }
        } //trim whitespaces from either sides


        val = val.trim(); //if val is just digits return true

        if (!!val.match(/^\d+$/)) {
          return true;
        } //if val is empty return false


        if (val === '') {
          return false;
        } //get the decimal and thousands separator from numeral.localeData


        try {
          //check if the culture is understood by numeral. if not, default it to current locale
          localeData = _numeral.localeData(culture);
        } catch (e) {
          localeData = _numeral.localeData(_numeral.locale());
        } //setup the delimiters and currency symbol based on culture/locale


        _currSymbol = localeData.currency.symbol;
        _abbrObj = localeData.abbreviations;
        _decimalSep = localeData.delimiters.decimal;

        if (localeData.delimiters.thousands === '.') {
          _thousandSep = '\\.';
        } else {
          _thousandSep = localeData.delimiters.thousands;
        } // validating currency symbol


        temp = val.match(/^[^\d]+/);

        if (temp !== null) {
          val = val.substr(1);

          if (temp[0] !== _currSymbol) {
            return false;
          }
        } //validating abbreviation symbol


        temp = val.match(/[^\d]+$/);

        if (temp !== null) {
          val = val.slice(0, -1);

          if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
            return false;
          }
        }

        _thousandRegEx = new RegExp(_thousandSep + '{2}');

        if (!val.match(/[^\d.,]/g)) {
          _valArray = val.split(_decimalSep);

          if (_valArray.length > 2) {
            return false;
          } else {
            if (_valArray.length < 2) {
              return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
            } else {
              if (_valArray[0].length === 1) {
                return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
              } else {
                return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
              }
            }
          }
        }

        return false;
      };
      /************************************
          Numeral Prototype
      ************************************/


      _numeral.fn = Numeral.prototype = {
        clone: function clone() {
          return _numeral(this);
        },
        format: function format(inputString, roundingFunction) {
          var value = this._value,
              format = inputString || options.defaultFormat,
              kind,
              output,
              formatFunction; // make sure we have a roundingFunction

          roundingFunction = roundingFunction || Math.round; // format based on value

          if (value === 0 && options.zeroFormat !== null) {
            output = options.zeroFormat;
          } else if (value === null && options.nullFormat !== null) {
            output = options.nullFormat;
          } else {
            for (kind in formats) {
              if (format.match(formats[kind].regexps.format)) {
                formatFunction = formats[kind].format;
                break;
              }
            }

            formatFunction = formatFunction || _numeral._.numberToFormat;
            output = formatFunction(value, format, roundingFunction);
          }

          return output;
        },
        value: function value() {
          return this._value;
        },
        input: function input() {
          return this._input;
        },
        set: function set(value) {
          this._value = Number(value);
          return this;
        },
        add: function add(value) {
          var corrFactor = _.correctionFactor.call(null, this._value, value);

          function cback(accum, curr, currI, O) {
            return accum + Math.round(corrFactor * curr);
          }

          this._value = _.reduce([this._value, value], cback, 0) / corrFactor;
          return this;
        },
        subtract: function subtract(value) {
          var corrFactor = _.correctionFactor.call(null, this._value, value);

          function cback(accum, curr, currI, O) {
            return accum - Math.round(corrFactor * curr);
          }

          this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;
          return this;
        },
        multiply: function multiply(value) {
          function cback(accum, curr, currI, O) {
            var corrFactor = _.correctionFactor(accum, curr);

            return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
          }

          this._value = _.reduce([this._value, value], cback, 1);
          return this;
        },
        divide: function divide(value) {
          function cback(accum, curr, currI, O) {
            var corrFactor = _.correctionFactor(accum, curr);

            return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
          }

          this._value = _.reduce([this._value, value], cback);
          return this;
        },
        difference: function difference(value) {
          return Math.abs(_numeral(this._value).subtract(value).value());
        }
      };
      /************************************
          Default Locale && Format
      ************************************/

      _numeral.register('locale', 'en', {
        delimiters: {
          thousands: ',',
          decimal: '.'
        },
        abbreviations: {
          thousand: 'k',
          million: 'm',
          billion: 'b',
          trillion: 't'
        },
        ordinal: function ordinal(number) {
          var b = number % 10;
          return ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
          symbol: '$'
        }
      });

      (function () {
        _numeral.register('format', 'bps', {
          regexps: {
            format: /(BPS)/,
            unformat: /(BPS)/
          },
          format: function format(value, _format, roundingFunction) {
            var space = _numeral._.includes(_format, ' BPS') ? ' ' : '',
                output;
            value = value * 10000; // check for space before BPS

            _format = _format.replace(/\s?BPS/, '');
            output = _numeral._.numberToFormat(value, _format, roundingFunction);

            if (_numeral._.includes(output, ')')) {
              output = output.split('');
              output.splice(-1, 0, space + 'BPS');
              output = output.join('');
            } else {
              output = output + space + 'BPS';
            }

            return output;
          },
          unformat: function unformat(string) {
            return +(_numeral._.stringToNumber(string) * 0.0001).toFixed(15);
          }
        });
      })();

      (function () {
        var decimal = {
          base: 1000,
          suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
        },
            binary = {
          base: 1024,
          suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
        };
        var allSuffixes = decimal.suffixes.concat(binary.suffixes.filter(function (item) {
          return decimal.suffixes.indexOf(item) < 0;
        }));
        var unformatRegex = allSuffixes.join('|'); // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)

        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';

        _numeral.register('format', 'bytes', {
          regexps: {
            format: /([0\s]i?b)/,
            unformat: new RegExp(unformatRegex)
          },
          format: function format(value, _format2, roundingFunction) {
            var output,
                bytes = _numeral._.includes(_format2, 'ib') ? binary : decimal,
                suffix = _numeral._.includes(_format2, ' b') || _numeral._.includes(_format2, ' ib') ? ' ' : '',
                power,
                min,
                max; // check for space before

            _format2 = _format2.replace(/\s?i?b/, '');

            for (power = 0; power <= bytes.suffixes.length; power++) {
              min = Math.pow(bytes.base, power);
              max = Math.pow(bytes.base, power + 1);

              if (value === null || value === 0 || value >= min && value < max) {
                suffix += bytes.suffixes[power];

                if (min > 0) {
                  value = value / min;
                }

                break;
              }
            }

            output = _numeral._.numberToFormat(value, _format2, roundingFunction);
            return output + suffix;
          },
          unformat: function unformat(string) {
            var value = _numeral._.stringToNumber(string),
                power,
                bytesMultiplier;

            if (value) {
              for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                if (_numeral._.includes(string, decimal.suffixes[power])) {
                  bytesMultiplier = Math.pow(decimal.base, power);
                  break;
                }

                if (_numeral._.includes(string, binary.suffixes[power])) {
                  bytesMultiplier = Math.pow(binary.base, power);
                  break;
                }
              }

              value *= bytesMultiplier || 1;
            }

            return value;
          }
        });
      })();

      (function () {
        _numeral.register('format', 'currency', {
          regexps: {
            format: /(\$)/
          },
          format: function format(value, _format3, roundingFunction) {
            var locale = _numeral.locales[_numeral.options.currentLocale],
                symbols = {
              before: _format3.match(/^([\+|\-|\(|\s|\$]*)/)[0],
              after: _format3.match(/([\+|\-|\)|\s|\$]*)$/)[0]
            },
                output,
                symbol,
                i; // strip format of spaces and $

            _format3 = _format3.replace(/\s?\$\s?/, ''); // format the number

            output = _numeral._.numberToFormat(value, _format3, roundingFunction); // update the before and after based on value

            if (value >= 0) {
              symbols.before = symbols.before.replace(/[\-\(]/, '');
              symbols.after = symbols.after.replace(/[\-\)]/, '');
            } else if (value < 0 && !_numeral._.includes(symbols.before, '-') && !_numeral._.includes(symbols.before, '(')) {
              symbols.before = '-' + symbols.before;
            } // loop through each before symbol


            for (i = 0; i < symbols.before.length; i++) {
              symbol = symbols.before[i];

              switch (symbol) {
                case '$':
                  output = _numeral._.insert(output, locale.currency.symbol, i);
                  break;

                case ' ':
                  output = _numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
                  break;
              }
            } // loop through each after symbol


            for (i = symbols.after.length - 1; i >= 0; i--) {
              symbol = symbols.after[i];

              switch (symbol) {
                case '$':
                  output = i === symbols.after.length - 1 ? output + locale.currency.symbol : _numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
                  break;

                case ' ':
                  output = i === symbols.after.length - 1 ? output + ' ' : _numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
                  break;
              }
            }

            return output;
          }
        });
      })();

      (function () {
        _numeral.register('format', 'exponential', {
          regexps: {
            format: /(e\+|e-)/,
            unformat: /(e\+|e-)/
          },
          format: function format(value, _format4, roundingFunction) {
            var output,
                exponential = typeof value === 'number' && !_numeral._.isNaN(value) ? value.toExponential() : '0e+0',
                parts = exponential.split('e');
            _format4 = _format4.replace(/e[\+|\-]{1}0/, '');
            output = _numeral._.numberToFormat(Number(parts[0]), _format4, roundingFunction);
            return output + 'e' + parts[1];
          },
          unformat: function unformat(string) {
            var parts = _numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),
                value = Number(parts[0]),
                power = Number(parts[1]);
            power = _numeral._.includes(string, 'e-') ? power *= -1 : power;

            function cback(accum, curr, currI, O) {
              var corrFactor = _numeral._.correctionFactor(accum, curr),
                  num = accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);

              return num;
            }

            return _numeral._.reduce([value, Math.pow(10, power)], cback, 1);
          }
        });
      })();

      (function () {
        _numeral.register('format', 'ordinal', {
          regexps: {
            format: /(o)/
          },
          format: function format(value, _format5, roundingFunction) {
            var locale = _numeral.locales[_numeral.options.currentLocale],
                output,
                ordinal = _numeral._.includes(_format5, ' o') ? ' ' : ''; // check for space before

            _format5 = _format5.replace(/\s?o/, '');
            ordinal += locale.ordinal(value);
            output = _numeral._.numberToFormat(value, _format5, roundingFunction);
            return output + ordinal;
          }
        });
      })();

      (function () {
        _numeral.register('format', 'percentage', {
          regexps: {
            format: /(%)/,
            unformat: /(%)/
          },
          format: function format(value, _format6, roundingFunction) {
            var space = _numeral._.includes(_format6, ' %') ? ' ' : '',
                output;

            if (_numeral.options.scalePercentBy100) {
              value = value * 100;
            } // check for space before %


            _format6 = _format6.replace(/\s?\%/, '');
            output = _numeral._.numberToFormat(value, _format6, roundingFunction);

            if (_numeral._.includes(output, ')')) {
              output = output.split('');
              output.splice(-1, 0, space + '%');
              output = output.join('');
            } else {
              output = output + space + '%';
            }

            return output;
          },
          unformat: function unformat(string) {
            var number = _numeral._.stringToNumber(string);

            if (_numeral.options.scalePercentBy100) {
              return number * 0.01;
            }

            return number;
          }
        });
      })();

      (function () {
        _numeral.register('format', 'time', {
          regexps: {
            format: /(:)/,
            unformat: /(:)/
          },
          format: function format(value, _format7, roundingFunction) {
            var hours = Math.floor(value / 60 / 60),
                minutes = Math.floor((value - hours * 60 * 60) / 60),
                seconds = Math.round(value - hours * 60 * 60 - minutes * 60);
            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
          },
          unformat: function unformat(string) {
            var timeArray = string.split(':'),
                seconds = 0; // turn hours and minutes into seconds and add them all up

            if (timeArray.length === 3) {
              // hours
              seconds = seconds + Number(timeArray[0]) * 60 * 60; // minutes

              seconds = seconds + Number(timeArray[1]) * 60; // seconds

              seconds = seconds + Number(timeArray[2]);
            } else if (timeArray.length === 2) {
              // minutes
              seconds = seconds + Number(timeArray[0]) * 60; // seconds

              seconds = seconds + Number(timeArray[1]);
            }

            return Number(seconds);
          }
        });
      })();

      return _numeral;
    });
  })(numeral);

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var runtime$1 = {exports: {}};

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  (function (module) {
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1; // More compressible than void 0.

      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }

      try {
        // IE 8 has a broken Object.defineProperty that only works on DOM objects.
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.

        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.

      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.


      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define(Gp, "constructor", GeneratorFunctionPrototype);
      define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      }; // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.


      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return PromiseImpl.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              // If a rejected Promise was yielded, throw the rejection back
              // into the async generator function so it can be handled there.
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).


        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);
      define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      });
      exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.

      exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            } // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted; // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.

              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      } // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.


      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === "throw") {
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (delegate.iterator["return"]) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

          context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        } // The delegate iterator is finished, so forget it and continue with
        // the outer generator.


        context.delegate = null;
        return ContinueSentinel;
      } // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.


      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.

      define(Gp, iteratorSymbol, function () {
        return this;
      });
      define(Gp, "toString", function () {
        return "[object Generator]";
      });

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse(); // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.

        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          } // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.


          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        } // Return an iterator with no values.


        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0; // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.

          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          } // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.


          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      }; // Regardless of whether this script is executing as a CommonJS module
      // or not, return the runtime object so that we can declare the variable
      // regeneratorRuntime in the outer scope, which allows this module to be
      // injected easily by `bin/regenerator --include-runtime script.js`.

      return exports;
    }( // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      // This module should not be running in strict mode, so the above
      // assignment should always work unless something is misconfigured. Just
      // in case runtime.js accidentally runs in strict mode, in modern engines
      // we can explicitly access globalThis. In older engines we can escape
      // strict mode using a global Function call. This could conceivably fail
      // if a Content Security Policy forbids using Function, but in that case
      // the proper solution is to fix the accidental strict mode problem. If
      // you've misconfigured your bundler to force strict mode and applied a
      // CSP to forbid Function, and you're not willing to fix either of those
      // problems, please detail your unique predicament in a GitHub issue.
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  })(runtime$1);

  var regenerator = runtime$1.exports;

  var dist$1 = {};

  var core = {};

  var Block = {};

  Object.defineProperty(Block, "__esModule", {
    value: true
  });

  var Coin = {};

  var json$1 = {};

  Object.defineProperty(json$1, "__esModule", {
    value: true
  });
  json$1.removeNull = json$1.JSONSerializable = json$1.prepareSignBytes = void 0;

  function prepareSignBytes(obj) {
    if (Array.isArray(obj)) {
      return obj.map(prepareSignBytes);
    } // string or number


    if (typeof obj !== "object") {
      return obj;
    }

    var sorted = {};
    Object.keys(obj).sort().forEach(function (key) {
      if (obj[key] === undefined || obj[key] === null) return;
      sorted[key] = prepareSignBytes(obj[key]);
    });
    return sorted;
  }

  json$1.prepareSignBytes = prepareSignBytes;

  var JSONSerializable =
  /** @class */
  function () {
    function JSONSerializable() {}

    JSONSerializable.prototype.toJSON = function () {
      return JSON.stringify(prepareSignBytes(this.toData()));
    };

    return JSONSerializable;
  }();

  json$1.JSONSerializable = JSONSerializable;

  function removeNull(obj) {
    if (obj !== null && typeof obj === 'object') {
      Object.keys(obj).forEach(function (key) {
        if (obj[key] === null) {
          delete obj[key];
        } else if (typeof obj[key] === 'object') {
          removeNull(obj[key]);
        }
      });
    }

    return obj;
  }

  json$1.removeNull = removeNull;

  var numeric = {};

  /*
   *  decimal.js v10.3.1
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   */
  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //
  // The maximum exponent magnitude.
  // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
  var EXP_LIMIT = 9e15,
      // 0 to 9e15
  // The limit on the value of `precision`, and on the value of the first argument to
  // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
  MAX_DIGITS = 1e9,
      // 0 to 1e9
  // Base conversion alphabet.
  NUMERALS = '0123456789abcdef',
      // The natural logarithm of 10 (1025 digits).
  LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',
      // Pi (1025 digits).
  PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',
      // The initial configuration properties of the Decimal constructor.
  DEFAULTS = {
    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed at run-time using the `Decimal.config` method.
    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,
    // 1 to MAX_DIGITS
    // The rounding mode used when rounding to `precision`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,
    // 0 to 8
    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP         0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
    // FLOOR      3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN  6 The IEEE 754 remainder function.
    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
    //
    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
    // division (9) are commonly used for the modulus operation. The other rounding modes can also
    // be used, but they may not give useful results.
    modulo: 1,
    // 0 to 9
    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,
    // 0 to -EXP_LIMIT
    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos: 21,
    // 0 to EXP_LIMIT
    // The minimum exponent value, beneath which underflow to zero occurs.
    // JavaScript numbers: -324  (5e-324)
    minE: -EXP_LIMIT,
    // -1 to -EXP_LIMIT
    // The maximum exponent value, above which overflow to Infinity occurs.
    // JavaScript numbers: 308  (1.7976931348623157e+308)
    maxE: EXP_LIMIT,
    // 1 to EXP_LIMIT
    // Whether to use cryptographically-secure random number generation, if available.
    crypto: false // true/false

  },
      // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //
  inexact,
      quadrant,
      external = true,
      decimalError = '[DecimalError] ',
      invalidArgument = decimalError + 'Invalid argument: ',
      precisionLimitExceeded = decimalError + 'Precision limit exceeded',
      cryptoUnavailable = decimalError + 'crypto unavailable',
      tag = '[object Decimal]',
      mathfloor = Math.floor,
      mathpow = Math.pow,
      isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
      isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
      isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
      isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
      BASE = 1e7,
      LOG_BASE = 7,
      MAX_SAFE_INTEGER = 9007199254740991,
      LN10_PRECISION = LN10.length - 1,
      PI_PRECISION = PI.length - 1,
      // Decimal.prototype object
  P$1 = {
    toStringTag: tag
  }; // Decimal prototype methods

  /*
   *  absoluteValue             abs
   *  ceil
   *  clampedTo                 clamp
   *  comparedTo                cmp
   *  cosine                    cos
   *  cubeRoot                  cbrt
   *  decimalPlaces             dp
   *  dividedBy                 div
   *  dividedToIntegerBy        divToInt
   *  equals                    eq
   *  floor
   *  greaterThan               gt
   *  greaterThanOrEqualTo      gte
   *  hyperbolicCosine          cosh
   *  hyperbolicSine            sinh
   *  hyperbolicTangent         tanh
   *  inverseCosine             acos
   *  inverseHyperbolicCosine   acosh
   *  inverseHyperbolicSine     asinh
   *  inverseHyperbolicTangent  atanh
   *  inverseSine               asin
   *  inverseTangent            atan
   *  isFinite
   *  isInteger                 isInt
   *  isNaN
   *  isNegative                isNeg
   *  isPositive                isPos
   *  isZero
   *  lessThan                  lt
   *  lessThanOrEqualTo         lte
   *  logarithm                 log
   *  [maximum]                 [max]
   *  [minimum]                 [min]
   *  minus                     sub
   *  modulo                    mod
   *  naturalExponential        exp
   *  naturalLogarithm          ln
   *  negated                   neg
   *  plus                      add
   *  precision                 sd
   *  round
   *  sine                      sin
   *  squareRoot                sqrt
   *  tangent                   tan
   *  times                     mul
   *  toBinary
   *  toDecimalPlaces           toDP
   *  toExponential
   *  toFixed
   *  toFraction
   *  toHexadecimal             toHex
   *  toNearest
   *  toNumber
   *  toOctal
   *  toPower                   pow
   *  toPrecision
   *  toSignificantDigits       toSD
   *  toString
   *  truncated                 trunc
   *  valueOf                   toJSON
   */

  /*
   * Return a new Decimal whose value is the absolute value of this Decimal.
   *
   */

  P$1.absoluteValue = P$1.abs = function () {
    var x = new this.constructor(this);
    if (x.s < 0) x.s = 1;
    return finalise(x);
  };
  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of positive Infinity.
   *
   */


  P$1.ceil = function () {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };
  /*
   * Return a new Decimal whose value is the value of this Decimal clamped to the range
   * delineated by `min` and `max`.
   *
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */


  P$1.clampedTo = P$1.clamp = function (min, max) {
    var k,
        x = this,
        Ctor = x.constructor;
    min = new Ctor(min);
    max = new Ctor(max);
    if (!min.s || !max.s) return new Ctor(NaN);
    if (min.gt(max)) throw Error(invalidArgument + max);
    k = x.cmp(min);
    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
  };
  /*
   * Return
   *   1    if the value of this Decimal is greater than the value of `y`,
   *  -1    if the value of this Decimal is less than the value of `y`,
   *   0    if they have the same value,
   *   NaN  if the value of either Decimal is NaN.
   *
   */


  P$1.comparedTo = P$1.cmp = function (y) {
    var i,
        j,
        xdL,
        ydL,
        x = this,
        xd = x.d,
        yd = (y = new x.constructor(y)).d,
        xs = x.s,
        ys = y.s; // Either NaN or ±Infinity?

    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    } // Either zero?


    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0; // Signs differ?

    if (xs !== ys) return xs; // Compare exponents.

    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
    xdL = xd.length;
    ydL = yd.length; // Compare digit by digit.

    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    } // Compare lengths.


    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };
  /*
   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * cos(0)         = 1
   * cos(-0)        = 1
   * cos(Infinity)  = NaN
   * cos(-Infinity) = NaN
   * cos(NaN)       = NaN
   *
   */


  P$1.cosine = P$1.cos = function () {
    var pr,
        rm,
        x = this,
        Ctor = x.constructor;
    if (!x.d) return new Ctor(NaN); // cos(0) = cos(-0) = 1

    if (!x.d[0]) return new Ctor(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };
  /*
   *
   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   *  cbrt(0)  =  0
   *  cbrt(-0) = -0
   *  cbrt(1)  =  1
   *  cbrt(-1) = -1
   *  cbrt(N)  =  N
   *  cbrt(-I) = -I
   *  cbrt(I)  =  I
   *
   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
   *
   */


  P$1.cubeRoot = P$1.cbrt = function () {
    var e,
        m,
        n,
        r,
        rep,
        s,
        sd,
        t,
        t3,
        t3plusx,
        x = this,
        Ctor = x.constructor;
    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    external = false; // Initial estimate.

    s = x.s * mathpow(x.s * x, 1 / 3); // Math.cbrt underflow/overflow?
    // Pass x to Math.pow as integer, then adjust the exponent of the result.

    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e = x.e; // Adjust n exponent so it is a multiple of 3 away from x exponent.

      if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? '0' : '00';
      s = mathpow(n, 1 / 3); // Rarely, e may be one less than the result exponent value.

      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3; // Halley's method.
    // TODO? Compare Newton's method.

    for (;;) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1); // TODO? Replace with for-loop and checkRoundingDigits.

      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
        // , i.e. approaching a rounding boundary, continue the iteration.

        if (n == '9999' || !rep && n == '4999') {
          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {
          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;
    return finalise(r, e, Ctor.rounding, m);
  };
  /*
   * Return the number of decimal places of the value of this Decimal.
   *
   */


  P$1.decimalPlaces = P$1.dp = function () {
    var w,
        d = this.d,
        n = NaN;

    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE; // Subtract the number of trailing zeros of the last word.

      w = d[w];
      if (w) for (; w % 10 == 0; w /= 10) {
        n--;
      }
      if (n < 0) n = 0;
    }

    return n;
  };
  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   */


  P$1.dividedBy = P$1.div = function (y) {
    return divide(this, new this.constructor(y));
  };
  /*
   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */


  P$1.dividedToIntegerBy = P$1.divToInt = function (y) {
    var x = this,
        Ctor = x.constructor;
    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };
  /*
   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
   *
   */


  P$1.equals = P$1.eq = function (y) {
    return this.cmp(y) === 0;
  };
  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of negative Infinity.
   *
   */


  P$1.floor = function () {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };
  /*
   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
   * false.
   *
   */


  P$1.greaterThan = P$1.gt = function (y) {
    return this.cmp(y) > 0;
  };
  /*
   * Return true if the value of this Decimal is greater than or equal to the value of `y`,
   * otherwise return false.
   *
   */


  P$1.greaterThanOrEqualTo = P$1.gte = function (y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };
  /*
   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [1, Infinity]
   *
   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
   *
   * cosh(0)         = 1
   * cosh(-0)        = 1
   * cosh(Infinity)  = Infinity
   * cosh(-Infinity) = Infinity
   * cosh(NaN)       = NaN
   *
   *  x        time taken (ms)   result
   * 1000      9                 9.8503555700852349694e+433
   * 10000     25                4.4034091128314607936e+4342
   * 100000    171               1.4033316802130615897e+43429
   * 1000000   3817              1.5166076984010437725e+434294
   * 10000000  abandoned after 2 minute wait
   *
   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
   *
   */


  P$1.hyperbolicCosine = P$1.cosh = function () {
    var k,
        n,
        pr,
        rm,
        len,
        x = this,
        Ctor = x.constructor,
        one = new Ctor(1);
    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero()) return one;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length; // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))
    // Estimate the optimum number of times to use the argument reduction.
    // TODO? Estimation reused from cosine() and may not be optimal here.

    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = '2.3283064365386962890625e-10';
    }

    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true); // Reverse argument reduction

    var cosh2_x,
        i = k,
        d8 = new Ctor(8);

    for (; i--;) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }

    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  /*
   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
   *
   * sinh(0)         = 0
   * sinh(-0)        = -0
   * sinh(Infinity)  = Infinity
   * sinh(-Infinity) = -Infinity
   * sinh(NaN)       = NaN
   *
   * x        time taken (ms)
   * 10       2 ms
   * 100      5 ms
   * 1000     14 ms
   * 10000    82 ms
   * 100000   886 ms            1.4033316802130615897e+43429
   * 200000   2613 ms
   * 300000   5407 ms
   * 400000   8824 ms
   * 500000   13026 ms          8.7080643612718084129e+217146
   * 1000000  48543 ms
   *
   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
   *
   */


  P$1.hyperbolicSine = P$1.sinh = function () {
    var k,
        pr,
        rm,
        len,
        x = this,
        Ctor = x.constructor;
    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {
      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
      // 3 multiplications and 1 addition
      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
      // 4 multiplications and 2 additions
      // Estimate the optimum number of times to use the argument reduction.
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true); // Reverse argument reduction

      var sinh2_x,
          d5 = new Ctor(5),
          d16 = new Ctor(16),
          d20 = new Ctor(20);

      for (; k--;) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }

    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(x, pr, rm, true);
  };
  /*
   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * tanh(x) = sinh(x) / cosh(x)
   *
   * tanh(0)         = 0
   * tanh(-0)        = -0
   * tanh(Infinity)  = 1
   * tanh(-Infinity) = -1
   * tanh(NaN)       = NaN
   *
   */


  P$1.hyperbolicTangent = P$1.tanh = function () {
    var pr,
        rm,
        x = this,
        Ctor = x.constructor;
    if (!x.isFinite()) return new Ctor(x.s);
    if (x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;
    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };
  /*
   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
   * this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [0, pi]
   *
   * acos(x) = pi/2 - asin(x)
   *
   * acos(0)       = pi/2
   * acos(-0)      = pi/2
   * acos(1)       = 0
   * acos(-1)      = pi
   * acos(1/2)     = pi/3
   * acos(-1/2)    = 2*pi/3
   * acos(|x| > 1) = NaN
   * acos(NaN)     = NaN
   *
   */


  P$1.inverseCosine = P$1.acos = function () {
    var halfPi,
        x = this,
        Ctor = x.constructor,
        k = x.abs().cmp(1),
        pr = Ctor.precision,
        rm = Ctor.rounding;

    if (k !== -1) {
      return k === 0 // |x| is 1
      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) // |x| > 1 or x is NaN
      : new Ctor(NaN);
    }

    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5); // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.asin();
    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return halfPi.minus(x);
  };
  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
   * value of this Decimal.
   *
   * Domain: [1, Infinity]
   * Range: [0, Infinity]
   *
   * acosh(x) = ln(x + sqrt(x^2 - 1))
   *
   * acosh(x < 1)     = NaN
   * acosh(NaN)       = NaN
   * acosh(Infinity)  = Infinity
   * acosh(-Infinity) = NaN
   * acosh(0)         = NaN
   * acosh(-0)        = NaN
   * acosh(1)         = 0
   * acosh(-1)        = NaN
   *
   */


  P$1.inverseHyperbolicCosine = P$1.acosh = function () {
    var pr,
        rm,
        x = this,
        Ctor = x.constructor;
    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).minus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * asinh(x) = ln(x + sqrt(x^2 + 1))
   *
   * asinh(NaN)       = NaN
   * asinh(Infinity)  = Infinity
   * asinh(-Infinity) = -Infinity
   * asinh(0)         = 0
   * asinh(-0)        = -0
   *
   */


  P$1.inverseHyperbolicSine = P$1.asinh = function () {
    var pr,
        rm,
        x = this,
        Ctor = x.constructor;
    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).plus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
   * value of this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [-Infinity, Infinity]
   *
   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
   *
   * atanh(|x| > 1)   = NaN
   * atanh(NaN)       = NaN
   * atanh(Infinity)  = NaN
   * atanh(-Infinity) = NaN
   * atanh(0)         = 0
   * atanh(-0)        = -0
   * atanh(1)         = Infinity
   * atanh(-1)        = -Infinity
   *
   */


  P$1.inverseHyperbolicTangent = P$1.atanh = function () {
    var pr,
        rm,
        wpr,
        xsd,
        x = this,
        Ctor = x.constructor;
    if (!x.isFinite()) return new Ctor(NaN);
    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();
    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
    Ctor.precision = wpr = xsd - x.e;
    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
    Ctor.precision = pr + 4;
    Ctor.rounding = 1;
    x = x.ln();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(0.5);
  };
  /*
   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
   *
   * asin(0)       = 0
   * asin(-0)      = -0
   * asin(1/2)     = pi/6
   * asin(-1/2)    = -pi/6
   * asin(1)       = pi/2
   * asin(-1)      = -pi/2
   * asin(|x| > 1) = NaN
   * asin(NaN)     = NaN
   *
   * TODO? Compare performance of Taylor series.
   *
   */


  P$1.inverseSine = P$1.asin = function () {
    var halfPi,
        k,
        pr,
        rm,
        x = this,
        Ctor = x.constructor;
    if (x.isZero()) return new Ctor(x);
    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (k !== -1) {
      // |x| is 1
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      } // |x| > 1 or x is NaN


      return new Ctor(NaN);
    } // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6


    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(2);
  };
  /*
   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
   *
   * atan(0)         = 0
   * atan(-0)        = -0
   * atan(1)         = pi/4
   * atan(-1)        = -pi/4
   * atan(Infinity)  = pi/2
   * atan(-Infinity) = -pi/2
   * atan(NaN)       = NaN
   *
   */


  P$1.inverseTangent = P$1.atan = function () {
    var i,
        j,
        k,
        n,
        px,
        t,
        r,
        wpr,
        x2,
        x = this,
        Ctor = x.constructor,
        pr = Ctor.precision,
        rm = Ctor.rounding;

    if (!x.isFinite()) {
      if (!x.s) return new Ctor(NaN);

      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }

    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1; // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);
    // Argument reduction
    // Ensure |x| < 0.42
    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

    k = Math.min(28, wpr / LOG_BASE + 2 | 0);

    for (i = k; i; --i) {
      x = x.div(x.times(x).plus(1).sqrt().plus(1));
    }

    external = false;
    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x; // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...

    for (; i !== -1;) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));
      px = px.times(x2);
      r = t.plus(px.div(n += 2));
      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;) {
      }
    }

    if (k) r = r.times(2 << k - 1);
    external = true;
    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  /*
   * Return true if the value of this Decimal is a finite number, otherwise return false.
   *
   */


  P$1.isFinite = function () {
    return !!this.d;
  };
  /*
   * Return true if the value of this Decimal is an integer, otherwise return false.
   *
   */


  P$1.isInteger = P$1.isInt = function () {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };
  /*
   * Return true if the value of this Decimal is NaN, otherwise return false.
   *
   */


  P$1.isNaN = function () {
    return !this.s;
  };
  /*
   * Return true if the value of this Decimal is negative, otherwise return false.
   *
   */


  P$1.isNegative = P$1.isNeg = function () {
    return this.s < 0;
  };
  /*
   * Return true if the value of this Decimal is positive, otherwise return false.
   *
   */


  P$1.isPositive = P$1.isPos = function () {
    return this.s > 0;
  };
  /*
   * Return true if the value of this Decimal is 0 or -0, otherwise return false.
   *
   */


  P$1.isZero = function () {
    return !!this.d && this.d[0] === 0;
  };
  /*
   * Return true if the value of this Decimal is less than `y`, otherwise return false.
   *
   */


  P$1.lessThan = P$1.lt = function (y) {
    return this.cmp(y) < 0;
  };
  /*
   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
   *
   */


  P$1.lessThanOrEqualTo = P$1.lte = function (y) {
    return this.cmp(y) < 1;
  };
  /*
   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * If no base is specified, return log[10](arg).
   *
   * log[base](arg) = ln(arg) / ln(base)
   *
   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
   * otherwise:
   *
   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
   * between the result and the correctly rounded result will be one ulp (unit in the last place).
   *
   * log[-b](a)       = NaN
   * log[0](a)        = NaN
   * log[1](a)        = NaN
   * log[NaN](a)      = NaN
   * log[Infinity](a) = NaN
   * log[b](0)        = -Infinity
   * log[b](-0)       = -Infinity
   * log[b](-a)       = NaN
   * log[b](1)        = 0
   * log[b](Infinity) = Infinity
   * log[b](NaN)      = NaN
   *
   * [base] {number|string|Decimal} The base of the logarithm.
   *
   */


  P$1.logarithm = P$1.log = function (base) {
    var isBase10,
        d,
        denominator,
        k,
        inf,
        num,
        sd,
        r,
        arg = this,
        Ctor = arg.constructor,
        pr = Ctor.precision,
        rm = Ctor.rounding,
        guard = 5; // Default base is 10.

    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d; // Return NaN if base is negative, or non-finite, or is 0 or 1.

      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
      isBase10 = base.eq(10);
    }

    d = arg.d; // Is arg negative, non-finite, 0 or 1?

    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    } // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
    // integer power of 10.


    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0;) {
          k /= 10;
        }

        inf = k !== 1;
      }
    }

    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd); // The result will have 5 rounding digits.

    r = divide(num, denominator, sd, 1); // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
    // calculate 10 further digits.
    //
    // If the result is known to have an infinite decimal expansion, repeat this until it is clear
    // that the result is above or below the boundary. Otherwise, if after calculating the 10
    // further digits, the last 14 are nines, round up and assume the result is exact.
    // Also assume the result is exact if the last 14 are zero.
    //
    // Example of a result that will be incorrectly rounded:
    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
    // place is still 2.6.

    if (checkRoundingDigits(r.d, k = pr, rm)) {
      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);

        if (!inf) {
          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }

          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }

    external = true;
    return finalise(r, pr, rm);
  };
  /*
   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.max = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'lt');
  };
   */

  /*
   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.min = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'gt');
  };
   */

  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */


  P$1.minus = P$1.sub = function (y) {
    var d,
        e,
        i,
        j,
        k,
        len,
        pr,
        rm,
        xd,
        xe,
        xLTy,
        yd,
        x = this,
        Ctor = x.constructor;
    y = new Ctor(y); // If either is not finite...

    if (!x.d || !y.d) {
      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN); // Return y negated if x is finite and y is ±Infinity.
      else if (x.d) y.s = -y.s; // Return x if y is finite and x is ±Infinity.
      // Return x if both are ±Infinity with different signs.
      // Return NaN if both are ±Infinity with the same sign.
      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
      return y;
    } // If signs differ...


    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding; // If either is zero...

    if (!xd[0] || !yd[0]) {
      // Return y negated if x is zero and y is non-zero.
      if (yd[0]) y.s = -y.s; // Return x if y is zero and x is non-zero.
      else if (xd[0]) y = new Ctor(x); // Return zero if both are zero.
      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
      else return new Ctor(rm === 3 ? -0 : 0);
      return external ? finalise(y, pr, rm) : y;
    } // x and y are finite, non-zero numbers with the same sign.
    // Calculate base 1e7 exponents.


    e = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);
    xd = xd.slice();
    k = xe - e; // If base 1e7 exponents differ...

    if (k) {
      xLTy = k < 0;

      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      } // Numbers with massively different exponents would result in a very high number of
      // zeros needing to be prepended, but this can be avoided while still ensuring correct
      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.


      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

      if (k > i) {
        k = i;
        d.length = 1;
      } // Prepend zeros to equalise exponents.


      d.reverse();

      for (i = k; i--;) {
        d.push(0);
      }

      d.reverse(); // Base 1e7 exponents equal.
    } else {
      // Check digits to determine which is the bigger number.
      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy) len = i;

      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }

      k = 0;
    }

    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }

    len = xd.length; // Append zeros to `xd` if shorter.
    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.

    for (i = yd.length - len; i > 0; --i) {
      xd[len++] = 0;
    } // Subtract yd from xd.


    for (i = yd.length; i > k;) {
      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0;) {
          xd[j] = BASE - 1;
        }

        --xd[j];
        xd[i] += BASE;
      }

      xd[i] -= yd[i];
    } // Remove trailing zeros.


    for (; xd[--len] === 0;) {
      xd.pop();
    } // Remove leading zeros and adjust exponent accordingly.


    for (; xd[0] === 0; xd.shift()) {
      --e;
    } // Zero?


    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
    y.d = xd;
    y.e = getBase10Exponent(xd, e);
    return external ? finalise(y, pr, rm) : y;
  };
  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * The result depends on the modulo mode.
   *
   */


  P$1.modulo = P$1.mod = function (y) {
    var q,
        x = this,
        Ctor = x.constructor;
    y = new Ctor(y); // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.

    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN); // Return x if y is ±Infinity or x is ±0.

    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    } // Prevent rounding of intermediate calculations.


    external = false;

    if (Ctor.modulo == 9) {
      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // result = x - q * y    where  0 <= result < abs(y)
      q = divide(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide(x, y, 0, Ctor.modulo, 1);
    }

    q = q.times(y);
    external = true;
    return x.minus(q);
  };
  /*
   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */


  P$1.naturalExponential = P$1.exp = function () {
    return naturalExponential(this);
  };
  /*
   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */


  P$1.naturalLogarithm = P$1.ln = function () {
    return naturalLogarithm(this);
  };
  /*
   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
   * -1.
   *
   */


  P$1.negated = P$1.neg = function () {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };
  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */


  P$1.plus = P$1.add = function (y) {
    var carry,
        d,
        e,
        i,
        k,
        len,
        pr,
        rm,
        xd,
        yd,
        x = this,
        Ctor = x.constructor;
    y = new Ctor(y); // If either is not finite...

    if (!x.d || !y.d) {
      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN); // Return x if y is finite and x is ±Infinity.
      // Return x if both are ±Infinity with the same sign.
      // Return NaN if both are ±Infinity with different signs.
      // Return y if x is finite and y is ±Infinity.
      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
      return y;
    } // If signs differ...


    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding; // If either is zero...

    if (!xd[0] || !yd[0]) {
      // Return x if y is zero.
      // Return y if y is non-zero.
      if (!yd[0]) y = new Ctor(x);
      return external ? finalise(y, pr, rm) : y;
    } // x and y are finite, non-zero numbers with the same sign.
    // Calculate base 1e7 exponents.


    k = mathfloor(x.e / LOG_BASE);
    e = mathfloor(y.e / LOG_BASE);
    xd = xd.slice();
    i = k - e; // If base 1e7 exponents differ...

    if (i) {
      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      } // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.


      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;

      if (i > len) {
        i = len;
        d.length = 1;
      } // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.


      d.reverse();

      for (; i--;) {
        d.push(0);
      }

      d.reverse();
    }

    len = xd.length;
    i = yd.length; // If yd is longer than xd, swap xd and yd so xd points to the longer array.

    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    } // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.


    for (carry = 0; i;) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }

    if (carry) {
      xd.unshift(carry);
      ++e;
    } // Remove trailing zeros.
    // No need to check for zero, as +x + +y != 0 && -x + -y != 0


    for (len = xd.length; xd[--len] == 0;) {
      xd.pop();
    }

    y.d = xd;
    y.e = getBase10Exponent(xd, e);
    return external ? finalise(y, pr, rm) : y;
  };
  /*
   * Return the number of significant digits of the value of this Decimal.
   *
   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
   *
   */


  P$1.precision = P$1.sd = function (z) {
    var k,
        x = this;
    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k) k = x.e + 1;
    } else {
      k = NaN;
    }

    return k;
  };
  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
   * rounding mode `rounding`.
   *
   */


  P$1.round = function () {
    var x = this,
        Ctor = x.constructor;
    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };
  /*
   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * sin(x) = x - x^3/3! + x^5/5! - ...
   *
   * sin(0)         = 0
   * sin(-0)        = -0
   * sin(Infinity)  = NaN
   * sin(-Infinity) = NaN
   * sin(NaN)       = NaN
   *
   */


  P$1.sine = P$1.sin = function () {
    var pr,
        rm,
        x = this,
        Ctor = x.constructor;
    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = sine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };
  /*
   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   *  sqrt(-n) =  N
   *  sqrt(N)  =  N
   *  sqrt(-I) =  N
   *  sqrt(I)  =  I
   *  sqrt(0)  =  0
   *  sqrt(-0) = -0
   *
   */


  P$1.squareRoot = P$1.sqrt = function () {
    var m,
        n,
        sd,
        r,
        rep,
        t,
        x = this,
        d = x.d,
        e = x.e,
        s = x.s,
        Ctor = x.constructor; // Negative/NaN/Infinity/zero?

    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }

    external = false; // Initial estimate.

    s = Math.sqrt(+x); // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.

    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);
      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3; // Newton-Raphson iteration.

    for (;;) {
      t = r;
      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5); // TODO? Replace with for-loop and checkRoundingDigits.

      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
        // 4999, i.e. approaching a rounding boundary, continue the iteration.

        if (n == '9999' || !rep && n == '4999') {
          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {
          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;
    return finalise(r, e, Ctor.rounding, m);
  };
  /*
   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * tan(0)         = 0
   * tan(-0)        = -0
   * tan(Infinity)  = NaN
   * tan(-Infinity) = NaN
   * tan(NaN)       = NaN
   *
   */


  P$1.tangent = P$1.tan = function () {
    var pr,
        rm,
        x = this,
        Ctor = x.constructor;
    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;
    x = x.sin();
    x.s = 1;
    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };
  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   */


  P$1.times = P$1.mul = function (y) {
    var carry,
        e,
        i,
        k,
        r,
        rL,
        t,
        xdL,
        ydL,
        x = this,
        Ctor = x.constructor,
        xd = x.d,
        yd = (y = new Ctor(y)).d;
    y.s *= x.s; // If either is NaN, ±Infinity or ±0...

    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd // Return NaN if either is NaN.
      // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.
      ? NaN // Return ±Infinity if either is ±Infinity.
      // Return ±0 if either is ±0.
      : !xd || !yd ? y.s / 0 : y.s * 0);
    }

    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length; // Ensure xd points to the longer array.

    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    } // Initialise the result array with zeros.


    r = [];
    rL = xdL + ydL;

    for (i = rL; i--;) {
      r.push(0);
    } // Multiply!


    for (i = ydL; --i >= 0;) {
      carry = 0;

      for (k = xdL + i; k > i;) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }

      r[k] = (r[k] + carry) % BASE | 0;
    } // Remove trailing zeros.


    for (; !r[--rL];) {
      r.pop();
    }

    if (carry) ++e;else r.shift();
    y.d = r;
    y.e = getBase10Exponent(r, e);
    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };
  /*
   * Return a string representing the value of this Decimal in base 2, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */


  P$1.toBinary = function (sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };
  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
   *
   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */


  P$1.toDecimalPlaces = P$1.toDP = function (dp, rm) {
    var x = this,
        Ctor = x.constructor;
    x = new Ctor(x);
    if (dp === void 0) return x;
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
    return finalise(x, dp + x.e + 1, rm);
  };
  /*
   * Return a string representing the value of this Decimal in exponential notation rounded to
   * `dp` fixed decimal places using rounding mode `rounding`.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */


  P$1.toExponential = function (dp, rm) {
    var str,
        x = this,
        Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };
  /*
   * Return a string representing the value of this Decimal in normal (fixed-point) notation to
   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
   * omitted.
   *
   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   * (-0).toFixed(3) is '0.000'.
   * (-0.5).toFixed(0) is '-0'.
   *
   */


  P$1.toFixed = function (dp, rm) {
    var str,
        y,
        x = this,
        Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    } // To determine whether to add the minus sign look at the value before it was rounded,
    // i.e. look at `x` rather than `y`.


    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };
  /*
   * Return an array representing the value of this Decimal as a simple fraction with an integer
   * numerator and an integer denominator.
   *
   * The denominator will be a positive non-zero value less than or equal to the specified maximum
   * denominator. If a maximum denominator is not specified, the denominator will be the lowest
   * value necessary to represent the number exactly.
   *
   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
   *
   */


  P$1.toFraction = function (maxD) {
    var d,
        d0,
        d1,
        d2,
        e,
        k,
        n,
        n0,
        n1,
        pr,
        q,
        r,
        x = this,
        xd = x.d,
        Ctor = x.constructor;
    if (!xd) return new Ctor(x);
    n1 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);
    d = new Ctor(d1);
    e = d.e = getPrecision(xd) - x.e - 1;
    k = e % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

    if (maxD == null) {
      // d is 10**e, the minimum max-denominator needed.
      maxD = e > 0 ? d : n1;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
      maxD = n.gt(d) ? e > 0 ? d : n1 : n;
    }

    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e = xd.length * LOG_BASE * 2;

    for (;;) {
      q = divide(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1) break;
      d0 = d1;
      d1 = d2;
      d2 = n1;
      n1 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }

    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s; // Determine which fraction is closer to x, n0/d0 or n1/d1?

    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
    Ctor.precision = pr;
    external = true;
    return r;
  };
  /*
   * Return a string representing the value of this Decimal in base 16, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */


  P$1.toHexadecimal = P$1.toHex = function (sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };
  /*
   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
   *
   * The return value will always have the same sign as this Decimal, unless either this Decimal
   * or `y` is NaN, in which case the return value will be also be NaN.
   *
   * The return value is not affected by the value of `precision`.
   *
   * y {number|string|Decimal} The magnitude to round to a multiple of.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toNearest() rounding mode not an integer: {rm}'
   * 'toNearest() rounding mode out of range: {rm}'
   *
   */


  P$1.toNearest = function (y, rm) {
    var x = this,
        Ctor = x.constructor;
    x = new Ctor(x);

    if (y == null) {
      // If x is not finite, return x.
      if (!x.d) return x;
      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);

      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      } // If x is not finite, return x if y is not NaN, else NaN.


      if (!x.d) return y.s ? x : y; // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.

      if (!y.d) {
        if (y.s) y.s = x.s;
        return y;
      }
    } // If y is not zero, calculate the nearest multiple of y to x.


    if (y.d[0]) {
      external = false;
      x = divide(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x); // If y is zero, return zero with the sign of x.
    } else {
      y.s = x.s;
      x = y;
    }

    return x;
  };
  /*
   * Return the value of this Decimal converted to a number primitive.
   * Zero keeps its sign.
   *
   */


  P$1.toNumber = function () {
    return +this;
  };
  /*
   * Return a string representing the value of this Decimal in base 8, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */


  P$1.toOctal = function (sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };
  /*
   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
   * to `precision` significant digits using rounding mode `rounding`.
   *
   * ECMAScript compliant.
   *
   *   pow(x, NaN)                           = NaN
   *   pow(x, ±0)                            = 1

   *   pow(NaN, non-zero)                    = NaN
   *   pow(abs(x) > 1, +Infinity)            = +Infinity
   *   pow(abs(x) > 1, -Infinity)            = +0
   *   pow(abs(x) == 1, ±Infinity)           = NaN
   *   pow(abs(x) < 1, +Infinity)            = +0
   *   pow(abs(x) < 1, -Infinity)            = +Infinity
   *   pow(+Infinity, y > 0)                 = +Infinity
   *   pow(+Infinity, y < 0)                 = +0
   *   pow(-Infinity, odd integer > 0)       = -Infinity
   *   pow(-Infinity, even integer > 0)      = +Infinity
   *   pow(-Infinity, odd integer < 0)       = -0
   *   pow(-Infinity, even integer < 0)      = +0
   *   pow(+0, y > 0)                        = +0
   *   pow(+0, y < 0)                        = +Infinity
   *   pow(-0, odd integer > 0)              = -0
   *   pow(-0, even integer > 0)             = +0
   *   pow(-0, odd integer < 0)              = -Infinity
   *   pow(-0, even integer < 0)             = +Infinity
   *   pow(finite x < 0, finite non-integer) = NaN
   *
   * For non-integer or very large exponents pow(x, y) is calculated using
   *
   *   x^y = exp(y*ln(x))
   *
   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
   * probability of an incorrectly rounded result
   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
   * i.e. 1 in 250,000,000,000,000
   *
   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
   *
   * y {number|string|Decimal} The power to which to raise this Decimal.
   *
   */


  P$1.toPower = P$1.pow = function (y) {
    var e,
        k,
        pr,
        r,
        rm,
        s,
        x = this,
        Ctor = x.constructor,
        yn = +(y = new Ctor(y)); // Either ±Infinity, NaN or ±0?

    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
    x = new Ctor(x);
    if (x.eq(1)) return x;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (y.eq(1)) return finalise(x, pr, rm); // y exponent

    e = mathfloor(y.e / LOG_BASE); // If y is a small integer use the 'exponentiation by squaring' algorithm.

    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }

    s = x.s; // if x is negative

    if (s < 0) {
      // if y is not an integer
      if (e < y.d.length - 1) return new Ctor(NaN); // Result is positive if x is negative and the last digit of integer y is even.

      if ((y.d[e] & 1) == 0) s = 1; // if x.eq(-1)

      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    } // Estimate result exponent.
    // x^y = 10^e,  where e = y * log10(x)
    // log10(x) = log10(x_significand) + x_exponent
    // log10(x_significand) = ln(x_significand) / ln(10)


    k = mathpow(+x, yn);
    e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + '').e; // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.
    // Overflow/underflow?

    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
    external = false;
    Ctor.rounding = x.s = 1; // Estimate the extra guard digits needed to ensure five correct rounding digits from
    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
    // new Decimal(2.32456).pow('2087987436534566.46411')
    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815

    k = Math.min(12, (e + '').length); // r = x^y = exp(y*ln(x))

    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr); // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)

    if (r.d) {
      // Truncate to the required precision plus five rounding digits.
      r = finalise(r, pr + 5, 1); // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
      // the result.

      if (checkRoundingDigits(r.d, pr, rm)) {
        e = pr + 10; // Truncate to the increased precision plus five rounding digits.

        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1); // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).

        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }

    r.s = s;
    external = true;
    Ctor.rounding = rm;
    return finalise(r, pr, rm);
  };
  /*
   * Return a string representing the value of this Decimal rounded to `sd` significant digits
   * using rounding mode `rounding`.
   *
   * Return exponential notation if `sd` is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */


  P$1.toPrecision = function (sd, rm) {
    var str,
        x = this,
        Ctor = x.constructor;

    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };
  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
   * omitted.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toSD() digits out of range: {sd}'
   * 'toSD() digits not an integer: {sd}'
   * 'toSD() rounding mode not an integer: {rm}'
   * 'toSD() rounding mode out of range: {rm}'
   *
   */


  P$1.toSignificantDigits = P$1.toSD = function (sd, rm) {
    var x = this,
        Ctor = x.constructor;

    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
    }

    return finalise(new Ctor(x), sd, rm);
  };
  /*
   * Return a string representing the value of this Decimal.
   *
   * Return exponential notation if this Decimal has a positive exponent equal to or greater than
   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
   *
   */


  P$1.toString = function () {
    var x = this,
        Ctor = x.constructor,
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };
  /*
   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
   *
   */


  P$1.truncated = P$1.trunc = function () {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };
  /*
   * Return a string representing the value of this Decimal.
   * Unlike `toString`, negative zero will include the minus sign.
   *
   */


  P$1.valueOf = P$1.toJSON = function () {
    var x = this,
        Ctor = x.constructor,
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() ? '-' + str : str;
  }; // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.

  /*
   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
   *                           finiteToString, naturalExponential, naturalLogarithm
   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
   *  convertBase              toStringBinary, parseOther
   *  cos                      P.cos
   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
   *                           taylorSeries, atan2, parseOther
   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
   *                           P.truncated, divide, getLn10, getPi, naturalExponential,
   *                           naturalLogarithm, ceil, floor, round, trunc
   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
   *                           toStringBinary
   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
   *  getLn10                  P.logarithm, naturalLogarithm
   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
   *  getPrecision             P.precision, P.toFraction
   *  getZeroString            digitsToString, finiteToString
   *  intPow                   P.toPower, parseOther
   *  isOdd                    toLessThanHalfPi
   *  maxOrMin                 max, min
   *  naturalExponential       P.naturalExponential, P.toPower
   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
   *                           P.toPower, naturalExponential
   *  nonFiniteToString        finiteToString, toStringBinary
   *  parseDecimal             Decimal
   *  parseOther               Decimal
   *  sin                      P.sin
   *  taylorSeries             P.cosh, P.sinh, cos, sin
   *  toLessThanHalfPi         P.cos, P.sin
   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
   *  truncate                 intPow
   *
   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
   *                           naturalLogarithm, config, parseOther, random, Decimal
   */


  function digitsToString(d) {
    var i,
        k,
        ws,
        indexOfLastWord = d.length - 1,
        str = '',
        w = d[0];

    if (indexOfLastWord > 0) {
      str += w;

      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
        str += ws;
      }

      w = d[i];
      ws = w + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
    } else if (w === 0) {
      return '0';
    } // Remove trailing zeros of last w.


    for (; w % 10 === 0;) {
      w /= 10;
    }

    return str + w;
  }

  function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
      throw Error(invalidArgument + i);
    }
  }
  /*
   * Check 5 rounding digits if `repeating` is null, 4 otherwise.
   * `repeating == null` if caller is `log` or `pow`,
   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
   */


  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd; // Get the length of the first word of the array d.

    for (k = d[0]; k >= 10; k /= 10) {
      --i;
    } // Is the rounding digit in the first word of d?


    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    } // i is the index (0 - 6) of the rounding digit.
    // E.g. if within the word 3487563 the first rounding digit is 5,
    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563


    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;

    if (repeating == null) {
      if (i < 3) {
        if (i == 0) rd = rd / 100 | 0;else if (i == 1) rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0) rd = rd / 1000 | 0;else if (i == 1) rd = rd / 100 | 0;else if (i == 2) rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
      }
    }

    return r;
  } // Convert string of `baseIn` to an array of numbers of `baseOut`.
  // Eg. convertBase('255', 10, 16) returns [15, 15].
  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].


  function convertBase(str, baseIn, baseOut) {
    var j,
        arr = [0],
        arrL,
        i = 0,
        strL = str.length;

    for (; i < strL;) {
      for (arrL = arr.length; arrL--;) {
        arr[arrL] *= baseIn;
      }

      arr[0] += NUMERALS.indexOf(str.charAt(i++));

      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0) arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }

    return arr.reverse();
  }
  /*
   * cos(x) = 1 - x^2/2! + x^4/4! - ...
   * |x| < pi/2
   *
   */


  function cosine(Ctor, x) {
    var k, len, y;
    if (x.isZero()) return x; // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1
    // Estimate the optimum number of times to use the argument reduction.

    len = x.d.length;

    if (len < 32) {
      k = Math.ceil(len / 3);
      y = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y = '2.3283064365386962890625e-10';
    }

    Ctor.precision += k;
    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1)); // Reverse argument reduction

    for (var i = k; i--;) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }

    Ctor.precision -= k;
    return x;
  }
  /*
   * Perform division in the specified base.
   */


  var divide = function () {
    // Assumes non-zero x and k, and hence non-zero result.
    function multiplyInteger(x, k, base) {
      var temp,
          carry = 0,
          i = x.length;

      for (x = x.slice(); i--;) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }

      if (carry) x.unshift(carry);
      return x;
    }

    function compare(a, b, aL, bL) {
      var i, r;

      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return r;
    }

    function subtract(a, b, aL, base) {
      var i = 0; // Subtract b from a.

      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      } // Remove leading zeros.


      for (; !a[0] && a.length > 1;) {
        a.shift();
      }
    }

    return function (x, y, pr, rm, dp, base) {
      var cmp,
          e,
          i,
          k,
          logBase,
          more,
          prod,
          prodL,
          q,
          qd,
          rem,
          remL,
          rem0,
          sd,
          t,
          xi,
          xL,
          yd0,
          yL,
          yz,
          Ctor = x.constructor,
          sign = x.s == y.s ? 1 : -1,
          xd = x.d,
          yd = y.d; // Either NaN, Infinity or 0?

      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor( // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
        xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
      }

      if (base) {
        logBase = 1;
        e = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }

      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign);
      qd = q.d = []; // Result exponent may be one less than e.
      // The digit array of a Decimal from toStringBinary may have trailing zeros.

      for (i = 0; yd[i] == (xd[i] || 0); i++) {
      }

      if (yd[i] > (xd[i] || 0)) e--;

      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }

      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {
        // Convert precision in number of base 10 digits to base 1e7 digits.
        sd = sd / logBase + 2 | 0;
        i = 0; // divisor < 1e7

        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++; // k is the carry.

          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }

          more = k || i < xL; // divisor >= 1e7
        } else {
          // Normalise xd and yd so highest order digit of yd is >= base/2
          k = base / (yd[0] + 1) | 0;

          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }

          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length; // Add zeros to make remainder as long as divisor.

          for (; remL < yL;) {
            rem[remL++] = 0;
          }

          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];
          if (yd[1] >= base / 2) ++yd0;

          do {
            k = 0; // Compare divisor and remainder.

            cmp = compare(yd, rem, yL, remL); // If divisor < remainder.

            if (cmp < 0) {
              // Calculate trial digit, k.
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0); // k will be how many times the divisor goes into the current remainder.

              k = rem0 / yd0 | 0; //  Algorithm:
              //  1. product = divisor * trial digit (k)
              //  2. if product > remainder: product -= divisor, k--
              //  3. remainder -= product
              //  4. if product was < remainder at 2:
              //    5. compare new remainder and divisor
              //    6. If remainder > divisor: remainder -= divisor, k++

              if (k > 1) {
                if (k >= base) k = base - 1; // product = divisor * trial digit.

                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length; // Compare product and remainder.

                cmp = compare(prod, rem, prodL, remL); // product > remainder.

                if (cmp == 1) {
                  k--; // Subtract divisor from product.

                  subtract(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {
                // cmp is -1.
                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                if (k == 0) cmp = k = 1;
                prod = yd.slice();
              }

              prodL = prod.length;
              if (prodL < remL) prod.unshift(0); // Subtract product from remainder.

              subtract(rem, prod, remL, base); // If product was < previous remainder.

              if (cmp == -1) {
                remL = rem.length; // Compare divisor and new remainder.

                cmp = compare(yd, rem, yL, remL); // If divisor < new remainder, subtract divisor from remainder.

                if (cmp < 1) {
                  k++; // Subtract divisor from remainder.

                  subtract(rem, yL < remL ? yz : yd, remL, base);
                }
              }

              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            } // if cmp === 1, k will be 0
            // Add the next digit, k, to the result array.


            qd[i++] = k; // Update the remainder.

            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] !== void 0) && sd--);

          more = rem[0] !== void 0;
        } // Leading zero?


        if (!qd[0]) qd.shift();
      } // logBase is 1 when divide is being used for base conversion.


      if (logBase == 1) {
        q.e = e;
        inexact = more;
      } else {
        // To calculate q.e, first get the number of digits of qd[0].
        for (i = 1, k = qd[0]; k >= 10; k /= 10) {
          i++;
        }

        q.e = i + e * logBase - 1;
        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }

      return q;
    };
  }();
  /*
   * Round `x` to `sd` significant digits using rounding mode `rm`.
   * Check for over/under-flow.
   */


  function finalise(x, sd, rm, isTruncated) {
    var digits,
        i,
        j,
        k,
        rd,
        roundUp,
        w,
        xd,
        xdi,
        Ctor = x.constructor; // Don't round if sd is null or undefined.

    out: if (sd != null) {
      xd = x.d; // Infinity/NaN.

      if (!xd) return x; // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
      // w: the word of xd containing rd, a base 1e7 number.
      // xdi: the index of w within xd.
      // digits: the number of digits of w.
      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
      // they had leading zeros)
      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).
      // Get the length of the first word of the digits array xd.

      for (digits = 1, k = xd[0]; k >= 10; k /= 10) {
        digits++;
      }

      i = sd - digits; // Is the rounding digit in the first word of xd?

      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0]; // Get the rounding digit at index j of w.

        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;

        if (xdi >= k) {
          if (isTruncated) {
            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
            for (; k++ <= xdi;) {
              xd.push(0);
            }

            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi]; // Get the number of digits of w.

          for (digits = 1; k >= 10; k /= 10) {
            digits++;
          } // Get the index of rd within w.


          i %= LOG_BASE; // Get the index of rd within w, adjusted for leading zeros.
          // The number of leading zeros of w is given by LOG_BASE - digits.

          j = i - LOG_BASE + digits; // Get the rounding digit at index j of w.

          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      } // Are there any non-zero digits after the rounding digit?


      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1)); // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
      // will give 714.

      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));

      if (sd < 1 || !xd[0]) {
        xd.length = 0;

        if (roundUp) {
          // Convert sd to decimal places.
          sd -= x.e + 1; // 1, 0.1, 0.01, 0.001, 0.0001 etc.

          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          // Zero.
          xd[0] = x.e = 0;
        }

        return x;
      } // Remove excess digits.


      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i); // E.g. 56700 becomes 56000 if 7 is the rounding digit.
        // j > 0 means i > number of leading zeros of w.

        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }

      if (roundUp) {
        for (;;) {
          // Is the digit to be rounded up in the first word of xd?
          if (xdi == 0) {
            // i will be the length of xd[0] before k is added.
            for (i = 1, j = xd[0]; j >= 10; j /= 10) {
              i++;
            }

            j = xd[0] += k;

            for (k = 1; j >= 10; j /= 10) {
              k++;
            } // if i != k the length has increased.


            if (i != k) {
              x.e++;
              if (xd[0] == BASE) xd[0] = 1;
            }

            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE) break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      } // Remove trailing zeros.


      for (i = xd.length; xd[--i] === 0;) {
        xd.pop();
      }
    }

    if (external) {
      // Overflow?
      if (x.e > Ctor.maxE) {
        // Infinity.
        x.d = null;
        x.e = NaN; // Underflow?
      } else if (x.e < Ctor.minE) {
        // Zero.
        x.e = 0;
        x.d = [0]; // Ctor.underflow = true;
      } // else Ctor.underflow = false;

    }

    return x;
  }

  function finiteToString(x, isExp, sd) {
    if (!x.isFinite()) return nonFiniteToString(x);
    var k,
        e = x.e,
        str = digitsToString(x.d),
        len = str.length;

    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + '.' + str.slice(1);
      }

      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
    } else if (e < 0) {
      str = '0.' + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
    } else {
      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);

      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len) str += '.';
        str += getZeroString(k);
      }
    }

    return str;
  } // Calculate the base 10 exponent from the base 1e7 exponent.


  function getBase10Exponent(digits, e) {
    var w = digits[0]; // Add the number of digits of the first word of the digits array.

    for (e *= LOG_BASE; w >= 10; w /= 10) {
      e++;
    }

    return e;
  }

  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {
      // Reset global state in case the exception is caught.
      external = true;
      if (pr) Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }

    return finalise(new Ctor(LN10), sd, 1, true);
  }

  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }

  function getPrecision(digits) {
    var w = digits.length - 1,
        len = w * LOG_BASE + 1;
    w = digits[w]; // If non-zero...

    if (w) {
      // Subtract the number of trailing zeros of the last word.
      for (; w % 10 == 0; w /= 10) {
        len--;
      } // Add the number of digits of the first word.


      for (w = digits[0]; w >= 10; w /= 10) {
        len++;
      }
    }

    return len;
  }

  function getZeroString(k) {
    var zs = '';

    for (; k--;) {
      zs += '0';
    }

    return zs;
  }
  /*
   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
   * integer of type number.
   *
   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
   *
   */


  function intPow(Ctor, x, n, pr) {
    var isTruncated,
        r = new Ctor(1),
        // Max n of 9007199254740991 takes 53 loop iterations.
    // Maximum digits array length; leaves [28, 34] guard digits.
    k = Math.ceil(pr / LOG_BASE + 4);
    external = false;

    for (;;) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k)) isTruncated = true;
      }

      n = mathfloor(n / 2);

      if (n === 0) {
        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0) ++r.d[n];
        break;
      }

      x = x.times(x);
      truncate(x.d, k);
    }

    external = true;
    return r;
  }

  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }
  /*
   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
   */


  function maxOrMin(Ctor, args, ltgt) {
    var y,
        x = new Ctor(args[0]),
        i = 0;

    for (; ++i < args.length;) {
      y = new Ctor(args[i]);

      if (!y.s) {
        x = y;
        break;
      } else if (x[ltgt](y)) {
        x = y;
      }
    }

    return x;
  }
  /*
   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
   * digits.
   *
   * Taylor/Maclaurin series.
   *
   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
   *
   * Argument reduction:
   *   Repeat x = x / 32, k += 5, until |x| < 0.1
   *   exp(x) = exp(x / 2^k)^(2^k)
   *
   * Previously, the argument was initially reduced by
   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
   * found to be slower than just dividing repeatedly by 32 as above.
   *
   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
   *
   *  exp(Infinity)  = Infinity
   *  exp(-Infinity) = 0
   *  exp(NaN)       = NaN
   *  exp(±0)        = 1
   *
   *  exp(x) is non-terminating for any finite, non-zero x.
   *
   *  The result will always be correctly rounded.
   *
   */


  function naturalExponential(x, sd) {
    var denominator,
        guard,
        j,
        pow,
        sum,
        t,
        wpr,
        rep = 0,
        i = 0,
        k = 0,
        Ctor = x.constructor,
        rm = Ctor.rounding,
        pr = Ctor.precision; // 0/NaN/Infinity?

    if (!x.d || !x.d[0] || x.e > 17) {
      return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    t = new Ctor(0.03125); // while abs(x) >= 0.1

    while (x.e > -2) {
      // x = x / 2^5
      x = x.times(t);
      k += 5;
    } // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
    // necessary to ensure the first 4 rounding digits are correct.


    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(1);
    Ctor.precision = wpr;

    for (;;) {
      pow = finalise(pow.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum.plus(divide(pow, denominator, wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        j = k;

        while (j--) {
          sum = finalise(sum.times(sum), wpr, 1);
        } // Check to see if the first 4 rounding digits are [49]999.
        // If so, repeat the summation with a higher precision, otherwise
        // e.g. with precision: 18, rounding: 1
        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
        // `wpr - guard` is the index of first rounding digit.


        if (sd == null) {
          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
    }
  }
  /*
   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
   * digits.
   *
   *  ln(-n)        = NaN
   *  ln(0)         = -Infinity
   *  ln(-0)        = -Infinity
   *  ln(1)         = 0
   *  ln(Infinity)  = Infinity
   *  ln(-Infinity) = NaN
   *  ln(NaN)       = NaN
   *
   *  ln(n) (n != 1) is non-terminating.
   *
   */


  function naturalLogarithm(y, sd) {
    var c,
        c0,
        denominator,
        e,
        numerator,
        rep,
        sum,
        t,
        wpr,
        x1,
        x2,
        n = 1,
        guard = 10,
        x = y,
        xd = x.d,
        Ctor = x.constructor,
        rm = Ctor.rounding,
        pr = Ctor.precision; // Is x negative or Infinity, NaN, 0 or 1?

    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);

    if (Math.abs(e = x.e) < 1.5e15) {
      // Argument reduction.
      // The series converges faster the closer the argument is to 1, so using
      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
      // later be divided by this number, then separate out the power of 10 using
      // ln(a*10^b) = ln(a) + b*ln(10).
      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
      // max n is 6 (gives 0.7 - 1.3)
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }

      e = x.e;

      if (c0 > 1) {
        x = new Ctor('0.' + c);
        e++;
      } else {
        x = new Ctor(c0 + '.' + c.slice(1));
      }
    } else {
      // The argument reduction method above may result in overflow if the argument y is a massive
      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
      // function using ln(x*10^e) = ln(x) + e*ln(10).
      t = getLn10(Ctor, wpr + 2, pr).times(e + '');
      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;
      return sd == null ? finalise(x, pr, rm, external = true) : x;
    } // x1 is x reduced to a value near 1.


    x1 = x; // Taylor series.
    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
    // where x = (y - 1)/(y + 1)    (|x| < 1)

    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;

    for (;;) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        sum = sum.times(2); // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.

        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
        sum = divide(sum, new Ctor(n), wpr, 1); // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
        // been repeated previously) and the first 4 rounding digits 9999?
        // If so, restart the summation with a higher precision, otherwise
        // e.g. with precision: 12, rounding: 1
        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
        // `wpr - guard` is the index of first rounding digit.

        if (sd == null) {
          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
      denominator += 2;
    }
  } // ±Infinity, NaN.


  function nonFiniteToString(x) {
    // Unsigned.
    return String(x.s * x.s / 0);
  }
  /*
   * Parse the value of a new Decimal `x` from string `str`.
   */


  function parseDecimal(x, str) {
    var e, i, len; // Decimal point?

    if ((e = str.indexOf('.')) > -1) str = str.replace('.', ''); // Exponential form?

    if ((i = str.search(/e/i)) > 0) {
      // Determine exponent.
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {
      // Integer.
      e = str.length;
    } // Determine leading zeros.


    for (i = 0; str.charCodeAt(i) === 48; i++) {
    } // Determine trailing zeros.


    for (len = str.length; str.charCodeAt(len - 1) === 48; --len) {
    }

    str = str.slice(i, len);

    if (str) {
      len -= i;
      x.e = e = e - i - 1;
      x.d = []; // Transform base
      // e is the base 10 exponent.
      // i is where to slice str to get the first word of the digits array.

      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;

      if (i < len) {
        if (i) x.d.push(+str.slice(0, i));

        for (len -= LOG_BASE; i < len;) {
          x.d.push(+str.slice(i, i += LOG_BASE));
        }

        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }

      for (; i--;) {
        str += '0';
      }

      x.d.push(+str);

      if (external) {
        // Overflow?
        if (x.e > x.constructor.maxE) {
          // Infinity.
          x.d = null;
          x.e = NaN; // Underflow?
        } else if (x.e < x.constructor.minE) {
          // Zero.
          x.e = 0;
          x.d = [0]; // x.constructor.underflow = true;
        } // else x.constructor.underflow = false;

      }
    } else {
      // Zero.
      x.e = 0;
      x.d = [0];
    }

    return x;
  }
  /*
   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
   */


  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

    if (str.indexOf('_') > -1) {
      str = str.replace(/(\d)_(?=\d)/g, '$1');
      if (isDecimal.test(str)) return parseDecimal(x, str);
    } else if (str === 'Infinity' || str === 'NaN') {
      if (!+str) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }

    if (isHex.test(str)) {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str)) {
      base = 2;
    } else if (isOctal.test(str)) {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    } // Is there a binary exponent part?


    i = str.search(/p/i);

    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    } // Convert `str` as an integer then divide the result by `base` raised to a power such that the
    // fraction part will be restored.


    i = str.indexOf('.');
    isFloat = i >= 0;
    Ctor = x.constructor;

    if (isFloat) {
      str = str.replace('.', '');
      len = str.length;
      i = len - i; // log[10](16) = 1.2041... , log[10](88) = 1.9444....

      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }

    xd = convertBase(str, base, BASE);
    xe = xd.length - 1; // Remove trailing zeros.

    for (i = xe; xd[i] === 0; --i) {
      xd.pop();
    }

    if (i < 0) return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false; // At what precision to perform the division to ensure exact conversion?
    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
    // Therefore using 4 * the number of digits of str will always be enough.

    if (isFloat) x = divide(x, divisor, len * 4); // Multiply by the binary exponent part if present.

    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;
    return x;
  }
  /*
   * sin(x) = x - x^3/3! + x^5/5! - ...
   * |x| < pi/2
   *
   */


  function sine(Ctor, x) {
    var k,
        len = x.d.length;

    if (len < 3) {
      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
    } // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))
    // Estimate the optimum number of times to use the argument reduction.


    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x); // Reverse argument reduction

    var sin2_x,
        d5 = new Ctor(5),
        d16 = new Ctor(16),
        d20 = new Ctor(20);

    for (; k--;) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }

    return x;
  } // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.


  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j,
        t,
        u,
        x2,
        pr = Ctor.precision,
        k = Math.ceil(pr / LOG_BASE);
    external = false;
    x2 = x.times(x);
    u = new Ctor(y);

    for (;;) {
      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);

      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--;) {
        }

        if (j == -1) break;
      }

      j = u;
      u = y;
      y = t;
      t = j;
    }

    external = true;
    t.d.length = k + 1;
    return t;
  } // Exponent e must be positive and non-zero.


  function tinyPow(b, e) {
    var n = b;

    while (--e) {
      n *= b;
    }

    return n;
  } // Return the absolute value of `x` reduced to less than or equal to half pi.


  function toLessThanHalfPi(Ctor, x) {
    var t,
        isNeg = x.s < 0,
        pi = getPi(Ctor, Ctor.precision, 1),
        halfPi = pi.times(0.5);
    x = x.abs();

    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }

    t = x.divToInt(pi);

    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi)); // 0 <= x < pi

      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
        return x;
      }

      quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
    }

    return x.minus(pi).abs();
  }
  /*
   * Return the value of Decimal `x` as a string in base `baseOut`.
   *
   * If the optional `sd` argument is present include a binary exponent suffix.
   */


  function toStringBinary(x, baseOut, sd, rm) {
    var base,
        e,
        i,
        k,
        len,
        roundUp,
        str,
        xd,
        y,
        Ctor = x.constructor,
        isExp = sd !== void 0;

    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }

    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf('.'); // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
      // minBinaryExponent = floor(decimalExponent * log[2](10))
      // log[2](10) = 3.321928094887362347870319429489390175864

      if (isExp) {
        base = 2;

        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      } // Convert the number as an integer then divide the result by its base raised to a power such
      // that the fraction part will be restored.
      // Non-integer.


      if (i >= 0) {
        str = str.replace('.', '');
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }

      xd = convertBase(str, 10, base);
      e = len = xd.length; // Remove trailing zeros.

      for (; xd[--len] == 0;) {
        xd.pop();
      }

      if (!xd[0]) {
        str = isExp ? '0p+0' : '0';
      } else {
        if (i < 0) {
          e--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e;
          x = divide(x, y, sd, rm, 0, base);
          xd = x.d;
          e = x.e;
          roundUp = inexact;
        } // The rounding digit, i.e. the digit after the digit that may be rounded up.


        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;
        roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
        xd.length = sd;

        if (roundUp) {
          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (; ++xd[--sd] > base - 1;) {
            xd[sd] = 0;

            if (!sd) {
              ++e;
              xd.unshift(1);
            }
          }
        } // Determine trailing zeros.


        for (len = xd.length; !xd[len - 1]; --len) {
        } // E.g. [4, 11, 15] becomes 4bf.


        for (i = 0, str = ''; i < len; i++) {
          str += NUMERALS.charAt(xd[i]);
        } // Add binary exponent suffix?


        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;

              for (--len; len % i; len++) {
                str += '0';
              }

              xd = convertBase(str, base, baseOut);

              for (len = xd.length; !xd[len - 1]; --len) {
              } // xd[0] will always be be 1


              for (i = 1, str = '1.'; i < len; i++) {
                str += NUMERALS.charAt(xd[i]);
              }
            } else {
              str = str.charAt(0) + '.' + str.slice(1);
            }
          }

          str = str + (e < 0 ? 'p' : 'p+') + e;
        } else if (e < 0) {
          for (; ++e;) {
            str = '0' + str;
          }

          str = '0.' + str;
        } else {
          if (++e > len) for (e -= len; e--;) {
            str += '0';
          } else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
        }
      }

      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
    }

    return x.s < 0 ? '-' + str : str;
  } // Does not strip trailing zeros.


  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  } // Decimal methods

  /*
   *  abs
   *  acos
   *  acosh
   *  add
   *  asin
   *  asinh
   *  atan
   *  atanh
   *  atan2
   *  cbrt
   *  ceil
   *  clamp
   *  clone
   *  config
   *  cos
   *  cosh
   *  div
   *  exp
   *  floor
   *  hypot
   *  ln
   *  log
   *  log2
   *  log10
   *  max
   *  min
   *  mod
   *  mul
   *  pow
   *  random
   *  round
   *  set
   *  sign
   *  sin
   *  sinh
   *  sqrt
   *  sub
   *  sum
   *  tan
   *  tanh
   *  trunc
   */

  /*
   * Return a new Decimal whose value is the absolute value of `x`.
   *
   * x {number|string|Decimal}
   *
   */


  function abs(x) {
    return new this(x).abs();
  }
  /*
   * Return a new Decimal whose value is the arccosine in radians of `x`.
   *
   * x {number|string|Decimal}
   *
   */


  function acos(x) {
    return new this(x).acos();
  }
  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */


  function acosh(x) {
    return new this(x).acosh();
  }
  /*
   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */


  function add(x, y) {
    return new this(x).plus(y);
  }
  /*
   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */


  function asin(x) {
    return new this(x).asin();
  }
  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */


  function asinh(x) {
    return new this(x).asinh();
  }
  /*
   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */


  function atan(x) {
    return new this(x).atan();
  }
  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */


  function atanh(x) {
    return new this(x).atanh();
  }
  /*
   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi, pi]
   *
   * y {number|string|Decimal} The y-coordinate.
   * x {number|string|Decimal} The x-coordinate.
   *
   * atan2(±0, -0)               = ±pi
   * atan2(±0, +0)               = ±0
   * atan2(±0, -x)               = ±pi for x > 0
   * atan2(±0, x)                = ±0 for x > 0
   * atan2(-y, ±0)               = -pi/2 for y > 0
   * atan2(y, ±0)                = pi/2 for y > 0
   * atan2(±y, -Infinity)        = ±pi for finite y > 0
   * atan2(±y, +Infinity)        = ±0 for finite y > 0
   * atan2(±Infinity, x)         = ±pi/2 for finite x
   * atan2(±Infinity, -Infinity) = ±3*pi/4
   * atan2(±Infinity, +Infinity) = ±pi/4
   * atan2(NaN, x) = NaN
   * atan2(y, NaN) = NaN
   *
   */


  function atan2(y, x) {
    y = new this(y);
    x = new this(x);
    var r,
        pr = this.precision,
        rm = this.rounding,
        wpr = pr + 4; // Either NaN

    if (!y.s || !x.s) {
      r = new this(NaN); // Both ±Infinity
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s; // x is ±Infinity or y is ±0
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s; // y is ±Infinity or x is ±0
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s; // Both non-zero and finite
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide(y, x, wpr, 1));
    }

    return r;
  }
  /*
   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */


  function cbrt(x) {
    return new this(x).cbrt();
  }
  /*
   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
   *
   * x {number|string|Decimal}
   *
   */


  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }
  /*
   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
   *
   * x {number|string|Decimal}
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */


  function clamp(x, min, max) {
    return new this(x).clamp(min, max);
  }
  /*
   * Configure global settings for a Decimal constructor.
   *
   * `obj` is an object with one or more of the following properties,
   *
   *   precision  {number}
   *   rounding   {number}
   *   toExpNeg   {number}
   *   toExpPos   {number}
   *   maxE       {number}
   *   minE       {number}
   *   modulo     {number}
   *   crypto     {boolean|number}
   *   defaults   {true}
   *
   * E.g. Decimal.config({ precision: 20, rounding: 4 })
   *
   */


  function config(obj) {
    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
    var i,
        p,
        v,
        useDefaults = obj.defaults === true,
        ps = ['precision', 1, MAX_DIGITS, 'rounding', 0, 8, 'toExpNeg', -EXP_LIMIT, 0, 'toExpPos', 0, EXP_LIMIT, 'maxE', 0, EXP_LIMIT, 'minE', -EXP_LIMIT, 0, 'modulo', 0, 9];

    for (i = 0; i < ps.length; i += 3) {
      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];

      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;else throw Error(invalidArgument + p + ': ' + v);
      }
    }

    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];

    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ': ' + v);
      }
    }

    return this;
  }
  /*
   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */


  function cos(x) {
    return new this(x).cos();
  }
  /*
   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */


  function cosh(x) {
    return new this(x).cosh();
  }
  /*
   * Create and return a Decimal constructor with the same configuration properties as this Decimal
   * constructor.
   *
   */


  function clone(obj) {
    var i, p, ps;
    /*
     * The Decimal constructor and exported function.
     * Return a new Decimal instance.
     *
     * v {number|string|Decimal} A numeric value.
     *
     */

    function Decimal(v) {
      var e,
          i,
          t,
          x = this; // Decimal called without new.

      if (!(x instanceof Decimal)) return new Decimal(v); // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
      // which points to Object.

      x.constructor = Decimal; // Duplicate.

      if (isDecimalInstance(v)) {
        x.s = v.s;

        if (external) {
          if (!v.d || v.e > Decimal.maxE) {
            // Infinity.
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal.minE) {
            // Zero.
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }

        return;
      }

      t = typeof v;

      if (t === 'number') {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }

        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        } // Fast path for small integers.


        if (v === ~~v && v < 1e7) {
          for (e = 0, i = v; i >= 10; i /= 10) {
            e++;
          }

          if (external) {
            if (e > Decimal.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e < Decimal.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e;
              x.d = [v];
            }
          } else {
            x.e = e;
            x.d = [v];
          }

          return; // Infinity, NaN.
        } else if (v * 0 !== 0) {
          if (!v) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }

        return parseDecimal(x, v.toString());
      } else if (t !== 'string') {
        throw Error(invalidArgument + v);
      } // Minus sign?


      if ((i = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        // Plus sign?
        if (i === 43) v = v.slice(1);
        x.s = 1;
      }

      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }

    Decimal.prototype = P$1;
    Decimal.ROUND_UP = 0;
    Decimal.ROUND_DOWN = 1;
    Decimal.ROUND_CEIL = 2;
    Decimal.ROUND_FLOOR = 3;
    Decimal.ROUND_HALF_UP = 4;
    Decimal.ROUND_HALF_DOWN = 5;
    Decimal.ROUND_HALF_EVEN = 6;
    Decimal.ROUND_HALF_CEIL = 7;
    Decimal.ROUND_HALF_FLOOR = 8;
    Decimal.EUCLID = 9;
    Decimal.config = Decimal.set = config;
    Decimal.clone = clone;
    Decimal.isDecimal = isDecimalInstance;
    Decimal.abs = abs;
    Decimal.acos = acos;
    Decimal.acosh = acosh; // ES6

    Decimal.add = add;
    Decimal.asin = asin;
    Decimal.asinh = asinh; // ES6

    Decimal.atan = atan;
    Decimal.atanh = atanh; // ES6

    Decimal.atan2 = atan2;
    Decimal.cbrt = cbrt; // ES6

    Decimal.ceil = ceil;
    Decimal.clamp = clamp;
    Decimal.cos = cos;
    Decimal.cosh = cosh; // ES6

    Decimal.div = div;
    Decimal.exp = exp;
    Decimal.floor = floor;
    Decimal.hypot = hypot; // ES6

    Decimal.ln = ln;
    Decimal.log = log;
    Decimal.log10 = log10; // ES6

    Decimal.log2 = log2; // ES6

    Decimal.max = max;
    Decimal.min = min;
    Decimal.mod = mod;
    Decimal.mul = mul;
    Decimal.pow = pow;
    Decimal.random = random;
    Decimal.round = round;
    Decimal.sign = sign$1; // ES6

    Decimal.sin = sin;
    Decimal.sinh = sinh; // ES6

    Decimal.sqrt = sqrt;
    Decimal.sub = sub;
    Decimal.sum = sum;
    Decimal.tan = tan;
    Decimal.tanh = tanh; // ES6

    Decimal.trunc = trunc; // ES6

    if (obj === void 0) obj = {};

    if (obj) {
      if (obj.defaults !== true) {
        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];

        for (i = 0; i < ps.length;) {
          if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
        }
      }
    }

    Decimal.config(obj);
    return Decimal;
  }
  /*
   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */


  function div(x, y) {
    return new this(x).div(y);
  }
  /*
   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The power to which to raise the base of the natural log.
   *
   */


  function exp(x) {
    return new this(x).exp();
  }
  /*
   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
   *
   * x {number|string|Decimal}
   *
   */


  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }
  /*
   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
   *
   * arguments {number|string|Decimal}
   *
   */


  function hypot() {
    var i,
        n,
        t = new this(0);
    external = false;

    for (i = 0; i < arguments.length;) {
      n = new this(arguments[i++]);

      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }

        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }

    external = true;
    return t.sqrt();
  }
  /*
   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
   * otherwise return false.
   *
   */


  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }
  /*
   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */


  function ln(x) {
    return new this(x).ln();
  }
  /*
   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * log[y](x)
   *
   * x {number|string|Decimal} The argument of the logarithm.
   * y {number|string|Decimal} The base of the logarithm.
   *
   */


  function log(x, y) {
    return new this(x).log(y);
  }
  /*
   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */


  function log2(x) {
    return new this(x).log(2);
  }
  /*
   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */


  function log10(x) {
    return new this(x).log(10);
  }
  /*
   * Return a new Decimal whose value is the maximum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */


  function max() {
    return maxOrMin(this, arguments, 'lt');
  }
  /*
   * Return a new Decimal whose value is the minimum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */


  function min() {
    return maxOrMin(this, arguments, 'gt');
  }
  /*
   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */


  function mod(x, y) {
    return new this(x).mod(y);
  }
  /*
   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */


  function mul(x, y) {
    return new this(x).mul(y);
  }
  /*
   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The base.
   * y {number|string|Decimal} The exponent.
   *
   */


  function pow(x, y) {
    return new this(x).pow(y);
  }
  /*
   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
   * are produced).
   *
   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
   *
   */


  function random(sd) {
    var d,
        e,
        k,
        n,
        i = 0,
        r = new this(1),
        rd = [];
    if (sd === void 0) sd = this.precision;else checkInt32(sd, 1, MAX_DIGITS);
    k = Math.ceil(sd / LOG_BASE);

    if (!this.crypto) {
      for (; i < k;) {
        rd[i++] = Math.random() * 1e7 | 0;
      } // Browsers supporting crypto.getRandomValues.

    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));

      for (; i < k;) {
        n = d[i]; // 0 <= n < 4294967296
        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).

        if (n >= 4.29e9) {
          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {
          // 0 <= n <= 4289999999
          // 0 <= (n % 1e7) <= 9999999
          rd[i++] = n % 1e7;
        }
      } // Node.js supporting crypto.randomBytes.

    } else if (crypto.randomBytes) {
      // buffer
      d = crypto.randomBytes(k *= 4);

      for (; i < k;) {
        // 0 <= n < 2147483648
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24); // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).

        if (n >= 2.14e9) {
          crypto.randomBytes(4).copy(d, i);
        } else {
          // 0 <= n <= 2139999999
          // 0 <= (n % 1e7) <= 9999999
          rd.push(n % 1e7);
          i += 4;
        }
      }

      i = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }

    k = rd[--i];
    sd %= LOG_BASE; // Convert trailing digits to zeros according to sd.

    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    } // Remove trailing words which are zero.


    for (; rd[i] === 0; i--) {
      rd.pop();
    } // Zero?


    if (i < 0) {
      e = 0;
      rd = [0];
    } else {
      e = -1; // Remove leading words which are zero and adjust exponent accordingly.

      for (; rd[0] === 0; e -= LOG_BASE) {
        rd.shift();
      } // Count the digits of the first word of rd to determine leading zeros.


      for (k = 1, n = rd[0]; n >= 10; n /= 10) {
        k++;
      } // Adjust the exponent for leading zeros of the first word of rd.


      if (k < LOG_BASE) e -= LOG_BASE - k;
    }

    r.e = e;
    r.d = rd;
    return r;
  }
  /*
   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
   *
   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
   *
   * x {number|string|Decimal}
   *
   */


  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }
  /*
   * Return
   *   1    if x > 0,
   *  -1    if x < 0,
   *   0    if x is 0,
   *  -0    if x is -0,
   *   NaN  otherwise
   *
   * x {number|string|Decimal}
   *
   */


  function sign$1(x) {
    x = new this(x);
    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
  }
  /*
   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */


  function sin(x) {
    return new this(x).sin();
  }
  /*
   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */


  function sinh(x) {
    return new this(x).sinh();
  }
  /*
   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */


  function sqrt(x) {
    return new this(x).sqrt();
  }
  /*
   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */


  function sub(x, y) {
    return new this(x).sub(y);
  }
  /*
   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * Only the result is rounded, not the intermediate calculations.
   *
   * arguments {number|string|Decimal}
   *
   */


  function sum() {
    var i = 0,
        args = arguments,
        x = new this(args[i]);
    external = false;

    for (; x.s && ++i < args.length;) {
      x = x.plus(args[i]);
    }

    external = true;
    return finalise(x, this.precision, this.rounding);
  }
  /*
   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */


  function tan(x) {
    return new this(x).tan();
  }
  /*
   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */


  function tanh(x) {
    return new this(x).tanh();
  }
  /*
   * Return a new Decimal whose value is `x` truncated to an integer.
   *
   * x {number|string|Decimal}
   *
   */


  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }

  P$1[Symbol.for('nodejs.util.inspect.custom')] = P$1.toString;
  P$1[Symbol.toStringTag] = 'Decimal'; // Create and configure initial Decimal constructor.

  var Decimal = P$1.constructor = clone(DEFAULTS); // Create the internal constants from their string values.

  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);

  var decimal = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Decimal: Decimal,
    'default': Decimal
  });

  var require$$0$4 = /*@__PURE__*/getAugmentedNamespace(decimal);

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.int = exports.dec = exports.Int = exports.Dec = exports.Numeric = exports.DEC_PRECISION = void 0;

    var decimal_js_1 = __importDefault(require$$0$4);

    exports.DEC_PRECISION = 18;

    var _Dec = decimal_js_1.default.clone();

    _Dec.prototype.toString = function () {
      return this.toFixed(exports.DEC_PRECISION);
    };

    var Numeric;

    (function (Numeric) {
      function parse(value) {
        if (value instanceof Dec) {
          return value;
        } else if (typeof value === 'string') {
          if (value.includes('.')) {
            return new Dec(value);
          } else {
            return new Int(value);
          }
        } else {
          var _value = new decimal_js_1.default(value);

          if (_value.isInteger()) {
            return new Int(_value);
          } else {
            return new Dec(_value.toString());
          }
        }
      }

      Numeric.parse = parse;
    })(Numeric = exports.Numeric || (exports.Numeric = {}));
    /**
     * Represents decimal values serialized with 18 digits of precision. This implementation
     * is based on the `decimal.js` library, and returns Dec values for only [[Dec.add]],
     * [[Dec.sub]], [[Dec.mul]], [[Dec.div]], and [[Dec.mod]]. For other methods inherited
     * from `Decimal`, you will need to convert back to `Dec` to remain compatible for
     * submitting information that requires `Dec` format back to the blockchain.
     *
     * Example:
     *
     * ```ts
     * const dec = new Dec(1.5);
     *
     * const decimal = dec.sqrt();
     * const dec2 = new Dec(decimal);
     */


    var Dec =
    /** @class */
    function (_super) {
      __extends(Dec, _super);

      function Dec(arg) {
        return _super.call(this, (arg !== null && arg !== void 0 ? arg : 0).toString()) || this;
      }

      Dec.withPrec = function (value, prec) {
        return new Dec(new Dec(value).div(Math.pow(10, prec)));
      }; // type conversion


      Dec.prototype.toInt = function () {
        return new Int(this);
      }; // arithmetic


      Dec.prototype.add = function (other) {
        var val = new Dec(Numeric.parse(other));
        return new Dec(_super.prototype.add.call(this, val));
      };

      Dec.prototype.sub = function (other) {
        var val = new Dec(Numeric.parse(other));
        return new Dec(_super.prototype.sub.call(this, val));
      };

      Dec.prototype.mul = function (other) {
        var val = new Dec(Numeric.parse(other));
        return new Dec(_super.prototype.mul.call(this, val));
      };

      Dec.prototype.div = function (other) {
        var val = new Dec(Numeric.parse(other));
        return new Dec(_super.prototype.div.call(this, val));
      };

      Dec.prototype.mod = function (other) {
        var val = new Dec(Numeric.parse(other));
        return new Dec(_super.prototype.mod.call(this, val));
      };

      return Dec;
    }(_Dec);

    exports.Dec = Dec;

    var _Int = decimal_js_1.default.clone();
    /**
     * Represents Integer values. Used mainly to store integer values of [[Coin]] and [[Coins]].
     *
     * Note: Do not use to work with values greater than 9999999999999999999. This
     * implementation is based on the `decimal.js` library, and returns Int values for only
     * [[Int.add]], [[Int.sub]], [[Int.mul]], [[Int.div]], and [[Int.mod]]. For other
     * methods inherited from `Decimal`, you will need to convert back to `Int` to remain
     * compatible for submitting information that requires `Int` format back to the
     * blockchain.
     *
     * Example:
     *
     * ```ts
     * const int = new Int(1.5);
     *
     * const decimal = int.pow(3);
     * const int2 = new Int(decimal);
     */


    var Int =
    /** @class */
    function (_super) {
      __extends(Int, _super);

      function Int(arg) {
        var _this = this;

        var _arg = new decimal_js_1.default((arg !== null && arg !== void 0 ? arg : 0).toString());

        _this = _super.call(this, _arg.divToInt(1)) || this;
        return _this;
      }

      Int.prototype.toString = function () {
        return this.toFixed();
      }; // type conversion


      Int.prototype.toDec = function () {
        return new Dec(this);
      }; // artihmetic


      Int.prototype.add = function (other) {
        var val = Numeric.parse(other);

        if (val instanceof Dec) {
          return new Dec(this).add(val);
        } else {
          return new Int(this.plus(val));
        }
      };

      Int.prototype.sub = function (other) {
        var val = Numeric.parse(other);

        if (val instanceof Dec) {
          return new Dec(this).sub(val);
        } else {
          return new Int(this.minus(val));
        }
      };

      Int.prototype.mul = function (other) {
        var val = Numeric.parse(other);

        if (val instanceof Dec) {
          return new Dec(this).mul(val);
        } else {
          return new Int(this.times(val));
        }
      };

      Int.prototype.div = function (other) {
        var val = Numeric.parse(other);

        if (val instanceof Dec) {
          return new Dec(this).div(val);
        } else {
          return new Int(_super.prototype.div.call(this, val));
        }
      };

      Int.prototype.mod = function (other) {
        var val = Numeric.parse(other);

        if (val instanceof Dec) {
          return new Dec(this).mod(val);
        } else {
          return new Int(_super.prototype.mod.call(this, val));
        }
      };

      return Int;
    }(_Int);

    exports.Int = Int;
    /**
     * Template tagged literal for creating new Dec objects out of literal string.
     * This does not support literal string interpolation  with `${}`.
     *
     * Usage is:
     *
     * ```ts
     * import { dec } from "@terra-money/terra.js";
     *
     * const dec1 = dec`234.12312`;
     * const dec2 = new Dec("234.12312");
     *
     * dec1.equals(dec2);
     * ```
     * @param strings
     */

    function dec(strings) {
      return new Dec(strings[0]);
    }

    exports.dec = dec;
    /**
     * Template tagged literal for creating new Int objects out of literal string.
     * This does not support literal string interpolation  with `${}`.
     *
     * Usage is:
     *
     * ```ts
     * import { int } from "@terra-money/terra.js";
     *
     * const int1 = int`234`;
     * const int2 = new Int("234");
     *
     * int1.equals(int2);
     * ```
     * @param strings
     */

    function int(strings) {
      return new Int(strings[0]);
    }

    exports.int = int;
  })(numeric);

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Coin = void 0;
    var json_1 = json$1;
    var numeric_1 = numeric;
    /**
     * Captures `sdk.Coin` and `sdk.DecCoin` from Cosmos SDK. A composite value that combines
     * a denomination with an amount value. Coins are immutable once created, and operations
     * that return Coin will return a new Coin. See [[Coins]] for a collection of Coin objects.
     */

    var Coin =
    /** @class */
    function (_super) {
      __extends(Coin, _super);
      /**
       * Creates a new coin. Depending on the type of amount, it will be converted to an
       * integer coin or decimal coin.
       *
       * @param denom denomination
       * @param amount coin's amount
       */


      function Coin(denom, amount) {
        var _this = _super.call(this) || this;

        _this.denom = denom;
        _this.amount = numeric_1.Numeric.parse(amount);
        return _this;
      }

      Coin.fromData = function (data) {
        var denom = data.denom,
            amount = data.amount;
        return new Coin(denom, amount);
      };
      /**
       * Checks whether the Coin is an Integer coin.
       */


      Coin.prototype.isIntCoin = function () {
        // TODO: convert into typeguard
        return this.amount instanceof numeric_1.Int;
      };
      /**
       * Checks whether the Coin is a Decimal coin.
       */


      Coin.prototype.isDecCoin = function () {
        return this.amount instanceof numeric_1.Dec;
      };
      /**
       * Turns the Coin into an Integer coin.
       */


      Coin.prototype.toIntCoin = function () {
        return new Coin(this.denom, new numeric_1.Int(this.amount));
      };
      /**
       * Turns the Coin into a Decimal coin.
       */


      Coin.prototype.toDecCoin = function () {
        return new Coin(this.denom, new numeric_1.Dec(this.amount));
      };

      Coin.prototype.toData = function () {
        var _a = this,
            denom = _a.denom,
            amount = _a.amount;

        return {
          denom: denom,
          amount: amount.toString()
        };
      };
      /**
       * Outputs `<amount><denom>`.
       *
       * Eg: `Coin('uluna', 1500) -> 1500uluna`
       */


      Coin.prototype.toString = function () {
        var amount = this.amount.toFixed();

        if (this.isDecCoin() && amount.indexOf('.') === -1) {
          return amount + ".0" + this.denom;
        }

        return "" + amount + this.denom;
      };

      Coin.fromString = function (str) {
        var m = str.match(/^(-?[0-9]+(\.[0-9]+)?)([a-zA-Z]+)$/);

        if (m === null) {
          throw new Error("failed to parse to Coin: " + str);
        }

        var amount = m[1];
        var denom = m[3];
        return new Coin(denom, amount);
      };
      /**
       * Creates a new Coin adding to the current value.
       *
       * @param other
       */


      Coin.prototype.add = function (other) {
        var otherAmount;

        if (other instanceof Coin) {
          if (other.denom !== this.denom) {
            throw new Coin.ArithmeticError("cannot add two Coins of different denoms: " + this.denom + " and " + other.denom);
          }

          otherAmount = other.amount;
        } else {
          otherAmount = other;
        }

        otherAmount = numeric_1.Numeric.parse(otherAmount);
        return new Coin(this.denom, this.amount.add(otherAmount));
      };
      /**
       * Creates a new Coin subtracting from the current value.
       * @param other
       */


      Coin.prototype.sub = function (other) {
        var otherAmount;

        if (other instanceof Coin) {
          if (other.denom !== this.denom) {
            throw new Coin.ArithmeticError("cannot subtract two Coins of different denoms: " + this.denom + " and " + other.denom);
          }

          otherAmount = other.amount;
        } else {
          otherAmount = other;
        }

        otherAmount = numeric_1.Numeric.parse(otherAmount);
        return new Coin(this.denom, this.amount.sub(otherAmount));
      };
      /**
       * Multiplies the current value with an amount.
       * @param other
       */


      Coin.prototype.mul = function (other) {
        var otherAmount = numeric_1.Numeric.parse(other);
        return new Coin(this.denom, this.amount.mul(otherAmount));
      };
      /**
       * Divides the current value with an amount.
       * @param other
       */


      Coin.prototype.div = function (other) {
        var otherAmount = numeric_1.Numeric.parse(other);
        return new Coin(this.denom, this.amount.div(otherAmount));
      };
      /**
       * Modulo the current value with an amount.
       * @param other
       */


      Coin.prototype.mod = function (other) {
        var otherAmount = numeric_1.Numeric.parse(other);
        return new Coin(this.denom, this.amount.mod(otherAmount));
      };

      return Coin;
    }(json_1.JSONSerializable);

    exports.Coin = Coin;

    (function (Coin) {
      var ArithmeticError =
      /** @class */
      function () {
        function ArithmeticError(message) {
          this.message = message;
        }

        return ArithmeticError;
      }();

      Coin.ArithmeticError = ArithmeticError;
    })(Coin = exports.Coin || (exports.Coin = {}));

    exports.Coin = Coin;
  })(Coin);

  var Coins$1 = {};

  var __extends$11 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __assign$7 = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign$7 = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return __assign$7.apply(this, arguments);
  };

  var __spreadArray$1 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(Coins$1, "__esModule", {
    value: true
  });
  Coins$1.Coins = void 0;
  var Coin_1$a = Coin;
  var json_1$L = json$1;
  /**
   * Analagous to `sdk.Coins` and `sdk.DecCoins` from Cosmos-SDK, and represents a collection
   * of [[Coin]] objects.
   *
   */

  var Coins =
  /** @class */
  function (_super) {
    __extends$11(Coins, _super);
    /**
     * @param arg coins to input
     */


    function Coins(arg) {
      if (arg === void 0) {
        arg = {};
      }

      var _this = _super.call(this) || this;

      if (arg instanceof Coins) {
        _this._coins = __assign$7({}, arg._coins);
      } else if (typeof arg === 'string') {
        _this._coins = Coins.fromString(arg)._coins;
      } else {
        _this._coins = {};
        var coins_2;

        if (!Array.isArray(arg)) {
          coins_2 = [];
          Object.keys(arg).forEach(function (denom) {
            return coins_2.push(new Coin_1$a.Coin(denom, arg[denom]));
          });
        } else {
          coins_2 = arg;
        }

        for (var _i = 0, coins_1 = coins_2; _i < coins_1.length; _i++) {
          var coin = coins_1[_i];
          var denom = coin.denom;
          var x = _this._coins[denom];

          if (x !== undefined) {
            _this._coins[denom] = x.add(coin);
          } else {
            _this._coins[denom] = coin;
          }
        } // convert all coins to Dec if one is Dec


        if (!_this.toArray().every(function (c) {
          return c.isIntCoin();
        })) {
          for (var _a = 0, _b = Object.keys(_this._coins); _a < _b.length; _a++) {
            var denom = _b[_a];
            _this._coins[denom] = _this._coins[denom].toDecCoin();
          }
        }
      }

      return _this;
    }
    /**
     * Converts the Coins information to a comma-separated list.
     *
     * Eg: `15000ukrw,12000uluna`
     */


    Coins.prototype.toString = function () {
      return this.toArray().map(function (c) {
        return c.toString();
      }).join(',');
    };
    /**
     * Converts a comma-separated list of coins to a Coins object
     *
     * Eg. `1500ukrw,12302uluna`
     *
     * @param str comma-separated list of coins
     */


    Coins.fromString = function (str) {
      var coin_strings = str.split(/,\s*/);
      var coins = coin_strings.map(function (s) {
        return Coin_1$a.Coin.fromString(s);
      });
      return new Coins(coins);
    };
    /**
     * Gets the list of denominations
     */


    Coins.prototype.denoms = function () {
      return this.map(function (c) {
        return c.denom;
      });
    };
    /**
     * Creates a new Coins object with all Decimal coins
     */


    Coins.prototype.toDecCoins = function () {
      return new Coins(this.map(function (c) {
        return c.toDecCoin();
      }));
    };
    /**
     * Creates a new Coins object with all Integer coins
     */


    Coins.prototype.toIntCoins = function () {
      return new Coins(this.map(function (c) {
        return c.toIntCoin();
      }));
    };
    /**
     * Gets the Coin for denomination if it exists in the collection.
     * @param denom denomination to lookup
     */


    Coins.prototype.get = function (denom) {
      return this._coins[denom];
    };
    /**
     * Sets the Coin value for a denomination.
     * @param denom denomination to set
     * @param value value to set
     */


    Coins.prototype.set = function (denom, value) {
      var val;

      if (value instanceof Coin_1$a.Coin) {
        if (value.denom != denom) {
          throw new Error("Denoms must match when setting: " + denom + ", " + value.denom);
        }

        val = value;
      } else {
        val = new Coin_1$a.Coin(denom, value);
      }

      this._coins[denom] = val;
    };

    Coins.fromData = function (data) {
      return new Coins((data !== null && data !== void 0 ? data : []).map(Coin_1$a.Coin.fromData));
    };
    /**
     * Gets the individual elements of the collection.
     */


    Coins.prototype.toArray = function () {
      return Object.values(this._coins).sort(function (a, b) {
        return a.denom.localeCompare(b.denom);
      });
    };

    Coins.prototype.toData = function () {
      return this.toArray().map(function (c) {
        return c.toData();
      });
    };
    /**
     * Adds a value from the elements of the collection. Coins of a similar denomination
     * will be clobbered into one value containing their sum.
     * @param other
     */


    Coins.prototype.add = function (other) {
      if (other instanceof Coin_1$a.Coin) {
        return new Coins(__spreadArray$1([other], Object.values(this._coins), true));
      } else {
        return new Coins(__spreadArray$1(__spreadArray$1([], Object.values(other._coins), true), Object.values(this._coins), true));
      }
    };
    /**
     * Subtracts a value from the elements of the collection.
     * @param other
     */


    Coins.prototype.sub = function (other) {
      return this.add(other.mul(-1));
    };
    /**
     * Multiplies the elements of the collection by a value.
     * @param other
     */


    Coins.prototype.mul = function (other) {
      return new Coins(this.map(function (c) {
        return c.mul(other);
      }));
    };
    /**
     * Divides the elements of the collection by a value.
     * @param other
     */


    Coins.prototype.div = function (other) {
      return new Coins(this.map(function (c) {
        return c.div(other);
      }));
    };
    /**
     * Modulos the elements of the collection with a value.
     * @param other
     */


    Coins.prototype.mod = function (other) {
      return new Coins(this.map(function (c) {
        return c.mod(other);
      }));
    };
    /**
     * Map a value onto the elements of the Coin collection.
     * @param fn
     */


    Coins.prototype.map = function (fn) {
      return this.toArray().map(fn);
    };
    /**
     * Filters out the Coin objects that don't match the predicate
     * @param fn predicate
     */


    Coins.prototype.filter = function (fn) {
      return new Coins(this.toArray().filter(fn));
    };

    return Coins;
  }(json_1$L.JSONSerializable);

  Coins$1.Coins = Coins;

  var Denom = {};

  Object.defineProperty(Denom, "__esModule", {
    value: true
  });

  var Msg = {};

  var msgs$8 = {};

  var MsgSend$1 = {};

  var __extends$10 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgSend$1, "__esModule", {
    value: true
  });
  MsgSend$1.MsgSend = void 0;
  var Coins_1$a = Coins$1;
  var json_1$K = json$1;
  /**
   * A basic message for sending [[Coins]] between Terra accounts.
   */

  var MsgSend =
  /** @class */
  function (_super) {
    __extends$10(MsgSend, _super);
    /**
     * @param from_address sender's address
     * @param to_address recipient's address
     * @param amount value of the transaction
     */


    function MsgSend(from_address, to_address, amount) {
      var _this = _super.call(this) || this;

      _this.from_address = from_address;
      _this.to_address = to_address;
      _this.amount = new Coins_1$a.Coins(amount);
      return _this;
    }

    MsgSend.fromData = function (data) {
      var _a = data.value,
          from_address = _a.from_address,
          to_address = _a.to_address,
          amount = _a.amount;
      return new MsgSend(from_address, to_address, Coins_1$a.Coins.fromData(amount));
    };

    MsgSend.prototype.toData = function () {
      var _a = this,
          from_address = _a.from_address,
          to_address = _a.to_address,
          amount = _a.amount;

      return {
        type: 'bank/MsgSend',
        value: {
          from_address: from_address,
          to_address: to_address,
          amount: amount.toData()
        }
      };
    };

    return MsgSend;
  }(json_1$K.JSONSerializable);

  MsgSend$1.MsgSend = MsgSend;

  var MsgMultiSend = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MsgMultiSend = void 0;
    var json_1 = json$1;
    var Coins_1 = Coins$1;
    /**
     * If you have multiple senders and/or multiple recipients, you can use MsgMultiSend,
     * which can batch together the senders and recipients in one message to save on gas
     * fees.
     *
     * Specify the senders and recipients and their corresponding deposit contribution /
     * receiving amounts with [[MsgMultiSend.Input]] or [[MsgMultiSend.Output]].
     *
     * Example:
     *
     * ```ts
     * import { MsgMultiSend } from "@terra-money/terra.js";
     *
     * const inputs: MsgMultiSend.Input[] = [
     *    new MsgMultiSend.Input(
     *      'terra105rz2q5a4w7nv7239tl9c4px5cjy7axx3axf6p',
     *      {
     *        ukrw: 123123,
     *      })
     *    ),
     *    new MsgMultiSend.Input('terra105rz2q5a4w7nv7239tl9c4px5cjy7axx3axfad', [
     *      new Coin('uluna', 123123),
     *    ]),
     *  ];
     *   const outputs: MsgMultiSend.Output[] = [
     *    new MsgMultiSend.Output(
     *      'terra105rz2q5a4w7nv7239tl9c4px5cjy7axx3axfad',
     *        {
     *          ukrw: 123123,
     *        }
     *    ),
     *    new MsgMultiSend.Output('terra105rz2q5a4w7nv7239tl9c4px5cjy7axx3axfga',
     *      {
     *        uluna: 123123,
     *      }
     *    ),
     *  ];
     *  const multisend = new MsgMultiSend(inputs, outputs);
     * ```
     */

    var MsgMultiSend =
    /** @class */
    function (_super) {
      __extends(MsgMultiSend, _super);
      /**
       * @param inputs inputs
       * @param outputs outputs
       */


      function MsgMultiSend(inputs, outputs) {
        var _this = _super.call(this) || this;

        _this.inputs = inputs;
        _this.outputs = outputs;
        return _this;
      }

      MsgMultiSend.fromData = function (data) {
        var _a = data.value,
            inputs = _a.inputs,
            outputs = _a.outputs;
        return new MsgMultiSend(inputs.map(function (i) {
          return MsgMultiSend.Input.fromData(i);
        }), outputs.map(function (o) {
          return MsgMultiSend.Output.fromData(o);
        }));
      };

      MsgMultiSend.prototype.toData = function () {
        var _a = this,
            inputs = _a.inputs,
            outputs = _a.outputs;

        return {
          type: 'bank/MsgMultiSend',
          value: {
            inputs: inputs.map(function (i) {
              return i.toData();
            }),
            outputs: outputs.map(function (o) {
              return o.toData();
            })
          }
        };
      };

      return MsgMultiSend;
    }(json_1.JSONSerializable);

    exports.MsgMultiSend = MsgMultiSend;

    (function (MsgMultiSend) {
      var IO =
      /** @class */
      function (_super) {
        __extends(IO, _super);
        /**
         * @param address address
         * @param coinsInput coins-compatible input
         */


        function IO(address, coinsInput) {
          var _this = _super.call(this) || this;

          _this.address = address;
          _this.coins = new Coins_1.Coins(coinsInput);
          return _this;
        }

        IO.prototype.toData = function () {
          var _a = this,
              address = _a.address,
              coins = _a.coins;

          return {
            address: address,
            coins: coins.toData()
          };
        };

        IO.fromData = function (data) {
          var address = data.address,
              coins = data.coins;
          return new IO(address, Coins_1.Coins.fromData(coins));
        };

        return IO;
      }(json_1.JSONSerializable);

      MsgMultiSend.IO = IO;
      MsgMultiSend.Input = IO;
      MsgMultiSend.Output = IO;
    })(MsgMultiSend = exports.MsgMultiSend || (exports.MsgMultiSend = {}));

    exports.MsgMultiSend = MsgMultiSend;
  })(MsgMultiSend);

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(MsgSend$1, exports);

    __exportStar(MsgMultiSend, exports);
  })(msgs$8);

  var msgs$7 = {};

  var MsgModifyWithdrawAddress$1 = {};

  var __extends$$ = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgModifyWithdrawAddress$1, "__esModule", {
    value: true
  });
  MsgModifyWithdrawAddress$1.MsgModifyWithdrawAddress = void 0;
  var json_1$J = json$1;
  /**
   * A validator can withdraw their outstanding commission rewards accrued from all
   * delegations (not including its self-delegation) into their associated account's
   * withdraw address.
   */

  var MsgModifyWithdrawAddress =
  /** @class */
  function (_super) {
    __extends$$(MsgModifyWithdrawAddress, _super);
    /**
     * @param delegator_address delegator's account address
     * @param withdraw_address desired new withdraw address
     */


    function MsgModifyWithdrawAddress(delegator_address, withdraw_address) {
      var _this = _super.call(this) || this;

      _this.delegator_address = delegator_address;
      _this.withdraw_address = withdraw_address;
      return _this;
    }

    MsgModifyWithdrawAddress.fromData = function (data) {
      var _a = data.value,
          delegator_address = _a.delegator_address,
          withdraw_address = _a.withdraw_address;
      return new MsgModifyWithdrawAddress(delegator_address, withdraw_address);
    };

    MsgModifyWithdrawAddress.prototype.toData = function () {
      var _a = this,
          delegator_address = _a.delegator_address,
          withdraw_address = _a.withdraw_address;

      return {
        type: 'distribution/MsgModifyWithdrawAddress',
        value: {
          delegator_address: delegator_address,
          withdraw_address: withdraw_address
        }
      };
    };

    return MsgModifyWithdrawAddress;
  }(json_1$J.JSONSerializable);

  MsgModifyWithdrawAddress$1.MsgModifyWithdrawAddress = MsgModifyWithdrawAddress;

  var MsgWithdrawDelegationReward$1 = {};

  var __extends$_ = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgWithdrawDelegationReward$1, "__esModule", {
    value: true
  });
  MsgWithdrawDelegationReward$1.MsgWithdrawDelegationReward = void 0;
  var json_1$I = json$1;
  /**
   * A delegator can withdraw currently outstanding rewards accrued from their delegation
   * toward a validator by submitting the following message.
   *
   * The rewards will be deposited to their Withdraw Address.
   */

  var MsgWithdrawDelegationReward =
  /** @class */
  function (_super) {
    __extends$_(MsgWithdrawDelegationReward, _super);
    /**
     *
     * @param delegator_address delegator's account address
     * @param validator_address validator's operator address
     */


    function MsgWithdrawDelegationReward(delegator_address, validator_address) {
      var _this = _super.call(this) || this;

      _this.delegator_address = delegator_address;
      _this.validator_address = validator_address;
      return _this;
    }

    MsgWithdrawDelegationReward.fromData = function (data) {
      var _a = data.value,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address;
      return new MsgWithdrawDelegationReward(delegator_address, validator_address);
    };

    MsgWithdrawDelegationReward.prototype.toData = function () {
      var _a = this,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address;

      return {
        type: 'distribution/MsgWithdrawDelegationReward',
        value: {
          delegator_address: delegator_address,
          validator_address: validator_address
        }
      };
    };

    return MsgWithdrawDelegationReward;
  }(json_1$I.JSONSerializable);

  MsgWithdrawDelegationReward$1.MsgWithdrawDelegationReward = MsgWithdrawDelegationReward;

  var MsgWithdrawValidatorCommission$1 = {};

  var __extends$Z = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgWithdrawValidatorCommission$1, "__esModule", {
    value: true
  });
  MsgWithdrawValidatorCommission$1.MsgWithdrawValidatorCommission = void 0;
  var json_1$H = json$1;
  /**
   * A validator can withdraw their outstanding commission rewards accrued from all
   * delegations (not including its self-delegation) into their associated account's
   * withdraw address.
   */

  var MsgWithdrawValidatorCommission =
  /** @class */
  function (_super) {
    __extends$Z(MsgWithdrawValidatorCommission, _super);
    /**
     * @param validator_address validator's operator address
     */


    function MsgWithdrawValidatorCommission(validator_address) {
      var _this = _super.call(this) || this;

      _this.validator_address = validator_address;
      return _this;
    }

    MsgWithdrawValidatorCommission.fromData = function (data) {
      var validator_address = data.value.validator_address;
      return new MsgWithdrawValidatorCommission(validator_address);
    };

    MsgWithdrawValidatorCommission.prototype.toData = function () {
      var validator_address = this.validator_address;
      return {
        type: 'distribution/MsgWithdrawValidatorCommission',
        value: {
          validator_address: validator_address
        }
      };
    };

    return MsgWithdrawValidatorCommission;
  }(json_1$H.JSONSerializable);

  MsgWithdrawValidatorCommission$1.MsgWithdrawValidatorCommission = MsgWithdrawValidatorCommission;

  var MsgFundCommunityPool$1 = {};

  var __extends$Y = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgFundCommunityPool$1, "__esModule", {
    value: true
  });
  MsgFundCommunityPool$1.MsgFundCommunityPool = void 0;
  var json_1$G = json$1;
  var Coins_1$9 = Coins$1;

  var MsgFundCommunityPool =
  /** @class */
  function (_super) {
    __extends$Y(MsgFundCommunityPool, _super);
    /**
     * @param depositor depositor's account address
     * @param amount coins to fund the community pool
     */


    function MsgFundCommunityPool(depositor, amount) {
      var _this = _super.call(this) || this;

      _this.depositor = depositor;
      _this.amount = new Coins_1$9.Coins(amount);
      return _this;
    }

    MsgFundCommunityPool.fromData = function (data) {
      var _a = data.value,
          depositor = _a.depositor,
          amount = _a.amount;
      return new MsgFundCommunityPool(depositor, Coins_1$9.Coins.fromData(amount));
    };

    MsgFundCommunityPool.prototype.toData = function () {
      var _a = this,
          depositor = _a.depositor,
          amount = _a.amount;

      return {
        type: 'distribution/MsgFundCommunityPool',
        value: {
          depositor: depositor,
          amount: amount.toData()
        }
      };
    };

    return MsgFundCommunityPool;
  }(json_1$G.JSONSerializable);

  MsgFundCommunityPool$1.MsgFundCommunityPool = MsgFundCommunityPool;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(MsgModifyWithdrawAddress$1, exports);

    __exportStar(MsgWithdrawDelegationReward$1, exports);

    __exportStar(MsgWithdrawValidatorCommission$1, exports);

    __exportStar(MsgFundCommunityPool$1, exports);
  })(msgs$7);

  var msgs$6 = {};

  var MsgDeposit$1 = {};

  var __extends$X = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgDeposit$1, "__esModule", {
    value: true
  });
  MsgDeposit$1.MsgDeposit = void 0;
  var Coins_1$8 = Coins$1;
  var json_1$F = json$1;
  /**
   * Add a deposit for a proposal
   */

  var MsgDeposit =
  /** @class */
  function (_super) {
    __extends$X(MsgDeposit, _super);
    /**
     * @param proposal_id Id of porposal to deposit to
     * @param depositor depositor's account address
     * @param amount amount to deposit
     */


    function MsgDeposit(proposal_id, depositor, amount) {
      var _this = _super.call(this) || this;

      _this.proposal_id = proposal_id;
      _this.depositor = depositor;
      _this.amount = new Coins_1$8.Coins(amount);
      return _this;
    }

    MsgDeposit.fromData = function (data) {
      var _a = data.value,
          proposal_id = _a.proposal_id,
          depositor = _a.depositor,
          amount = _a.amount;
      return new MsgDeposit(Number.parseInt(proposal_id), depositor, Coins_1$8.Coins.fromData(amount));
    };

    MsgDeposit.prototype.toData = function () {
      var _a = this,
          proposal_id = _a.proposal_id,
          depositor = _a.depositor,
          amount = _a.amount;

      return {
        type: 'gov/MsgDeposit',
        value: {
          proposal_id: proposal_id.toString(),
          depositor: depositor,
          amount: amount.toData()
        }
      };
    };

    return MsgDeposit;
  }(json_1$F.JSONSerializable);

  MsgDeposit$1.MsgDeposit = MsgDeposit;

  var MsgSubmitProposal$1 = {};

  var Proposal = {};

  var proposals$3 = {};

  var CommunityPoolSpendProposal$1 = {};

  var __extends$W = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(CommunityPoolSpendProposal$1, "__esModule", {
    value: true
  });
  CommunityPoolSpendProposal$1.CommunityPoolSpendProposal = void 0;
  var json_1$E = json$1;
  var Coins_1$7 = Coins$1;
  /**
   * Proposal that disburses funds from the Distribution module's community pool to the
   * specified recipient if passed.
   */

  var CommunityPoolSpendProposal =
  /** @class */
  function (_super) {
    __extends$W(CommunityPoolSpendProposal, _super);
    /**
     * @param title proposal's title
     * @param description proposal's description
     * @param recipient recipient address
     * @param amount amount to give recipient
     */


    function CommunityPoolSpendProposal(title, description, recipient, amount) {
      var _this = _super.call(this) || this;

      _this.title = title;
      _this.description = description;
      _this.recipient = recipient;
      _this.amount = new Coins_1$7.Coins(amount);
      return _this;
    }

    CommunityPoolSpendProposal.fromData = function (data) {
      var _a = data.value,
          title = _a.title,
          description = _a.description,
          recipient = _a.recipient,
          amount = _a.amount;
      return new CommunityPoolSpendProposal(title, description, recipient, Coins_1$7.Coins.fromData(amount));
    };

    CommunityPoolSpendProposal.prototype.toData = function () {
      var _a = this,
          title = _a.title,
          description = _a.description,
          recipient = _a.recipient,
          amount = _a.amount;

      return {
        type: 'distribution/CommunityPoolSpendProposal',
        value: {
          title: title,
          description: description,
          recipient: recipient,
          amount: amount.toData()
        }
      };
    };

    return CommunityPoolSpendProposal;
  }(json_1$E.JSONSerializable);

  CommunityPoolSpendProposal$1.CommunityPoolSpendProposal = CommunityPoolSpendProposal;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(CommunityPoolSpendProposal$1, exports);
  })(proposals$3);

  var proposals$2 = {};

  var ParameterChangeProposal$1 = {};

  var ParamChange$1 = {};

  var __extends$V = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(ParamChange$1, "__esModule", {
    value: true
  });
  ParamChange$1.ParamChange = ParamChange$1.ParamChanges = void 0;
  var json_1$D = json$1;

  var ParamChanges =
  /** @class */
  function (_super) {
    __extends$V(ParamChanges, _super);

    function ParamChanges(paramChanges) {
      var _this = _super.call(this) || this;

      _this.paramChanges = paramChanges;
      return _this;
    }

    ParamChanges.fromData = function (proto) {
      return new ParamChanges((proto !== null && proto !== void 0 ? proto : []).map(ParamChange.fromData));
    };

    ParamChanges.prototype.toData = function () {
      return this.paramChanges.map(function (c) {
        return c.toData();
      });
    };

    return ParamChanges;
  }(json_1$D.JSONSerializable);

  ParamChange$1.ParamChanges = ParamChanges;

  var ParamChange =
  /** @class */
  function (_super) {
    __extends$V(ParamChange, _super);

    function ParamChange(subspace, key, value) {
      var _this = _super.call(this) || this;

      _this.subspace = subspace;
      _this.key = key;
      _this.value = value;
      return _this;
    }

    ParamChange.fromData = function (data) {
      var subspace = data.subspace,
          key = data.key,
          value = data.value;
      return new ParamChange(subspace, key, value);
    };

    ParamChange.prototype.toData = function () {
      var _a = this,
          subspace = _a.subspace,
          key = _a.key,
          value = _a.value;

      return {
        subspace: subspace,
        key: key,
        value: value
      };
    };

    return ParamChange;
  }(json_1$D.JSONSerializable);

  ParamChange$1.ParamChange = ParamChange;

  var __extends$U = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(ParameterChangeProposal$1, "__esModule", {
    value: true
  });
  ParameterChangeProposal$1.ParameterChangeProposal = void 0;
  var json_1$C = json$1;
  var ParamChange_1 = ParamChange$1;
  /**
   * Describes a proposal for directly altering the value of the module parameters.
   * If you want to select a couple parameters to change for your proposal, you'll first
   * include the subspace (module it belongs to, such as "oracle" or "distribution"), and
   * then just the specific keys that you want to include in your changes as items in a
   * JavaScript object.
   *
   * ```ts
   * import {
   *    Dec,
   *    MsgSubmitProposal,
   *    ParameterChangeProposal
   * } from "@terra-money/terra.js";
   *
   * const proposal = new ParameterChangeProposal("title", "description", {
   *    market: {
   *      minspread: new Dec(0.25),
   *      basepool: new Dec(10000000)
   *    },
   *    staking: {
   *      UnbondingTime: 15000000
   *    }
   * });
   *
   * const msg = new MsgSubmitProposal();
   * ```
   */

  var ParameterChangeProposal =
  /** @class */
  function (_super) {
    __extends$U(ParameterChangeProposal, _super);
    /**
     * @param title proposal's title
     * @param description proposal's description
     * @param changes an object whose keys are subspace names, and whose values are objects
     * with objects having for keys and values, the desired parameter changes.
     */


    function ParameterChangeProposal(title, description, changes) {
      var _this = _super.call(this) || this;

      _this.title = title;
      _this.description = description;

      if (Array.isArray(changes)) {
        _this.changes = ParamChange_1.ParamChanges.fromData(changes);
      } else {
        _this.changes = changes;
      }

      return _this;
    }

    ParameterChangeProposal.fromData = function (data) {
      var _a = data.value,
          title = _a.title,
          description = _a.description,
          changes = _a.changes;
      return new ParameterChangeProposal(title, description, ParamChange_1.ParamChanges.fromData(changes));
    };

    ParameterChangeProposal.prototype.toData = function () {
      var _a = this,
          title = _a.title,
          description = _a.description,
          changes = _a.changes;

      return {
        type: 'params/ParameterChangeProposal',
        value: {
          title: title,
          description: description,
          changes: changes.toData()
        }
      };
    };

    return ParameterChangeProposal;
  }(json_1$C.JSONSerializable);

  ParameterChangeProposal$1.ParameterChangeProposal = ParameterChangeProposal;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(ParameterChangeProposal$1, exports);
  })(proposals$2);

  var proposals$1 = {};

  var TextProposal$1 = {};

  var __extends$T = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(TextProposal$1, "__esModule", {
    value: true
  });
  TextProposal$1.TextProposal = void 0;
  var json_1$B = json$1;
  /**
   * Basic proposal which describes the candidate proposition that must be put into effect
   * manually if passed. Used as a general-purpose way of discovering community's
   * sentiment / interest for an arbitrary change.
   */

  var TextProposal =
  /** @class */
  function (_super) {
    __extends$T(TextProposal, _super);
    /**
     * @param title proposal's title
     * @param description proposal's description
     */


    function TextProposal(title, description) {
      var _this = _super.call(this) || this;

      _this.title = title;
      _this.description = description;
      return _this;
    }

    TextProposal.fromData = function (data) {
      var _a = data.value,
          title = _a.title,
          description = _a.description;
      return new TextProposal(title, description);
    };

    TextProposal.prototype.toData = function () {
      var _a = this,
          title = _a.title,
          description = _a.description;

      return {
        type: 'gov/TextProposal',
        value: {
          title: title,
          description: description
        }
      };
    };

    return TextProposal;
  }(json_1$B.JSONSerializable);

  TextProposal$1.TextProposal = TextProposal;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(TextProposal$1, exports);
  })(proposals$1);

  var proposals = {};

  var SoftwareUpgradeProposal$1 = {};

  var Plan$1 = {};

  var __extends$S = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(Plan$1, "__esModule", {
    value: true
  });
  Plan$1.Plan = void 0;
  var json_1$A = json$1;
  /*
   * Plan specifies information about a planned upgrade and when it should occur.
   */

  var Plan =
  /** @class */
  function (_super) {
    __extends$S(Plan, _super);
    /**
     * @param name This name will be used by the upgraded  version of the software to apply any special "on-upgrade" commands during the first BeginBlock method after the upgrade is applied.
     * @param time Deprecated
     * @param height  The height at which the upgrade must be performed. Only used if Time is not set.
     * @param info Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to
     * @param upgraded_client_state Deprecated
     */


    function Plan(name, time, height, info, upgraded_client_state) {
      var _this = _super.call(this) || this;

      _this.name = name;
      _this.time = time;
      _this.height = height;
      _this.info = info;
      _this.upgraded_client_state = upgraded_client_state;
      return _this;
    }

    Plan.fromData = function (data) {
      var name = data.name,
          time = data.time,
          height = data.height,
          info = data.info,
          upgraded_client_state = data.upgraded_client_state;
      return new Plan(name, time ? new Date(time) : undefined, height, info, upgraded_client_state);
    };

    Plan.prototype.toData = function () {
      var _a = this,
          name = _a.name,
          time = _a.time,
          height = _a.height,
          info = _a.info,
          upgraded_client_state = _a.upgraded_client_state;

      var res = {
        name: name,
        time: time ? time.toISOString().replace(/\.000Z$/, 'Z') : undefined,
        height: height,
        info: info,
        upgraded_client_state: upgraded_client_state
      };
      return res;
    };

    return Plan;
  }(json_1$A.JSONSerializable);

  Plan$1.Plan = Plan;

  var __extends$R = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(SoftwareUpgradeProposal$1, "__esModule", {
    value: true
  });
  SoftwareUpgradeProposal$1.SoftwareUpgradeProposal = void 0;
  var json_1$z = json$1;
  var Plan_1 = Plan$1;
  /**
   * Softwareupgradeproposal is a gov Content type for initiating a software upgrade.
   */

  var SoftwareUpgradeProposal =
  /** @class */
  function (_super) {
    __extends$R(SoftwareUpgradeProposal, _super);
    /**
     *
     * @param title
     * @param description
     * @param plan
     */


    function SoftwareUpgradeProposal(title, description, plan) {
      var _this = _super.call(this) || this;

      _this.title = title;
      _this.description = description;
      _this.plan = plan;
      return _this;
    }

    SoftwareUpgradeProposal.fromData = function (data) {
      var _a = data.value,
          title = _a.title,
          description = _a.description,
          plan = _a.plan;
      return new SoftwareUpgradeProposal(title, description, plan ? Plan_1.Plan.fromData(plan) : undefined);
    };

    SoftwareUpgradeProposal.prototype.toData = function () {
      var _a = this,
          title = _a.title,
          description = _a.description,
          plan = _a.plan;

      return {
        type: 'upgrade/SoftwareUpgradeProposal',
        value: {
          title: title,
          description: description,
          plan: plan ? plan.toData() : undefined
        }
      };
    };

    return SoftwareUpgradeProposal;
  }(json_1$z.JSONSerializable);

  SoftwareUpgradeProposal$1.SoftwareUpgradeProposal = SoftwareUpgradeProposal;

  var CancelSoftwareUpgradeProposal$1 = {};

  var __extends$Q = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(CancelSoftwareUpgradeProposal$1, "__esModule", {
    value: true
  });
  CancelSoftwareUpgradeProposal$1.CancelSoftwareUpgradeProposal = void 0;
  var json_1$y = json$1;
  /**
   *  CancelSoftwareUpgradeProposal is a gov Content type for cancelling a software upgrade
   */

  var CancelSoftwareUpgradeProposal =
  /** @class */
  function (_super) {
    __extends$Q(CancelSoftwareUpgradeProposal, _super);
    /**
     *
     * @param title
     * @param description
     */


    function CancelSoftwareUpgradeProposal(title, description) {
      var _this = _super.call(this) || this;

      _this.title = title;
      _this.description = description;
      return _this;
    }

    CancelSoftwareUpgradeProposal.fromData = function (data) {
      var _a = data.value,
          title = _a.title,
          description = _a.description;
      return new CancelSoftwareUpgradeProposal(title, description);
    };

    CancelSoftwareUpgradeProposal.prototype.toData = function () {
      var _a = this,
          title = _a.title,
          description = _a.description;

      return {
        type: 'upgrade/CancelSoftwareUpgradeProposal',
        value: {
          title: title,
          description: description
        }
      };
    };

    return CancelSoftwareUpgradeProposal;
  }(json_1$y.JSONSerializable);

  CancelSoftwareUpgradeProposal$1.CancelSoftwareUpgradeProposal = CancelSoftwareUpgradeProposal;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(SoftwareUpgradeProposal$1, exports);

    __exportStar(CancelSoftwareUpgradeProposal$1, exports);
  })(proposals);

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Proposal = void 0;
    var Coins_1 = Coins$1;
    var numeric_1 = numeric;
    var json_1 = json$1;
    var proposals_1 = proposals$3;
    var proposals_2 = proposals$2;
    var proposals_3 = proposals$1;
    var proposals_4 = proposals;
    /**
     * Stores information pertaining to a submitted proposal, such as its status and time of
     * the voting period
     */

    var Proposal =
    /** @class */
    function (_super) {
      __extends(Proposal, _super);
      /**
       *
       * @param id proposal's ID
       * @param content content of the proposal
       * @param status proposal's status
       * @param final_tally_result tally result
       * @param submit_time time proposal was submitted and deposit period started
       * @param deposit_end_time time deposit period will end
       * @param total_deposit amount of coins deposited by all users
       * @param voting_start_time time voting period will start
       * @param voting_end_time time voting period will end
       */


      function Proposal(id, content, status, final_tally_result, submit_time, deposit_end_time, total_deposit, voting_start_time, voting_end_time) {
        var _this = _super.call(this) || this;

        _this.id = id;
        _this.content = content;
        _this.status = status;
        _this.final_tally_result = final_tally_result;
        _this.submit_time = submit_time;
        _this.deposit_end_time = deposit_end_time;
        _this.total_deposit = total_deposit;
        _this.voting_start_time = voting_start_time;
        _this.voting_end_time = voting_end_time;
        return _this;
      }

      Proposal.fromData = function (data) {
        var id = data.id,
            content = data.content,
            status = data.status,
            final_tally_result = data.final_tally_result,
            submit_time = data.submit_time,
            deposit_end_time = data.deposit_end_time,
            total_deposit = data.total_deposit,
            voting_start_time = data.voting_start_time,
            voting_end_time = data.voting_end_time;
        var ftr;

        if (final_tally_result) {
          ftr = {
            yes: new numeric_1.Int(final_tally_result.yes),
            no: new numeric_1.Int(final_tally_result.no),
            abstain: new numeric_1.Int(final_tally_result.abstain),
            no_with_veto: new numeric_1.Int(final_tally_result.no_with_veto)
          };
        }

        return new Proposal(Number.parseInt(id), Proposal.Content.fromData(content), status, ftr, new Date(submit_time), new Date(deposit_end_time), Coins_1.Coins.fromData(total_deposit), new Date(voting_start_time), new Date(voting_end_time));
      };

      Proposal.prototype.toData = function () {
        var _a = this,
            status = _a.status,
            final_tally_result = _a.final_tally_result;

        var ftr;

        if (final_tally_result) {
          ftr = {
            yes: final_tally_result.yes.toString(),
            no: final_tally_result.no.toString(),
            abstain: final_tally_result.abstain.toString(),
            no_with_veto: final_tally_result.no_with_veto.toString()
          };
        }

        return {
          id: this.id.toFixed(),
          content: this.content.toData(),
          status: status,
          final_tally_result: ftr,
          submit_time: this.submit_time.toISOString(),
          deposit_end_time: this.deposit_end_time.toISOString(),
          total_deposit: this.total_deposit.toData(),
          voting_start_time: this.voting_start_time.toISOString(),
          voting_end_time: this.voting_end_time.toISOString()
        };
      };

      return Proposal;
    }(json_1.JSONSerializable);

    exports.Proposal = Proposal;

    (function (Proposal) {

      (function (Content) {
        function fromData(data) {
          switch (data.type) {
            case 'gov/TextProposal':
              return proposals_3.TextProposal.fromData(data);

            case 'distribution/CommunityPoolSpendProposal':
              return proposals_1.CommunityPoolSpendProposal.fromData(data);

            case 'params/ParameterChangeProposal':
              return proposals_2.ParameterChangeProposal.fromData(data);

            case 'upgrade/SoftwareUpgradeProposal':
              return proposals_4.SoftwareUpgradeProposal.fromData(data);

            case 'upgrade/CancelSoftwareUpgradeProposal':
              return proposals_4.CancelSoftwareUpgradeProposal.fromData(data);
          }
        }

        Content.fromData = fromData;
      })(Proposal.Content || (Proposal.Content = {}));

      (function (Status) {
        Status[Status["NIL"] = 0] = "NIL";
        Status[Status["DEPOSIT_PERIOD"] = 1] = "DEPOSIT_PERIOD";
        Status[Status["VOTING_PERIOD"] = 2] = "VOTING_PERIOD";
        Status[Status["PASSED"] = 3] = "PASSED";
        Status[Status["REJECTED"] = 4] = "REJECTED";
        Status[Status["FAILED"] = 5] = "FAILED";
      })(Proposal.Status || (Proposal.Status = {}));
    })(Proposal = exports.Proposal || (exports.Proposal = {}));

    exports.Proposal = Proposal;
  })(Proposal);

  var __extends$P = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgSubmitProposal$1, "__esModule", {
    value: true
  });
  MsgSubmitProposal$1.MsgSubmitProposal = void 0;
  var Coins_1$6 = Coins$1;
  var Proposal_1 = Proposal;
  var json_1$x = json$1;
  /**
   * Submit a proposal alongside an initial deposit.
   */

  var MsgSubmitProposal =
  /** @class */
  function (_super) {
    __extends$P(MsgSubmitProposal, _super);
    /**
     * @param content proposal content to submit
     * @param initial_deposit deposit provided
     * @param proposer proposer's account address
     */


    function MsgSubmitProposal(content, initial_deposit, proposer) {
      var _this = _super.call(this) || this;

      _this.content = content;
      _this.proposer = proposer;
      _this.initial_deposit = new Coins_1$6.Coins(initial_deposit);
      return _this;
    }

    MsgSubmitProposal.fromData = function (data) {
      var _a = data.value,
          content = _a.content,
          initial_deposit = _a.initial_deposit,
          proposer = _a.proposer;
      return new MsgSubmitProposal(Proposal_1.Proposal.Content.fromData(content), Coins_1$6.Coins.fromData(initial_deposit), proposer);
    };

    MsgSubmitProposal.prototype.toData = function () {
      var _a = this,
          content = _a.content,
          initial_deposit = _a.initial_deposit,
          proposer = _a.proposer;

      return {
        type: 'gov/MsgSubmitProposal',
        value: {
          content: content.toData(),
          initial_deposit: initial_deposit.toData(),
          proposer: proposer
        }
      };
    };

    return MsgSubmitProposal;
  }(json_1$x.JSONSerializable);

  MsgSubmitProposal$1.MsgSubmitProposal = MsgSubmitProposal;

  var MsgVote = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MsgVote = void 0;
    var json_1 = json$1;
    /**
     * Vote for a proposal
     */

    var MsgVote =
    /** @class */
    function (_super) {
      __extends(MsgVote, _super);
      /**
       * @param proposal_id ID of proposal to vote on
       * @param voter voter's account address
       * @param option one of voting options
       */


      function MsgVote(proposal_id, voter, option) {
        var _this = _super.call(this) || this;

        _this.proposal_id = proposal_id;
        _this.voter = voter;
        _this.option = option;
        return _this;
      }

      MsgVote.fromData = function (data) {
        var _a = data.value,
            proposal_id = _a.proposal_id,
            voter = _a.voter,
            option = _a.option;
        return new MsgVote(Number.parseInt(proposal_id), voter, option);
      };

      MsgVote.prototype.toData = function () {
        var _a = this,
            proposal_id = _a.proposal_id,
            voter = _a.voter,
            option = _a.option;

        return {
          type: 'gov/MsgVote',
          value: {
            proposal_id: proposal_id.toFixed(),
            voter: voter,
            option: option
          }
        };
      };

      return MsgVote;
    }(json_1.JSONSerializable);

    exports.MsgVote = MsgVote;

    (function (MsgVote) {

      (function (Option) {
        Option[Option["EMPTY"] = 0] = "EMPTY";
        Option[Option["YES"] = 1] = "YES";
        Option[Option["ABSTAIN"] = 2] = "ABSTAIN";
        Option[Option["NO"] = 3] = "NO";
        Option[Option["NO_WITH_VETO"] = 4] = "NO_WITH_VETO";
      })(MsgVote.Option || (MsgVote.Option = {}));
    })(MsgVote = exports.MsgVote || (exports.MsgVote = {}));

    exports.MsgVote = MsgVote;
  })(MsgVote);

  var MsgVoteWeighted$1 = {};

  var __extends$O = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgVoteWeighted$1, "__esModule", {
    value: true
  });
  MsgVoteWeighted$1.MsgVoteWeighted = void 0;
  var json_1$w = json$1;
  /**
   * Weighted vote for a proposal
   */

  var MsgVoteWeighted =
  /** @class */
  function (_super) {
    __extends$O(MsgVoteWeighted, _super);
    /**
     * @param proposal_id ID of proposal to vote on
     * @param voter voter's account address
     * @param option one of voting options
     */


    function MsgVoteWeighted(proposal_id, voter, options) {
      var _this = _super.call(this) || this;

      _this.proposal_id = proposal_id;
      _this.voter = voter;
      _this.options = options;
      return _this;
    }

    MsgVoteWeighted.fromData = function (data) {
      var _a = data.value,
          proposal_id = _a.proposal_id,
          voter = _a.voter,
          options = _a.options;
      return new MsgVoteWeighted(Number.parseInt(proposal_id), voter, options);
    };

    MsgVoteWeighted.prototype.toData = function () {
      var _a = this,
          proposal_id = _a.proposal_id,
          voter = _a.voter,
          options = _a.options;

      return {
        type: 'gov/MsgVoteWeighted',
        value: {
          proposal_id: proposal_id.toFixed(),
          voter: voter,
          options: options
        }
      };
    };

    return MsgVoteWeighted;
  }(json_1$w.JSONSerializable);

  MsgVoteWeighted$1.MsgVoteWeighted = MsgVoteWeighted;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(MsgDeposit$1, exports);

    __exportStar(MsgSubmitProposal$1, exports);

    __exportStar(MsgVote, exports);

    __exportStar(MsgVoteWeighted$1, exports);
  })(msgs$6);

  var msgs$5 = {};

  var MsgSwap$1 = {};

  var __extends$N = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgSwap$1, "__esModule", {
    value: true
  });
  MsgSwap$1.MsgSwap = void 0;
  var json_1$v = json$1;
  var Coin_1$9 = Coin;
  /**
   * Executes a market swap between 2 denominations at the exchange rate registered by the
   * Oracle module. The account will lose the amount of coins offered, and receive funds
   * in the requested denomination after a swap fee has been applied.
   */

  var MsgSwap =
  /** @class */
  function (_super) {
    __extends$N(MsgSwap, _super);
    /**
     * @param trader trader's account address
     * @param offer_coin coin to be swapped (from)
     * @param ask_denom desired denomination (to)
     */


    function MsgSwap(trader, offer_coin, ask_denom) {
      var _this = _super.call(this) || this;

      _this.trader = trader;
      _this.offer_coin = offer_coin;
      _this.ask_denom = ask_denom;
      return _this;
    }

    MsgSwap.fromData = function (data) {
      var _a = data.value,
          trader = _a.trader,
          offer_coin = _a.offer_coin,
          ask_denom = _a.ask_denom;
      return new MsgSwap(trader, Coin_1$9.Coin.fromData(offer_coin), ask_denom);
    };

    MsgSwap.prototype.toData = function () {
      var _a = this,
          trader = _a.trader,
          offer_coin = _a.offer_coin,
          ask_denom = _a.ask_denom;

      return {
        type: 'market/MsgSwap',
        value: {
          trader: trader,
          offer_coin: offer_coin.toData(),
          ask_denom: ask_denom
        }
      };
    };

    return MsgSwap;
  }(json_1$v.JSONSerializable);

  MsgSwap$1.MsgSwap = MsgSwap;

  var MsgSwapSend$1 = {};

  var __extends$M = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgSwapSend$1, "__esModule", {
    value: true
  });
  MsgSwapSend$1.MsgSwapSend = void 0;
  var json_1$u = json$1;
  var Coin_1$8 = Coin;
  /**
   * Executes a market swap send between 2 denominations at the exchange rate registered by the
   * Oracle module. The sender account will lose the amount of coins offered, and receiver will receive funds
   * in the requested denomination after a swap and send fee has been applied.
   */

  var MsgSwapSend =
  /** @class */
  function (_super) {
    __extends$M(MsgSwapSend, _super);
    /**
     * @param from_address sender's account address
     * @param to_address receiver's account address
     * @param offer_coin coin to be swapped (from)
     * @param ask_denom desired denomination (to)
     */


    function MsgSwapSend(from_address, to_address, offer_coin, ask_denom) {
      var _this = _super.call(this) || this;

      _this.from_address = from_address;
      _this.to_address = to_address;
      _this.offer_coin = offer_coin;
      _this.ask_denom = ask_denom;
      return _this;
    }

    MsgSwapSend.fromData = function (data) {
      var _a = data.value,
          from_address = _a.from_address,
          to_address = _a.to_address,
          offer_coin = _a.offer_coin,
          ask_denom = _a.ask_denom;
      return new MsgSwapSend(from_address, to_address, Coin_1$8.Coin.fromData(offer_coin), ask_denom);
    };

    MsgSwapSend.prototype.toData = function () {
      var _a = this,
          from_address = _a.from_address,
          to_address = _a.to_address,
          offer_coin = _a.offer_coin,
          ask_denom = _a.ask_denom;

      return {
        type: 'market/MsgSwapSend',
        value: {
          from_address: from_address,
          to_address: to_address,
          offer_coin: offer_coin.toData(),
          ask_denom: ask_denom
        }
      };
    };

    return MsgSwapSend;
  }(json_1$u.JSONSerializable);

  MsgSwapSend$1.MsgSwapSend = MsgSwapSend;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(MsgSwap$1, exports);

    __exportStar(MsgSwapSend$1, exports);
  })(msgs$5);

  var msgs$4 = {};

  var MsgGrantAuthorization$1 = {};

  var Authorization = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GenericAuthorization = exports.SendAuthorization = exports.Authorization = exports.AuthorizationGrant = void 0;
    var json_1 = json$1;
    var Coins_1 = Coins$1;

    var AuthorizationGrant =
    /** @class */
    function (_super) {
      __extends(AuthorizationGrant, _super);

      function AuthorizationGrant(authorization, expiration) {
        var _this = _super.call(this) || this;

        _this.authorization = authorization;
        _this.expiration = expiration;
        return _this;
      }

      AuthorizationGrant.fromData = function (data) {
        var authorization = data.authorization,
            expiration = data.expiration;
        return new AuthorizationGrant(Authorization.fromData(authorization), new Date(expiration));
      };

      AuthorizationGrant.prototype.toData = function () {
        var _a = this,
            authorization = _a.authorization,
            expiration = _a.expiration;

        return {
          authorization: authorization.toData(),
          expiration: expiration.toISOString().replace(/\.000Z$/, 'Z')
        };
      };

      return AuthorizationGrant;
    }(json_1.JSONSerializable);

    exports.AuthorizationGrant = AuthorizationGrant;
    var Authorization;

    (function (Authorization) {
      function fromData(data) {
        switch (data.type) {
          case 'msgauth/SendAuthorization':
            return SendAuthorization.fromData(data);

          case 'msgauth/GenericAuthorization':
            return GenericAuthorization.fromData(data);
        }
      }

      Authorization.fromData = fromData;
    })(Authorization = exports.Authorization || (exports.Authorization = {}));

    var SendAuthorization =
    /** @class */
    function (_super) {
      __extends(SendAuthorization, _super);

      function SendAuthorization(spend_limit) {
        var _this = _super.call(this) || this;

        _this.spend_limit = new Coins_1.Coins(spend_limit);
        return _this;
      }

      SendAuthorization.fromData = function (data) {
        return new SendAuthorization(Coins_1.Coins.fromData(data.value.spend_limit));
      };

      SendAuthorization.prototype.toData = function () {
        var spend_limit = this.spend_limit;
        return {
          type: 'msgauth/SendAuthorization',
          value: {
            spend_limit: spend_limit.toData()
          }
        };
      };

      return SendAuthorization;
    }(json_1.JSONSerializable);

    exports.SendAuthorization = SendAuthorization;

    var GenericAuthorization =
    /** @class */
    function (_super) {
      __extends(GenericAuthorization, _super);

      function GenericAuthorization(grant_msg_type) {
        var _this = _super.call(this) || this;

        _this.grant_msg_type = grant_msg_type;
        return _this;
      }

      GenericAuthorization.fromData = function (data) {
        return new GenericAuthorization(data.value.grant_msg_type);
      };

      GenericAuthorization.prototype.toData = function () {
        var grant_msg_type = this.grant_msg_type;
        return {
          type: 'msgauth/GenericAuthorization',
          value: {
            grant_msg_type: grant_msg_type
          }
        };
      };

      return GenericAuthorization;
    }(json_1.JSONSerializable);

    exports.GenericAuthorization = GenericAuthorization;
  })(Authorization);

  var __extends$L = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgGrantAuthorization$1, "__esModule", {
    value: true
  });
  MsgGrantAuthorization$1.MsgGrantAuthorization = void 0;
  var json_1$t = json$1;
  var Authorization_1$1 = Authorization;

  var MsgGrantAuthorization =
  /** @class */
  function (_super) {
    __extends$L(MsgGrantAuthorization, _super);
    /**
     * @param depositor depositor's account address
     * @param amount coins to fund the community pool
     */


    function MsgGrantAuthorization(granter, grantee, authorization, expiration) {
      var _this = _super.call(this) || this;

      _this.granter = granter;
      _this.grantee = grantee;
      _this.authorization = authorization;
      _this.expiration = expiration;
      return _this;
    }

    MsgGrantAuthorization.fromData = function (data) {
      var _a = data.value,
          granter = _a.granter,
          grantee = _a.grantee,
          _b = _a.grant,
          authorization = _b.authorization,
          expiration = _b.expiration;
      return new MsgGrantAuthorization(granter, grantee, Authorization_1$1.Authorization.fromData(authorization), new Date(expiration));
    };

    MsgGrantAuthorization.prototype.toData = function () {
      var _a = this,
          granter = _a.granter,
          grantee = _a.grantee,
          authorization = _a.authorization,
          expiration = _a.expiration;

      return {
        type: 'msgauth/MsgGrantAuthorization',
        value: {
          granter: granter,
          grantee: grantee,
          grant: {
            authorization: authorization.toData(),
            expiration: expiration.toISOString().replace(/\.000Z$/, 'Z')
          }
        }
      };
    };

    return MsgGrantAuthorization;
  }(json_1$t.JSONSerializable);

  MsgGrantAuthorization$1.MsgGrantAuthorization = MsgGrantAuthorization;

  var MsgRevokeAuthorization$1 = {};

  var __extends$K = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgRevokeAuthorization$1, "__esModule", {
    value: true
  });
  MsgRevokeAuthorization$1.MsgRevokeAuthorization = void 0;
  var json_1$s = json$1;

  var MsgRevokeAuthorization =
  /** @class */
  function (_super) {
    __extends$K(MsgRevokeAuthorization, _super);
    /**
     * @param granter authorization granter
     * @param grantee authorization grantee
     * @param authorization_msg_type type of message to revoke
     */


    function MsgRevokeAuthorization(granter, grantee, msg_type_url) {
      var _this = _super.call(this) || this;

      _this.granter = granter;
      _this.grantee = grantee;
      _this.msg_type_url = msg_type_url;
      return _this;
    }

    MsgRevokeAuthorization.fromData = function (data) {
      var _a = data.value,
          granter = _a.granter,
          grantee = _a.grantee,
          msg_type_url = _a.msg_type_url;
      return new MsgRevokeAuthorization(granter, grantee, msg_type_url);
    };

    MsgRevokeAuthorization.prototype.toData = function () {
      var _a = this,
          granter = _a.granter,
          grantee = _a.grantee,
          msg_type_url = _a.msg_type_url;

      return {
        type: 'msgauth/MsgRevokeAuthorization',
        value: {
          granter: granter,
          grantee: grantee,
          msg_type_url: msg_type_url
        }
      };
    };

    return MsgRevokeAuthorization;
  }(json_1$s.JSONSerializable);

  MsgRevokeAuthorization$1.MsgRevokeAuthorization = MsgRevokeAuthorization;

  var MsgExecAuthorized$1 = {};

  var __extends$J = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgExecAuthorized$1, "__esModule", {
    value: true
  });
  MsgExecAuthorized$1.MsgExecAuthorized = void 0;
  var json_1$r = json$1;
  var Msg_1$2 = Msg;

  var MsgExecAuthorized =
  /** @class */
  function (_super) {
    __extends$J(MsgExecAuthorized, _super);
    /**
     * @param grantee authorization grantee
     * @param msgs list of messages to execute
     */


    function MsgExecAuthorized(grantee, msgs) {
      var _this = _super.call(this) || this;

      _this.grantee = grantee;
      _this.msgs = msgs;
      return _this;
    }

    MsgExecAuthorized.fromData = function (data) {
      var _a = data.value,
          grantee = _a.grantee,
          msgs = _a.msgs;
      return new MsgExecAuthorized(grantee, msgs.map(function (x) {
        return Msg_1$2.Msg.fromData(x);
      }));
    };

    MsgExecAuthorized.prototype.toData = function () {
      var _a = this,
          grantee = _a.grantee,
          msgs = _a.msgs;

      return {
        type: 'msgauth/MsgExecAuthorized',
        value: {
          grantee: grantee,
          msgs: msgs.map(function (msg) {
            return msg.toData();
          })
        }
      };
    };

    return MsgExecAuthorized;
  }(json_1$r.JSONSerializable);

  MsgExecAuthorized$1.MsgExecAuthorized = MsgExecAuthorized;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(MsgGrantAuthorization$1, exports);

    __exportStar(MsgRevokeAuthorization$1, exports);

    __exportStar(MsgExecAuthorized$1, exports);
  })(msgs$4);

  var msgs$3 = {};

  var MsgDelegateFeedConsent$1 = {};

  var __extends$I = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgDelegateFeedConsent$1, "__esModule", {
    value: true
  });
  MsgDelegateFeedConsent$1.MsgDelegateFeedConsent = void 0;
  var json_1$q = json$1;
  /**
   * A **feeeder** is an account which is responsible for signing transactions with Oracle vote
   * and prevote messages on behalf of the validator. The blockchain will reject
   * [[MsgExchangeRateVote]] and [[MsgExchangeRatePrevote]] messages in transactions
   * signed by an
   * account different than the registered feeder.
   *
   * The following message registers a validator's feeder address.
   */

  var MsgDelegateFeedConsent =
  /** @class */
  function (_super) {
    __extends$I(MsgDelegateFeedConsent, _super);
    /**
     * @param operator validator's operator address
     * @param delegate account address to set to feeder
     */


    function MsgDelegateFeedConsent(operator, delegate) {
      var _this = _super.call(this) || this;

      _this.operator = operator;
      _this.delegate = delegate;
      return _this;
    }

    MsgDelegateFeedConsent.fromData = function (data) {
      var _a = data.value,
          operator = _a.operator,
          delegate = _a.delegate;
      return new MsgDelegateFeedConsent(operator, delegate);
    };

    MsgDelegateFeedConsent.prototype.toData = function () {
      var _a = this,
          operator = _a.operator,
          delegate = _a.delegate;

      return {
        type: 'oracle/MsgDelegateFeedConsent',
        value: {
          operator: operator,
          delegate: delegate
        }
      };
    };

    return MsgDelegateFeedConsent;
  }(json_1$q.JSONSerializable);

  MsgDelegateFeedConsent$1.MsgDelegateFeedConsent = MsgDelegateFeedConsent;

  var MsgAggregateExchangeRateVote$1 = {};

  var SHA256$2 = {exports: {}};

  (function (module, exports) {
    !function (n, t) {
      module.exports = t();
    }(commonjsGlobal, function () {
      return function () {

        var n = {
          3354: function _(n, t, r) {
            r.d(t, {
              e: function e() {
                return o;
              }
            });

            var i = r(5720),
                e = r(9054),
                o = function () {
              function n(t, r) {
                if (Array.isArray(t) || !t) return this.t = Array.isArray(t) ? t : [], void (this.i = "number" == typeof r ? r : 4 * this.t.length);
                if (t instanceof n) return this.t = t.words.slice(), void (this.i = t.nSigBytes);
                var i;

                try {
                  t instanceof ArrayBuffer ? i = new Uint8Array(t) : (t instanceof Uint8Array || t instanceof Int8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array) && (i = new Uint8Array(t.buffer, t.byteOffset, t.byteLength));
                } catch (n) {
                  throw new Error("Invalid argument");
                }

                if (!i) throw new Error("Invalid argument");

                for (var e = i.byteLength, o = [], u = 0; u < e; u++) {
                  o[u >>> 2] |= i[u] << 24 - u % 4 * 8;
                }

                this.t = o, this.i = e;
              }

              return Object.defineProperty(n.prototype, "nSigBytes", {
                get: function get() {
                  return this.i;
                },
                set: function set(n) {
                  this.i = n;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(n.prototype, "words", {
                get: function get() {
                  return this.t;
                },
                enumerable: !1,
                configurable: !0
              }), n.prototype.toString = function (n) {
                return n ? n.stringify(this) : i.p.stringify(this);
              }, n.prototype.toUint8Array = function () {
                for (var n = this.t, t = this.i, r = new Uint8Array(t), i = 0; i < t; i++) {
                  r[i] = n[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                }

                return r;
              }, n.prototype.concat = function (n) {
                var t = n.words.slice(),
                    r = n.nSigBytes;
                if (this.clamp(), this.i % 4) for (var i = 0; i < r; i++) {
                  var e = t[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                  this.t[this.i + i >>> 2] |= e << 24 - (this.i + i) % 4 * 8;
                } else for (i = 0; i < r; i += 4) {
                  this.t[this.i + i >>> 2] = t[i >>> 2];
                }
                return this.i += r, this;
              }, n.prototype.clamp = function () {
                var n = this.i;
                this.t[n >>> 2] &= 4294967295 << 32 - n % 4 * 8, this.t.length = Math.ceil(n / 4);
              }, n.prototype.clone = function () {
                return new n(this.t.slice(), this.i);
              }, n.random = function (t) {
                for (var r = [], i = 0; i < t; i += 4) {
                  r.push((0, e.M)());
                }

                return new n(r, t);
              }, n;
            }();
          },
          7211: function _(n, t, r) {
            r.d(t, {
              C: function C() {
                return o;
              }
            });

            var i = r(3354),
                e = r(4768),
                o = function () {
              function n(n) {
                this.u = 0, this.h = 0, this.v = n, this.l = n && void 0 !== n.data ? n.data.clone() : new i.e(), this.A = n && "number" == typeof n.nBytes ? n.nBytes : 0;
              }

              return Object.defineProperty(n.prototype, "blockSize", {
                get: function get() {
                  return this.h;
                },
                enumerable: !1,
                configurable: !0
              }), n.prototype.reset = function (n, t) {
                this.l = void 0 !== n ? n.clone() : new i.e(), this.A = "number" == typeof t ? t : 0;
              }, n.prototype.j = function (n) {
                var t = "string" == typeof n ? e.d.parse(n) : n;
                this.l.concat(t), this.A += t.nSigBytes;
              }, n.prototype.O = function (n) {
                var t,
                    r = this.l.words,
                    e = this.l.nSigBytes,
                    o = this.h,
                    u = e / (4 * this.h),
                    f = (u = n ? Math.ceil(u) : Math.max((0 | u) - this.u, 0)) * o,
                    c = Math.min(4 * f, e);

                if (f) {
                  for (var a = 0; a < f; a += o) {
                    this.I(r, a);
                  }

                  t = r.splice(0, f), this.l.nSigBytes -= c;
                }

                return new i.e(t, c);
              }, n.prototype.I = function (n, t) {
                throw new Error("Not implemented");
              }, n;
            }();
          },
          1868: function _(n, t, r) {
            r.d(t, {
              P: function P() {
                return u;
              }
            });

            var _i,
                e = r(7211),
                o = (_i = function i(n, t) {
              return (_i = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (n, t) {
                n.__proto__ = t;
              } || function (n, t) {
                for (var r in t) {
                  Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
              })(n, t);
            }, function (n, t) {
              function r() {
                this.constructor = n;
              }

              _i(n, t), n.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
            }),
                u = function (n) {
              function t(t) {
                var r = n.call(this, t) || this;
                return r.h = 16, r.v = t, t && "number" == typeof t.blockSize && (r.h = t.blockSize), r.reset(t ? t.data : void 0, t ? t.nBytes : void 0), r;
              }

              return o(t, n), Object.defineProperty(t.prototype, "blockSize", {
                get: function get() {
                  return this.h;
                },
                enumerable: !1,
                configurable: !0
              }), t.prototype.reset = function (t, r) {
                n.prototype.reset.call(this, t, r), this.U();
              }, t.prototype.update = function (n) {
                return this.j(n), this.O(), this;
              }, t.prototype.finalize = function (n) {
                return n && this.j(n), this._();
              }, t.prototype.U = function () {
                throw new Error("Not implemented");
              }, t.prototype._ = function () {
                throw new Error("Not implemented");
              }, t;
            }(e.C);
          },
          1756: function _(n, t, r) {
            r.d(t, {
              w: function w() {
                return u;
              }
            });
            var i,
                e = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
                o = (i = parseInt((/msie (\d+)/.exec(e) || [])[1], 10), isNaN(i) ? (i = parseInt((/trident\/.*; rv:(\d+)/.exec(e) || [])[1], 10), !isNaN(i) && i) : i);

            function u(n, t) {
              return !1 !== o && (!t || ("<" === n ? o < t : "<=" === n ? o <= t : ">" === n ? o > t : ">=" === n ? o >= t : o === t));
            }
          },
          5720: function _(n, t, r) {
            r.d(t, {
              p: function p() {
                return e;
              }
            });
            var i = r(3354),
                e = {
              stringify: function stringify(n) {
                for (var t = n.nSigBytes, r = n.words, i = [], e = 0; e < t; e++) {
                  var o = r[e >>> 2] >>> 24 - e % 4 * 8 & 255;
                  i.push((o >>> 4).toString(16)), i.push((15 & o).toString(16));
                }

                return i.join("");
              },
              parse: function parse(n) {
                var t = n.length;
                if (t % 2 != 0) throw new Error("Hex string count must be even");
                if (!/^[a-fA-F0-9]+$/.test(n)) throw new Error("Invalid Hex string: " + n);

                for (var r = [], e = 0; e < t; e += 2) {
                  r[e >>> 3] |= parseInt(n.substr(e, 2), 16) << 24 - e % 8 * 4;
                }

                return new i.e(r, t / 2);
              }
            };
          },
          8702: function _(n, t, r) {
            r.d(t, {
              m: function m() {
                return e;
              }
            });
            var i = r(3354),
                e = {
              stringify: function stringify(n) {
                for (var t = n.nSigBytes, r = n.words, i = [], e = 0; e < t; e++) {
                  var o = r[e >>> 2] >>> 24 - e % 4 * 8 & 255;
                  i.push(String.fromCharCode(o));
                }

                return i.join("");
              },
              parse: function parse(n) {
                for (var t = n.length, r = [], e = 0; e < t; e++) {
                  r[e >>> 2] |= (255 & n.charCodeAt(e)) << 24 - e % 4 * 8;
                }

                return new i.e(r, t);
              }
            };
          },
          4768: function _(n, t, r) {
            r.d(t, {
              d: function d() {
                return e;
              }
            });
            var i = r(8702),
                e = {
              stringify: function stringify(n) {
                try {
                  return decodeURIComponent(escape(i.m.stringify(n)));
                } catch (n) {
                  throw new Error("Malformed UTF-8 data");
                }
              },
              parse: function parse(n) {
                return i.m.parse(unescape(encodeURIComponent(n)));
              }
            };
          },
          9054: function _(n, t, r) {
            r.d(t, {
              M: function M() {
                return e;
              }
            });
            var i = r(1756);

            var e = function () {
              if ("undefined" != typeof window) {
                var n = window.crypto || window.msCrypto;

                if (!n) {
                  if ((0, i.w)("<", 11)) return console.warn("IE <= 10 uses insecure random generator. Please consider to use IE11 or another modern browser"), function () {
                    return Math.floor(512 * Math.random()) % 256;
                  };
                  throw new Error("Crypto module not found");
                }

                return function () {
                  return n.getRandomValues(new Uint32Array(1))[0];
                };
              }

              return void 0 !== r.g && r.g.crypto ? function () {
                return r.g.crypto.randomBytes(4).readInt32LE();
              } : function () {
                return require$$0__default["default"].randomBytes(4).readInt32LE();
              };
            }();
          }
        },
            t = {};

        function r(i) {
          var e = t[i];
          if (void 0 !== e) return e.exports;
          var o = t[i] = {
            exports: {}
          };
          return n[i](o, o.exports, r), o.exports;
        }

        r.d = function (n, t) {
          for (var i in t) {
            r.o(t, i) && !r.o(n, i) && Object.defineProperty(n, i, {
              enumerable: !0,
              get: t[i]
            });
          }
        }, r.g = function () {
          if ("object" == typeof globalThis) return globalThis;

          try {
            return this || new Function("return this")();
          } catch (n) {
            if ("object" == typeof window) return window;
          }
        }(), r.o = function (n, t) {
          return Object.prototype.hasOwnProperty.call(n, t);
        }, r.r = function (n) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, {
            value: "Module"
          }), Object.defineProperty(n, "S", {
            value: !0
          });
        };
        var i = {};
        return function () {
          r.r(i), r.d(i, {
            SHA256: function SHA256() {
              return h;
            }
          });

          var _n,
              t = r(1868),
              e = r(3354),
              o = (_n = function n(t, r) {
            return (_n = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (n, t) {
              n.__proto__ = t;
            } || function (n, t) {
              for (var r in t) {
                Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
              }
            })(t, r);
          }, function (t, r) {
            function i() {
              this.constructor = t;
            }

            _n(t, r), t.prototype = null === r ? Object.create(r) : (i.prototype = r.prototype, new i());
          }),
              u = [],
              f = [];

          function c(n) {
            for (var t = Math.sqrt(n), r = 2; r <= t; r++) {
              if (!(n % r)) return !1;
            }

            return !0;
          }

          function a(n) {
            return 4294967296 * (n - (0 | n)) | 0;
          }

          !function () {
            for (var n = 2, t = 0; t < 64;) {
              c(n) && (t < 8 && (u[t] = a(Math.pow(n, .5))), f[t] = a(Math.pow(n, 1 / 3)), t++), n++;
            }
          }();

          var s = [],
              h = function (n) {
            function t(t) {
              var r = n.call(this, t) || this;
              return r.N = new e.e(u.slice(0)), r.v = t, t && void 0 !== t.hash && (r.N = t.hash.clone()), r;
            }

            return o(t, n), t.prototype.U = function () {
              this.N = new e.e(u.slice(0));
            }, t.prototype.I = function (n, t) {
              for (var r = this.N.words, i = r[0], e = r[1], o = r[2], u = r[3], c = r[4], a = r[5], h = r[6], v = r[7], d = 0; d < 64; d++) {
                if (d < 16) s[d] = 0 | n[t + d];else {
                  var w = s[d - 15],
                      l = (w << 25 | w >>> 7) ^ (w << 14 | w >>> 18) ^ w >>> 3,
                      y = s[d - 2],
                      b = (y << 15 | y >>> 17) ^ (y << 13 | y >>> 19) ^ y >>> 10;
                  s[d] = l + s[d - 7] + b + s[d - 16];
                }
                var p = i & e ^ i & o ^ e & o,
                    m = (i << 30 | i >>> 2) ^ (i << 19 | i >>> 13) ^ (i << 10 | i >>> 22),
                    g = v + ((c << 26 | c >>> 6) ^ (c << 21 | c >>> 11) ^ (c << 7 | c >>> 25)) + (c & a ^ ~c & h) + f[d] + s[d];
                v = h, h = a, a = c, c = u + g | 0, u = o, o = e, e = i, i = g + (m + p) | 0;
              }

              r[0] = r[0] + i | 0, r[1] = r[1] + e | 0, r[2] = r[2] + o | 0, r[3] = r[3] + u | 0, r[4] = r[4] + c | 0, r[5] = r[5] + a | 0, r[6] = r[6] + h | 0, r[7] = r[7] + v | 0;
            }, t.prototype._ = function () {
              var n = this.l.words,
                  t = 8 * this.A,
                  r = 8 * this.l.nSigBytes;
              return n[r >>> 5] |= 128 << 24 - r % 32, n[14 + (r + 64 >>> 9 << 4)] = Math.floor(t / 4294967296), n[15 + (r + 64 >>> 9 << 4)] = t, this.l.nSigBytes = 4 * n.length, this.O(), this.N;
            }, t.prototype.clone = function () {
              return new t({
                hash: this.N,
                blockSize: this.h,
                data: this.l,
                nBytes: this.A
              });
            }, t.hash = function (n, r) {
              return new t(r).finalize(n);
            }, t;
          }(t.P);
        }(), i;
      }();
    });
  })(SHA256$2);

  var MsgAggregateExchangeRatePrevote$1 = {};

  var __extends$H = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgAggregateExchangeRatePrevote$1, "__esModule", {
    value: true
  });
  MsgAggregateExchangeRatePrevote$1.MsgAggregateExchangeRatePrevote = void 0;
  var json_1$p = json$1;
  /**
   * Aggregate analog of MsgExchangeRatePrevote
   */

  var MsgAggregateExchangeRatePrevote =
  /** @class */
  function (_super) {
    __extends$H(MsgAggregateExchangeRatePrevote, _super);
    /**
     * @param hash vote hash
     * @param feeder validator's feeder account address
     * @param validator validator's operator address
     */


    function MsgAggregateExchangeRatePrevote(hash, feeder, validator) {
      var _this = _super.call(this) || this;

      _this.hash = hash;
      _this.feeder = feeder;
      _this.validator = validator;
      return _this;
    }

    MsgAggregateExchangeRatePrevote.fromData = function (data) {
      var _a = data.value,
          hash = _a.hash,
          feeder = _a.feeder,
          validator = _a.validator;
      return new MsgAggregateExchangeRatePrevote(hash, feeder, validator);
    };

    MsgAggregateExchangeRatePrevote.prototype.toData = function () {
      var _a = this,
          hash = _a.hash,
          feeder = _a.feeder,
          validator = _a.validator;

      return {
        type: 'oracle/MsgAggregateExchangeRatePrevote',
        value: {
          hash: hash,
          feeder: feeder,
          validator: validator
        }
      };
    };

    return MsgAggregateExchangeRatePrevote;
  }(json_1$p.JSONSerializable);

  MsgAggregateExchangeRatePrevote$1.MsgAggregateExchangeRatePrevote = MsgAggregateExchangeRatePrevote;

  var __extends$G = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgAggregateExchangeRateVote$1, "__esModule", {
    value: true
  });
  MsgAggregateExchangeRateVote$1.MsgAggregateExchangeRateVote = MsgAggregateExchangeRateVote$1.aggregateVoteHash = void 0;
  var SHA256_1$3 = SHA256$2.exports;
  var json_1$o = json$1;
  var MsgAggregateExchangeRatePrevote_1 = MsgAggregateExchangeRatePrevote$1;
  var Coins_1$5 = Coins$1;
  /**
   * Calculates the aggregate vote hash
   * @param exchangeRates exchange rates
   * @param salt salt
   * @param validator validator operator address
   */

  function aggregateVoteHash(exchangeRates, salt, validator) {
    var payload = salt + ":" + exchangeRates.toDecCoins().toString() + ":" + validator;
    return SHA256_1$3.SHA256.hash(payload).toString().substring(0, 40);
  }

  MsgAggregateExchangeRateVote$1.aggregateVoteHash = aggregateVoteHash;
  /**
   * Aggregate analog of MsgExchangeRateVote: submits an oracle vote for multiple denominations
   * through a single message rather than multiple messages.
   */

  var MsgAggregateExchangeRateVote =
  /** @class */
  function (_super) {
    __extends$G(MsgAggregateExchangeRateVote, _super);
    /**
     * @param exchange_rate exchange rates
     * @param salt salt
     * @param feeder feeder address
     * @param validator validator operator address
     */


    function MsgAggregateExchangeRateVote(exchange_rates, salt, feeder, validator) {
      var _this = _super.call(this) || this;

      _this.salt = salt;
      _this.feeder = feeder;
      _this.validator = validator;
      _this.exchange_rates = new Coins_1$5.Coins(exchange_rates).toDecCoins();
      return _this;
    }

    MsgAggregateExchangeRateVote.fromData = function (data) {
      var _a = data.value,
          exchange_rates = _a.exchange_rates,
          salt = _a.salt,
          feeder = _a.feeder,
          validator = _a.validator;
      var xrs = Coins_1$5.Coins.fromString(exchange_rates);
      return new MsgAggregateExchangeRateVote(xrs, salt, feeder, validator);
    };

    MsgAggregateExchangeRateVote.prototype.toData = function () {
      var _a = this,
          exchange_rates = _a.exchange_rates,
          salt = _a.salt,
          feeder = _a.feeder,
          validator = _a.validator;

      return {
        type: 'oracle/MsgAggregateExchangeRateVote',
        value: {
          exchange_rates: exchange_rates.toDecCoins().toString(),
          salt: salt,
          feeder: feeder,
          validator: validator
        }
      };
    };
    /**
     * Gets the aggregate vote hash for the MsgAggregateExchangeRateVote, for the creation of
     *  the corresponding prevote message.
     */


    MsgAggregateExchangeRateVote.prototype.getAggregateVoteHash = function () {
      return aggregateVoteHash(this.exchange_rates, this.salt, this.validator);
    };
    /**
     * You can generate the corresponding aggregate prevote message.
     * This will return a [[MsgAggregateExchangeRatePrevote]] with the proper vote hash and values,
     * determined by the current attributes of the object.
     *
     * @returns the corresponding prevote message to send
     */


    MsgAggregateExchangeRateVote.prototype.getPrevote = function () {
      return new MsgAggregateExchangeRatePrevote_1.MsgAggregateExchangeRatePrevote(this.getAggregateVoteHash(), this.feeder, this.validator);
    };

    return MsgAggregateExchangeRateVote;
  }(json_1$o.JSONSerializable);

  MsgAggregateExchangeRateVote$1.MsgAggregateExchangeRateVote = MsgAggregateExchangeRateVote;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(MsgDelegateFeedConsent$1, exports);

    __exportStar(MsgAggregateExchangeRateVote$1, exports);

    __exportStar(MsgAggregateExchangeRatePrevote$1, exports);
  })(msgs$3);

  var msgs$2 = {};

  var MsgUnjail$1 = {};

  var __extends$F = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgUnjail$1, "__esModule", {
    value: true
  });
  MsgUnjail$1.MsgUnjail = void 0;
  var json_1$n = json$1;
  /**
   * A validator can be jailed by the blockchain if misbehavior is detected, such as
   * double-signing or having missed too many vote periods in the Oracle ballot.
   *
   * This is done to protect delegators' funds from getting slashed further, until the
   * validator's issues have been addressed. A jailed validator cannot participate in
   * block rewards, and must be manually unjailed by submitting this message.
   */

  var MsgUnjail =
  /** @class */
  function (_super) {
    __extends$F(MsgUnjail, _super);
    /**
     * @param address validator's operator address
     */


    function MsgUnjail(address) {
      var _this = _super.call(this) || this;

      _this.address = address;
      return _this;
    }

    MsgUnjail.fromData = function (data) {
      var address = data.value.address;
      return new MsgUnjail(address);
    };

    MsgUnjail.prototype.toData = function () {
      var address = this.address;
      return {
        type: 'slashing/MsgUnjail',
        value: {
          address: address
        }
      };
    };

    return MsgUnjail;
  }(json_1$n.JSONSerializable);

  MsgUnjail$1.MsgUnjail = MsgUnjail;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(MsgUnjail$1, exports);
  })(msgs$2);

  var msgs$1 = {};

  var MsgDelegate$1 = {};

  var __extends$E = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgDelegate$1, "__esModule", {
    value: true
  });
  MsgDelegate$1.MsgDelegate = void 0;
  var Coin_1$7 = Coin;
  var json_1$m = json$1;
  /**
   * A delegator can submit this message to send more Luna to be staked through a
   * validator delegate.
   */

  var MsgDelegate =
  /** @class */
  function (_super) {
    __extends$E(MsgDelegate, _super);
    /**
     *
     * @param delegator_address delegator's account address
     * @param validator_address validator's operator address
     * @param amount amount of LUNA to be sent for delegation
     */


    function MsgDelegate(delegator_address, validator_address, amount) {
      var _this = _super.call(this) || this;

      _this.delegator_address = delegator_address;
      _this.validator_address = validator_address;
      _this.amount = amount;
      return _this;
    }

    MsgDelegate.fromData = function (data) {
      var _a = data.value,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address,
          amount = _a.amount;
      return new MsgDelegate(delegator_address, validator_address, Coin_1$7.Coin.fromData(amount));
    };

    MsgDelegate.prototype.toData = function () {
      var _a = this,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address,
          amount = _a.amount;

      return {
        type: 'staking/MsgDelegate',
        value: {
          delegator_address: delegator_address,
          validator_address: validator_address,
          amount: amount.toData()
        }
      };
    };

    return MsgDelegate;
  }(json_1$m.JSONSerializable);

  MsgDelegate$1.MsgDelegate = MsgDelegate;

  var MsgUndelegate$1 = {};

  var __extends$D = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgUndelegate$1, "__esModule", {
    value: true
  });
  MsgUndelegate$1.MsgUndelegate = void 0;
  var Coin_1$6 = Coin;
  var json_1$l = json$1;
  /**
   * A delegator can undelegate an amount of bonded Luna, and will begin the unbonding
   * process for those funds. The unbonding process takes 21 days to complete, during
   * which the Luna cannot be transacted or swapped.
   */

  var MsgUndelegate =
  /** @class */
  function (_super) {
    __extends$D(MsgUndelegate, _super);
    /**
     * @param delegator_address delegator's account address
     * @param validator_address validator's operator address
     * @param amount Luna to be undelegated
     */


    function MsgUndelegate(delegator_address, validator_address, amount) {
      var _this = _super.call(this) || this;

      _this.delegator_address = delegator_address;
      _this.validator_address = validator_address;
      _this.amount = amount;
      return _this;
    }

    MsgUndelegate.fromData = function (data) {
      var _a = data.value,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address,
          amount = _a.amount;
      return new MsgUndelegate(delegator_address, validator_address, Coin_1$6.Coin.fromData(amount));
    };

    MsgUndelegate.prototype.toData = function () {
      var _a = this,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address,
          amount = _a.amount;

      return {
        type: 'staking/MsgUndelegate',
        value: {
          delegator_address: delegator_address,
          validator_address: validator_address,
          amount: amount.toData()
        }
      };
    };

    return MsgUndelegate;
  }(json_1$l.JSONSerializable);

  MsgUndelegate$1.MsgUndelegate = MsgUndelegate;

  var MsgBeginRedelegate$1 = {};

  var __extends$C = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgBeginRedelegate$1, "__esModule", {
    value: true
  });
  MsgBeginRedelegate$1.MsgBeginRedelegate = void 0;
  var json_1$k = json$1;
  var Coin_1$5 = Coin;
  /**
   * A delegator can choose to redelegate their bonded Luna and transfer a delegation
   * amount from one validator to another. Unlike undelegating, redelegations do not incur
   * a 21-day unbonding period and happen immediately.
   */

  var MsgBeginRedelegate =
  /** @class */
  function (_super) {
    __extends$C(MsgBeginRedelegate, _super);
    /**
     *
     * @param delegator_address delegator's account address
     * @param validator_src_address validator to undelegate from
     * @param validator_dst_address validator to delegate to
     * @param amount LUNA to be redelegated
     */


    function MsgBeginRedelegate(delegator_address, validator_src_address, validator_dst_address, amount) {
      var _this = _super.call(this) || this;

      _this.delegator_address = delegator_address;
      _this.validator_src_address = validator_src_address;
      _this.validator_dst_address = validator_dst_address;
      _this.amount = amount;
      return _this;
    }

    MsgBeginRedelegate.fromData = function (data) {
      var _a = data.value,
          delegator_address = _a.delegator_address,
          validator_src_address = _a.validator_src_address,
          validator_dst_address = _a.validator_dst_address,
          amount = _a.amount;
      return new MsgBeginRedelegate(delegator_address, validator_src_address, validator_dst_address, Coin_1$5.Coin.fromData(amount));
    };

    MsgBeginRedelegate.prototype.toData = function () {
      var _a = this,
          delegator_address = _a.delegator_address,
          validator_src_address = _a.validator_src_address,
          validator_dst_address = _a.validator_dst_address,
          amount = _a.amount;

      return {
        type: 'staking/MsgBeginRedelegate',
        value: {
          delegator_address: delegator_address,
          validator_src_address: validator_src_address,
          validator_dst_address: validator_dst_address,
          amount: amount.toData()
        }
      };
    };

    return MsgBeginRedelegate;
  }(json_1$k.JSONSerializable);

  MsgBeginRedelegate$1.MsgBeginRedelegate = MsgBeginRedelegate;

  var MsgCreateValidator$1 = {};

  var Validator = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Validator = void 0;
    var json_1 = json$1;
    var numeric_1 = numeric;
    /**
     * Stores information fetched from the blockchain about the current status of a validator.
     * As an end user, you will not have to create an instance of this class, one will be
     * generated for you to store information about a validator polled from the API functions
     * in [[StakingAPI]].
     */

    var Validator =
    /** @class */
    function (_super) {
      __extends(Validator, _super);
      /**
       *
       * @param operator_address validator's operator address
       * @param consensus_pubkey validator's consensus public key
       * @param jailed whether the current validator is jailed
       * @param status unbonded `0`, unbonding `1`, bonded `2`
       * @param tokens total Luna from all delegations (including self)
       * @param delegator_shares total shares of all delegators
       * @param description validator's delegate description
       * @param unbonding_height if unbonding, height at which this validator began unbonding
       * @param unbonding_time if unbonding, min time for the validator to complete unbonding
       * @param commission validator commission
       * @param min_self_delegation minimum self delegation
       */


      function Validator(operator_address, consensus_pubkey, jailed, status, tokens, delegator_shares, description, unbonding_height, unbonding_time, commission, min_self_delegation) {
        var _this = _super.call(this) || this;

        _this.operator_address = operator_address;
        _this.consensus_pubkey = consensus_pubkey;
        _this.jailed = jailed;
        _this.status = status;
        _this.tokens = tokens;
        _this.delegator_shares = delegator_shares;
        _this.description = description;
        _this.unbonding_height = unbonding_height;
        _this.unbonding_time = unbonding_time;
        _this.commission = commission;
        _this.min_self_delegation = min_self_delegation;
        return _this;
      }

      Validator.prototype.toData = function () {
        return {
          operator_address: this.operator_address,
          consensus_pubkey: this.consensus_pubkey,
          jailed: this.jailed,
          status: this.status,
          tokens: this.tokens.toString(),
          delegator_shares: this.delegator_shares.toString(),
          description: this.description,
          unbonding_height: this.unbonding_height.toFixed(),
          unbonding_time: this.unbonding_time.toISOString(),
          commission: this.commission.toData(),
          min_self_delegation: this.min_self_delegation.toString()
        };
      };

      Validator.fromData = function (data) {
        return new Validator(data.operator_address, data.consensus_pubkey, data.jailed || false, data.status || 0, new numeric_1.Int(data.tokens), new numeric_1.Dec(data.delegator_shares), Validator.Description.fromData(data.description), Number.parseInt(data.unbonding_height), new Date(data.unbonding_time), Validator.Commission.fromData(data.commission), new numeric_1.Int(data.min_self_delegation));
      };

      return Validator;
    }(json_1.JSONSerializable);

    exports.Validator = Validator;

    (function (Validator) {
      var Description =
      /** @class */
      function (_super) {
        __extends(Description, _super);
        /**
         * @param moniker Identifying name, e.g. "Hashed"
         * @param identity time at which commission was last updated
         * @param website validator's website
         * @param details long description
         * @param security_contact validator's contact
         */


        function Description(moniker, identity, website, details, security_contact) {
          var _this = _super.call(this) || this;

          _this.moniker = moniker;
          _this.identity = identity;
          _this.website = website;
          _this.details = details;
          _this.security_contact = security_contact;
          return _this;
        }

        Description.prototype.toData = function () {
          return {
            moniker: this.moniker,
            identity: this.identity,
            website: this.website,
            details: this.details,
            security_contact: this.security_contact
          };
        };

        Description.fromData = function (data) {
          return new Description(data.moniker, data.identity || '', data.website || '', data.details || '', data.security_contact || '');
        };

        return Description;
      }(json_1.JSONSerializable);

      Validator.Description = Description;

      var CommissionRates =
      /** @class */
      function (_super) {
        __extends(CommissionRates, _super);
        /**
         * @param rate current commission rate
         * @param max_rate max commission rate
         * @param max_change_rate max percentage commission can change in 24hrs
         */


        function CommissionRates(rate, max_rate, max_change_rate) {
          var _this = _super.call(this) || this;

          _this.rate = rate;
          _this.max_rate = max_rate;
          _this.max_change_rate = max_change_rate;
          return _this;
        }

        CommissionRates.fromData = function (data) {
          var rate = data.rate,
              max_rate = data.max_rate,
              max_change_rate = data.max_change_rate;
          return new CommissionRates(new numeric_1.Dec(rate), new numeric_1.Dec(max_rate), new numeric_1.Dec(max_change_rate));
        };

        CommissionRates.prototype.toData = function () {
          var _a = this,
              rate = _a.rate,
              max_rate = _a.max_rate,
              max_change_rate = _a.max_change_rate;

          return {
            rate: rate.toString(),
            max_rate: max_rate.toString(),
            max_change_rate: max_change_rate.toString()
          };
        };

        return CommissionRates;
      }(json_1.JSONSerializable);

      Validator.CommissionRates = CommissionRates;

      var Commission =
      /** @class */
      function (_super) {
        __extends(Commission, _super);
        /**
         * @param commission_rates commission rates
         * @param update_time time at which commission was last updated
         */


        function Commission(commission_rates, update_time) {
          var _this = _super.call(this) || this;

          _this.commission_rates = commission_rates;
          _this.update_time = update_time;
          return _this;
        }

        Commission.prototype.toData = function () {
          return {
            commission_rates: this.commission_rates.toData(),
            update_time: this.update_time.toISOString()
          };
        };

        Commission.fromData = function (data) {
          return new Commission(CommissionRates.fromData(data.commission_rates), new Date(data.update_time));
        };

        return Commission;
      }(json_1.JSONSerializable);

      Validator.Commission = Commission;
    })(Validator = exports.Validator || (exports.Validator = {}));

    exports.Validator = Validator;
  })(Validator);

  var __extends$B = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgCreateValidator$1, "__esModule", {
    value: true
  });
  MsgCreateValidator$1.MsgCreateValidator = void 0;
  var json_1$j = json$1;
  var Coin_1$4 = Coin;
  var numeric_1$4 = numeric;
  var Validator_1$1 = Validator;
  /**
   * For new validators, this message registers a validator address to be a delegate on
   * the blockchain.
   */

  var MsgCreateValidator =
  /** @class */
  function (_super) {
    __extends$B(MsgCreateValidator, _super);
    /**
     *
     * @param description validator's delegate information
     * @param commission validator's commission policy
     * @param min_self_delegation minimum self delegation
     * @param delegator_address validator's account address
     * @param validator_address validator's operator address
     * @param pubkey validator's consensus public key
     * @param value amount to use for self-delegation
     */


    function MsgCreateValidator(description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value) {
      var _this = _super.call(this) || this;

      _this.description = description;
      _this.commission = commission;
      _this.min_self_delegation = min_self_delegation;
      _this.delegator_address = delegator_address;
      _this.validator_address = validator_address;
      _this.pubkey = pubkey;
      _this.value = value;
      return _this;
    }

    MsgCreateValidator.fromData = function (data) {
      var _a = data.value,
          description = _a.description,
          commission = _a.commission,
          min_self_delegation = _a.min_self_delegation,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address,
          pubkey = _a.pubkey,
          value = _a.value;
      return new MsgCreateValidator(description, Validator_1$1.Validator.CommissionRates.fromData(commission), new numeric_1$4.Int(min_self_delegation), delegator_address, validator_address, pubkey, Coin_1$4.Coin.fromData(value));
    };

    MsgCreateValidator.prototype.toData = function () {
      var _a = this,
          description = _a.description,
          commission = _a.commission,
          min_self_delegation = _a.min_self_delegation,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address,
          pubkey = _a.pubkey,
          value = _a.value;

      return {
        type: 'staking/MsgCreateValidator',
        value: {
          description: description,
          commission: commission.toData(),
          min_self_delegation: min_self_delegation.toString(),
          delegator_address: delegator_address,
          validator_address: validator_address,
          pubkey: pubkey,
          value: value.toData()
        }
      };
    };

    return MsgCreateValidator;
  }(json_1$j.JSONSerializable);

  MsgCreateValidator$1.MsgCreateValidator = MsgCreateValidator;

  var MsgEditValidator = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MsgEditValidator = void 0;
    var json_1 = json$1;
    var numeric_1 = numeric;
    /**
     * A validator can edit its delegate information, such as moniker, website, commission
     * rate, etc.
     *
     * You must use special or sentinel values to inform that you want to leave the current
     * field untouched. For `Description`,` you should start with [[MsgEditValidator.DESC_DO_NOT_MODIFY]] and
     * change each field you wish to modify individually.
     */

    var MsgEditValidator =
    /** @class */
    function (_super) {
      __extends(MsgEditValidator, _super);
      /**
       * @param Description new description to apply
       * @param address new address to apply
       * @param commission_rate new commission rates to apply
       * @param min_self_delegation new min self delegation
       */


      function MsgEditValidator(description, validator_address, commission_rate, min_self_delegation) {
        var _this = _super.call(this) || this;

        _this.description = description;
        _this.validator_address = validator_address;
        _this.commission_rate = commission_rate;
        _this.min_self_delegation = min_self_delegation;
        return _this;
      }

      MsgEditValidator.fromData = function (data) {
        var _a = data.value,
            description = _a.description,
            validator_address = _a.validator_address,
            commission_rate = _a.commission_rate,
            min_self_delegation = _a.min_self_delegation;
        return new MsgEditValidator(description, validator_address, commission_rate ? new numeric_1.Dec(commission_rate) : undefined, min_self_delegation ? new numeric_1.Int(min_self_delegation) : undefined);
      };

      MsgEditValidator.prototype.toData = function () {
        var _a = this,
            description = _a.description,
            validator_address = _a.validator_address,
            commission_rate = _a.commission_rate,
            min_self_delegation = _a.min_self_delegation;

        return {
          type: 'staking/MsgEditValidator',
          value: {
            description: description,
            validator_address: validator_address,
            commission_rate: commission_rate ? commission_rate.toString() : undefined,
            min_self_delegation: min_self_delegation ? min_self_delegation.toString() : undefined
          }
        };
      };

      return MsgEditValidator;
    }(json_1.JSONSerializable);

    exports.MsgEditValidator = MsgEditValidator;

    (function (MsgEditValidator) {
      MsgEditValidator.DESC_DO_NOT_MODIFY = {
        moniker: '[do-not-modify]',
        website: '[do-not-modify]',
        identity: '[do-not-modify]',
        details: '[do-not-modify]',
        security_contact: '[do-not-modify]'
      };
    })(MsgEditValidator = exports.MsgEditValidator || (exports.MsgEditValidator = {}));

    exports.MsgEditValidator = MsgEditValidator;
  })(MsgEditValidator);

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(MsgDelegate$1, exports);

    __exportStar(MsgUndelegate$1, exports);

    __exportStar(MsgBeginRedelegate$1, exports);

    __exportStar(MsgCreateValidator$1, exports);

    __exportStar(MsgEditValidator, exports);
  })(msgs$1);

  var msgs = {};

  var MsgStoreCode$1 = {};

  var __extends$A = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgStoreCode$1, "__esModule", {
    value: true
  });
  MsgStoreCode$1.MsgStoreCode = void 0;
  var json_1$i = json$1;

  var MsgStoreCode =
  /** @class */
  function (_super) {
    __extends$A(MsgStoreCode, _super);
    /**
     * @param sender code creator
     * @param wasm_byte_code base64-encoded bytecode contents
     */


    function MsgStoreCode(sender, wasm_byte_code) {
      var _this = _super.call(this) || this;

      _this.sender = sender;
      _this.wasm_byte_code = wasm_byte_code;
      return _this;
    }

    MsgStoreCode.fromData = function (data) {
      var _a = data.value,
          sender = _a.sender,
          wasm_byte_code = _a.wasm_byte_code;
      return new MsgStoreCode(sender, wasm_byte_code);
    };

    MsgStoreCode.prototype.toData = function () {
      var _a = this,
          sender = _a.sender,
          wasm_byte_code = _a.wasm_byte_code;

      return {
        type: 'wasm/MsgStoreCode',
        value: {
          sender: sender,
          wasm_byte_code: wasm_byte_code
        }
      };
    };

    return MsgStoreCode;
  }(json_1$i.JSONSerializable);

  MsgStoreCode$1.MsgStoreCode = MsgStoreCode;

  var MsgMigrateCode$1 = {};

  var __extends$z = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgMigrateCode$1, "__esModule", {
    value: true
  });
  MsgMigrateCode$1.MsgMigrateCode = void 0;
  var json_1$h = json$1;

  var MsgMigrateCode =
  /** @class */
  function (_super) {
    __extends$z(MsgMigrateCode, _super);
    /**
     * @param sender code migrator address
     * @param code_id reference to the code on the blockchain
     * @param wasm_byte_code base64-encoded bytecode contents
     */


    function MsgMigrateCode(sender, code_id, wasm_byte_code) {
      var _this = _super.call(this) || this;

      _this.sender = sender;
      _this.code_id = code_id;
      _this.wasm_byte_code = wasm_byte_code;
      return _this;
    }

    MsgMigrateCode.fromData = function (data) {
      var _a = data.value,
          sender = _a.sender,
          code_id = _a.code_id,
          wasm_byte_code = _a.wasm_byte_code;
      return new MsgMigrateCode(sender, Number.parseInt(code_id), wasm_byte_code);
    };

    MsgMigrateCode.prototype.toData = function () {
      var _a = this,
          sender = _a.sender,
          code_id = _a.code_id,
          wasm_byte_code = _a.wasm_byte_code;

      return {
        type: 'wasm/MsgMigrateCode',
        value: {
          sender: sender,
          code_id: code_id.toFixed(),
          wasm_byte_code: wasm_byte_code
        }
      };
    };

    return MsgMigrateCode;
  }(json_1$h.JSONSerializable);

  MsgMigrateCode$1.MsgMigrateCode = MsgMigrateCode;

  var MsgInstantiateContract$1 = {};

  var __extends$y = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgInstantiateContract$1, "__esModule", {
    value: true
  });
  MsgInstantiateContract$1.MsgInstantiateContract = void 0;
  var json_1$g = json$1;
  var Coins_1$4 = Coins$1;

  var MsgInstantiateContract =
  /** @class */
  function (_super) {
    __extends$y(MsgInstantiateContract, _super);
    /**
     * @param sender is a sender address
     * @param admin is an optional contract admin address who can migrate the contract, put empty string to disable migration
     * @param code_id is the reference to the stored WASM code
     * @param init_msg json encoded message to be passed to the contract on instantiation
     * @param init_coins are transferred to the contract on execution
     */


    function MsgInstantiateContract(sender, admin, code_id, init_msg, init_coins) {
      if (init_coins === void 0) {
        init_coins = {};
      }

      var _this = _super.call(this) || this;

      _this.sender = sender;
      _this.admin = admin;
      _this.code_id = code_id;
      _this.init_msg = init_msg;
      _this.init_coins = new Coins_1$4.Coins(init_coins);
      return _this;
    }

    MsgInstantiateContract.fromData = function (data) {
      var _a = data.value,
          sender = _a.sender,
          admin = _a.admin,
          code_id = _a.code_id,
          init_msg = _a.init_msg,
          init_coins = _a.init_coins;
      return new MsgInstantiateContract(sender, admin, Number.parseInt(code_id), init_msg, Coins_1$4.Coins.fromData(init_coins));
    };

    MsgInstantiateContract.prototype.toData = function () {
      var _a = this,
          sender = _a.sender,
          admin = _a.admin,
          code_id = _a.code_id,
          init_msg = _a.init_msg,
          init_coins = _a.init_coins;

      return {
        type: 'wasm/MsgInstantiateContract',
        value: {
          sender: sender,
          admin: admin === '' || admin === null ? undefined : admin,
          code_id: code_id.toFixed(),
          init_msg: (0, json_1$g.removeNull)(init_msg),
          init_coins: init_coins.toData()
        }
      };
    };

    return MsgInstantiateContract;
  }(json_1$g.JSONSerializable);

  MsgInstantiateContract$1.MsgInstantiateContract = MsgInstantiateContract;

  var MsgExecuteContract$1 = {};

  var __extends$x = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgExecuteContract$1, "__esModule", {
    value: true
  });
  MsgExecuteContract$1.MsgExecuteContract = void 0;
  var json_1$f = json$1;
  var Coins_1$3 = Coins$1;

  var MsgExecuteContract =
  /** @class */
  function (_super) {
    __extends$x(MsgExecuteContract, _super);
    /**
     * @param sender contract user
     * @param contract contract address
     * @param msg HandleMsg to pass as arguments for contract invocation
     * @param coins coins to be sent to contract
     */


    function MsgExecuteContract(sender, contract, execute_msg, coins) {
      if (coins === void 0) {
        coins = {};
      }

      var _this = _super.call(this) || this;

      _this.sender = sender;
      _this.contract = contract;
      _this.execute_msg = execute_msg;
      _this.coins = new Coins_1$3.Coins(coins);
      return _this;
    }

    MsgExecuteContract.fromData = function (data) {
      var _a = data.value,
          sender = _a.sender,
          contract = _a.contract,
          execute_msg = _a.execute_msg,
          coins = _a.coins;
      return new MsgExecuteContract(sender, contract, execute_msg, Coins_1$3.Coins.fromData(coins));
    };

    MsgExecuteContract.prototype.toData = function () {
      var _a = this,
          sender = _a.sender,
          contract = _a.contract,
          execute_msg = _a.execute_msg,
          coins = _a.coins;

      return {
        type: 'wasm/MsgExecuteContract',
        value: {
          sender: sender,
          contract: contract,
          execute_msg: (0, json_1$f.removeNull)(execute_msg),
          coins: coins.toData()
        }
      };
    };

    return MsgExecuteContract;
  }(json_1$f.JSONSerializable);

  MsgExecuteContract$1.MsgExecuteContract = MsgExecuteContract;

  var MsgMigrateContract$1 = {};

  var __extends$w = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgMigrateContract$1, "__esModule", {
    value: true
  });
  MsgMigrateContract$1.MsgMigrateContract = void 0;
  var json_1$e = json$1;

  var MsgMigrateContract =
  /** @class */
  function (_super) {
    __extends$w(MsgMigrateContract, _super);
    /**
     * @param admin contract admin
     * @param contract contract address to be migrated from
     * @param new_code_id reference to the new code on the blockchain
     * @param migrate_msg JSON message to configure the migrate state of the contract
     */


    function MsgMigrateContract(admin, contract, new_code_id, migrate_msg // json object
    ) {
      var _this = _super.call(this) || this;

      _this.admin = admin;
      _this.contract = contract;
      _this.new_code_id = new_code_id;
      _this.migrate_msg = migrate_msg;
      return _this;
    }

    MsgMigrateContract.fromData = function (data) {
      var _a = data.value,
          admin = _a.admin,
          contract = _a.contract,
          new_code_id = _a.new_code_id,
          migrate_msg = _a.migrate_msg;
      return new MsgMigrateContract(admin, contract, Number.parseInt(new_code_id), migrate_msg);
    };

    MsgMigrateContract.prototype.toData = function () {
      var _a = this,
          admin = _a.admin,
          contract = _a.contract,
          new_code_id = _a.new_code_id,
          migrate_msg = _a.migrate_msg;

      return {
        type: 'wasm/MsgMigrateContract',
        value: {
          admin: admin,
          contract: contract,
          new_code_id: new_code_id.toFixed(),
          migrate_msg: (0, json_1$e.removeNull)(migrate_msg)
        }
      };
    };

    return MsgMigrateContract;
  }(json_1$e.JSONSerializable);

  MsgMigrateContract$1.MsgMigrateContract = MsgMigrateContract;

  var MsgUpdateContractAdmin$1 = {};

  var __extends$v = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgUpdateContractAdmin$1, "__esModule", {
    value: true
  });
  MsgUpdateContractAdmin$1.MsgUpdateContractAdmin = void 0;
  var json_1$d = json$1;

  var MsgUpdateContractAdmin =
  /** @class */
  function (_super) {
    __extends$v(MsgUpdateContractAdmin, _super);
    /**
     * @param admin contract admin
     * @param new_admin new admin
     * @param contract contract address
     */


    function MsgUpdateContractAdmin(admin, new_admin, contract) {
      var _this = _super.call(this) || this;

      _this.admin = admin;
      _this.new_admin = new_admin;
      _this.contract = contract;
      return _this;
    }

    MsgUpdateContractAdmin.fromData = function (data) {
      var _a = data.value,
          admin = _a.admin,
          new_admin = _a.new_admin,
          contract = _a.contract;
      return new MsgUpdateContractAdmin(admin, new_admin, contract);
    };

    MsgUpdateContractAdmin.prototype.toData = function () {
      var _a = this,
          admin = _a.admin,
          new_admin = _a.new_admin,
          contract = _a.contract;

      return {
        type: 'wasm/MsgUpdateContractAdmin',
        value: {
          admin: admin,
          new_admin: new_admin,
          contract: contract
        }
      };
    };

    return MsgUpdateContractAdmin;
  }(json_1$d.JSONSerializable);

  MsgUpdateContractAdmin$1.MsgUpdateContractAdmin = MsgUpdateContractAdmin;

  var MsgClearContractAdmin$1 = {};

  var __extends$u = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(MsgClearContractAdmin$1, "__esModule", {
    value: true
  });
  MsgClearContractAdmin$1.MsgClearContractAdmin = void 0;
  var json_1$c = json$1;

  var MsgClearContractAdmin =
  /** @class */
  function (_super) {
    __extends$u(MsgClearContractAdmin, _super);
    /**
     * @param admin contract admin
     * @param new_admin new admin
     * @param contract contract address
     */


    function MsgClearContractAdmin(admin, contract) {
      var _this = _super.call(this) || this;

      _this.admin = admin;
      _this.contract = contract;
      return _this;
    }

    MsgClearContractAdmin.fromData = function (data) {
      var _a = data.value,
          admin = _a.admin,
          contract = _a.contract;
      return new MsgClearContractAdmin(admin, contract);
    };

    MsgClearContractAdmin.prototype.toData = function () {
      var _a = this,
          admin = _a.admin,
          contract = _a.contract;

      return {
        type: 'wasm/MsgClearContractAdmin',
        value: {
          admin: admin,
          contract: contract
        }
      };
    };

    return MsgClearContractAdmin;
  }(json_1$c.JSONSerializable);

  MsgClearContractAdmin$1.MsgClearContractAdmin = MsgClearContractAdmin;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(MsgStoreCode$1, exports);

    __exportStar(MsgMigrateCode$1, exports);

    __exportStar(MsgInstantiateContract$1, exports);

    __exportStar(MsgExecuteContract$1, exports);

    __exportStar(MsgMigrateContract$1, exports);

    __exportStar(MsgUpdateContractAdmin$1, exports);

    __exportStar(MsgClearContractAdmin$1, exports);
  })(msgs);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Msg = void 0;
    var msgs_1 = msgs$8;
    var msgs_2 = msgs$7;
    var msgs_3 = msgs$6;
    var msgs_4 = msgs$5;
    var msgs_5 = msgs$4;
    var msgs_6 = msgs$3;
    var msgs_7 = msgs$2;
    var msgs_8 = msgs$1;
    var msgs_9 = msgs;

    (function (Msg) {
      function fromData(data) {
        switch (data.type) {
          // bank
          case 'bank/MsgSend':
            return msgs_1.MsgSend.fromData(data);

          case 'bank/MsgMultiSend':
            return msgs_1.MsgMultiSend.fromData(data);
          // distribution

          case 'distribution/MsgModifyWithdrawAddress':
            return msgs_2.MsgModifyWithdrawAddress.fromData(data);

          case 'distribution/MsgWithdrawDelegationReward':
            return msgs_2.MsgWithdrawDelegationReward.fromData(data);

          case 'distribution/MsgWithdrawValidatorCommission':
            return msgs_2.MsgWithdrawValidatorCommission.fromData(data);

          case 'distribution/MsgFundCommunityPool':
            return msgs_2.MsgFundCommunityPool.fromData(data);
          // gov

          case 'gov/MsgDeposit':
            return msgs_3.MsgDeposit.fromData(data);

          case 'gov/MsgSubmitProposal':
            return msgs_3.MsgSubmitProposal.fromData(data);

          case 'gov/MsgVote':
            return msgs_3.MsgVote.fromData(data);
          // market

          case 'market/MsgSwap':
            return msgs_4.MsgSwap.fromData(data);

          case 'market/MsgSwapSend':
            return msgs_4.MsgSwapSend.fromData(data);
          // msgauth

          case 'msgauth/MsgGrantAuthorization':
            return msgs_5.MsgGrantAuthorization.fromData(data);

          case 'msgauth/MsgRevokeAuthorization':
            return msgs_5.MsgRevokeAuthorization.fromData(data);

          case 'msgauth/MsgExecAuthorized':
            return msgs_5.MsgExecAuthorized.fromData(data);
          // oracle

          case 'oracle/MsgDelegateFeedConsent':
            return msgs_6.MsgDelegateFeedConsent.fromData(data);

          case 'oracle/MsgAggregateExchangeRatePrevote':
            return msgs_6.MsgAggregateExchangeRatePrevote.fromData(data);

          case 'oracle/MsgAggregateExchangeRateVote':
            return msgs_6.MsgAggregateExchangeRateVote.fromData(data);
          // slashing

          case 'slashing/MsgUnjail':
            return msgs_7.MsgUnjail.fromData(data);
          // staking

          case 'staking/MsgDelegate':
            return msgs_8.MsgDelegate.fromData(data);

          case 'staking/MsgUndelegate':
            return msgs_8.MsgUndelegate.fromData(data);

          case 'staking/MsgBeginRedelegate':
            return msgs_8.MsgBeginRedelegate.fromData(data);

          case 'staking/MsgCreateValidator':
            return msgs_8.MsgCreateValidator.fromData(data);

          case 'staking/MsgEditValidator':
            return msgs_8.MsgEditValidator.fromData(data);
          // wasm

          case 'wasm/MsgStoreCode':
            return msgs_9.MsgStoreCode.fromData(data);

          case 'wasm/MsgMigrateCode':
            return msgs_9.MsgMigrateCode.fromData(data);

          case 'wasm/MsgInstantiateContract':
            return msgs_9.MsgInstantiateContract.fromData(data);

          case 'wasm/MsgExecuteContract':
            return msgs_9.MsgExecuteContract.fromData(data);

          case 'wasm/MsgMigrateContract':
            return msgs_9.MsgMigrateContract.fromData(data);

          case 'wasm/MsgUpdateContractAdmin':
            return msgs_9.MsgUpdateContractAdmin.fromData(data);

          case 'wasm/MsgClearContractAdmin':
            return msgs_9.MsgClearContractAdmin.fromData(data);
        }

        throw new Error("unable to parse msg: " + data + " unrecognized");
      }

      Msg.fromData = fromData;
    })(exports.Msg || (exports.Msg = {}));
  })(Msg);

  var PublicKey$1 = {};

  var __extends$t = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(PublicKey$1, "__esModule", {
    value: true
  });
  PublicKey$1.PublicKey = void 0;
  var json_1$b = json$1;

  var PublicKey =
  /** @class */
  function (_super) {
    __extends$t(PublicKey, _super);

    function PublicKey(type, value) {
      var _this = _super.call(this) || this;

      _this.type = type;
      _this.value = value;
      return _this;
    }

    PublicKey.fromData = function (data) {
      var type = data.type,
          value = data.value;
      return new PublicKey(type, value);
    };

    PublicKey.prototype.toData = function () {
      var _a = this,
          type = _a.type,
          value = _a.value;

      if (type === 'tendermint/PubKeySecp256k1' && typeof value === 'string') {
        return {
          type: type,
          value: value
        };
      } else if (type === 'tendermint/PubKeyMultisigThreshold' && typeof value !== 'string') {
        return {
          type: type,
          value: value
        };
      }

      throw new TypeError('invalid public key: type and value do not match');
    };

    return PublicKey;
  }(json_1$b.JSONSerializable);

  PublicKey$1.PublicKey = PublicKey;

  var StdFee$1 = {};

  var __extends$s = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(StdFee$1, "__esModule", {
    value: true
  });
  StdFee$1.StdFee = void 0;
  var json_1$a = json$1;
  var Coins_1$2 = Coins$1;
  var numeric_1$3 = numeric;
  /**
   * A transaction must include a fee, otherwise it will be rejected.
   */

  var StdFee =
  /** @class */
  function (_super) {
    __extends$s(StdFee, _super);
    /**
     * Creates a new StdFee object.
     * @param gas gas limit
     * @param amount amount to be paid to validator
     */


    function StdFee(gas, amount) {
      var _this = _super.call(this) || this;

      _this.gas = gas;
      _this.amount = new Coins_1$2.Coins(amount);
      return _this;
    }

    StdFee.fromData = function (data) {
      var gas = data.gas,
          amount = data.amount;
      return new StdFee(Number.parseInt(gas), Coins_1$2.Coins.fromData(amount));
    };

    StdFee.prototype.toData = function () {
      return {
        gas: new numeric_1$3.Int(this.gas).toString(),
        amount: this.amount.toData()
      };
    };
    /**
     * Gets the mininimum gas prices implied by the fee. Minimum gas prices are `fee amount / gas`.
     */


    StdFee.prototype.gasPrices = function () {
      return this.amount.toDecCoins().div(this.gas);
    };

    return StdFee;
  }(json_1$a.JSONSerializable);

  StdFee$1.StdFee = StdFee;

  var StdSignature$1 = {};

  var __extends$r = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(StdSignature$1, "__esModule", {
    value: true
  });
  StdSignature$1.StdSignature = void 0;
  var PublicKey_1$1 = PublicKey$1;
  var json_1$9 = json$1;
  /**
   * A signature consists of a message signature with a public key to verify its validity.
   * You likely will not need to work with StdSignature objects directly as they are automatically created for you.
   */

  var StdSignature =
  /** @class */
  function (_super) {
    __extends$r(StdSignature, _super);
    /**
     *
     * @param signature Message signature string (base64-encoded).
     * @param pub_key Public key
     */


    function StdSignature(signature, pub_key) {
      var _this = _super.call(this) || this;

      _this.signature = signature;
      _this.pub_key = pub_key;
      return _this;
    }

    StdSignature.fromData = function (data) {
      var signature = data.signature,
          pub_key = data.pub_key;
      return new StdSignature(signature, PublicKey_1$1.PublicKey.fromData(pub_key || {
        type: 'tendermint/PubKeySecp256k1',
        value: ''
      }));
    };

    StdSignature.prototype.toData = function () {
      var _a = this,
          signature = _a.signature,
          pub_key = _a.pub_key;

      return {
        signature: signature,
        pub_key: pub_key === null || pub_key === void 0 ? void 0 : pub_key.toData()
      };
    };

    return StdSignature;
  }(json_1$9.JSONSerializable);

  StdSignature$1.StdSignature = StdSignature;

  var StdSignMsg$1 = {};

  var StdTx$1 = {};

  var __extends$q = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(StdTx$1, "__esModule", {
    value: true
  });
  StdTx$1.StdTx = void 0;
  var StdSignature_1$1 = StdSignature$1;
  var json_1$8 = json$1;
  var StdFee_1$1 = StdFee$1;
  var Msg_1$1 = Msg;
  /**
   * The StdTx data structure contains the signatures from [[StdSignMsg]] with the same
   * information, and can be broadcasted to the node to be included in a block.
   */

  var StdTx =
  /** @class */
  function (_super) {
    __extends$q(StdTx, _super);
    /**
     * @param msg list of messages to include (not a typo)
     * @param fee transaction fee
     * @param signatures list of signatures
     * @param memo optional note
     * @param timeout_height optional tx timeout
     */


    function StdTx(msg, fee, signatures, memo, timeout_height) {
      if (memo === void 0) {
        memo = '';
      }

      if (timeout_height === void 0) {
        timeout_height = 0;
      }

      var _this = _super.call(this) || this;

      _this.msg = msg;
      _this.fee = fee;
      _this.signatures = signatures;
      _this.memo = memo;
      _this.timeout_height = timeout_height;
      return _this;
    }

    StdTx.fromData = function (data) {
      var _a = data.value,
          msg = _a.msg,
          fee = _a.fee,
          signatures = _a.signatures,
          memo = _a.memo,
          timeout_height = _a.timeout_height;
      return new StdTx(msg.map(function (m) {
        return Msg_1$1.Msg.fromData(m);
      }), StdFee_1$1.StdFee.fromData(fee), signatures.map(function (s) {
        return StdSignature_1$1.StdSignature.fromData(s);
      }), memo, Number.parseInt(timeout_height));
    };

    StdTx.prototype.toData = function () {
      var _a = this,
          msg = _a.msg,
          fee = _a.fee,
          signatures = _a.signatures,
          memo = _a.memo,
          timeout_height = _a.timeout_height;

      return {
        type: 'core/StdTx',
        value: {
          msg: msg.map(function (m) {
            return m.toData();
          }),
          fee: fee.toData(),
          signatures: signatures.map(function (s) {
            return s.toData();
          }),
          memo: memo,
          timeout_height: timeout_height.toFixed()
        }
      };
    };

    return StdTx;
  }(json_1$8.JSONSerializable);

  StdTx$1.StdTx = StdTx;

  var __extends$p = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(StdSignMsg$1, "__esModule", {
    value: true
  });
  StdSignMsg$1.StdSignMsg = void 0;
  var StdFee_1 = StdFee$1;
  var Msg_1 = Msg;
  var json_1$7 = json$1;
  var StdTx_1$1 = StdTx$1;
  /**
   * A sign message is a data structure that is used to create a [[StdSignature]] to be later
   * appended to the list of signatures in an [[StdTx]]. Essentially, it contains all the
   * information needed to sign and build a transaction, and can be described as an
   * "unsigned transaction."
   */

  var StdSignMsg =
  /** @class */
  function (_super) {
    __extends$p(StdSignMsg, _super);
    /**
     *
     * @param chain_id ID of blockchain to submit transaction to
     * @param account_number account number on blockchain
     * @param sequence Sequence number (nonce), number of signed previous transactions by
     *    account included on the blockchain at time of broadcast.
     * @param fee transaction fee
     * @param msgs list of messages to include
     * @param memo optional note
     */


    function StdSignMsg(chain_id, account_number, sequence, fee, msgs, memo, timeout_height) {
      if (memo === void 0) {
        memo = '';
      }

      if (timeout_height === void 0) {
        timeout_height = 0;
      }

      var _this = _super.call(this) || this;

      _this.chain_id = chain_id;
      _this.account_number = account_number;
      _this.sequence = sequence;
      _this.fee = fee;
      _this.msgs = msgs;
      _this.memo = memo;
      _this.timeout_height = timeout_height;
      return _this;
    }

    StdSignMsg.prototype.toData = function () {
      var _a = this,
          chain_id = _a.chain_id,
          account_number = _a.account_number,
          sequence = _a.sequence,
          fee = _a.fee,
          msgs = _a.msgs,
          memo = _a.memo,
          timeout_height = _a.timeout_height;

      return {
        chain_id: chain_id,
        account_number: account_number.toString(),
        sequence: sequence.toString(),
        fee: fee.toData(),
        msgs: msgs.map(function (m) {
          return m.toData();
        }),
        memo: memo,
        timeout_height: timeout_height !== 0 ? timeout_height.toFixed() : undefined
      };
    };

    StdSignMsg.fromData = function (data) {
      var chain_id = data.chain_id,
          account_number = data.account_number,
          sequence = data.sequence,
          fee = data.fee,
          msgs = data.msgs,
          memo = data.memo,
          timeout_height = data.timeout_height;
      return new StdSignMsg(chain_id, Number.parseInt(account_number) || 0, Number.parseInt(sequence) || 0, StdFee_1.StdFee.fromData(fee), msgs.map(function (m) {
        return Msg_1.Msg.fromData(m);
      }), memo, Number.parseInt(timeout_height !== null && timeout_height !== void 0 ? timeout_height : '0'));
    };
    /**
     * You get the [[StdTx]] value from a `StdSignMsg` (without the signature).
     */


    StdSignMsg.prototype.toStdTx = function () {
      var _a = this,
          fee = _a.fee,
          msgs = _a.msgs,
          memo = _a.memo,
          timeout_height = _a.timeout_height;

      return new StdTx_1$1.StdTx(msgs, fee, [], memo, timeout_height);
    };

    return StdSignMsg;
  }(json_1$7.JSONSerializable);

  StdSignMsg$1.StdSignMsg = StdSignMsg;

  var TxInfo = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TxLog = exports.EventsByType = exports.TxInfo = void 0;
    var json_1 = json$1;
    var StdTx_1 = StdTx$1;
    /**
     * A TxInfo data structure is used to capture information from a transaction lookup for
     * a transaction already included in a block
     */

    var TxInfo =
    /** @class */
    function (_super) {
      __extends(TxInfo, _super);
      /**
       *
       * @param height height of the block in which the transaction was included.
       * @param txhash transaction's hash.
       * @param raw_log raw log information, as a string.
       * @param logs log information
       * @param gas_wanted gas limited submitted in fee
       * @param gas_used actual gas consumption
       * @param tx transaction content
       * @param timestamp time of inclusion
       * @param code error code
       */


      function TxInfo(height, txhash, raw_log, logs, gas_wanted, gas_used, tx, timestamp, code, codespace) {
        var _this = _super.call(this) || this;

        _this.height = height;
        _this.txhash = txhash;
        _this.raw_log = raw_log;
        _this.logs = logs;
        _this.gas_wanted = gas_wanted;
        _this.gas_used = gas_used;
        _this.tx = tx;
        _this.timestamp = timestamp;
        _this.code = code;
        _this.codespace = codespace;
        return _this;
      }

      TxInfo.fromData = function (data) {
        return new TxInfo(Number.parseInt(data.height), data.txhash, data.raw_log, data.logs && data.logs.map(function (log) {
          return TxLog.fromData(log);
        }), Number.parseInt(data.gas_wanted), Number.parseInt(data.gas_used), StdTx_1.StdTx.fromData(data.tx), data.timestamp, data.code, data.codespace);
      };

      TxInfo.prototype.toData = function () {
        var data = {
          height: this.height.toFixed(),
          txhash: this.txhash,
          raw_log: this.raw_log,
          gas_wanted: this.gas_wanted.toFixed(),
          gas_used: this.gas_used.toFixed(),
          tx: this.tx.toData(),
          timestamp: this.timestamp
        };

        if (this.logs) {
          data.logs = this.logs.map(function (log) {
            return log.toData();
          });
        }

        if (this.code) {
          data.code = this.code;
        }

        if (this.codespace) {
          data.codespace = this.codespace;
        }

        return data;
      };

      return TxInfo;
    }(json_1.JSONSerializable);

    exports.TxInfo = TxInfo;
    var EventsByType;

    (function (EventsByType) {
      function parse(eventData) {
        var events = {};
        eventData.forEach(function (ev) {
          ev.attributes.forEach(function (attr) {
            if (!(ev.type in events)) {
              events[ev.type] = {};
            }

            if (!(attr.key in events[ev.type])) {
              events[ev.type][attr.key] = [];
            }

            events[ev.type][attr.key].push(attr.value);
          });
        });
        return events;
      }

      EventsByType.parse = parse;
    })(EventsByType = exports.EventsByType || (exports.EventsByType = {}));

    var TxLog =
    /** @class */
    function (_super) {
      __extends(TxLog, _super);

      function TxLog(msg_index, log, events) {
        var _this = _super.call(this) || this;

        _this.msg_index = msg_index;
        _this.log = log;
        _this.events = events;
        _this.eventsByType = EventsByType.parse(_this.events);
        return _this;
      }

      TxLog.fromData = function (data) {
        var msg_index = data.msg_index,
            log = data.log,
            events = data.events;
        return new TxLog(msg_index, log, events);
      };

      TxLog.prototype.toData = function () {
        var _a = this,
            msg_index = _a.msg_index,
            log = _a.log,
            events = _a.events;

        return {
          msg_index: msg_index,
          log: log,
          events: events
        };
      };

      return TxLog;
    }(json_1.JSONSerializable);

    exports.TxLog = TxLog;
  })(TxInfo);

  var ValidatorSet = {};

  Object.defineProperty(ValidatorSet, "__esModule", {
    value: true
  });

  var Deposit$1 = {};

  var __extends$o = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(Deposit$1, "__esModule", {
    value: true
  });
  Deposit$1.Deposit = void 0;
  var Coins_1$1 = Coins$1;
  var json_1$6 = json$1;
  /**
   * Stores deposit information for a proposal
   */

  var Deposit =
  /** @class */
  function (_super) {
    __extends$o(Deposit, _super);
    /**
     * @param proposal_id Id of porposal to deposit to
     * @param depositor depositor's account address
     * @param amount amount to deposit
     */


    function Deposit(proposal_id, depositor, amount) {
      var _this = _super.call(this) || this;

      _this.proposal_id = proposal_id;
      _this.depositor = depositor;
      _this.amount = new Coins_1$1.Coins(amount);
      return _this;
    }

    Deposit.fromData = function (data) {
      var proposal_id = data.proposal_id,
          depositor = data.depositor,
          amount = data.amount;
      return new Deposit(Number.parseInt(proposal_id), depositor, Coins_1$1.Coins.fromData(amount));
    };

    Deposit.prototype.toData = function () {
      var _a = this,
          proposal_id = _a.proposal_id,
          depositor = _a.depositor,
          amount = _a.amount;

      return {
        proposal_id: proposal_id.toString(),
        depositor: depositor,
        amount: amount.toData()
      };
    };

    return Deposit;
  }(json_1$6.JSONSerializable);

  Deposit$1.Deposit = Deposit;

  var Account$1 = {};

  var __extends$n = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(Account$1, "__esModule", {
    value: true
  });
  Account$1.Account = void 0;
  var PublicKey_1 = PublicKey$1;
  var json_1$5 = json$1;
  /**
   * Stores information about an account fetched from the blockchain.
   */

  var Account =
  /** @class */
  function (_super) {
    __extends$n(Account, _super);
    /**
     * Creates a new Account object, holding information about a basic account.
     *
     * @param address account address
     * @param public_key account's public key information
     * @param account_number account number on the blockchain
     * @param sequence sequence number, or number of transactions that have been posted
     */


    function Account(address, public_key, account_number, sequence) {
      var _this = _super.call(this) || this;

      _this.address = address;
      _this.public_key = public_key;
      _this.account_number = account_number;
      _this.sequence = sequence;
      return _this;
    }

    Account.prototype.toData = function () {
      var _a = this,
          address = _a.address,
          public_key = _a.public_key,
          account_number = _a.account_number,
          sequence = _a.sequence;

      return {
        type: 'core/Account',
        value: {
          address: address,
          public_key: public_key ? public_key.toData() : null,
          account_number: account_number.toFixed(),
          sequence: sequence.toFixed()
        }
      };
    };

    Account.fromData = function (data) {
      var _a = data.value,
          address = _a.address,
          public_key = _a.public_key,
          account_number = _a.account_number,
          sequence = _a.sequence;
      return new Account(address || '', public_key ? PublicKey_1.PublicKey.fromData(public_key) : null, Number.parseInt(account_number) || 0, Number.parseInt(sequence) || 0);
    };

    return Account;
  }(json_1$5.JSONSerializable);

  Account$1.Account = Account;

  var LazyGradedVestingAccount = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LazyGradedVestingAccount = void 0;
    var Coins_1 = Coins$1;
    var json_1 = json$1;
    var numeric_1 = numeric;
    var PublicKey_1 = PublicKey$1;
    /**
     * Holds information about a Account which has vesting information.
     */

    var LazyGradedVestingAccount =
    /** @class */
    function (_super) {
      __extends(LazyGradedVestingAccount, _super);
      /**
       *
       * @param BaseAccount account information
       * @param original_vesting initial vesting amount
       * @param delegated_free
       * @param delegated_vesting
       * @param vesting_schedules Entries that make up vesting
       */


      function LazyGradedVestingAccount(address, public_key, account_number, sequence, original_vesting, delegated_free, delegated_vesting, vesting_schedules) {
        var _this = _super.call(this) || this;

        _this.address = address;
        _this.public_key = public_key;
        _this.account_number = account_number;
        _this.sequence = sequence;
        _this.original_vesting = original_vesting;
        _this.delegated_free = delegated_free;
        _this.delegated_vesting = delegated_vesting;
        _this.vesting_schedules = vesting_schedules;
        return _this;
      }

      LazyGradedVestingAccount.prototype.toData = function () {
        var _a = this,
            address = _a.address,
            public_key = _a.public_key,
            account_number = _a.account_number,
            sequence = _a.sequence,
            original_vesting = _a.original_vesting,
            delegated_free = _a.delegated_free,
            delegated_vesting = _a.delegated_vesting,
            vesting_schedules = _a.vesting_schedules;

        return {
          type: 'core/LazyGradedVestingAccount',
          value: {
            base_vesting_account: {
              base_account: {
                address: address,
                public_key: public_key && public_key.toData(),
                account_number: account_number.toFixed(),
                sequence: sequence.toFixed()
              },
              original_vesting: original_vesting.toData(),
              delegated_free: delegated_free.toData(),
              delegated_vesting: delegated_vesting.toData()
            },
            vesting_schedules: vesting_schedules.map(function (vs) {
              return vs.toData();
            })
          }
        };
      };

      LazyGradedVestingAccount.fromData = function (data) {
        var _a = data.value,
            _b = _a.base_vesting_account,
            _c = _b.base_account,
            address = _c.address,
            public_key = _c.public_key,
            account_number = _c.account_number,
            sequence = _c.sequence,
            original_vesting = _b.original_vesting,
            delegated_free = _b.delegated_free,
            delegated_vesting = _b.delegated_vesting,
            vesting_schedules = _a.vesting_schedules;
        return new LazyGradedVestingAccount(address || '', public_key ? PublicKey_1.PublicKey.fromData(public_key) : null, Number.parseInt(account_number) || 0, Number.parseInt(sequence) || 0, Coins_1.Coins.fromData(original_vesting), Coins_1.Coins.fromData(delegated_free), Coins_1.Coins.fromData(delegated_vesting), vesting_schedules.map(function (vs) {
          return LazyGradedVestingAccount.VestingSchedule.fromData(vs);
        }));
      };

      return LazyGradedVestingAccount;
    }(json_1.JSONSerializable);

    exports.LazyGradedVestingAccount = LazyGradedVestingAccount;

    (function (LazyGradedVestingAccount) {
      var VestingSchedule =
      /** @class */
      function (_super) {
        __extends(VestingSchedule, _super);

        function VestingSchedule(denom, schedules) {
          var _this = _super.call(this) || this;

          _this.denom = denom;
          _this.schedules = schedules;
          return _this;
        }

        VestingSchedule.prototype.toData = function () {
          var _a = this,
              denom = _a.denom,
              schedules = _a.schedules;

          return {
            denom: denom,
            schedules: schedules.map(function (s) {
              return s.toData();
            })
          };
        };

        VestingSchedule.fromData = function (data) {
          var denom = data.denom,
              schedules = data.schedules;
          return new VestingSchedule(denom, schedules.map(function (s) {
            return VestingSchedule.Entry.fromData(s);
          }));
        };

        return VestingSchedule;
      }(json_1.JSONSerializable);

      LazyGradedVestingAccount.VestingSchedule = VestingSchedule;

      (function (VestingSchedule) {
        var Entry =
        /** @class */
        function (_super) {
          __extends(Entry, _super);
          /**
           *
           * @param start_time Starting time (block height)
           * @param end_time Ending time (block height)
           * @param ratio Ratio (percentage of vested funds that should be released)
           */


          function Entry(start_time, end_time, ratio) {
            var _this = _super.call(this) || this;

            _this.start_time = start_time;
            _this.end_time = end_time;
            _this.ratio = ratio;
            return _this;
          }

          Entry.fromData = function (data) {
            var start_time = data.start_time,
                end_time = data.end_time,
                ratio = data.ratio;
            return new Entry(Number.parseInt(start_time), Number.parseInt(end_time), new numeric_1.Dec(ratio));
          };

          Entry.prototype.toData = function () {
            return {
              start_time: this.start_time.toFixed(),
              end_time: this.end_time.toFixed(),
              ratio: this.ratio.toString()
            };
          };

          return Entry;
        }(json_1.JSONSerializable);

        VestingSchedule.Entry = Entry;
      })(VestingSchedule = LazyGradedVestingAccount.VestingSchedule || (LazyGradedVestingAccount.VestingSchedule = {}));
    })(LazyGradedVestingAccount = exports.LazyGradedVestingAccount || (exports.LazyGradedVestingAccount = {}));

    exports.LazyGradedVestingAccount = LazyGradedVestingAccount;
  })(LazyGradedVestingAccount);

  var Vote = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Vote = void 0;
    var json_1 = json$1;
    /**
     * Stores vote information for a proposal
     */

    var Vote =
    /** @class */
    function (_super) {
      __extends(Vote, _super);
      /**
       * @param proposal_id ID of proposal to vote on
       * @param voter voter's account address
       * @param option one of voting options
       */


      function Vote(proposal_id, voter, options, option // undefined except proposals in voting status
      ) {
        var _this = _super.call(this) || this;

        _this.proposal_id = proposal_id;
        _this.voter = voter;
        _this.options = options;
        _this.option = option;
        return _this;
      }

      Vote.fromData = function (data) {
        var proposal_id = data.proposal_id,
            voter = data.voter,
            options = data.options,
            option = data.option;
        return new Vote(Number.parseInt(proposal_id), voter, options, option);
      };

      Vote.prototype.toData = function () {
        var _a = this,
            proposal_id = _a.proposal_id,
            voter = _a.voter,
            options = _a.options,
            option = _a.option;

        var res = {
          proposal_id: proposal_id.toFixed(),
          voter: voter,
          options: options
        };

        if (option) {
          res.option = option;
        }

        return res;
      };

      return Vote;
    }(json_1.JSONSerializable);

    exports.Vote = Vote;

    (function (Vote) {

      (function (Option) {
        /** - */
        Option[Option["EMPTY"] = 0] = "EMPTY";
        /** Vote yes */

        Option[Option["YES"] = 1] = "YES";
        /** Do not vote */

        Option[Option["ABSTAIN"] = 2] = "ABSTAIN";
        /** Vote no */

        Option[Option["NO"] = 3] = "NO";
        /** Vote No with the option to veto if passed */

        Option[Option["NO_WITH_VETO"] = 4] = "NO_WITH_VETO";
      })(Vote.Option || (Vote.Option = {}));
    })(Vote = exports.Vote || (exports.Vote = {}));

    exports.Vote = Vote;
  })(Vote);

  var AggregateExchangeRatePrevote$1 = {};

  var __extends$m = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(AggregateExchangeRatePrevote$1, "__esModule", {
    value: true
  });
  AggregateExchangeRatePrevote$1.AggregateExchangeRatePrevote = void 0;
  var json_1$4 = json$1;
  /**
   * Stores information about data about Oracle aggregate prevotes fetched from the blockchain.
   */

  var AggregateExchangeRatePrevote =
  /** @class */
  function (_super) {
    __extends$m(AggregateExchangeRatePrevote, _super);
    /**
     * @param hash aggregate vote hash
     * @param voter validator
     * @param submit_block block during which aggregate prevote was submitted
     */


    function AggregateExchangeRatePrevote(hash, voter, submit_block) {
      var _this = _super.call(this) || this;

      _this.hash = hash;
      _this.voter = voter;
      _this.submit_block = submit_block;
      return _this;
    }

    AggregateExchangeRatePrevote.fromData = function (data) {
      var hash = data.hash,
          voter = data.voter,
          submit_block = data.submit_block;
      return new AggregateExchangeRatePrevote(hash, voter, Number.parseInt(submit_block));
    };

    AggregateExchangeRatePrevote.prototype.toData = function () {
      var _a = this,
          hash = _a.hash,
          voter = _a.voter,
          submit_block = _a.submit_block;

      return {
        hash: hash,
        voter: voter,
        submit_block: submit_block.toFixed()
      };
    };

    return AggregateExchangeRatePrevote;
  }(json_1$4.JSONSerializable);

  AggregateExchangeRatePrevote$1.AggregateExchangeRatePrevote = AggregateExchangeRatePrevote;

  var AggregateExchangeRateVote$1 = {};

  var __extends$l = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(AggregateExchangeRateVote$1, "__esModule", {
    value: true
  });
  AggregateExchangeRateVote$1.AggregateExchangeRateVote = void 0;
  var json_1$3 = json$1;
  var Coin_1$3 = Coin;
  var Coins_1 = Coins$1;
  /**
   * Stores information about data about Oracle aggregate vote fetched from the blockchain.
   */

  var AggregateExchangeRateVote =
  /** @class */
  function (_super) {
    __extends$l(AggregateExchangeRateVote, _super);
    /**
     * @param exchange_rate_tuples exchange rates for LUNA
     * @param voter validator
     */


    function AggregateExchangeRateVote(exchange_rate_tuples, voter) {
      var _this = _super.call(this) || this;

      _this.exchange_rate_tuples = exchange_rate_tuples;
      _this.voter = voter;
      return _this;
    }

    AggregateExchangeRateVote.fromData = function (data) {
      var exchange_rate_tuples = data.exchange_rate_tuples,
          voter = data.voter;
      var xr_coins = new Coins_1.Coins(exchange_rate_tuples.map(function (t) {
        return new Coin_1$3.Coin(t.denom, t.exchange_rate);
      })).toDecCoins();
      return new AggregateExchangeRateVote(xr_coins, voter);
    };

    AggregateExchangeRateVote.prototype.toData = function () {
      var _a = this,
          exchange_rate_tuples = _a.exchange_rate_tuples,
          voter = _a.voter;

      return {
        exchange_rate_tuples: exchange_rate_tuples.map(function (c) {
          return {
            denom: c.denom,
            exchange_rate: c.amount.toString()
          };
        }),
        voter: voter
      };
    };

    return AggregateExchangeRateVote;
  }(json_1$3.JSONSerializable);

  AggregateExchangeRateVote$1.AggregateExchangeRateVote = AggregateExchangeRateVote;

  var Delegation$1 = {};

  var __extends$k = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(Delegation$1, "__esModule", {
    value: true
  });
  Delegation$1.Delegation = void 0;
  var json_1$2 = json$1;
  var numeric_1$2 = numeric;
  var Coin_1$2 = Coin;
  /**
   * Stores information about the status of a delegation between a delegator and validator, fetched from the blockchain.
   */

  var Delegation =
  /** @class */
  function (_super) {
    __extends$k(Delegation, _super);
    /**
     * @param delegator_address 	delegator's account address
     * @param validator_address 	validator's operator address
     * @param shares 	delegator's shares
     * @param balance balance of the delegation
     */


    function Delegation(delegator_address, validator_address, shares, balance) {
      var _this = _super.call(this) || this;

      _this.delegator_address = delegator_address;
      _this.validator_address = validator_address;
      _this.shares = shares;
      _this.balance = balance;
      return _this;
    }

    Delegation.fromData = function (data) {
      var _a = data.delegation,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address,
          shares = _a.shares,
          balance = data.balance;
      return new Delegation(delegator_address, validator_address, new numeric_1$2.Dec(shares), Coin_1$2.Coin.fromData(balance));
    };

    Delegation.prototype.toData = function () {
      var _a = this,
          delegator_address = _a.delegator_address,
          validator_address = _a.validator_address,
          shares = _a.shares,
          balance = _a.balance;

      return {
        delegation: {
          delegator_address: delegator_address,
          validator_address: validator_address,
          shares: shares.toString()
        },
        balance: balance.toData()
      };
    };

    return Delegation;
  }(json_1$2.JSONSerializable);

  Delegation$1.Delegation = Delegation;

  var Redelegation = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Redelegation = void 0;
    var json_1 = json$1;
    var numeric_1 = numeric;
    /**
     * A redelegation is when a delegator decides to stop staking with one validator and
     * transfer their delegation to another validator. Rather than unbonding (which takes
     * some time) and re-staking, the funds can be redelegated immediately if a
     * [[Redelegation.Entry]] can be created.
     *
     * A redelegation, like an unbonding delegation, is implemented through
     * [[Redelegation.Entry]] objects, limited by the `max_entry` parameter in the staking
     * module params. For each pair of source and target validators, you cannot redelegate
     * more times than the amount of entries. Entries are cleared when the redelegation is
     * completed, the same amount of time as unbonding.
     */

    var Redelegation =
    /** @class */
    function (_super) {
      __extends(Redelegation, _super);
      /**
       *
       * @param delegator_address delegator's account address
       * @param validator_src_address source validator's operator address (from)
       * @param validator_dst_address target validator's operator address (to)
       * @param entries entries
       */


      function Redelegation(delegator_address, validator_src_address, validator_dst_address, entries) {
        var _this = _super.call(this) || this;

        _this.delegator_address = delegator_address;
        _this.validator_src_address = validator_src_address;
        _this.validator_dst_address = validator_dst_address;
        _this.entries = entries;
        return _this;
      }

      Redelegation.fromData = function (data) {
        var _a = data.redelegation,
            delegator_address = _a.delegator_address,
            validator_src_address = _a.validator_src_address,
            validator_dst_address = _a.validator_dst_address,
            entries = data.entries;
        return new Redelegation(delegator_address, validator_src_address, validator_dst_address, entries.map(function (e) {
          return Redelegation.Entry.fromData(e);
        }));
      };

      Redelegation.prototype.toData = function () {
        var _a = this,
            delegator_address = _a.delegator_address,
            validator_src_address = _a.validator_src_address,
            validator_dst_address = _a.validator_dst_address,
            entries = _a.entries;

        return {
          redelegation: {
            delegator_address: delegator_address,
            validator_src_address: validator_src_address,
            validator_dst_address: validator_dst_address
          },
          entries: entries.map(function (e) {
            return e.toData();
          })
        };
      };

      return Redelegation;
    }(json_1.JSONSerializable);

    exports.Redelegation = Redelegation;

    (function (Redelegation) {
      var Entry =
      /** @class */
      function (_super) {
        __extends(Entry, _super);
        /**
         *
         * @param initial_balance balance of delegation prior to initiating redelegation
         * @param balance 	balance of delegation after initiating redelegation
         * @param shares_dst
         * @param creation_height 	height of blockchain when entry was created
         * @param completion_time time when redelegation entry will be removed
         */


        function Entry(initial_balance, balance, shares_dst, creation_height, completion_time) {
          var _this = _super.call(this) || this;

          _this.initial_balance = initial_balance;
          _this.balance = balance;
          _this.shares_dst = shares_dst;
          _this.creation_height = creation_height;
          _this.completion_time = completion_time;
          return _this;
        }

        Entry.prototype.toData = function () {
          return {
            redelegation_entry: {
              initial_balance: this.initial_balance.toString(),
              shares_dst: this.shares_dst.toString(),
              creation_height: this.creation_height,
              completion_time: this.completion_time.toISOString()
            },
            balance: this.balance.toString()
          };
        };

        Entry.fromData = function (data) {
          var _a = data.redelegation_entry,
              initial_balance = _a.initial_balance,
              shares_dst = _a.shares_dst,
              creation_height = _a.creation_height,
              completion_time = _a.completion_time,
              balance = data.balance;
          return new Entry(new numeric_1.Int(initial_balance), new numeric_1.Int(balance), new numeric_1.Dec(shares_dst), creation_height, new Date(completion_time));
        };

        return Entry;
      }(json_1.JSONSerializable);

      Redelegation.Entry = Entry;
    })(Redelegation = exports.Redelegation || (exports.Redelegation = {}));

    exports.Redelegation = Redelegation;
  })(Redelegation);

  var UnbondingDelegation = {};

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UnbondingDelegation = void 0;
    var json_1 = json$1;
    var numeric_1 = numeric;
    /**
     * When a delegator decides to take out their funds from the staking pool, they must
     * unbond their tokens which takes an amount of time specified by `unbonding_time`
     * parameter in the staking module.
     *
     * An unbonding delegation is implemented through creating [[UnbondingDelegation.Entry]]
     * objects, limited by the max_entry parameter in the staking module params. You cannot
     * initiate unbonds more times than the amount of entries permitted. Entries are cleared
     * when their unbonding periods are completed and the funds are returned to the
     * delegator's account balance to be spent freely.
     */

    var UnbondingDelegation =
    /** @class */
    function (_super) {
      __extends(UnbondingDelegation, _super);

      function UnbondingDelegation(delegator_address, validator_address, entries) {
        var _this = _super.call(this) || this;

        _this.delegator_address = delegator_address;
        _this.validator_address = validator_address;
        _this.entries = entries;
        return _this;
      }

      UnbondingDelegation.fromData = function (data) {
        var delegator_address = data.delegator_address,
            validator_address = data.validator_address,
            entries = data.entries;
        return new UnbondingDelegation(delegator_address, validator_address, entries.map(function (e) {
          return UnbondingDelegation.Entry.fromData(e);
        }));
      };

      UnbondingDelegation.prototype.toData = function () {
        var _a = this,
            delegator_address = _a.delegator_address,
            validator_address = _a.validator_address,
            entries = _a.entries;

        return {
          delegator_address: delegator_address,
          validator_address: validator_address,
          entries: entries.map(function (e) {
            return e.toData();
          })
        };
      };

      return UnbondingDelegation;
    }(json_1.JSONSerializable);

    exports.UnbondingDelegation = UnbondingDelegation;

    (function (UnbondingDelegation) {
      var Entry =
      /** @class */
      function (_super) {
        __extends(Entry, _super);
        /**
         * Note that the size of the undelegation is `initial_balance - balance`
         * @param initial_balance balance of delegation prior to initiating unbond
         * @param balance balance of delegation after initiating unbond
         * @param creation_height height of blockchain when entry was created
         * @param completion_time time when unbonding will be completed
         */


        function Entry(initial_balance, balance, creation_height, completion_time) {
          var _this = _super.call(this) || this;

          _this.initial_balance = initial_balance;
          _this.balance = balance;
          _this.creation_height = creation_height;
          _this.completion_time = completion_time;
          return _this;
        }

        Entry.prototype.toData = function () {
          return {
            initial_balance: this.initial_balance.toString(),
            balance: this.balance.toString(),
            creation_height: this.creation_height.toFixed(),
            completion_time: this.completion_time.toISOString()
          };
        };

        Entry.fromData = function (data) {
          var initial_balance = data.initial_balance,
              balance = data.balance,
              creation_height = data.creation_height,
              completion_time = data.completion_time;
          return new Entry(new numeric_1.Int(initial_balance), new numeric_1.Int(balance), Number.parseInt(creation_height), new Date(completion_time));
        };

        return Entry;
      }(json_1.JSONSerializable);

      UnbondingDelegation.Entry = Entry;
    })(UnbondingDelegation = exports.UnbondingDelegation || (exports.UnbondingDelegation = {}));

    exports.UnbondingDelegation = UnbondingDelegation;
  })(UnbondingDelegation);

  var PolicyConstraints$1 = {};

  var __extends$j = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(PolicyConstraints$1, "__esModule", {
    value: true
  });
  PolicyConstraints$1.PolicyConstraints = void 0;
  var json_1$1 = json$1;
  var Coin_1$1 = Coin;
  var numeric_1$1 = numeric;
  /**
   * This captures the Treasury module's `tax_policy` and `reward_policy` parameters, which
   * determine how the Tax Rate and Reward Weight values are allowed to change.
   */

  var PolicyConstraints =
  /** @class */
  function (_super) {
    __extends$j(PolicyConstraints, _super);
    /**
     *
     * @param rate_min minimum value
     * @param rate_max maximum value
     * @param cap Tax Cap (only applicable for Tax Rate)
     * @param change_rate_max max change %
     */


    function PolicyConstraints(rate_min, rate_max, cap, change_rate_max) {
      var _this = _super.call(this) || this;

      _this.cap = cap;
      _this.rate_min = new numeric_1$1.Dec(rate_min);
      _this.rate_max = new numeric_1$1.Dec(rate_max);
      _this.change_rate_max = new numeric_1$1.Dec(change_rate_max);
      return _this;
    }

    PolicyConstraints.fromData = function (data) {
      var rate_min = data.rate_min,
          rate_max = data.rate_max,
          cap = data.cap,
          change_rate_max = data.change_rate_max;
      return new PolicyConstraints(rate_min, rate_max, Coin_1$1.Coin.fromData(cap), change_rate_max);
    };

    PolicyConstraints.prototype.toData = function () {
      var _a = this,
          rate_min = _a.rate_min,
          rate_max = _a.rate_max,
          cap = _a.cap,
          change_rate_max = _a.change_rate_max;

      return {
        rate_min: rate_min.toString(),
        rate_max: rate_max.toString(),
        cap: cap.toData(),
        change_rate_max: change_rate_max.toString()
      };
    };
    /**
     * You can simulate the result of the clamping algorithm, which subjects updates in
     * rate to the rules defined by the `PolicyConstraints`.
     *
     * @param prevRate previous rate
     * @param newRate next rate
     * @returns New rate, after clamping constraints have been applied
     */


    PolicyConstraints.prototype.clamp = function (prevRate, newRate) {
      var p = new numeric_1$1.Dec(prevRate); // prev

      var n = new numeric_1$1.Dec(newRate); // new

      if (n.lt(this.rate_min)) {
        n = this.rate_min;
      } else if (n.gt(this.rate_max)) {
        n = this.rate_max;
      }

      var delta = n.sub(p);

      if (n.gt(p)) {
        if (delta.gt(this.change_rate_max)) {
          n = p.add(this.change_rate_max);
        }
      } else {
        if (delta.abs().gt(this.change_rate_max)) {
          n = p.sub(this.change_rate_max);
        }
      }

      return n;
    };

    return PolicyConstraints;
  }(json_1$1.JSONSerializable);

  PolicyConstraints$1.PolicyConstraints = PolicyConstraints;

  var bech32 = {};

  var dist = {};

  Object.defineProperty(dist, "__esModule", {
    value: true
  });
  dist.bech32m = dist.bech32 = void 0;
  var ALPHABET$1 = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
  var ALPHABET_MAP = {};

  for (var z$1 = 0; z$1 < ALPHABET$1.length; z$1++) {
    var x$2 = ALPHABET$1.charAt(z$1);
    ALPHABET_MAP[x$2] = z$1;
  }

  function polymodStep(pre) {
    var b = pre >> 25;
    return (pre & 0x1ffffff) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
  }

  function prefixChk(prefix) {
    var chk = 1;

    for (var i = 0; i < prefix.length; ++i) {
      var c = prefix.charCodeAt(i);
      if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
      chk = polymodStep(chk) ^ c >> 5;
    }

    chk = polymodStep(chk);

    for (var _i = 0; _i < prefix.length; ++_i) {
      var v = prefix.charCodeAt(_i);
      chk = polymodStep(chk) ^ v & 0x1f;
    }

    return chk;
  }

  function convert(data, inBits, outBits, pad) {
    var value = 0;
    var bits = 0;
    var maxV = (1 << outBits) - 1;
    var result = [];

    for (var i = 0; i < data.length; ++i) {
      value = value << inBits | data[i];
      bits += inBits;

      while (bits >= outBits) {
        bits -= outBits;
        result.push(value >> bits & maxV);
      }
    }

    if (pad) {
      if (bits > 0) {
        result.push(value << outBits - bits & maxV);
      }
    } else {
      if (bits >= inBits) return 'Excess padding';
      if (value << outBits - bits & maxV) return 'Non-zero padding';
    }

    return result;
  }

  function toWords(bytes) {
    return convert(bytes, 8, 5, true);
  }

  function fromWordsUnsafe(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
  }

  function fromWords(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
    throw new Error(res);
  }

  function getLibraryFromEncoding(encoding) {
    var ENCODING_CONST;

    if (encoding === 'bech32') {
      ENCODING_CONST = 1;
    } else {
      ENCODING_CONST = 0x2bc830a3;
    }

    function encode(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
      prefix = prefix.toLowerCase(); // determine chk mod

      var chk = prefixChk(prefix);
      if (typeof chk === 'string') throw new Error(chk);
      var result = prefix + '1';

      for (var i = 0; i < words.length; ++i) {
        var _x = words[i];
        if (_x >> 5 !== 0) throw new Error('Non 5-bit word');
        chk = polymodStep(chk) ^ _x;
        result += ALPHABET$1.charAt(_x);
      }

      for (var _i2 = 0; _i2 < 6; ++_i2) {
        chk = polymodStep(chk);
      }

      chk ^= ENCODING_CONST;

      for (var _i3 = 0; _i3 < 6; ++_i3) {
        var v = chk >> (5 - _i3) * 5 & 0x1f;
        result += ALPHABET$1.charAt(v);
      }

      return result;
    }

    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8) return str + ' too short';
      if (str.length > LIMIT) return 'Exceeds length limit'; // don't allow mixed case

      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
      str = lowered;
      var split = str.lastIndexOf('1');
      if (split === -1) return 'No separator character for ' + str;
      if (split === 0) return 'Missing prefix for ' + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6) return 'Data too short';
      var chk = prefixChk(prefix);
      if (typeof chk === 'string') return chk;
      var words = [];

      for (var i = 0; i < wordChars.length; ++i) {
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === undefined) return 'Unknown character ' + c;
        chk = polymodStep(chk) ^ v; // not in the checksum?

        if (i + 6 >= wordChars.length) continue;
        words.push(v);
      }

      if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str;
      return {
        prefix: prefix,
        words: words
      };
    }

    function decodeUnsafe(str, LIMIT) {
      var res = __decode(str, LIMIT);

      if (typeof res === 'object') return res;
    }

    function decode(str, LIMIT) {
      var res = __decode(str, LIMIT);

      if (typeof res === 'object') return res;
      throw new Error(res);
    }

    return {
      decodeUnsafe: decodeUnsafe,
      decode: decode,
      encode: encode,
      toWords: toWords,
      fromWordsUnsafe: fromWordsUnsafe,
      fromWords: fromWords
    };
  }

  dist.bech32 = getLibraryFromEncoding('bech32');
  dist.bech32m = getLibraryFromEncoding('bech32m');

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ValConsPubKey = exports.ValConsAddress = exports.ValPubKey = exports.ValAddress = exports.AccPubKey = exports.AccAddress = void 0;
    var bech32_1 = dist;

    function checkPrefixAndLength(prefix, data, length) {
      try {
        var vals = bech32_1.bech32.decode(data);
        return vals.prefix === prefix && data.length == length;
      } catch (e) {
        return false;
      }
    }

    (function (AccAddress) {
      /**
       * Checks if a string is a valid Terra account address.
       *
       * @param data string to check
       */
      function validate(data) {
        return checkPrefixAndLength('terra', data, 44);
      }

      AccAddress.validate = validate;
      /**
       * Converts a validator address into an account address
       *
       * @param address validator address
       */

      function fromValAddress(address) {
        var vals = bech32_1.bech32.decode(address);
        return bech32_1.bech32.encode('terra', vals.words);
      }

      AccAddress.fromValAddress = fromValAddress;
    })(exports.AccAddress || (exports.AccAddress = {}));

    (function (AccPubKey) {
      /**
       * Checks if a string is a Terra account's public key
       * @param data string to check
       */
      function validate(data) {
        return checkPrefixAndLength('terrapub', data, 47);
      }

      AccPubKey.validate = validate;
      /**
       * Converts a Terra validator pubkey to an account pubkey.
       * @param address validator pubkey to convert
       */

      function fromAccAddress(address) {
        var vals = bech32_1.bech32.decode(address);
        return bech32_1.bech32.encode('terrapub', vals.words);
      }

      AccPubKey.fromAccAddress = fromAccAddress;
    })(exports.AccPubKey || (exports.AccPubKey = {}));

    (function (ValAddress) {
      /**
       * Checks if a string is a Terra validator address.
       *
       * @param data string to check
       */
      function validate(data) {
        return checkPrefixAndLength('terravaloper', data, 51);
      }

      ValAddress.validate = validate;
      /**
       * Converts a Terra account address to a validator address.
       * @param address account address to convert
       */

      function fromAccAddress(address) {
        var vals = bech32_1.bech32.decode(address);
        return bech32_1.bech32.encode('terravaloper', vals.words);
      }

      ValAddress.fromAccAddress = fromAccAddress;
    })(exports.ValAddress || (exports.ValAddress = {}));

    (function (ValPubKey) {
      /**
       * Checks if a string is a Terra validator pubkey
       * @param data string to check
       */
      function validate(data) {
        return checkPrefixAndLength('terravaloperpub', data, 54);
      }

      ValPubKey.validate = validate;
      /**
       * Converts a Terra validator operator address to a validator pubkey.
       * @param valAddress account pubkey
       */

      function fromValAddress(valAddress) {
        var vals = bech32_1.bech32.decode(valAddress);
        return bech32_1.bech32.encode('terravaloperpub', vals.words);
      }

      ValPubKey.fromValAddress = fromValAddress;
    })(exports.ValPubKey || (exports.ValPubKey = {}));

    (function (ValConsAddress) {
      /**
       * Checks if a string is a Terra validator consensus address
       * @param data string to check
       */
      function validate(data) {
        return checkPrefixAndLength('terravalcons', data, 51);
      }

      ValConsAddress.validate = validate;
    })(exports.ValConsAddress || (exports.ValConsAddress = {}));

    (function (ValConsPubKey) {
      /**
       * Checks if string is a valid Terra consensus (node) pubkey.
       * @param data string to check
       */
      function validate(data) {
        return data.type === 'tendermint/PubKeyEd25519' && typeof data.value === 'string';
      }

      ValConsPubKey.validate = validate;
    })(exports.ValConsPubKey || (exports.ValConsPubKey = {}));
  })(bech32);

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(Block, exports);

    __exportStar(Coin, exports);

    __exportStar(Coins$1, exports);

    __exportStar(Denom, exports);

    __exportStar(Msg, exports);

    __exportStar(numeric, exports);

    __exportStar(PublicKey$1, exports);

    __exportStar(StdFee$1, exports);

    __exportStar(StdSignature$1, exports);

    __exportStar(StdSignMsg$1, exports);

    __exportStar(StdTx$1, exports);

    __exportStar(TxInfo, exports);

    __exportStar(ValidatorSet, exports);

    __exportStar(Deposit$1, exports); // Auth


    __exportStar(Account$1, exports);

    __exportStar(LazyGradedVestingAccount, exports); // Bank


    __exportStar(msgs$8, exports); // Distribution


    __exportStar(msgs$7, exports);

    __exportStar(proposals$3, exports); // Governance


    __exportStar(msgs$6, exports);

    __exportStar(proposals$1, exports);

    __exportStar(Proposal, exports);

    __exportStar(Vote, exports); // Market


    __exportStar(msgs$5, exports); // MsgAuth


    __exportStar(msgs$4, exports);

    __exportStar(Authorization, exports); // Oracle


    __exportStar(msgs$3, exports);

    __exportStar(AggregateExchangeRatePrevote$1, exports);

    __exportStar(AggregateExchangeRateVote$1, exports); // Parameters


    __exportStar(proposals$2, exports);

    __exportStar(ParamChange$1, exports); // Slashing


    __exportStar(msgs$2, exports); // Staking


    __exportStar(msgs$1, exports);

    __exportStar(Delegation$1, exports);

    __exportStar(Redelegation, exports);

    __exportStar(UnbondingDelegation, exports);

    __exportStar(Validator, exports); // Treasury


    __exportStar(PolicyConstraints$1, exports); // WASM


    __exportStar(msgs, exports); // bech32 types


    __exportStar(bech32, exports);
  })(core);

  var key$2 = {};

  var Key$1 = {};

  var Hex$1 = {exports: {}};

  (function (module, exports) {
    !function (n, r) {
      module.exports = r();
    }(commonjsGlobal, function () {
      return function () {

        var n = {
          d: function d(r, t) {
            for (var e in t) {
              n.o(t, e) && !n.o(r, e) && Object.defineProperty(r, e, {
                enumerable: !0,
                get: t[e]
              });
            }
          }
        };
        n.g = function () {
          if ("object" == typeof globalThis) return globalThis;

          try {
            return this || new Function("return this")();
          } catch (n) {
            if ("object" == typeof window) return window;
          }
        }(), n.o = function (n, r) {
          return Object.prototype.hasOwnProperty.call(n, r);
        }, n.r = function (n) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, {
            value: "Module"
          }), Object.defineProperty(n, "t", {
            value: !0
          });
        };
        var r = {};
        n.r(r), n.d(r, {
          Hex: function Hex() {
            return f;
          }
        });
        var t,
            e = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
            i = (t = parseInt((/msie (\d+)/.exec(e) || [])[1], 10), isNaN(t) ? (t = parseInt((/trident\/.*; rv:(\d+)/.exec(e) || [])[1], 10), !isNaN(t) && t) : t);

        var o = function () {
          if ("undefined" != typeof window) {
            var r = window.crypto || window.msCrypto;

            if (!r) {
              if (function (n, r) {
                return !1 !== i && (!r || ("<" === n ? i < r : "<=" === n ? i <= r : ">" === n ? i > r : ">=" === n ? i >= r : i === r));
              }("<", 11)) return console.warn("IE <= 10 uses insecure random generator. Please consider to use IE11 or another modern browser"), function () {
                return Math.floor(512 * Math.random()) % 256;
              };
              throw new Error("Crypto module not found");
            }

            return function () {
              return r.getRandomValues(new Uint32Array(1))[0];
            };
          }

          return void 0 !== n.g && n.g.crypto ? function () {
            return n.g.crypto.randomBytes(4).readInt32LE();
          } : function () {
            return require$$0__default["default"].randomBytes(4).readInt32LE();
          };
        }(),
            a = function () {
          function n(r, t) {
            if (Array.isArray(r) || !r) return this.i = Array.isArray(r) ? r : [], void (this.u = "number" == typeof t ? t : 4 * this.i.length);
            if (r instanceof n) return this.i = r.words.slice(), void (this.u = r.nSigBytes);
            var e;

            try {
              r instanceof ArrayBuffer ? e = new Uint8Array(r) : (r instanceof Uint8Array || r instanceof Int8Array || r instanceof Uint8ClampedArray || r instanceof Int16Array || r instanceof Uint16Array || r instanceof Int32Array || r instanceof Uint32Array || r instanceof Float32Array || r instanceof Float64Array) && (e = new Uint8Array(r.buffer, r.byteOffset, r.byteLength));
            } catch (n) {
              throw new Error("Invalid argument");
            }

            if (!e) throw new Error("Invalid argument");

            for (var i = e.byteLength, o = [], a = 0; a < i; a++) {
              o[a >>> 2] |= e[a] << 24 - a % 4 * 8;
            }

            this.i = o, this.u = i;
          }

          return Object.defineProperty(n.prototype, "nSigBytes", {
            get: function get() {
              return this.u;
            },
            set: function set(n) {
              this.u = n;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(n.prototype, "words", {
            get: function get() {
              return this.i;
            },
            enumerable: !1,
            configurable: !0
          }), n.prototype.toString = function (n) {
            return n ? n.stringify(this) : f.stringify(this);
          }, n.prototype.toUint8Array = function () {
            for (var n = this.i, r = this.u, t = new Uint8Array(r), e = 0; e < r; e++) {
              t[e] = n[e >>> 2] >>> 24 - e % 4 * 8 & 255;
            }

            return t;
          }, n.prototype.concat = function (n) {
            var r = n.words.slice(),
                t = n.nSigBytes;
            if (this.clamp(), this.u % 4) for (var e = 0; e < t; e++) {
              var i = r[e >>> 2] >>> 24 - e % 4 * 8 & 255;
              this.i[this.u + e >>> 2] |= i << 24 - (this.u + e) % 4 * 8;
            } else for (e = 0; e < t; e += 4) {
              this.i[this.u + e >>> 2] = r[e >>> 2];
            }
            return this.u += t, this;
          }, n.prototype.clamp = function () {
            var n = this.u;
            this.i[n >>> 2] &= 4294967295 << 32 - n % 4 * 8, this.i.length = Math.ceil(n / 4);
          }, n.prototype.clone = function () {
            return new n(this.i.slice(), this.u);
          }, n.random = function (r) {
            for (var t = [], e = 0; e < r; e += 4) {
              t.push(o());
            }

            return new n(t, r);
          }, n;
        }(),
            f = {
          stringify: function stringify(n) {
            for (var r = n.nSigBytes, t = n.words, e = [], i = 0; i < r; i++) {
              var o = t[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              e.push((o >>> 4).toString(16)), e.push((15 & o).toString(16));
            }

            return e.join("");
          },
          parse: function parse(n) {
            var r = n.length;
            if (r % 2 != 0) throw new Error("Hex string count must be even");
            if (!/^[a-fA-F0-9]+$/.test(n)) throw new Error("Invalid Hex string: " + n);

            for (var t = [], e = 0; e < r; e += 2) {
              t[e >>> 3] |= parseInt(n.substr(e, 2), 16) << 24 - e % 8 * 4;
            }

            return new a(t, r / 2);
          }
        };

        return r;
      }();
    });
  })(Hex$1);

  var RIPEMD160$3 = {exports: {}};

  (function (module, exports) {
    !function (n, t) {
      module.exports = t();
    }(commonjsGlobal, function () {
      return function () {

        var n = {
          3354: function _(n, t, r) {
            r.d(t, {
              e: function e() {
                return o;
              }
            });

            var e = r(5720),
                i = r(9054),
                o = function () {
              function n(t, r) {
                if (Array.isArray(t) || !t) return this.t = Array.isArray(t) ? t : [], void (this.i = "number" == typeof r ? r : 4 * this.t.length);
                if (t instanceof n) return this.t = t.words.slice(), void (this.i = t.nSigBytes);
                var e;

                try {
                  t instanceof ArrayBuffer ? e = new Uint8Array(t) : (t instanceof Uint8Array || t instanceof Int8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array) && (e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength));
                } catch (n) {
                  throw new Error("Invalid argument");
                }

                if (!e) throw new Error("Invalid argument");

                for (var i = e.byteLength, o = [], u = 0; u < i; u++) {
                  o[u >>> 2] |= e[u] << 24 - u % 4 * 8;
                }

                this.t = o, this.i = i;
              }

              return Object.defineProperty(n.prototype, "nSigBytes", {
                get: function get() {
                  return this.i;
                },
                set: function set(n) {
                  this.i = n;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(n.prototype, "words", {
                get: function get() {
                  return this.t;
                },
                enumerable: !1,
                configurable: !0
              }), n.prototype.toString = function (n) {
                return n ? n.stringify(this) : e.p.stringify(this);
              }, n.prototype.toUint8Array = function () {
                for (var n = this.t, t = this.i, r = new Uint8Array(t), e = 0; e < t; e++) {
                  r[e] = n[e >>> 2] >>> 24 - e % 4 * 8 & 255;
                }

                return r;
              }, n.prototype.concat = function (n) {
                var t = n.words.slice(),
                    r = n.nSigBytes;
                if (this.clamp(), this.i % 4) for (var e = 0; e < r; e++) {
                  var i = t[e >>> 2] >>> 24 - e % 4 * 8 & 255;
                  this.t[this.i + e >>> 2] |= i << 24 - (this.i + e) % 4 * 8;
                } else for (e = 0; e < r; e += 4) {
                  this.t[this.i + e >>> 2] = t[e >>> 2];
                }
                return this.i += r, this;
              }, n.prototype.clamp = function () {
                var n = this.i;
                this.t[n >>> 2] &= 4294967295 << 32 - n % 4 * 8, this.t.length = Math.ceil(n / 4);
              }, n.prototype.clone = function () {
                return new n(this.t.slice(), this.i);
              }, n.random = function (t) {
                for (var r = [], e = 0; e < t; e += 4) {
                  r.push((0, i.M)());
                }

                return new n(r, t);
              }, n;
            }();
          },
          7211: function _(n, t, r) {
            r.d(t, {
              C: function C() {
                return o;
              }
            });

            var e = r(3354),
                i = r(4768),
                o = function () {
              function n(n) {
                this.u = 0, this.h = 0, this.v = n, this.l = n && void 0 !== n.data ? n.data.clone() : new e.e(), this.j = n && "number" == typeof n.nBytes ? n.nBytes : 0;
              }

              return Object.defineProperty(n.prototype, "blockSize", {
                get: function get() {
                  return this.h;
                },
                enumerable: !1,
                configurable: !0
              }), n.prototype.reset = function (n, t) {
                this.l = void 0 !== n ? n.clone() : new e.e(), this.j = "number" == typeof t ? t : 0;
              }, n.prototype.A = function (n) {
                var t = "string" == typeof n ? i.d.parse(n) : n;
                this.l.concat(t), this.j += t.nSigBytes;
              }, n.prototype.I = function (n) {
                var t,
                    r = this.l.words,
                    i = this.l.nSigBytes,
                    o = this.h,
                    u = i / (4 * this.h),
                    f = (u = n ? Math.ceil(u) : Math.max((0 | u) - this.u, 0)) * o,
                    c = Math.min(4 * f, i);

                if (f) {
                  for (var a = 0; a < f; a += o) {
                    this.O(r, a);
                  }

                  t = r.splice(0, f), this.l.nSigBytes -= c;
                }

                return new e.e(t, c);
              }, n.prototype.O = function (n, t) {
                throw new Error("Not implemented");
              }, n;
            }();
          },
          1868: function _(n, t, r) {
            r.d(t, {
              P: function P() {
                return u;
              }
            });

            var _e,
                i = r(7211),
                o = (_e = function e(n, t) {
              return (_e = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (n, t) {
                n.__proto__ = t;
              } || function (n, t) {
                for (var r in t) {
                  Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
              })(n, t);
            }, function (n, t) {
              function r() {
                this.constructor = n;
              }

              _e(n, t), n.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
            }),
                u = function (n) {
              function t(t) {
                var r = n.call(this, t) || this;
                return r.h = 16, r.v = t, t && "number" == typeof t.blockSize && (r.h = t.blockSize), r.reset(t ? t.data : void 0, t ? t.nBytes : void 0), r;
              }

              return o(t, n), Object.defineProperty(t.prototype, "blockSize", {
                get: function get() {
                  return this.h;
                },
                enumerable: !1,
                configurable: !0
              }), t.prototype.reset = function (t, r) {
                n.prototype.reset.call(this, t, r), this.U();
              }, t.prototype.update = function (n) {
                return this.A(n), this.I(), this;
              }, t.prototype.finalize = function (n) {
                return n && this.A(n), this._();
              }, t.prototype.U = function () {
                throw new Error("Not implemented");
              }, t.prototype._ = function () {
                throw new Error("Not implemented");
              }, t;
            }(i.C);
          },
          1756: function _(n, t, r) {
            r.d(t, {
              w: function w() {
                return u;
              }
            });
            var e,
                i = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
                o = (e = parseInt((/msie (\d+)/.exec(i) || [])[1], 10), isNaN(e) ? (e = parseInt((/trident\/.*; rv:(\d+)/.exec(i) || [])[1], 10), !isNaN(e) && e) : e);

            function u(n, t) {
              return !1 !== o && (!t || ("<" === n ? o < t : "<=" === n ? o <= t : ">" === n ? o > t : ">=" === n ? o >= t : o === t));
            }
          },
          5720: function _(n, t, r) {
            r.d(t, {
              p: function p() {
                return i;
              }
            });
            var e = r(3354),
                i = {
              stringify: function stringify(n) {
                for (var t = n.nSigBytes, r = n.words, e = [], i = 0; i < t; i++) {
                  var o = r[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                  e.push((o >>> 4).toString(16)), e.push((15 & o).toString(16));
                }

                return e.join("");
              },
              parse: function parse(n) {
                var t = n.length;
                if (t % 2 != 0) throw new Error("Hex string count must be even");
                if (!/^[a-fA-F0-9]+$/.test(n)) throw new Error("Invalid Hex string: " + n);

                for (var r = [], i = 0; i < t; i += 2) {
                  r[i >>> 3] |= parseInt(n.substr(i, 2), 16) << 24 - i % 8 * 4;
                }

                return new e.e(r, t / 2);
              }
            };
          },
          8702: function _(n, t, r) {
            r.d(t, {
              m: function m() {
                return i;
              }
            });
            var e = r(3354),
                i = {
              stringify: function stringify(n) {
                for (var t = n.nSigBytes, r = n.words, e = [], i = 0; i < t; i++) {
                  var o = r[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                  e.push(String.fromCharCode(o));
                }

                return e.join("");
              },
              parse: function parse(n) {
                for (var t = n.length, r = [], i = 0; i < t; i++) {
                  r[i >>> 2] |= (255 & n.charCodeAt(i)) << 24 - i % 4 * 8;
                }

                return new e.e(r, t);
              }
            };
          },
          4768: function _(n, t, r) {
            r.d(t, {
              d: function d() {
                return i;
              }
            });
            var e = r(8702),
                i = {
              stringify: function stringify(n) {
                try {
                  return decodeURIComponent(escape(e.m.stringify(n)));
                } catch (n) {
                  throw new Error("Malformed UTF-8 data");
                }
              },
              parse: function parse(n) {
                return e.m.parse(unescape(encodeURIComponent(n)));
              }
            };
          },
          9054: function _(n, t, r) {
            r.d(t, {
              M: function M() {
                return i;
              }
            });
            var e = r(1756);

            var i = function () {
              if ("undefined" != typeof window) {
                var n = window.crypto || window.msCrypto;

                if (!n) {
                  if ((0, e.w)("<", 11)) return console.warn("IE <= 10 uses insecure random generator. Please consider to use IE11 or another modern browser"), function () {
                    return Math.floor(512 * Math.random()) % 256;
                  };
                  throw new Error("Crypto module not found");
                }

                return function () {
                  return n.getRandomValues(new Uint32Array(1))[0];
                };
              }

              return void 0 !== r.g && r.g.crypto ? function () {
                return r.g.crypto.randomBytes(4).readInt32LE();
              } : function () {
                return require$$0__default["default"].randomBytes(4).readInt32LE();
              };
            }();
          }
        },
            t = {};

        function r(e) {
          var i = t[e];
          if (void 0 !== i) return i.exports;
          var o = t[e] = {
            exports: {}
          };
          return n[e](o, o.exports, r), o.exports;
        }

        r.d = function (n, t) {
          for (var e in t) {
            r.o(t, e) && !r.o(n, e) && Object.defineProperty(n, e, {
              enumerable: !0,
              get: t[e]
            });
          }
        }, r.g = function () {
          if ("object" == typeof globalThis) return globalThis;

          try {
            return this || new Function("return this")();
          } catch (n) {
            if ("object" == typeof window) return window;
          }
        }(), r.o = function (n, t) {
          return Object.prototype.hasOwnProperty.call(n, t);
        }, r.r = function (n) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, {
            value: "Module"
          }), Object.defineProperty(n, "S", {
            value: !0
          });
        };
        var e = {};
        return function () {
          r.r(e), r.d(e, {
            RIPEMD160: function RIPEMD160() {
              return p;
            }
          });

          var _n,
              t = r(1868),
              i = r(3354),
              o = (_n = function n(t, r) {
            return (_n = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (n, t) {
              n.__proto__ = t;
            } || function (n, t) {
              for (var r in t) {
                Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
              }
            })(t, r);
          }, function (t, r) {
            function e() {
              this.constructor = t;
            }

            _n(t, r), t.prototype = null === r ? Object.create(r) : (e.prototype = r.prototype, new e());
          }),
              u = new i.e([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
              f = new i.e([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
              c = new i.e([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
              a = new i.e([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
              s = new i.e([0, 1518500249, 1859775393, 2400959708, 2840853838]),
              h = new i.e([1352829926, 1548603684, 1836072691, 2053994217, 0]);

          function v(n, t, r) {
            return n ^ t ^ r;
          }

          function w(n, t, r) {
            return n & t | ~n & r;
          }

          function d(n, t, r) {
            return (n | ~t) ^ r;
          }

          function l(n, t, r) {
            return n & r | t & ~r;
          }

          function y(n, t, r) {
            return n ^ (t | ~r);
          }

          function b(n, t) {
            return n << t | n >>> 32 - t;
          }

          var p = function (n) {
            function t(t) {
              var r = n.call(this, t) || this;
              return r.N = new i.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), r.v = t, t && void 0 !== t.hash && (r.N = t.hash.clone()), r;
            }

            return o(t, n), t.prototype.U = function () {
              this.N = new i.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            }, t.prototype.O = function (n, t) {
              for (var r = 0; r < 16; r++) {
                var e = t + r,
                    i = n[e];
                n[e] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8);
              }

              var o,
                  p,
                  m,
                  g,
                  j,
                  A,
                  I,
                  O,
                  E,
                  M,
                  U,
                  _ = this.N.words,
                  S = s.words,
                  N = h.words,
                  x = u.words,
                  C = f.words,
                  F = c.words,
                  k = a.words;
              A = o = _[0], I = p = _[1], O = m = _[2], E = g = _[3], M = j = _[4];

              for (r = 0; r < 80; r += 1) {
                U = o + n[t + x[r]] | 0, U += r < 16 ? v(p, m, g) + S[0] : r < 32 ? w(p, m, g) + S[1] : r < 48 ? d(p, m, g) + S[2] : r < 64 ? l(p, m, g) + S[3] : y(p, m, g) + S[4], U = (U = b(U |= 0, F[r])) + j | 0, o = j, j = g, g = b(m, 10), m = p, p = U, U = A + n[t + C[r]] | 0, U += r < 16 ? y(I, O, E) + N[0] : r < 32 ? l(I, O, E) + N[1] : r < 48 ? d(I, O, E) + N[2] : r < 64 ? w(I, O, E) + N[3] : v(I, O, E) + N[4], U = (U = b(U |= 0, k[r])) + M | 0, A = M, M = E, E = b(O, 10), O = I, I = U;
              }

              U = _[1] + m + E | 0, _[1] = _[2] + g + M | 0, _[2] = _[3] + j + A | 0, _[3] = _[4] + o + I | 0, _[4] = _[0] + p + O | 0, _[0] = U;
            }, t.prototype._ = function () {
              var n = this.l,
                  t = n.words,
                  r = 8 * this.j,
                  e = 8 * n.nSigBytes;
              t[e >>> 5] |= 128 << 24 - e % 32, t[14 + (e + 64 >>> 9 << 4)] = 16711935 & (r << 8 | r >>> 24) | 4278255360 & (r << 24 | r >>> 8), n.nSigBytes = 4 * (t.length + 1), this.I();

              for (var i = this.N, o = i.words, u = 0; u < 5; u++) {
                var f = o[u];
                o[u] = 16711935 & (f << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8);
              }

              return i;
            }, t.prototype.clone = function () {
              return new t({
                hash: this.N,
                blockSize: this.h,
                data: this.l,
                nBytes: this.j
              });
            }, t.hash = function (n, r) {
              return new t(r).finalize(n);
            }, t;
          }(t.P);
        }(), e;
      }();
    });
  })(RIPEMD160$3);

  var __awaiter$n = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$k = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(Key$1, "__esModule", {
    value: true
  });
  Key$1.Key = Key$1.pubKeyFromPublicKey = Key$1.addressFromPublicKey = void 0;
  var bech32_1 = dist;
  var Hex_1 = Hex$1.exports;
  var RIPEMD160_1 = RIPEMD160$3.exports;
  var SHA256_1$2 = SHA256$2.exports;
  var StdSignature_1 = StdSignature$1;
  var StdTx_1 = StdTx$1;
  var BECH32_PUBKEY_DATA_PREFIX = 'eb5ae98721';
  /**
   * Gets a raw address from a compressed bytes public key.
   *
   * @param publicKey raw public key
   */

  function addressFromPublicKey(publicKey) {
    if (typeof publicKey !== 'object' || !(publicKey instanceof Buffer)) {
      throw new TypeError('parameter must be Buffer that contains public key');
    }

    var message = Hex_1.Hex.parse(publicKey.toString('hex'));
    var hash = RIPEMD160_1.RIPEMD160.hash(SHA256_1$2.SHA256.hash(message)).toString();
    var address = Buffer.from(hash, 'hex');
    return Buffer.from(bech32_1.bech32.toWords(address));
  }

  Key$1.addressFromPublicKey = addressFromPublicKey;
  /**
   * Gets a bech32-words pubkey from a compressed bytes public key.
   *
   * @param publicKey raw public key
   */

  function pubKeyFromPublicKey(publicKey) {
    var buffer = Buffer.from(BECH32_PUBKEY_DATA_PREFIX, 'hex');
    var combined = Buffer.concat([buffer, publicKey]);
    return Buffer.from(bech32_1.bech32.toWords(combined));
  }

  Key$1.pubKeyFromPublicKey = pubKeyFromPublicKey;
  /**
   * Abstract key interface that provides transaction signing features and Bech32 address
   * and public key derivation from a public key. This allows you to create custom key
   * solutions, such as for various hardware wallets, by implementing signing and calling
   * `super` with the raw public key from within your subclass. See [[MnemonicKey]] for
   * an implementation of a basic mnemonic-based key.
   */

  var Key =
  /** @class */
  function () {
    /**
     * Called to derive the relevant account and validator addresses and public keys from
     * the raw compressed public key in bytes.
     *
     * @param publicKey raw compressed bytes public key
     */
    function Key(publicKey) {
      this.publicKey = publicKey;

      if (publicKey) {
        this.rawAddress = addressFromPublicKey(publicKey);
        this.rawPubKey = pubKeyFromPublicKey(publicKey);
      }
    }

    Object.defineProperty(Key.prototype, "accAddress", {
      /**
       * Terra account address. `terra-` prefixed.
       */
      get: function get() {
        if (!this.rawAddress) {
          throw new Error('Could not compute accAddress: missing rawAddress');
        }

        return bech32_1.bech32.encode('terra', Array.from(this.rawAddress));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Key.prototype, "valAddress", {
      /**
       * Terra validator address. `terravaloper-` prefixed.
       */
      get: function get() {
        if (!this.rawAddress) {
          throw new Error('Could not compute valAddress: missing rawAddress');
        }

        return bech32_1.bech32.encode('terravaloper', Array.from(this.rawAddress));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Key.prototype, "accPubKey", {
      /**
       * Terra account public key. `terrapub-` prefixed.
       */
      get: function get() {
        if (!this.rawPubKey) {
          throw new Error('Could not compute accPubKey: missing rawPubKey');
        }

        return bech32_1.bech32.encode('terrapub', Array.from(this.rawPubKey));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Key.prototype, "valPubKey", {
      /**
       * Terra validator public key. `terravaloperpub-` prefixed.
       */
      get: function get() {
        if (!this.rawPubKey) {
          throw new Error('Could not compute valPubKey: missing rawPubKey');
        }

        return bech32_1.bech32.encode('terravaloperpub', Array.from(this.rawPubKey));
      },
      enumerable: false,
      configurable: true
    });
    /**
     * Signs a [[StdSignMsg]] with the method supplied by the child class.
     *
     * @param tx sign-message of the transaction to sign
     */

    Key.prototype.createSignature = function (tx) {
      return __awaiter$n(this, void 0, void 0, function () {
        var sigBuffer;
        return __generator$k(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.sign(Buffer.from(tx.toJSON()))];

            case 1:
              sigBuffer = _a.sent();

              if (!this.publicKey) {
                throw new Error('Signature could not be created: Key instance missing publicKey');
              }

              return [2
              /*return*/
              , StdSignature_1.StdSignature.fromData({
                signature: sigBuffer.toString('base64'),
                pub_key: {
                  type: 'tendermint/PubKeySecp256k1',
                  value: this.publicKey.toString('base64')
                }
              })];
          }
        });
      });
    };
    /**
     * Signs a [[StdSignMsg]] and adds the signature to a generated StdTx that is ready to be broadcasted.
     * @param tx
     */


    Key.prototype.signTx = function (tx) {
      return __awaiter$n(this, void 0, void 0, function () {
        var sig;
        return __generator$k(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.createSignature(tx)];

            case 1:
              sig = _a.sent();
              return [2
              /*return*/
              , new StdTx_1.StdTx(tx.msgs, tx.fee, [sig], tx.memo, tx.timeout_height)];
          }
        });
      });
    };

    return Key;
  }();

  Key$1.Key = Key;

  var MnemonicKey = {};

  var src$2 = {};

  function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$2(Constructor, staticProps);
    return Constructor;
  }

  var bip32 = {};

  var crypto$5 = {};

  var createHash$7 = require$$0__default["default"].createHash;

  var createHmac$2 = require$$0__default["default"].createHmac;

  Object.defineProperty(crypto$5, "__esModule", {
    value: true
  });
  var createHash$6 = createHash$7;
  var createHmac$1 = createHmac$2;

  function hash160(buffer) {
    var sha256Hash = createHash$6('sha256').update(buffer).digest();

    try {
      return createHash$6('rmd160').update(sha256Hash).digest();
    } catch (err) {
      return createHash$6('ripemd160').update(sha256Hash).digest();
    }
  }

  crypto$5.hash160 = hash160;

  function hmacSHA512(key, data) {
    return createHmac$1('sha512', key).update(data).digest();
  }

  crypto$5.hmacSHA512 = hmacSHA512;

  var safeBuffer = {exports: {}};

  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

  (function (module, exports) {
    /* eslint-disable node/no-deprecated-api */
    var buffer = require$$0__default$1["default"];
    var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }

    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      // Copy properties from require('buffer')
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }

    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length);
    }

    SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

    copyProps(Buffer, SafeBuffer);

    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
      }

      return Buffer(arg, encodingOrOffset, length);
    };

    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      var buf = Buffer(size);

      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }

      return buf;
    };

    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return Buffer(size);
    };

    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return buffer.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);

  // Copyright (c) 2018 base-x contributors
  // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
  // Distributed under the MIT software license, see the accompanying
  // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
  // @ts-ignore


  var _Buffer$1 = safeBuffer.exports.Buffer;

  function base$2(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError('Alphabet too long');
    }

    var BASE_MAP = new Uint8Array(256);

    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }

    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);

      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + ' is ambiguous');
      }

      BASE_MAP[xc] = i;
    }

    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up

    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up

    function encode(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer$1.from(source);
      }

      if (!_Buffer$1.isBuffer(source)) {
        throw new TypeError('Expected Buffer');
      }

      if (source.length === 0) {
        return '';
      } // Skip & count leading zeroes.


      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;

      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      } // Allocate enough space in big-endian base58 representation.


      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size); // Process the bytes.

      while (pbegin !== pend) {
        var carry = source[pbegin]; // Apply "b58 = b58 * 256 + ch".

        var i = 0;

        for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }

        if (carry !== 0) {
          throw new Error('Non-zero carry');
        }

        length = i;
        pbegin++;
      } // Skip leading zeroes in base58 result.


      var it2 = size - length;

      while (it2 !== size && b58[it2] === 0) {
        it2++;
      } // Translate the result into a string.


      var str = LEADER.repeat(zeroes);

      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }

      return str;
    }

    function decodeUnsafe(source) {
      if (typeof source !== 'string') {
        throw new TypeError('Expected String');
      }

      if (source.length === 0) {
        return _Buffer$1.alloc(0);
      }

      var psz = 0; // Skip and count leading '1's.

      var zeroes = 0;
      var length = 0;

      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      } // Allocate enough space in big-endian base256 representation.


      var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.

      var b256 = new Uint8Array(size); // Process the characters.

      while (source[psz]) {
        // Decode character
        var carry = BASE_MAP[source.charCodeAt(psz)]; // Invalid character

        if (carry === 255) {
          return;
        }

        var i = 0;

        for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }

        if (carry !== 0) {
          throw new Error('Non-zero carry');
        }

        length = i;
        psz++;
      } // Skip leading zeroes in b256.


      var it4 = size - length;

      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }

      var vch = _Buffer$1.allocUnsafe(zeroes + (size - it4));

      vch.fill(0x00, 0, zeroes);
      var j = zeroes;

      while (it4 !== size) {
        vch[j++] = b256[it4++];
      }

      return vch;
    }

    function decode(string) {
      var buffer = decodeUnsafe(string);

      if (buffer) {
        return buffer;
      }

      throw new Error('Non-base' + BASE + ' character');
    }

    return {
      encode: encode,
      decodeUnsafe: decodeUnsafe,
      decode: decode
    };
  }

  var src$1 = base$2;

  var basex = src$1;
  var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  var bs58 = basex(ALPHABET);

  var base58 = bs58;
  var Buffer$h = safeBuffer.exports.Buffer;

  var base$1 = function base(checksumFn) {
    // Encode a buffer as a base58-check encoded string
    function encode(payload) {
      var checksum = checksumFn(payload);
      return base58.encode(Buffer$h.concat([payload, checksum], payload.length + 4));
    }

    function decodeRaw(buffer) {
      var payload = buffer.slice(0, -4);
      var checksum = buffer.slice(-4);
      var newChecksum = checksumFn(payload);
      if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
      return payload;
    } // Decode a base58-check encoded string to a buffer, no result if checksum is wrong


    function decodeUnsafe(string) {
      var buffer = base58.decodeUnsafe(string);
      if (!buffer) return;
      return decodeRaw(buffer);
    }

    function decode(string) {
      var buffer = base58.decode(string);
      var payload = decodeRaw(buffer);
      if (!payload) throw new Error('Invalid checksum');
      return payload;
    }

    return {
      encode: encode,
      decode: decode,
      decodeUnsafe: decodeUnsafe
    };
  };

  var createHash$5 = createHash$7;
  var bs58checkBase = base$1; // SHA256(SHA256(buffer))

  function sha256x2(buffer) {
    var tmp = createHash$5('sha256').update(buffer).digest();
    return createHash$5('sha256').update(tmp).digest();
  }

  var bs58check$2 = bs58checkBase(sha256x2);

  var bn$1 = {exports: {}};

  (function (module) {
    (function (module, exports) {

      function assert(val, msg) {
        if (!val) throw new Error(msg || 'Assertion failed');
      } // Could use `inherits` module, but don't want to move from single file
      // architecture yet.


      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      } // BN


      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }

        this.negative = 0;
        this.words = null;
        this.length = 0; // Reduction context

        this.red = null;

        if (number !== null) {
          if (base === 'le' || base === 'be') {
            endian = base;
            base = 10;
          }

          this._init(number || 0, base || 10, endian || 'be');
        }
      }

      if (typeof module === 'object') {
        module.exports = BN;
      } else {
        exports.BN = BN;
      }

      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer;

      try {
        Buffer = require$$0__default$1["default"].Buffer;
      } catch (e) {}

      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }

        return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };

      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };

      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };

      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === 'number') {
          return this._initNumber(number, base, endian);
        }

        if (typeof number === 'object') {
          return this._initArray(number, base, endian);
        }

        if (base === 'hex') {
          base = 16;
        }

        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, '');
        var start = 0;

        if (number[0] === '-') {
          start++;
        }

        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }

        if (number[0] === '-') {
          this.negative = 1;
        }

        this.strip();
        if (endian !== 'le') return;

        this._initArray(this.toArray(), base, endian);
      };

      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }

        if (number < 0x4000000) {
          this.words = [number & 0x3ffffff];
          this.length = 1;
        } else if (number < 0x10000000000000) {
          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
          this.length = 2;
        } else {
          assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)

          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
          this.length = 3;
        }

        if (endian !== 'le') return; // Reverse the bytes

        this._initArray(this.toArray(), base, endian);
      };

      BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === 'number');

        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }

        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }

        var j, w;
        var off = 0;

        if (endian === 'be') {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === 'le') {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }

        return this.strip();
      };

      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);

        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4; // 'a' - 'f'

          if (c >= 49 && c <= 54) {
            r |= c - 49 + 0xa; // 'A' - 'F'
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 0xa; // '0' - '9'
          } else {
            r |= c & 0xf;
          }
        }

        return r;
      }

      BN.prototype._parseHex = function _parseHex(number, start) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }

        var j, w; // Scan 24-bit chunks and add them to the number

        var off = 0;

        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 0x3ffffff; // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb

          this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }

        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 0x3ffffff;
          this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
        }

        this.strip();
      };

      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);

        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul; // 'a'

          if (c >= 49) {
            r += c - 49 + 0xa; // 'A'
          } else if (c >= 17) {
            r += c - 17 + 0xa; // '0' - '9'
          } else {
            r += c;
          }
        }

        return r;
      }

      BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [0];
        this.length = 1; // Find length of limb in base

        for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
          limbLen++;
        }

        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;

        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);

          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }

        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);

          for (i = 0; i < mod; i++) {
            pow *= base;
          }

          this.imuln(pow);

          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };

      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }

        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };

      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };

      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }

        return this;
      }; // Remove leading `0` from `this`


      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }

        return this._normSign();
      };

      BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }

        return this;
      };

      BN.prototype.inspect = function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
      };
      /*
       var zeros = [];
      var groupSizes = [];
      var groupBases = [];
       var s = '';
      var i = -1;
      while (++i < BN.wordSize) {
        zeros[i] = s;
        s += '0';
      }
      groupSizes[0] = 0;
      groupSizes[1] = 0;
      groupBases[0] = 0;
      groupBases[1] = 0;
      var base = 2 - 1;
      while (++base < 36 + 1) {
        var groupSize = 0;
        var groupBase = 1;
        while (groupBase < (1 << BN.wordSize) / base) {
          groupBase *= base;
          groupSize += 1;
        }
        groupSizes[base] = groupSize;
        groupBases[base] = groupBase;
      }
       */


      var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
      var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
      var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;

        if (base === 16 || base === 'hex') {
          out = '';
          var off = 0;
          var carry = 0;

          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;

            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }

            off += 2;

            if (off >= 26) {
              off -= 26;
              i--;
            }
          }

          if (carry !== 0) {
            out = carry.toString(16) + out;
          }

          while (out.length % padding !== 0) {
            out = '0' + out;
          }

          if (this.negative !== 0) {
            out = '-' + out;
          }

          return out;
        }

        if (base === (base | 0) && base >= 2 && base <= 36) {
          // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
          var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

          var groupBase = groupBases[base];
          out = '';
          var c = this.clone();
          c.negative = 0;

          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);

            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }

          if (this.isZero()) {
            out = '0' + out;
          }

          while (out.length % padding !== 0) {
            out = '0' + out;
          }

          if (this.negative !== 0) {
            out = '-' + out;
          }

          return out;
        }

        assert(false, 'Base should be between 2 and 36');
      };

      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];

        if (this.length === 2) {
          ret += this.words[1] * 0x4000000;
        } else if (this.length === 3 && this.words[2] === 0x01) {
          // NOTE: at this stage it is known that the top bit is set
          ret += 0x10000000000000 + this.words[1] * 0x4000000;
        } else if (this.length > 2) {
          assert(false, 'Number can only safely store up to 53 bits');
        }

        return this.negative !== 0 ? -ret : ret;
      };

      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };

      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== 'undefined');
        return this.toArrayLike(Buffer, endian, length);
      };

      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };

      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, 'byte array longer than desired length');
        assert(reqLength > 0, 'Requested array length <= 0');
        this.strip();
        var littleEndian = endian === 'le';
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();

        if (!littleEndian) {
          // Assume big-endian
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }

          for (i = 0; !q.isZero(); i++) {
            b = q.andln(0xff);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(0xff);
            q.iushrn(8);
            res[i] = b;
          }

          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }

        return res;
      };

      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;

          if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
          }

          if (t >= 0x40) {
            r += 7;
            t >>>= 7;
          }

          if (t >= 0x8) {
            r += 4;
            t >>>= 4;
          }

          if (t >= 0x02) {
            r += 2;
            t >>>= 2;
          }

          return r + t;
        };
      }

      BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;

        if ((t & 0x1fff) === 0) {
          r += 13;
          t >>>= 13;
        }

        if ((t & 0x7f) === 0) {
          r += 7;
          t >>>= 7;
        }

        if ((t & 0xf) === 0) {
          r += 4;
          t >>>= 4;
        }

        if ((t & 0x3) === 0) {
          r += 2;
          t >>>= 2;
        }

        if ((t & 0x1) === 0) {
          r++;
        }

        return r;
      }; // Return number of used bits in a BN


      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];

        var hi = this._countBits(w);

        return (this.length - 1) * 26 + hi;
      };

      function toBitArray(num) {
        var w = new Array(num.bitLength());

        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }

        return w;
      } // Number of trailing zero bits


      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;

        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);

          r += b;
          if (b !== 26) break;
        }

        return r;
      };

      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };

      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }

        return this.clone();
      };

      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }

        return this.clone();
      };

      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }; // Return negative clone of `this`


      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };

      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }

        return this;
      }; // Or `num` with `this` in-place


      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }

        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }

        return this.strip();
      };

      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      }; // Or `num` with `this`


      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };

      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      }; // And `num` with `this` in-place


      BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;

        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }

        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }

        this.length = b.length;
        return this.strip();
      };

      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      }; // And `num` with `this`


      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };

      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      }; // Xor `num` with `this` in-place


      BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;

        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }

        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = a.length;
        return this.strip();
      };

      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      }; // Xor `num` with `this`


      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };

      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }; // Not ``this`` with ``width`` bitwidth


      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === 'number' && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26; // Extend the buffer with leading zeroes

        this._expand(bytesNeeded);

        if (bitsLeft > 0) {
          bytesNeeded--;
        } // Handle complete words


        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 0x3ffffff;
        } // Handle the residue


        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        } // And remove leading zeroes


        return this.strip();
      };

      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }; // Set `bit` of `this`


      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === 'number' && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;

        this._expand(off + 1);

        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }

        return this.strip();
      }; // Add `num` to `this` in-place


      BN.prototype.iadd = function iadd(num) {
        var r; // negative + positive

        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign(); // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        } // a.length > b.length


        var a, b;

        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        var carry = 0;

        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }

        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }

        this.length = a.length;

        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++; // Copy the rest of the words
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        return this;
      }; // Add `num` to `this`


      BN.prototype.add = function add(num) {
        var res;

        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }

        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      }; // Subtract `num` from `this` in-place


      BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign(); // -this - num = -(this + num)
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        } // At this point both numbers are positive


        var cmp = this.cmp(num); // Optimization - zeroify

        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        } // a > b


        var a, b;

        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        var carry = 0;

        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }

        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        } // Copy rest of the words


        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = Math.max(this.length, i);

        if (a !== this) {
          this.negative = 1;
        }

        return this.strip();
      }; // Subtract `num` from `this`


      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };

      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;

        for (var k = 1; k < len; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = carry >>> 26;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);

          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
          }

          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }

        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }

        return out.strip();
      } // TODO(indutny): it may be reasonable to omit it for users who don't need
      // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
      // multiplication (like elliptic secp256k1).


      var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */

        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */

        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */

        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */

        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */

        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */

        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */

        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */

        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */

        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */

        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */

        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */

        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */

        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */

        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */

        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */

        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */

        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */

        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */

        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;

        if (c !== 0) {
          o[19] = c;
          out.length++;
        }

        return out;
      }; // Polyfill comb


      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }

      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;

        for (var k = 0; k < out.length - 1; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);

          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
          }

          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }

        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }

        return out.strip();
      }

      function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
      }

      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;

        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }

        return res;
      }; // Cooley-Tukey algorithm for FFT
      // slightly revisited to rely on looping instead of recursion


      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }

      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;

        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }

        return t;
      }; // Returns binary-reversed representation of `x`


      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;

        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }

        return rb;
      }; // Performs "tweedling" phase, therefore 'emulating'
      // behaviour of the recursive algorithm


      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };

      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);

        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);

          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;

            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              /* jshint maxdepth : false */

              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };

      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;

        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }

        return 1 << i + 1 + odd;
      };

      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;

        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };

      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;

        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 0x3ffffff;

          if (w < 0x4000000) {
            carry = 0;
          } else {
            carry = w / 0x4000000 | 0;
          }
        }

        return ws;
      };

      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;

        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 0x1fff;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 0x1fff;
          carry = carry >>> 13;
        } // Pad with zeroes


        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }

        assert(carry === 0);
        assert((carry & ~0x1fff) === 0);
      };

      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);

        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }

        return ph;
      };

      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);

        var _ = this.stub(N);

        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);

        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }

        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      }; // Multiply `this` by `num`


      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      }; // Multiply employing FFT


      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      }; // In-place Multiplication


      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };

      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000); // Carry

        var carry = 0;

        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
          carry >>= 26;
          carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum

          carry += lo >>> 26;
          this.words[i] = lo & 0x3ffffff;
        }

        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }

        return this;
      };

      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }; // `this` * `this`


      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }; // `this` * `this` in-place


      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }; // Math.pow(`this`, `num`)


      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1); // Skip leading zeroes

        var res = this;

        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }

        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }

        return res;
      }; // Shift-left in-place


      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;

        if (r !== 0) {
          var carry = 0;

          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }

          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }

        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }

          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }

          this.length += s;
        }

        return this.strip();
      };

      BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
      }; // Shift-right in-place
      // NOTE: `hint` is a lowest bit before trailing zeroes
      // NOTE: if `extended` is present - it will be filled with destroyed bits


      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        var h;

        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }

        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h); // Extended mode, copy masked part

        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }

          maskedWords.length = s;
        }

        if (s === 0) ; else if (this.length > s) {
          this.length -= s;

          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }

        var carry = 0;

        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        } // Push carried bits as a mask


        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }

        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }

        return this.strip();
      };

      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      }; // Shift-left


      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };

      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }; // Shift-right


      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };

      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }; // Test if n bit is set


      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r; // Fast case: bit is much higher than all existing words

        if (this.length <= s) return false; // Check bit and return

        var w = this.words[s];
        return !!(w & q);
      }; // Return only lowers bits of number (in-place)


      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, 'imaskn works only with positive numbers');

        if (this.length <= s) {
          return this;
        }

        if (r !== 0) {
          s++;
        }

        this.length = Math.min(s, this.length);

        if (r !== 0) {
          var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
          this.words[this.length - 1] &= mask;
        }

        return this.strip();
      }; // Return only lowers bits of number


      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }; // Add plain number `num` to `this`


      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num); // Possible sign change

        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }

          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        } // Add without checks


        return this._iaddn(num);
      };

      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num; // Carry

        for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
          this.words[i] -= 0x4000000;

          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }

        this.length = Math.max(this.length, i + 1);
        return this;
      }; // Subtract plain number `num` from `this`


      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);

        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }

        this.words[0] -= num;

        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          // Carry
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
          }
        }

        return this.strip();
      };

      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };

      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };

      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };

      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };

      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;

        this._expand(len);

        var w;
        var carry = 0;

        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 0x3ffffff;
          carry = (w >> 26) - (right / 0x4000000 | 0);
          this.words[i + shift] = w & 0x3ffffff;
        }

        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 0x3ffffff;
        }

        if (carry === 0) return this.strip(); // Subtraction overflow

        assert(carry === -1);
        carry = 0;

        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 0x3ffffff;
        }

        this.negative = 1;
        return this.strip();
      };

      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num; // Normalize

        var bhi = b.words[b.length - 1] | 0;

        var bhiBits = this._countBits(bhi);

        shift = 26 - bhiBits;

        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        } // Initialize quotient


        var m = a.length - b.length;
        var q;

        if (mode !== 'mod') {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);

          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }

        var diff = a.clone()._ishlnsubmul(b, 1, m);

        if (diff.negative === 0) {
          a = diff;

          if (q) {
            q.words[m] = 1;
          }
        }

        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
          // (0x7ffffff)

          qj = Math.min(qj / bhi | 0, 0x3ffffff);

          a._ishlnsubmul(b, qj, j);

          while (a.negative !== 0) {
            qj--;
            a.negative = 0;

            a._ishlnsubmul(b, 1, j);

            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }

          if (q) {
            q.words[j] = qj;
          }
        }

        if (q) {
          q.strip();
        }

        a.strip(); // Denormalize

        if (mode !== 'div' && shift !== 0) {
          a.iushrn(shift);
        }

        return {
          div: q || null,
          mod: a
        };
      }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
      //       to `div` to request div only, or be absent to
      //       request both div & mod
      //       2) `positive` is true if unsigned mod is requested


      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());

        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }

        var div, mod, res;

        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);

          if (mode !== 'mod') {
            div = res.div.neg();
          }

          if (mode !== 'div') {
            mod = res.mod.neg();

            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }

          return {
            div: div,
            mod: mod
          };
        }

        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);

          if (mode !== 'mod') {
            div = res.div.neg();
          }

          return {
            div: div,
            mod: res.mod
          };
        }

        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);

          if (mode !== 'div') {
            mod = res.mod.neg();

            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }

          return {
            div: res.div,
            mod: mod
          };
        } // Both numbers are positive at this point
        // Strip both numbers to approximate shift value


        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        } // Very short reduction


        if (num.length === 1) {
          if (mode === 'div') {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }

          if (mode === 'mod') {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }

          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }

        return this._wordDiv(num, mode);
      }; // Find `this` / `num`


      BN.prototype.div = function div(num) {
        return this.divmod(num, 'div', false).div;
      }; // Find `this` % `num`


      BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod', false).mod;
      };

      BN.prototype.umod = function umod(num) {
        return this.divmod(num, 'mod', true).mod;
      }; // Find Round(`this` / `num`)


      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num); // Fast case - exact division

        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half); // Round down

        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };

      BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;
        var acc = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }

        return acc;
      }; // In-place division by number


      BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 0x4000000;
          this.words[i] = w / num | 0;
          carry = w % num;
        }

        return this.strip();
      };

      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };

      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();

        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        } // A * x + B * y = x


        var A = new BN(1);
        var B = new BN(0); // C * x + D * y = y

        var C = new BN(0);
        var D = new BN(1);
        var g = 0;

        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }

        var yp = y.clone();
        var xp = x.clone();

        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
          }

          if (i > 0) {
            x.iushrn(i);

            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }

              A.iushrn(1);
              B.iushrn(1);
            }
          }

          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
          }

          if (j > 0) {
            y.iushrn(j);

            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }

              C.iushrn(1);
              D.iushrn(1);
            }
          }

          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }

        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      }; // This is reduced incarnation of the binary EEA
      // above, designated to invert members of the
      // _prime_ fields F(p) at a maximal speed


      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();

        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }

        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();

        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
          }

          if (i > 0) {
            a.iushrn(i);

            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }

              x1.iushrn(1);
            }
          }

          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
          }

          if (j > 0) {
            b.iushrn(j);

            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }

              x2.iushrn(1);
            }
          }

          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }

        var res;

        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }

        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }

        return res;
      };

      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0; // Remove common factor of two

        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }

        do {
          while (a.isEven()) {
            a.iushrn(1);
          }

          while (b.isEven()) {
            b.iushrn(1);
          }

          var r = a.cmp(b);

          if (r < 0) {
            // Swap `a` and `b` to make `a` always bigger than `b`
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }

          a.isub(b);
        } while (true);

        return b.iushln(shift);
      }; // Invert number in the field F(num)


      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };

      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };

      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }; // And first word and num


      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }; // Increment at the bit position in-line


      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r; // Fast case: bit is much higher than all existing words

        if (this.length <= s) {
          this._expand(s + 1);

          this.words[s] |= q;
          return this;
        } // Add bit and propagate, if needed


        var carry = q;

        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 0x3ffffff;
          this.words[i] = w;
        }

        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }

        return this;
      };

      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };

      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;

        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }

          assert(num <= 0x3ffffff, 'Number is too big');
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }

        if (this.negative !== 0) return -res | 0;
        return res;
      }; // Compare two numbers and return:
      // 1 - if `this` > `num`
      // 0 - if `this` == `num`
      // -1 - if `this` < `num`


      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      }; // Unsigned comparison


      BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;

          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }

          break;
        }

        return res;
      };

      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };

      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };

      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };

      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };

      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };

      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };

      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };

      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };

      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };

      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }; //
      // A reduce context, could be using montgomery or something better, depending
      // on the `m` itself.
      //


      BN.red = function red(num) {
        return new Red(num);
      };

      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(this.negative === 0, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
      };

      BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
      };

      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };

      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
      };

      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
      };

      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
      };

      BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
      };

      BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
      };

      BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
      };

      BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');

        this.red._verify2(this, num);

        return this.red.mul(this, num);
      };

      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');

        this.red._verify2(this, num);

        return this.red.imul(this, num);
      };

      BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');

        this.red._verify1(this);

        return this.red.sqr(this);
      };

      BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');

        this.red._verify1(this);

        return this.red.isqr(this);
      }; // Square root over p


      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');

        this.red._verify1(this);

        return this.red.sqrt(this);
      };

      BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');

        this.red._verify1(this);

        return this.red.invm(this);
      }; // Return negative clone of `this` % `red modulo`


      BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');

        this.red._verify1(this);

        return this.red.neg(this);
      };

      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');

        this.red._verify1(this);

        return this.red.pow(this, num);
      }; // Prime numbers with efficient reduction


      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      }; // Pseudo-Mersenne prime

      function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }

      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };

      MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;

        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);

        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);

        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }

        return r;
      };

      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };

      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };

      function K256() {
        MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
      }

      inherits(K256, MPrime);

      K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);

        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }

        output.length = outLen;

        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        } // Shift by 9 limbs


        var prev = input.words[9];
        output.words[output.length++] = prev & mask;

        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }

        prev >>>= 22;
        input.words[i - 10] = prev;

        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };

      K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

        var lo = 0;

        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 0x3d1;
          num.words[i] = lo & 0x3ffffff;
          lo = w * 0x40 + (lo / 0x4000000 | 0);
        } // Fast length reduction


        if (num.words[num.length - 1] === 0) {
          num.length--;

          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }

        return num;
      };

      function P224() {
        MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
      }

      inherits(P224, MPrime);

      function P192() {
        MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
      }

      inherits(P192, MPrime);

      function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
      }

      inherits(P25519, MPrime);

      P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;

        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 0x13 + carry;
          var lo = hi & 0x3ffffff;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }

        if (carry !== 0) {
          num.words[num.length++] = carry;
        }

        return num;
      }; // Exported mostly for testing purposes, use plain name instead


      BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;

        if (name === 'k256') {
          prime = new K256();
        } else if (name === 'p224') {
          prime = new P224();
        } else if (name === 'p192') {
          prime = new P192();
        } else if (name === 'p25519') {
          prime = new P25519();
        } else {
          throw new Error('Unknown prime ' + name);
        }

        primes[name] = prime;
        return prime;
      }; //
      // Base reduction engine
      //


      function Red(m) {
        if (typeof m === 'string') {
          var prime = BN._prime(m);

          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), 'modulus must be greater than 1');
          this.m = m;
          this.prime = null;
        }
      }

      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
      };

      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, 'red works only with positives');
        assert(a.red && a.red === b.red, 'red works only with red numbers');
      };

      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };

      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }

        return this.m.sub(a)._forceRed(this);
      };

      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);

        var res = a.add(b);

        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }

        return res._forceRed(this);
      };

      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);

        var res = a.iadd(b);

        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }

        return res;
      };

      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);

        var res = a.sub(b);

        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);

        var res = a.isub(b);

        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }

        return res;
      };

      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);

        return this.imod(a.ushln(num));
      };

      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);

        return this.imod(a.imul(b));
      };

      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);

        return this.imod(a.mul(b));
      };

      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };

      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };

      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1); // Fast case

        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)


        var q = this.m.subn(1);
        var s = 0;

        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }

        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg(); // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.

        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);

        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }

        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;

        while (t.cmp(one) !== 0) {
          var tmp = t;

          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }

          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }

        return r;
      };

      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);

        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };

      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;

        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }

        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;

        if (start === 0) {
          start = 26;
        }

        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];

          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;

            if (res !== wnd[0]) {
              res = this.sqr(res);
            }

            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }

            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }

          start = 26;
        }

        return res;
      };

      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };

      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }; //
      // Montgomery method engine
      //


      BN.mont = function mont(num) {
        return new Mont(num);
      };

      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();

        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }

        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }

      inherits(Mont, Red);

      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };

      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };

      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }

        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;

        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;

        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, commonjsGlobal);
  })(bn$1);

  var elliptic$2 = {};

  var name$1 = "elliptic";
  var version$1 = "6.5.4";
  var description$1 = "EC cryptography";
  var main$1 = "lib/elliptic.js";
  var files = ["lib"];
  var scripts$1 = {
    lint: "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    unit: "istanbul test _mocha --reporter=spec test/index.js",
    test: "npm run lint && npm run unit",
    version: "grunt dist && git add dist/"
  };
  var repository$1 = {
    type: "git",
    url: "git@github.com:indutny/elliptic"
  };
  var keywords$1 = ["EC", "Elliptic", "curve", "Cryptography"];
  var author$1 = "Fedor Indutny <fedor@indutny.com>";
  var license$1 = "MIT";
  var bugs$1 = {
    url: "https://github.com/indutny/elliptic/issues"
  };
  var homepage$1 = "https://github.com/indutny/elliptic";
  var devDependencies$1 = {
    brfs: "^2.0.2",
    coveralls: "^3.1.0",
    eslint: "^7.6.0",
    grunt: "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    istanbul: "^0.4.5",
    mocha: "^8.0.1"
  };
  var dependencies$1 = {
    "bn.js": "^4.11.9",
    brorand: "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    inherits: "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  };
  var require$$0$3 = {
    name: name$1,
    version: version$1,
    description: description$1,
    main: main$1,
    files: files,
    scripts: scripts$1,
    repository: repository$1,
    keywords: keywords$1,
    author: author$1,
    license: license$1,
    bugs: bugs$1,
    homepage: homepage$1,
    devDependencies: devDependencies$1,
    dependencies: dependencies$1
  };

  var utils$A = {};

  var bn = {exports: {}};

  (function (module) {
    (function (module, exports) {

      function assert(val, msg) {
        if (!val) throw new Error(msg || 'Assertion failed');
      } // Could use `inherits` module, but don't want to move from single file
      // architecture yet.


      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      } // BN


      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }

        this.negative = 0;
        this.words = null;
        this.length = 0; // Reduction context

        this.red = null;

        if (number !== null) {
          if (base === 'le' || base === 'be') {
            endian = base;
            base = 10;
          }

          this._init(number || 0, base || 10, endian || 'be');
        }
      }

      if (typeof module === 'object') {
        module.exports = BN;
      } else {
        exports.BN = BN;
      }

      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer;

      try {
        if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
          Buffer = window.Buffer;
        } else {
          Buffer = require$$0__default$1["default"].Buffer;
        }
      } catch (e) {}

      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }

        return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };

      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };

      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };

      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === 'number') {
          return this._initNumber(number, base, endian);
        }

        if (typeof number === 'object') {
          return this._initArray(number, base, endian);
        }

        if (base === 'hex') {
          base = 16;
        }

        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, '');
        var start = 0;

        if (number[0] === '-') {
          start++;
          this.negative = 1;
        }

        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);

            if (endian === 'le') {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };

      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }

        if (number < 0x4000000) {
          this.words = [number & 0x3ffffff];
          this.length = 1;
        } else if (number < 0x10000000000000) {
          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
          this.length = 2;
        } else {
          assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)

          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
          this.length = 3;
        }

        if (endian !== 'le') return; // Reverse the bytes

        this._initArray(this.toArray(), base, endian);
      };

      BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === 'number');

        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }

        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }

        var j, w;
        var off = 0;

        if (endian === 'be') {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === 'le') {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }

        return this.strip();
      };

      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index); // 'A' - 'F'

        if (c >= 65 && c <= 70) {
          return c - 55; // 'a' - 'f'
        } else if (c >= 97 && c <= 102) {
          return c - 87; // '0' - '9'
        } else {
          return c - 48 & 0xf;
        }
      }

      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);

        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }

        return r;
      }

      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        } // 24-bits chunks


        var off = 0;
        var j = 0;
        var w;

        if (endian === 'be') {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;

            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;

          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;

            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }

        this.strip();
      };

      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);

        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul; // 'a'

          if (c >= 49) {
            r += c - 49 + 0xa; // 'A'
          } else if (c >= 17) {
            r += c - 17 + 0xa; // '0' - '9'
          } else {
            r += c;
          }
        }

        return r;
      }

      BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [0];
        this.length = 1; // Find length of limb in base

        for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
          limbLen++;
        }

        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;

        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);

          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }

        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);

          for (i = 0; i < mod; i++) {
            pow *= base;
          }

          this.imuln(pow);

          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }

        this.strip();
      };

      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }

        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };

      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };

      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }

        return this;
      }; // Remove leading `0` from `this`


      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }

        return this._normSign();
      };

      BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }

        return this;
      };

      BN.prototype.inspect = function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
      };
      /*
       var zeros = [];
      var groupSizes = [];
      var groupBases = [];
       var s = '';
      var i = -1;
      while (++i < BN.wordSize) {
        zeros[i] = s;
        s += '0';
      }
      groupSizes[0] = 0;
      groupSizes[1] = 0;
      groupBases[0] = 0;
      groupBases[1] = 0;
      var base = 2 - 1;
      while (++base < 36 + 1) {
        var groupSize = 0;
        var groupBase = 1;
        while (groupBase < (1 << BN.wordSize) / base) {
          groupBase *= base;
          groupSize += 1;
        }
        groupSizes[base] = groupSize;
        groupBases[base] = groupBase;
      }
       */


      var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
      var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
      var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;

        if (base === 16 || base === 'hex') {
          out = '';
          var off = 0;
          var carry = 0;

          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;

            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }

            off += 2;

            if (off >= 26) {
              off -= 26;
              i--;
            }
          }

          if (carry !== 0) {
            out = carry.toString(16) + out;
          }

          while (out.length % padding !== 0) {
            out = '0' + out;
          }

          if (this.negative !== 0) {
            out = '-' + out;
          }

          return out;
        }

        if (base === (base | 0) && base >= 2 && base <= 36) {
          // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
          var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

          var groupBase = groupBases[base];
          out = '';
          var c = this.clone();
          c.negative = 0;

          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);

            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }

          if (this.isZero()) {
            out = '0' + out;
          }

          while (out.length % padding !== 0) {
            out = '0' + out;
          }

          if (this.negative !== 0) {
            out = '-' + out;
          }

          return out;
        }

        assert(false, 'Base should be between 2 and 36');
      };

      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];

        if (this.length === 2) {
          ret += this.words[1] * 0x4000000;
        } else if (this.length === 3 && this.words[2] === 0x01) {
          // NOTE: at this stage it is known that the top bit is set
          ret += 0x10000000000000 + this.words[1] * 0x4000000;
        } else if (this.length > 2) {
          assert(false, 'Number can only safely store up to 53 bits');
        }

        return this.negative !== 0 ? -ret : ret;
      };

      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };

      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== 'undefined');
        return this.toArrayLike(Buffer, endian, length);
      };

      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };

      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, 'byte array longer than desired length');
        assert(reqLength > 0, 'Requested array length <= 0');
        this.strip();
        var littleEndian = endian === 'le';
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();

        if (!littleEndian) {
          // Assume big-endian
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }

          for (i = 0; !q.isZero(); i++) {
            b = q.andln(0xff);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(0xff);
            q.iushrn(8);
            res[i] = b;
          }

          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }

        return res;
      };

      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;

          if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
          }

          if (t >= 0x40) {
            r += 7;
            t >>>= 7;
          }

          if (t >= 0x8) {
            r += 4;
            t >>>= 4;
          }

          if (t >= 0x02) {
            r += 2;
            t >>>= 2;
          }

          return r + t;
        };
      }

      BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;

        if ((t & 0x1fff) === 0) {
          r += 13;
          t >>>= 13;
        }

        if ((t & 0x7f) === 0) {
          r += 7;
          t >>>= 7;
        }

        if ((t & 0xf) === 0) {
          r += 4;
          t >>>= 4;
        }

        if ((t & 0x3) === 0) {
          r += 2;
          t >>>= 2;
        }

        if ((t & 0x1) === 0) {
          r++;
        }

        return r;
      }; // Return number of used bits in a BN


      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];

        var hi = this._countBits(w);

        return (this.length - 1) * 26 + hi;
      };

      function toBitArray(num) {
        var w = new Array(num.bitLength());

        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }

        return w;
      } // Number of trailing zero bits


      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;

        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);

          r += b;
          if (b !== 26) break;
        }

        return r;
      };

      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };

      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }

        return this.clone();
      };

      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }

        return this.clone();
      };

      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }; // Return negative clone of `this`


      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };

      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }

        return this;
      }; // Or `num` with `this` in-place


      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }

        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }

        return this.strip();
      };

      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      }; // Or `num` with `this`


      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };

      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      }; // And `num` with `this` in-place


      BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;

        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }

        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }

        this.length = b.length;
        return this.strip();
      };

      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      }; // And `num` with `this`


      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };

      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      }; // Xor `num` with `this` in-place


      BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;

        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }

        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = a.length;
        return this.strip();
      };

      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      }; // Xor `num` with `this`


      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };

      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }; // Not ``this`` with ``width`` bitwidth


      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === 'number' && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26; // Extend the buffer with leading zeroes

        this._expand(bytesNeeded);

        if (bitsLeft > 0) {
          bytesNeeded--;
        } // Handle complete words


        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 0x3ffffff;
        } // Handle the residue


        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        } // And remove leading zeroes


        return this.strip();
      };

      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }; // Set `bit` of `this`


      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === 'number' && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;

        this._expand(off + 1);

        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }

        return this.strip();
      }; // Add `num` to `this` in-place


      BN.prototype.iadd = function iadd(num) {
        var r; // negative + positive

        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign(); // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        } // a.length > b.length


        var a, b;

        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        var carry = 0;

        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }

        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }

        this.length = a.length;

        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++; // Copy the rest of the words
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        return this;
      }; // Add `num` to `this`


      BN.prototype.add = function add(num) {
        var res;

        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }

        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      }; // Subtract `num` from `this` in-place


      BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign(); // -this - num = -(this + num)
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        } // At this point both numbers are positive


        var cmp = this.cmp(num); // Optimization - zeroify

        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        } // a > b


        var a, b;

        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        var carry = 0;

        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }

        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        } // Copy rest of the words


        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = Math.max(this.length, i);

        if (a !== this) {
          this.negative = 1;
        }

        return this.strip();
      }; // Subtract `num` from `this`


      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };

      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;

        for (var k = 1; k < len; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = carry >>> 26;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);

          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
          }

          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }

        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }

        return out.strip();
      } // TODO(indutny): it may be reasonable to omit it for users who don't need
      // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
      // multiplication (like elliptic secp256k1).


      var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */

        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */

        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */

        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */

        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */

        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */

        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */

        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */

        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */

        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */

        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */

        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */

        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */

        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */

        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */

        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */

        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */

        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */

        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */

        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;

        if (c !== 0) {
          o[19] = c;
          out.length++;
        }

        return out;
      }; // Polyfill comb


      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }

      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;

        for (var k = 0; k < out.length - 1; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);

          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
          }

          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }

        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }

        return out.strip();
      }

      function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
      }

      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;

        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }

        return res;
      }; // Cooley-Tukey algorithm for FFT
      // slightly revisited to rely on looping instead of recursion


      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }

      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;

        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }

        return t;
      }; // Returns binary-reversed representation of `x`


      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;

        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }

        return rb;
      }; // Performs "tweedling" phase, therefore 'emulating'
      // behaviour of the recursive algorithm


      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };

      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);

        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);

          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;

            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              /* jshint maxdepth : false */

              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };

      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;

        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }

        return 1 << i + 1 + odd;
      };

      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;

        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };

      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;

        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 0x3ffffff;

          if (w < 0x4000000) {
            carry = 0;
          } else {
            carry = w / 0x4000000 | 0;
          }
        }

        return ws;
      };

      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;

        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 0x1fff;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 0x1fff;
          carry = carry >>> 13;
        } // Pad with zeroes


        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }

        assert(carry === 0);
        assert((carry & ~0x1fff) === 0);
      };

      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);

        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }

        return ph;
      };

      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);

        var _ = this.stub(N);

        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);

        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }

        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      }; // Multiply `this` by `num`


      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      }; // Multiply employing FFT


      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      }; // In-place Multiplication


      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };

      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000); // Carry

        var carry = 0;

        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
          carry >>= 26;
          carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum

          carry += lo >>> 26;
          this.words[i] = lo & 0x3ffffff;
        }

        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }

        return this;
      };

      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }; // `this` * `this`


      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }; // `this` * `this` in-place


      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }; // Math.pow(`this`, `num`)


      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1); // Skip leading zeroes

        var res = this;

        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }

        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }

        return res;
      }; // Shift-left in-place


      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;

        if (r !== 0) {
          var carry = 0;

          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }

          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }

        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }

          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }

          this.length += s;
        }

        return this.strip();
      };

      BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
      }; // Shift-right in-place
      // NOTE: `hint` is a lowest bit before trailing zeroes
      // NOTE: if `extended` is present - it will be filled with destroyed bits


      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        var h;

        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }

        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h); // Extended mode, copy masked part

        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }

          maskedWords.length = s;
        }

        if (s === 0) ; else if (this.length > s) {
          this.length -= s;

          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }

        var carry = 0;

        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        } // Push carried bits as a mask


        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }

        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }

        return this.strip();
      };

      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      }; // Shift-left


      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };

      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }; // Shift-right


      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };

      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }; // Test if n bit is set


      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r; // Fast case: bit is much higher than all existing words

        if (this.length <= s) return false; // Check bit and return

        var w = this.words[s];
        return !!(w & q);
      }; // Return only lowers bits of number (in-place)


      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, 'imaskn works only with positive numbers');

        if (this.length <= s) {
          return this;
        }

        if (r !== 0) {
          s++;
        }

        this.length = Math.min(s, this.length);

        if (r !== 0) {
          var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
          this.words[this.length - 1] &= mask;
        }

        return this.strip();
      }; // Return only lowers bits of number


      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }; // Add plain number `num` to `this`


      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num); // Possible sign change

        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }

          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        } // Add without checks


        return this._iaddn(num);
      };

      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num; // Carry

        for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
          this.words[i] -= 0x4000000;

          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }

        this.length = Math.max(this.length, i + 1);
        return this;
      }; // Subtract plain number `num` from `this`


      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);

        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }

        this.words[0] -= num;

        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          // Carry
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
          }
        }

        return this.strip();
      };

      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };

      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };

      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };

      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };

      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;

        this._expand(len);

        var w;
        var carry = 0;

        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 0x3ffffff;
          carry = (w >> 26) - (right / 0x4000000 | 0);
          this.words[i + shift] = w & 0x3ffffff;
        }

        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 0x3ffffff;
        }

        if (carry === 0) return this.strip(); // Subtraction overflow

        assert(carry === -1);
        carry = 0;

        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 0x3ffffff;
        }

        this.negative = 1;
        return this.strip();
      };

      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num; // Normalize

        var bhi = b.words[b.length - 1] | 0;

        var bhiBits = this._countBits(bhi);

        shift = 26 - bhiBits;

        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        } // Initialize quotient


        var m = a.length - b.length;
        var q;

        if (mode !== 'mod') {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);

          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }

        var diff = a.clone()._ishlnsubmul(b, 1, m);

        if (diff.negative === 0) {
          a = diff;

          if (q) {
            q.words[m] = 1;
          }
        }

        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
          // (0x7ffffff)

          qj = Math.min(qj / bhi | 0, 0x3ffffff);

          a._ishlnsubmul(b, qj, j);

          while (a.negative !== 0) {
            qj--;
            a.negative = 0;

            a._ishlnsubmul(b, 1, j);

            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }

          if (q) {
            q.words[j] = qj;
          }
        }

        if (q) {
          q.strip();
        }

        a.strip(); // Denormalize

        if (mode !== 'div' && shift !== 0) {
          a.iushrn(shift);
        }

        return {
          div: q || null,
          mod: a
        };
      }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
      //       to `div` to request div only, or be absent to
      //       request both div & mod
      //       2) `positive` is true if unsigned mod is requested


      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());

        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }

        var div, mod, res;

        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);

          if (mode !== 'mod') {
            div = res.div.neg();
          }

          if (mode !== 'div') {
            mod = res.mod.neg();

            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }

          return {
            div: div,
            mod: mod
          };
        }

        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);

          if (mode !== 'mod') {
            div = res.div.neg();
          }

          return {
            div: div,
            mod: res.mod
          };
        }

        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);

          if (mode !== 'div') {
            mod = res.mod.neg();

            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }

          return {
            div: res.div,
            mod: mod
          };
        } // Both numbers are positive at this point
        // Strip both numbers to approximate shift value


        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        } // Very short reduction


        if (num.length === 1) {
          if (mode === 'div') {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }

          if (mode === 'mod') {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }

          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }

        return this._wordDiv(num, mode);
      }; // Find `this` / `num`


      BN.prototype.div = function div(num) {
        return this.divmod(num, 'div', false).div;
      }; // Find `this` % `num`


      BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod', false).mod;
      };

      BN.prototype.umod = function umod(num) {
        return this.divmod(num, 'mod', true).mod;
      }; // Find Round(`this` / `num`)


      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num); // Fast case - exact division

        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half); // Round down

        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };

      BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;
        var acc = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }

        return acc;
      }; // In-place division by number


      BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 0x4000000;
          this.words[i] = w / num | 0;
          carry = w % num;
        }

        return this.strip();
      };

      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };

      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();

        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        } // A * x + B * y = x


        var A = new BN(1);
        var B = new BN(0); // C * x + D * y = y

        var C = new BN(0);
        var D = new BN(1);
        var g = 0;

        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }

        var yp = y.clone();
        var xp = x.clone();

        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
          }

          if (i > 0) {
            x.iushrn(i);

            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }

              A.iushrn(1);
              B.iushrn(1);
            }
          }

          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
          }

          if (j > 0) {
            y.iushrn(j);

            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }

              C.iushrn(1);
              D.iushrn(1);
            }
          }

          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }

        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      }; // This is reduced incarnation of the binary EEA
      // above, designated to invert members of the
      // _prime_ fields F(p) at a maximal speed


      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();

        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }

        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();

        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
          }

          if (i > 0) {
            a.iushrn(i);

            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }

              x1.iushrn(1);
            }
          }

          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
          }

          if (j > 0) {
            b.iushrn(j);

            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }

              x2.iushrn(1);
            }
          }

          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }

        var res;

        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }

        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }

        return res;
      };

      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0; // Remove common factor of two

        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }

        do {
          while (a.isEven()) {
            a.iushrn(1);
          }

          while (b.isEven()) {
            b.iushrn(1);
          }

          var r = a.cmp(b);

          if (r < 0) {
            // Swap `a` and `b` to make `a` always bigger than `b`
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }

          a.isub(b);
        } while (true);

        return b.iushln(shift);
      }; // Invert number in the field F(num)


      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };

      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };

      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }; // And first word and num


      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }; // Increment at the bit position in-line


      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r; // Fast case: bit is much higher than all existing words

        if (this.length <= s) {
          this._expand(s + 1);

          this.words[s] |= q;
          return this;
        } // Add bit and propagate, if needed


        var carry = q;

        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 0x3ffffff;
          this.words[i] = w;
        }

        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }

        return this;
      };

      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };

      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;

        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }

          assert(num <= 0x3ffffff, 'Number is too big');
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }

        if (this.negative !== 0) return -res | 0;
        return res;
      }; // Compare two numbers and return:
      // 1 - if `this` > `num`
      // 0 - if `this` == `num`
      // -1 - if `this` < `num`


      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      }; // Unsigned comparison


      BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;

          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }

          break;
        }

        return res;
      };

      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };

      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };

      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };

      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };

      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };

      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };

      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };

      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };

      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };

      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }; //
      // A reduce context, could be using montgomery or something better, depending
      // on the `m` itself.
      //


      BN.red = function red(num) {
        return new Red(num);
      };

      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(this.negative === 0, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
      };

      BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
      };

      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };

      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
      };

      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
      };

      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
      };

      BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
      };

      BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
      };

      BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
      };

      BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');

        this.red._verify2(this, num);

        return this.red.mul(this, num);
      };

      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');

        this.red._verify2(this, num);

        return this.red.imul(this, num);
      };

      BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');

        this.red._verify1(this);

        return this.red.sqr(this);
      };

      BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');

        this.red._verify1(this);

        return this.red.isqr(this);
      }; // Square root over p


      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');

        this.red._verify1(this);

        return this.red.sqrt(this);
      };

      BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');

        this.red._verify1(this);

        return this.red.invm(this);
      }; // Return negative clone of `this` % `red modulo`


      BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');

        this.red._verify1(this);

        return this.red.neg(this);
      };

      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');

        this.red._verify1(this);

        return this.red.pow(this, num);
      }; // Prime numbers with efficient reduction


      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      }; // Pseudo-Mersenne prime

      function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }

      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };

      MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;

        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);

        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);

        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== undefined) {
            // r is BN v4 instance
            r.strip();
          } else {
            // r is BN v5 instance
            r._strip();
          }
        }

        return r;
      };

      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };

      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };

      function K256() {
        MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
      }

      inherits(K256, MPrime);

      K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);

        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }

        output.length = outLen;

        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        } // Shift by 9 limbs


        var prev = input.words[9];
        output.words[output.length++] = prev & mask;

        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }

        prev >>>= 22;
        input.words[i - 10] = prev;

        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };

      K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

        var lo = 0;

        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 0x3d1;
          num.words[i] = lo & 0x3ffffff;
          lo = w * 0x40 + (lo / 0x4000000 | 0);
        } // Fast length reduction


        if (num.words[num.length - 1] === 0) {
          num.length--;

          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }

        return num;
      };

      function P224() {
        MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
      }

      inherits(P224, MPrime);

      function P192() {
        MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
      }

      inherits(P192, MPrime);

      function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
      }

      inherits(P25519, MPrime);

      P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;

        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 0x13 + carry;
          var lo = hi & 0x3ffffff;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }

        if (carry !== 0) {
          num.words[num.length++] = carry;
        }

        return num;
      }; // Exported mostly for testing purposes, use plain name instead


      BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;

        if (name === 'k256') {
          prime = new K256();
        } else if (name === 'p224') {
          prime = new P224();
        } else if (name === 'p192') {
          prime = new P192();
        } else if (name === 'p25519') {
          prime = new P25519();
        } else {
          throw new Error('Unknown prime ' + name);
        }

        primes[name] = prime;
        return prime;
      }; //
      // Base reduction engine
      //


      function Red(m) {
        if (typeof m === 'string') {
          var prime = BN._prime(m);

          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), 'modulus must be greater than 1');
          this.m = m;
          this.prime = null;
        }
      }

      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
      };

      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, 'red works only with positives');
        assert(a.red && a.red === b.red, 'red works only with red numbers');
      };

      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };

      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }

        return this.m.sub(a)._forceRed(this);
      };

      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);

        var res = a.add(b);

        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }

        return res._forceRed(this);
      };

      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);

        var res = a.iadd(b);

        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }

        return res;
      };

      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);

        var res = a.sub(b);

        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);

        var res = a.isub(b);

        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }

        return res;
      };

      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);

        return this.imod(a.ushln(num));
      };

      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);

        return this.imod(a.imul(b));
      };

      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);

        return this.imod(a.mul(b));
      };

      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };

      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };

      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1); // Fast case

        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)


        var q = this.m.subn(1);
        var s = 0;

        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }

        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg(); // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.

        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);

        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }

        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;

        while (t.cmp(one) !== 0) {
          var tmp = t;

          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }

          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }

        return r;
      };

      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);

        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };

      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;

        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }

        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;

        if (start === 0) {
          start = 26;
        }

        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];

          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;

            if (res !== wnd[0]) {
              res = this.sqr(res);
            }

            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }

            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }

          start = 26;
        }

        return res;
      };

      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };

      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }; //
      // Montgomery method engine
      //


      BN.mont = function mont(num) {
        return new Mont(num);
      };

      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();

        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }

        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }

      inherits(Mont, Red);

      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };

      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };

      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }

        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;

        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;

        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, commonjsGlobal);
  })(bn);

  var minimalisticAssert = assert$i;

  function assert$i(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  assert$i.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
  };

  var utils$z = {};

  (function (exports) {

    var utils = exports;

    function toArray(msg, enc) {
      if (Array.isArray(msg)) return msg.slice();
      if (!msg) return [];
      var res = [];

      if (typeof msg !== 'string') {
        for (var i = 0; i < msg.length; i++) {
          res[i] = msg[i] | 0;
        }

        return res;
      }

      if (enc === 'hex') {
        msg = msg.replace(/[^a-z0-9]+/ig, '');
        if (msg.length % 2 !== 0) msg = '0' + msg;

        for (var i = 0; i < msg.length; i += 2) {
          res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 0xff;
          if (hi) res.push(hi, lo);else res.push(lo);
        }
      }

      return res;
    }

    utils.toArray = toArray;

    function zero2(word) {
      if (word.length === 1) return '0' + word;else return word;
    }

    utils.zero2 = zero2;

    function toHex(msg) {
      var res = '';

      for (var i = 0; i < msg.length; i++) {
        res += zero2(msg[i].toString(16));
      }

      return res;
    }

    utils.toHex = toHex;

    utils.encode = function encode(arr, enc) {
      if (enc === 'hex') return toHex(arr);else return arr;
    };
  })(utils$z);

  (function (exports) {

    var utils = exports;
    var BN = bn.exports;
    var minAssert = minimalisticAssert;
    var minUtils = utils$z;
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode; // Represent num in a w-NAF form

    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w + 1;
      var k = num.clone();

      for (var i = 0; i < naf.length; i++) {
        var z;
        var mod = k.andln(ws - 1);

        if (k.isOdd()) {
          if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;else z = mod;
          k.isubn(z);
        } else {
          z = 0;
        }

        naf[i] = z;
        k.iushrn(1);
      }

      return naf;
    }

    utils.getNAF = getNAF; // Represent k1, k2 in a Joint Sparse Form

    function getJSF(k1, k2) {
      var jsf = [[], []];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;

      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        // First phase
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3) m14 = -1;
        if (m24 === 3) m24 = -1;
        var u1;

        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
        }

        jsf[0].push(u1);
        var u2;

        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;
        }

        jsf[1].push(u2); // Second phase

        if (2 * d1 === u1 + 1) d1 = 1 - d1;
        if (2 * d2 === u2 + 1) d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }

      return jsf;
    }

    utils.getJSF = getJSF;

    function cachedProperty(obj, name, computer) {
      var key = '_' + name;

      obj.prototype[name] = function cachedProperty() {
        return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
      };
    }

    utils.cachedProperty = cachedProperty;

    function parseBytes(bytes) {
      return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
    }

    utils.parseBytes = parseBytes;

    function intFromLE(bytes) {
      return new BN(bytes, 'hex', 'le');
    }

    utils.intFromLE = intFromLE;
  })(utils$A);

  var brorand = {exports: {}};

  var r$1;

  brorand.exports = function rand(len) {
    if (!r$1) r$1 = new Rand(null);
    return r$1.generate(len);
  };

  function Rand(rand) {
    this.rand = rand;
  }

  brorand.exports.Rand = Rand;

  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  }; // Emulate crypto API using randy


  Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes) return this.rand.getBytes(n);
    var res = new Uint8Array(n);

    for (var i = 0; i < res.length; i++) {
      res[i] = this.rand.getByte();
    }

    return res;
  };

  if (typeof self === 'object') {
    if (self.crypto && self.crypto.getRandomValues) {
      // Modern browsers
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      // IE
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
      }; // Safari's WebWorkers do not have `crypto`

    } else if (typeof window === 'object') {
      // Old junk
      Rand.prototype._rand = function () {
        throw new Error('Not implemented yet');
      };
    }
  } else {
    // Node.js or Web worker with no crypto support
    try {
      var crypto$4 = require$$0__default["default"];
      if (typeof crypto$4.randomBytes !== 'function') throw new Error('Not supported');

      Rand.prototype._rand = function _rand(n) {
        return crypto$4.randomBytes(n);
      };
    } catch (e) {}
  }

  var curve = {};

  var BN$9 = bn.exports;
  var utils$y = utils$A;
  var getNAF = utils$y.getNAF;
  var getJSF = utils$y.getJSF;
  var assert$h = utils$y.assert;

  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN$9(conf.p, 16); // Use Montgomery, when there is no fast reduction for the prime

    this.red = conf.prime ? BN$9.red(conf.prime) : BN$9.mont(this.p); // Useful for many curves

    this.zero = new BN$9(0).toRed(this.red);
    this.one = new BN$9(1).toRed(this.red);
    this.two = new BN$9(2).toRed(this.red); // Curve configuration, optional

    this.n = conf.n && new BN$9(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed); // Temporary arrays

    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0; // Generalized Greg Maxwell's trick

    var adjustCount = this.n && this.p.div(this.n);

    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }

  var base = BaseCurve;

  BaseCurve.prototype.point = function point() {
    throw new Error('Not implemented');
  };

  BaseCurve.prototype.validate = function validate() {
    throw new Error('Not implemented');
  };

  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert$h(p.precomputed);

    var doubles = p._getDoubles();

    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3; // Translate into more windowed form

    var repr = [];
    var j;
    var nafW;

    for (j = 0; j < naf.length; j += doubles.step) {
      nafW = 0;

      for (var l = j + doubles.step - 1; l >= j; l--) {
        nafW = (nafW << 1) + naf[l];
      }

      repr.push(nafW);
    }

    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);

    for (var i = I; i > 0; i--) {
      for (j = 0; j < repr.length; j++) {
        nafW = repr[j];
        if (nafW === i) b = b.mixedAdd(doubles.points[j]);else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
      }

      a = a.add(b);
    }

    return a.toP();
  };

  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4; // Precompute window

    var nafPoints = p._getNAFPoints(w);

    w = nafPoints.wnd;
    var wnd = nafPoints.points; // Get NAF form

    var naf = getNAF(k, w, this._bitLength); // Add `this`*(N+1) for every w-NAF index

    var acc = this.jpoint(null, null, null);

    for (var i = naf.length - 1; i >= 0; i--) {
      // Count zeroes
      for (var l = 0; i >= 0 && naf[i] === 0; i--) {
        l++;
      }

      if (i >= 0) l++;
      acc = acc.dblp(l);
      if (i < 0) break;
      var z = naf[i];
      assert$h(z !== 0);

      if (p.type === 'affine') {
        // J +- P
        if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
      } else {
        // J +- J
        if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);else acc = acc.add(wnd[-z - 1 >> 1].neg());
      }
    }

    return p.type === 'affine' ? acc.toP() : acc;
  };

  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3; // Fill all arrays

    var max = 0;
    var i;
    var j;
    var p;

    for (i = 0; i < len; i++) {
      p = points[i];

      var nafPoints = p._getNAFPoints(defW);

      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    } // Comb small window NAFs


    for (i = len - 1; i >= 1; i -= 2) {
      var a = i - 1;
      var b = i;

      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }

      var comb = [points[a],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b]
      /* 7 */
      ]; // Try to avoid Projective points, if possible

      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }

      var index = [-3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
      ];
      var jsf = getJSF(coeffs[a], coeffs[b]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);

      for (j = 0; j < max; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }

    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;

    for (i = max; i >= 0; i--) {
      var k = 0;

      while (i >= 0) {
        var zero = true;

        for (j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0) zero = false;
        }

        if (!zero) break;
        k++;
        i--;
      }

      if (i >= 0) k++;
      acc = acc.dblp(k);
      if (i < 0) break;

      for (j = 0; j < len; j++) {
        var z = tmp[j];
        if (z === 0) continue;else if (z > 0) p = wnd[j][z - 1 >> 1];else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
        if (p.type === 'affine') acc = acc.mixedAdd(p);else acc = acc.add(p);
      }
    } // Zeroify references


    for (i = 0; i < len; i++) {
      wnd[i] = null;
    }

    if (jacobianResult) return acc;else return acc.toP();
  };

  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }

  BaseCurve.BasePoint = BasePoint;

  BasePoint.prototype.eq = function eq() {
    throw new Error('Not implemented');
  };

  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };

  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils$y.toArray(bytes, enc);
    var len = this.p.byteLength(); // uncompressed, hybrid-odd, hybrid-even

    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
      if (bytes[0] === 0x06) assert$h(bytes[bytes.length - 1] % 2 === 0);else if (bytes[0] === 0x07) assert$h(bytes[bytes.length - 1] % 2 === 1);
      var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
      return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    }

    throw new Error('Unknown point format');
  };

  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };

  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray('be', len);
    if (compact) return [this.getY().isEven() ? 0x02 : 0x03].concat(x);
    return [0x04].concat(x, this.getY().toArray('be', len));
  };

  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils$y.encode(this._encode(compact), enc);
  };

  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed) return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };

  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed) return false;
    var doubles = this.precomputed.doubles;
    if (!doubles) return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };

  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;

    for (var i = 0; i < power; i += step) {
      for (var j = 0; j < step; j++) {
        acc = acc.dbl();
      }

      doubles.push(acc);
    }

    return {
      step: step,
      points: doubles
    };
  };

  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    var res = [this];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();

    for (var i = 1; i < max; i++) {
      res[i] = res[i - 1].add(dbl);
    }

    return {
      wnd: wnd,
      points: res
    };
  };

  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };

  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;

    for (var i = 0; i < k; i++) {
      r = r.dbl();
    }

    return r;
  };

  var inherits$d = {exports: {}};

  var inherits_browser = {exports: {}};

  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }

  try {
    var util$3 = require$$0__default$2["default"];
    /* istanbul ignore next */

    if (typeof util$3.inherits !== 'function') throw '';
    inherits$d.exports = util$3.inherits;
  } catch (e) {
    /* istanbul ignore next */
    inherits$d.exports = inherits_browser.exports;
  }

  var utils$x = utils$A;
  var BN$8 = bn.exports;
  var inherits$c = inherits$d.exports;
  var Base$2 = base;
  var assert$g = utils$x.assert;

  function ShortCurve(conf) {
    Base$2.call(this, 'short', conf);
    this.a = new BN$8(conf.a, 16).toRed(this.red);
    this.b = new BN$8(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0; // If the curve is endomorphic, precalculate beta and lambda

    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }

  inherits$c(ShortCurve, Base$2);
  var short = ShortCurve;

  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    // No efficient endomorphism
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return; // Compute beta and lambda, that lambda * P = (beta * Px; Py)

    var beta;
    var lambda;

    if (conf.beta) {
      beta = new BN$8(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p); // Choose the smallest beta


      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }

    if (conf.lambda) {
      lambda = new BN$8(conf.lambda, 16);
    } else {
      // Choose the lambda that is matching selected beta
      var lambdas = this._getEndoRoots(this.n);

      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert$g(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    } // Get basis vectors, used for balanced length-two representation


    var basis;

    if (conf.basis) {
      basis = conf.basis.map(function (vec) {
        return {
          a: new BN$8(vec.a, 16),
          b: new BN$8(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }

    return {
      beta: beta,
      lambda: lambda,
      basis: basis
    };
  };

  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    // Find roots of for x^2 + x + 1 in F
    // Root = (-1 +- Sqrt(-3)) / 2
    //
    var red = num === this.p ? this.red : BN$8.mont(num);
    var tinv = new BN$8(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN$8(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [l1, l2];
  };

  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    // aprxSqrt >= sqrt(this.n)
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)); // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt

    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN$8(1);
    var y1 = new BN$8(0);
    var x2 = new BN$8(0);
    var y2 = new BN$8(1); // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)

    var a0;
    var b0; // First vector

    var a1;
    var b1; // Second vector

    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;

    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));

      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }

      prevR = r;
      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }

    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());

    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    } // Normalize signs


    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }

    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }

    return [{
      a: a1,
      b: b1
    }, {
      a: a2,
      b: b2
    }];
  };

  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b); // Calculate answer

    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
      k1: k1,
      k2: k2
    };
  };

  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN$8(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point'); // XXX Is there any way to tell if the number is odd without converting it
    // to non-red form?

    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
  };

  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf) return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };

  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;

    for (var i = 0; i < points.length; i++) {
      var split = this._endoSplit(coeffs[i]);

      var p = points[i];

      var beta = p._getBeta();

      if (split.k1.negative) {
        split.k1.ineg();
        p = p.neg(true);
      }

      if (split.k2.negative) {
        split.k2.ineg();
        beta = beta.neg(true);
      }

      npoints[i * 2] = p;
      npoints[i * 2 + 1] = beta;
      ncoeffs[i * 2] = split.k1;
      ncoeffs[i * 2 + 1] = split.k2;
    }

    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult); // Clean-up references to points and coefficients


    for (var j = 0; j < i * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }

    return res;
  };

  function Point$2(curve, x, y, isRed) {
    Base$2.BasePoint.call(this, curve, 'affine');

    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN$8(x, 16);
      this.y = new BN$8(y, 16); // Force redgomery representation when loading from JSON

      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }

      if (!this.x.red) this.x = this.x.toRed(this.curve.red);
      if (!this.y.red) this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }

  inherits$c(Point$2, Base$2.BasePoint);

  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point$2(this, x, y, isRed);
  };

  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point$2.fromJSON(this, obj, red);
  };

  Point$2.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo) return;
    var pre = this.precomputed;
    if (pre && pre.beta) return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);

    if (pre) {
      var curve = this.curve;

      var endoMul = function endoMul(p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };

      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }

    return beta;
  };

  Point$2.prototype.toJSON = function toJSON() {
    if (!this.precomputed) return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };

  Point$2.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === 'string') obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2]) return res;

    function obj2point(obj) {
      return curve.point(obj[0], obj[1], red);
    }

    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };

  Point$2.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
  };

  Point$2.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };

  Point$2.prototype.add = function add(p) {
    // O + P = P
    if (this.inf) return p; // P + O = P

    if (p.inf) return this; // P + P = 2P

    if (this.eq(p)) return this.dbl(); // P + (-P) = O

    if (this.neg().eq(p)) return this.curve.point(null, null); // P + Q = O

    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };

  Point$2.prototype.dbl = function dbl() {
    if (this.inf) return this; // 2P = O

    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };

  Point$2.prototype.getX = function getX() {
    return this.x.fromRed();
  };

  Point$2.prototype.getY = function getY() {
    return this.y.fromRed();
  };

  Point$2.prototype.mul = function mul(k) {
    k = new BN$8(k, 16);
    if (this.isInfinity()) return this;else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [k]);else return this.curve._wnafMul(this, k);
  };

  Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);else return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };

  Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };

  Point$2.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };

  Point$2.prototype.neg = function neg(_precompute) {
    if (this.inf) return this;
    var res = this.curve.point(this.x, this.y.redNeg());

    if (_precompute && this.precomputed) {
      var pre = this.precomputed;

      var negate = function negate(p) {
        return p.neg();
      };

      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }

    return res;
  };

  Point$2.prototype.toJ = function toJ() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };

  function JPoint(curve, x, y, z) {
    Base$2.BasePoint.call(this, curve, 'jacobian');

    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN$8(0);
    } else {
      this.x = new BN$8(x, 16);
      this.y = new BN$8(y, 16);
      this.z = new BN$8(z, 16);
    }

    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }

  inherits$c(JPoint, Base$2.BasePoint);

  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };

  JPoint.prototype.toP = function toP() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };

  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };

  JPoint.prototype.add = function add(p) {
    // O + P = P
    if (this.isInfinity()) return p; // P + O = P

    if (p.isInfinity()) return this; // 12M + 4S + 7A

    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);

    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
    }

    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    // O + P = P
    if (this.isInfinity()) return p.toJ(); // P + O = P

    if (p.isInfinity()) return this; // 8M + 3S + 7A

    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);

    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
    }

    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0) return this;
    if (this.isInfinity()) return this;
    if (!pow) return this.dbl();
    var i;

    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;

      for (i = 0; i < pow; i++) {
        r = r.dbl();
      }

      return r;
    } // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A


    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr(); // Reuse results

    var jyd = jy.redAdd(jy);

    for (i = 0; i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }

    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };

  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    if (this.curve.zeroA) return this._zeroDbl();else if (this.curve.threeA) return this._threeDbl();else return this._dbl();
  };

  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz; // Z = 1

    if (this.zOne) {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
      //     #doubling-mdbl-2007-bl
      // 1M + 5S + 14A
      // XX = X1^2
      var xx = this.x.redSqr(); // YY = Y1^2

      var yy = this.y.redSqr(); // YYYY = YY^2

      var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s); // M = 3 * XX + a; a = 0

      var m = xx.redAdd(xx).redIAdd(xx); // T = M ^ 2 - 2*S

      var t = m.redSqr().redISub(s).redISub(s); // 8 * YYYY

      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8); // X3 = T

      nx = t; // Y3 = M * (S - T) - 8 * YYYY

      ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2*Y1

      nz = this.y.redAdd(this.y);
    } else {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
      //     #doubling-dbl-2009-l
      // 2M + 5S + 13A
      // A = X1^2
      var a = this.x.redSqr(); // B = Y1^2

      var b = this.y.redSqr(); // C = B^2

      var c = b.redSqr(); // D = 2 * ((X1 + B)^2 - A - C)

      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d); // E = 3 * A

      var e = a.redAdd(a).redIAdd(a); // F = E^2

      var f = e.redSqr(); // 8 * C

      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8); // X3 = F - 2 * D

      nx = f.redISub(d).redISub(d); // Y3 = E * (D - X3) - 8 * C

      ny = e.redMul(d.redISub(nx)).redISub(c8); // Z3 = 2 * Y1 * Z1

      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }

    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz; // Z = 1

    if (this.zOne) {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
      //     #doubling-mdbl-2007-bl
      // 1M + 5S + 15A
      // XX = X1^2
      var xx = this.x.redSqr(); // YY = Y1^2

      var yy = this.y.redSqr(); // YYYY = YY^2

      var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s); // M = 3 * XX + a

      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a); // T = M^2 - 2 * S

      var t = m.redSqr().redISub(s).redISub(s); // X3 = T

      nx = t; // Y3 = M * (S - T) - 8 * YYYY

      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2 * Y1

      nz = this.y.redAdd(this.y);
    } else {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
      // 3M + 5S
      // delta = Z1^2
      var delta = this.z.redSqr(); // gamma = Y1^2

      var gamma = this.y.redSqr(); // beta = X1 * gamma

      var beta = this.x.redMul(gamma); // alpha = 3 * (X1 - delta) * (X1 + delta)

      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha); // X3 = alpha^2 - 8 * beta

      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8); // Z3 = (Y1 + Z1)^2 - gamma - delta

      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta); // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2

      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }

    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a; // 4M + 6S + 10A

    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA) return this.dbl().add(this); // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...
    // XX = X1^2

    var xx = this.x.redSqr(); // YY = Y1^2

    var yy = this.y.redSqr(); // ZZ = Z1^2

    var zz = this.z.redSqr(); // YYYY = YY^2

    var yyyy = yy.redSqr(); // M = 3 * XX + a * ZZ2; a = 0

    var m = xx.redAdd(xx).redIAdd(xx); // MM = M^2

    var mm = m.redSqr(); // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM

    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm); // EE = E^2

    var ee = e.redSqr(); // T = 16*YYYY

    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t); // U = (M + E)^2 - MM - EE - T

    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t); // X3 = 4 * (X1 * EE - 4 * YY * U)

    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx); // Y3 = 8 * Y1 * (U * (T - U) - E * EE)

    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny); // Z3 = (Z1 + E)^2 - ZZ - EE

    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN$8(k, kbase);
    return this.curve._wnafMul(this, k);
  };

  JPoint.prototype.eq = function eq(p) {
    if (p.type === 'affine') return this.eq(p.toJ());
    if (this === p) return true; // x1 * z2^2 == x2 * z1^2

    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false; // y1 * z2^3 == y2 * z1^3

    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };

  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);

    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0) return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0) return true;
    }
  };

  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC JPoint Infinity>';
    return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
  };

  JPoint.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
  };

  var BN$7 = bn.exports;
  var inherits$b = inherits$d.exports;
  var Base$1 = base;
  var utils$w = utils$A;

  function MontCurve(conf) {
    Base$1.call(this, 'mont', conf);
    this.a = new BN$7(conf.a, 16).toRed(this.red);
    this.b = new BN$7(conf.b, 16).toRed(this.red);
    this.i4 = new BN$7(4).toRed(this.red).redInvm();
    this.two = new BN$7(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }

  inherits$b(MontCurve, Base$1);
  var mont = MontCurve;

  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };

  function Point$1(curve, x, z) {
    Base$1.BasePoint.call(this, curve, 'projective');

    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN$7(x, 16);
      this.z = new BN$7(z, 16);
      if (!this.x.red) this.x = this.x.toRed(this.curve.red);
      if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    }
  }

  inherits$b(Point$1, Base$1.BasePoint);

  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils$w.toArray(bytes, enc), 1);
  };

  MontCurve.prototype.point = function point(x, z) {
    return new Point$1(this, x, z);
  };

  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point$1.fromJSON(this, obj);
  };

  Point$1.prototype.precompute = function precompute() {// No-op
  };

  Point$1.prototype._encode = function _encode() {
    return this.getX().toArray('be', this.curve.p.byteLength());
  };

  Point$1.fromJSON = function fromJSON(curve, obj) {
    return new Point$1(curve, obj[0], obj[1] || curve.one);
  };

  Point$1.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };

  Point$1.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
  };

  Point$1.prototype.dbl = function dbl() {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    // 2M + 2S + 4A
    // A = X1 + Z1
    var a = this.x.redAdd(this.z); // AA = A^2

    var aa = a.redSqr(); // B = X1 - Z1

    var b = this.x.redSub(this.z); // BB = B^2

    var bb = b.redSqr(); // C = AA - BB

    var c = aa.redSub(bb); // X3 = AA * BB

    var nx = aa.redMul(bb); // Z3 = C * (BB + A24 * C)

    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };

  Point$1.prototype.add = function add() {
    throw new Error('Not supported on Montgomery curve');
  };

  Point$1.prototype.diffAdd = function diffAdd(p, diff) {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
    // 4M + 2S + 6A
    // A = X2 + Z2
    var a = this.x.redAdd(this.z); // B = X2 - Z2

    var b = this.x.redSub(this.z); // C = X3 + Z3

    var c = p.x.redAdd(p.z); // D = X3 - Z3

    var d = p.x.redSub(p.z); // DA = D * A

    var da = d.redMul(a); // CB = C * B

    var cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2

    var nx = diff.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2

    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };

  Point$1.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this; // (N / 2) * Q + Q

    var b = this.curve.point(null, null); // (N / 2) * Q

    var c = this; // Q

    for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) {
      bits.push(t.andln(1));
    }

    for (var i = bits.length - 1; i >= 0; i--) {
      if (bits[i] === 0) {
        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
        a = a.diffAdd(b, c); // N * Q = 2 * ((N / 2) * Q + Q))

        b = b.dbl();
      } else {
        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
        b = a.diffAdd(b, c); // N * Q + Q = 2 * ((N / 2) * Q + Q)

        a = a.dbl();
      }
    }

    return b;
  };

  Point$1.prototype.mulAdd = function mulAdd() {
    throw new Error('Not supported on Montgomery curve');
  };

  Point$1.prototype.jumlAdd = function jumlAdd() {
    throw new Error('Not supported on Montgomery curve');
  };

  Point$1.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };

  Point$1.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };

  Point$1.prototype.getX = function getX() {
    // Normalize coordinates
    this.normalize();
    return this.x.fromRed();
  };

  var utils$v = utils$A;
  var BN$6 = bn.exports;
  var inherits$a = inherits$d.exports;
  var Base = base;
  var assert$f = utils$v.assert;

  function EdwardsCurve(conf) {
    // NOTE: Important as we are creating point in Base.call()
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, 'edwards', conf);
    this.a = new BN$6(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN$6(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN$6(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert$f(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }

  inherits$a(EdwardsCurve, Base);
  var edwards = EdwardsCurve;

  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA) return num.redNeg();else return this.a.redMul(num);
  };

  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC) return num;else return this.c.redMul(num);
  }; // Just for compatibility with Short curve


  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
  };

  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN$6(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
  };

  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN$6(y, 16);
    if (!y.red) y = y.toRed(this.red); // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)

    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());

    if (x2.cmp(this.zero) === 0) {
      if (odd) throw new Error('invalid point');else return this.point(this.zero, y);
    }

    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error('invalid point');
    if (x.fromRed().isOdd() !== odd) x = x.redNeg();
    return this.point(x, y);
  };

  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity()) return true; // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)

    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
  };

  function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, 'projective');

    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN$6(x, 16);
      this.y = new BN$6(y, 16);
      this.z = z ? new BN$6(z, 16) : this.curve.one;
      this.t = t && new BN$6(t, 16);
      if (!this.x.red) this.x = this.x.toRed(this.curve.red);
      if (!this.y.red) this.y = this.y.toRed(this.curve.red);
      if (!this.z.red) this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one; // Use extended coordinates

      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }

  inherits$a(Point, Base.BasePoint);

  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };

  EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
  };

  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };

  Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };

  Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };

  Point.prototype._extDbl = function _extDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #doubling-dbl-2008-hwcd
    // 4M + 4S
    // A = X1^2
    var a = this.x.redSqr(); // B = Y1^2

    var b = this.y.redSqr(); // C = 2 * Z1^2

    var c = this.z.redSqr();
    c = c.redIAdd(c); // D = a * A

    var d = this.curve._mulA(a); // E = (X1 + Y1)^2 - A - B


    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b); // G = D + B

    var g = d.redAdd(b); // F = G - C

    var f = g.redSub(c); // H = D - B

    var h = d.redSub(b); // X3 = E * F

    var nx = e.redMul(f); // Y3 = G * H

    var ny = g.redMul(h); // T3 = E * H

    var nt = e.redMul(h); // Z3 = F * G

    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };

  Point.prototype._projDbl = function _projDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #doubling-dbl-2008-bbjlp
    //     #doubling-dbl-2007-bl
    // and others
    // Generally 3M + 4S or 2M + 4S
    // B = (X1 + Y1)^2
    var b = this.x.redAdd(this.y).redSqr(); // C = X1^2

    var c = this.x.redSqr(); // D = Y1^2

    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;

    if (this.curve.twisted) {
      // E = a * C
      e = this.curve._mulA(c); // F = E + D

      var f = e.redAdd(d);

      if (this.zOne) {
        // X3 = (B - C - D) * (F - 2)
        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)); // Y3 = F * (E - D)

        ny = f.redMul(e.redSub(d)); // Z3 = F^2 - 2 * F

        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        // H = Z1^2
        h = this.z.redSqr(); // J = F - 2 * H

        j = f.redSub(h).redISub(h); // X3 = (B-C-D)*J

        nx = b.redSub(c).redISub(d).redMul(j); // Y3 = F * (E - D)

        ny = f.redMul(e.redSub(d)); // Z3 = F * J

        nz = f.redMul(j);
      }
    } else {
      // E = C + D
      e = c.redAdd(d); // H = (c * Z1)^2

      h = this.curve._mulC(this.z).redSqr(); // J = E - 2 * H

      j = e.redSub(h).redSub(h); // X3 = c * (B - E) * J

      nx = this.curve._mulC(b.redISub(e)).redMul(j); // Y3 = c * E * (C - D)

      ny = this.curve._mulC(e).redMul(c.redISub(d)); // Z3 = E * J

      nz = e.redMul(j);
    }

    return this.curve.point(nx, ny, nz);
  };

  Point.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this; // Double in extended coordinates

    if (this.curve.extended) return this._extDbl();else return this._projDbl();
  };

  Point.prototype._extAdd = function _extAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #addition-add-2008-hwcd-3
    // 8M
    // A = (Y1 - X1) * (Y2 - X2)
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)); // B = (Y1 + X1) * (Y2 + X2)

    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)); // C = T1 * k * T2

    var c = this.t.redMul(this.curve.dd).redMul(p.t); // D = Z1 * 2 * Z2

    var d = this.z.redMul(p.z.redAdd(p.z)); // E = B - A

    var e = b.redSub(a); // F = D - C

    var f = d.redSub(c); // G = D + C

    var g = d.redAdd(c); // H = B + A

    var h = b.redAdd(a); // X3 = E * F

    var nx = e.redMul(f); // Y3 = G * H

    var ny = g.redMul(h); // T3 = E * H

    var nt = e.redMul(h); // Z3 = F * G

    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };

  Point.prototype._projAdd = function _projAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #addition-add-2008-bbjlp
    //     #addition-add-2007-bl
    // 10M + 1S
    // A = Z1 * Z2
    var a = this.z.redMul(p.z); // B = A^2

    var b = a.redSqr(); // C = X1 * X2

    var c = this.x.redMul(p.x); // D = Y1 * Y2

    var d = this.y.redMul(p.y); // E = d * C * D

    var e = this.curve.d.redMul(c).redMul(d); // F = B - E

    var f = b.redSub(e); // G = B + E

    var g = b.redAdd(e); // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)

    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;

    if (this.curve.twisted) {
      // Y3 = A * G * (D - a * C)
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))); // Z3 = F * G

      nz = f.redMul(g);
    } else {
      // Y3 = A * G * (D - C)
      ny = a.redMul(g).redMul(d.redSub(c)); // Z3 = c * F * G

      nz = this.curve._mulC(f).redMul(g);
    }

    return this.curve.point(nx, ny, nz);
  };

  Point.prototype.add = function add(p) {
    if (this.isInfinity()) return p;
    if (p.isInfinity()) return this;
    if (this.curve.extended) return this._extAdd(p);else return this._projAdd(p);
  };

  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else return this.curve._wnafMul(this, k);
  };

  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
  };

  Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
  };

  Point.prototype.normalize = function normalize() {
    if (this.zOne) return this; // Normalize coordinates

    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t) this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };

  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };

  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };

  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };

  Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };

  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);

    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0) return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0) return true;
    }
  }; // Compatibility with BaseCurve


  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;

  (function (exports) {

    var curve = exports;
    curve.base = base;
    curve.short = short;
    curve.mont = mont;
    curve.edwards = edwards;
  })(curve);

  var curves$2 = {};

  var hash$4 = {};

  var utils$u = {};

  var assert$e = minimalisticAssert;
  var inherits$9 = inherits$d.exports;
  utils$u.inherits = inherits$9;

  function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
      return false;
    }

    if (i < 0 || i + 1 >= msg.length) {
      return false;
    }

    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
  }

  function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];

    if (typeof msg === 'string') {
      if (!enc) {
        // Inspired by stringToUtf8ByteArray() in closure-library by Google
        // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
        // Apache License 2.0
        // https://github.com/google/closure-library/blob/master/LICENSE
        var p = 0;

        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);

          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = c >> 6 | 192;
            res[p++] = c & 63 | 128;
          } else if (isSurrogatePair(msg, i)) {
            c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
            res[p++] = c >> 18 | 240;
            res[p++] = c >> 12 & 63 | 128;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          } else {
            res[p++] = c >> 12 | 224;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          }
        }
      } else if (enc === 'hex') {
        msg = msg.replace(/[^a-z0-9]+/ig, '');
        if (msg.length % 2 !== 0) msg = '0' + msg;

        for (i = 0; i < msg.length; i += 2) {
          res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      }
    } else {
      for (i = 0; i < msg.length; i++) {
        res[i] = msg[i] | 0;
      }
    }

    return res;
  }

  utils$u.toArray = toArray;

  function toHex(msg) {
    var res = '';

    for (var i = 0; i < msg.length; i++) {
      res += zero2(msg[i].toString(16));
    }

    return res;
  }

  utils$u.toHex = toHex;

  function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
    return res >>> 0;
  }

  utils$u.htonl = htonl;

  function toHex32(msg, endian) {
    var res = '';

    for (var i = 0; i < msg.length; i++) {
      var w = msg[i];
      if (endian === 'little') w = htonl(w);
      res += zero8(w.toString(16));
    }

    return res;
  }

  utils$u.toHex32 = toHex32;

  function zero2(word) {
    if (word.length === 1) return '0' + word;else return word;
  }

  utils$u.zero2 = zero2;

  function zero8(word) {
    if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;
  }

  utils$u.zero8 = zero8;

  function join32(msg, start, end, endian) {
    var len = end - start;
    assert$e(len % 4 === 0);
    var res = new Array(len / 4);

    for (var i = 0, k = start; i < res.length; i++, k += 4) {
      var w;
      if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
      res[i] = w >>> 0;
    }

    return res;
  }

  utils$u.join32 = join32;

  function split32(msg, endian) {
    var res = new Array(msg.length * 4);

    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
      var m = msg[i];

      if (endian === 'big') {
        res[k] = m >>> 24;
        res[k + 1] = m >>> 16 & 0xff;
        res[k + 2] = m >>> 8 & 0xff;
        res[k + 3] = m & 0xff;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = m >>> 16 & 0xff;
        res[k + 1] = m >>> 8 & 0xff;
        res[k] = m & 0xff;
      }
    }

    return res;
  }

  utils$u.split32 = split32;

  function rotr32$1(w, b) {
    return w >>> b | w << 32 - b;
  }

  utils$u.rotr32 = rotr32$1;

  function rotl32$2(w, b) {
    return w << b | w >>> 32 - b;
  }

  utils$u.rotl32 = rotl32$2;

  function sum32$3(a, b) {
    return a + b >>> 0;
  }

  utils$u.sum32 = sum32$3;

  function sum32_3$1(a, b, c) {
    return a + b + c >>> 0;
  }

  utils$u.sum32_3 = sum32_3$1;

  function sum32_4$2(a, b, c, d) {
    return a + b + c + d >>> 0;
  }

  utils$u.sum32_4 = sum32_4$2;

  function sum32_5$2(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
  }

  utils$u.sum32_5 = sum32_5$2;

  function sum64$1(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }

  utils$u.sum64 = sum64$1;

  function sum64_hi$1(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }

  utils$u.sum64_hi = sum64_hi$1;

  function sum64_lo$1(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }

  utils$u.sum64_lo = sum64_lo$1;

  function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }

  utils$u.sum64_4_hi = sum64_4_hi$1;

  function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }

  utils$u.sum64_4_lo = sum64_4_lo$1;

  function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }

  utils$u.sum64_5_hi = sum64_5_hi$1;

  function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }

  utils$u.sum64_5_lo = sum64_5_lo$1;

  function rotr64_hi$1(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
  }

  utils$u.rotr64_hi = rotr64_hi$1;

  function rotr64_lo$1(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }

  utils$u.rotr64_lo = rotr64_lo$1;

  function shr64_hi$1(ah, al, num) {
    return ah >>> num;
  }

  utils$u.shr64_hi = shr64_hi$1;

  function shr64_lo$1(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }

  utils$u.shr64_lo = shr64_lo$1;

  var common$5 = {};

  var utils$t = utils$u;
  var assert$d = minimalisticAssert;

  function BlockHash$4() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }

  common$5.BlockHash = BlockHash$4;

  BlockHash$4.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils$t.toArray(msg, enc);
    if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length; // Enough data, try updating

    if (this.pending.length >= this._delta8) {
      msg = this.pending; // Process pending data in blocks

      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0) this.pending = null;
      msg = utils$t.join32(msg, 0, msg.length - r, this.endian);

      for (var i = 0; i < msg.length; i += this._delta32) {
        this._update(msg, i, i + this._delta32);
      }
    }

    return this;
  };

  BlockHash$4.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert$d(this.pending === null);
    return this._digest(enc);
  };

  BlockHash$4.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 0x80;

    for (var i = 1; i < k; i++) {
      res[i] = 0;
    } // Append length


    len <<= 3;

    if (this.endian === 'big') {
      for (var t = 8; t < this.padLength; t++) {
        res[i++] = 0;
      }

      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = len >>> 24 & 0xff;
      res[i++] = len >>> 16 & 0xff;
      res[i++] = len >>> 8 & 0xff;
      res[i++] = len & 0xff;
    } else {
      res[i++] = len & 0xff;
      res[i++] = len >>> 8 & 0xff;
      res[i++] = len >>> 16 & 0xff;
      res[i++] = len >>> 24 & 0xff;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;

      for (t = 8; t < this.padLength; t++) {
        res[i++] = 0;
      }
    }

    return res;
  };

  var sha$2 = {};

  var common$4 = {};

  var utils$s = utils$u;
  var rotr32 = utils$s.rotr32;

  function ft_1$1(s, x, y, z) {
    if (s === 0) return ch32$1(x, y, z);
    if (s === 1 || s === 3) return p32(x, y, z);
    if (s === 2) return maj32$1(x, y, z);
  }

  common$4.ft_1 = ft_1$1;

  function ch32$1(x, y, z) {
    return x & y ^ ~x & z;
  }

  common$4.ch32 = ch32$1;

  function maj32$1(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }

  common$4.maj32 = maj32$1;

  function p32(x, y, z) {
    return x ^ y ^ z;
  }

  common$4.p32 = p32;

  function s0_256$1(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }

  common$4.s0_256 = s0_256$1;

  function s1_256$1(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }

  common$4.s1_256 = s1_256$1;

  function g0_256$1(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
  }

  common$4.g0_256 = g0_256$1;

  function g1_256$1(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
  }

  common$4.g1_256 = g1_256$1;

  var utils$r = utils$u;
  var common$3 = common$5;
  var shaCommon$1 = common$4;
  var rotl32$1 = utils$r.rotl32;
  var sum32$2 = utils$r.sum32;
  var sum32_5$1 = utils$r.sum32_5;
  var ft_1 = shaCommon$1.ft_1;
  var BlockHash$3 = common$3.BlockHash;
  var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];

  function SHA1() {
    if (!(this instanceof SHA1)) return new SHA1();
    BlockHash$3.call(this);
    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    this.W = new Array(80);
  }

  utils$r.inherits(SHA1, BlockHash$3);
  var _1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;

  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;

    for (var i = 0; i < 16; i++) {
      W[i] = msg[start + i];
    }

    for (; i < W.length; i++) {
      W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    }

    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];

    for (i = 0; i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32$1(b, 30);
      b = a;
      a = t;
    }

    this.h[0] = sum32$2(this.h[0], a);
    this.h[1] = sum32$2(this.h[1], b);
    this.h[2] = sum32$2(this.h[2], c);
    this.h[3] = sum32$2(this.h[3], d);
    this.h[4] = sum32$2(this.h[4], e);
  };

  SHA1.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils$r.toHex32(this.h, 'big');else return utils$r.split32(this.h, 'big');
  };

  var utils$q = utils$u;
  var common$2 = common$5;
  var shaCommon = common$4;
  var assert$c = minimalisticAssert;
  var sum32$1 = utils$q.sum32;
  var sum32_4$1 = utils$q.sum32_4;
  var sum32_5 = utils$q.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash$2 = common$2.BlockHash;
  var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

  function SHA256$1() {
    if (!(this instanceof SHA256$1)) return new SHA256$1();
    BlockHash$2.call(this);
    this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    this.k = sha256_K;
    this.W = new Array(64);
  }

  utils$q.inherits(SHA256$1, BlockHash$2);
  var _256 = SHA256$1;
  SHA256$1.blockSize = 512;
  SHA256$1.outSize = 256;
  SHA256$1.hmacStrength = 192;
  SHA256$1.padLength = 64;

  SHA256$1.prototype._update = function _update(msg, start) {
    var W = this.W;

    for (var i = 0; i < 16; i++) {
      W[i] = msg[start + i];
    }

    for (; i < W.length; i++) {
      W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    }

    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert$c(this.k.length === W.length);

    for (i = 0; i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32$1(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32$1(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32$1(T1, T2);
    }

    this.h[0] = sum32$1(this.h[0], a);
    this.h[1] = sum32$1(this.h[1], b);
    this.h[2] = sum32$1(this.h[2], c);
    this.h[3] = sum32$1(this.h[3], d);
    this.h[4] = sum32$1(this.h[4], e);
    this.h[5] = sum32$1(this.h[5], f);
    this.h[6] = sum32$1(this.h[6], g);
    this.h[7] = sum32$1(this.h[7], h);
  };

  SHA256$1.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils$q.toHex32(this.h, 'big');else return utils$q.split32(this.h, 'big');
  };

  var utils$p = utils$u;
  var SHA256 = _256;

  function SHA224() {
    if (!(this instanceof SHA224)) return new SHA224();
    SHA256.call(this);
    this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
  }

  utils$p.inherits(SHA224, SHA256);
  var _224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;

  SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === 'hex') return utils$p.toHex32(this.h.slice(0, 7), 'big');else return utils$p.split32(this.h.slice(0, 7), 'big');
  };

  var utils$o = utils$u;
  var common$1 = common$5;
  var assert$b = minimalisticAssert;
  var rotr64_hi = utils$o.rotr64_hi;
  var rotr64_lo = utils$o.rotr64_lo;
  var shr64_hi = utils$o.shr64_hi;
  var shr64_lo = utils$o.shr64_lo;
  var sum64 = utils$o.sum64;
  var sum64_hi = utils$o.sum64_hi;
  var sum64_lo = utils$o.sum64_lo;
  var sum64_4_hi = utils$o.sum64_4_hi;
  var sum64_4_lo = utils$o.sum64_4_lo;
  var sum64_5_hi = utils$o.sum64_5_hi;
  var sum64_5_lo = utils$o.sum64_5_lo;
  var BlockHash$1 = common$1.BlockHash;
  var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

  function SHA512$2() {
    if (!(this instanceof SHA512$2)) return new SHA512$2();
    BlockHash$1.call(this);
    this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
    this.k = sha512_K;
    this.W = new Array(160);
  }

  utils$o.inherits(SHA512$2, BlockHash$1);
  var _512 = SHA512$2;
  SHA512$2.blockSize = 1024;
  SHA512$2.outSize = 512;
  SHA512$2.hmacStrength = 192;
  SHA512$2.padLength = 128;

  SHA512$2.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W; // 32 x 32bit words

    for (var i = 0; i < 32; i++) {
      W[i] = msg[start + i];
    }

    for (; i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2

      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14]; // i - 7

      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15

      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32]; // i - 16

      var c3_lo = W[i - 31];
      W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
  };

  SHA512$2.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);

    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert$b(this.k.length === W.length);

    for (var i = 0; i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
      var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }

    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };

  SHA512$2.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils$o.toHex32(this.h, 'big');else return utils$o.split32(this.h, 'big');
  };

  function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2); // 34

    var c2_hi = rotr64_hi(xl, xh, 7); // 39

    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2); // 34

    var c2_lo = rotr64_lo(xl, xh, 7); // 39

    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9); // 41

    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9); // 41

    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29); // 61

    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
  }

  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29); // 61

    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
  }

  var utils$n = utils$u;
  var SHA512$1 = _512;

  function SHA384() {
    if (!(this instanceof SHA384)) return new SHA384();
    SHA512$1.call(this);
    this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
  }

  utils$n.inherits(SHA384, SHA512$1);
  var _384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;

  SHA384.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils$n.toHex32(this.h.slice(0, 12), 'big');else return utils$n.split32(this.h.slice(0, 12), 'big');
  };

  sha$2.sha1 = _1;
  sha$2.sha224 = _224;
  sha$2.sha256 = _256;
  sha$2.sha384 = _384;
  sha$2.sha512 = _512;

  var ripemd = {};

  var utils$m = utils$u;
  var common = common$5;
  var rotl32 = utils$m.rotl32;
  var sum32 = utils$m.sum32;
  var sum32_3 = utils$m.sum32_3;
  var sum32_4 = utils$m.sum32_4;
  var BlockHash = common.BlockHash;

  function RIPEMD160$2() {
    if (!(this instanceof RIPEMD160$2)) return new RIPEMD160$2();
    BlockHash.call(this);
    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    this.endian = 'little';
  }

  utils$m.inherits(RIPEMD160$2, BlockHash);
  ripemd.ripemd160 = RIPEMD160$2;
  RIPEMD160$2.blockSize = 512;
  RIPEMD160$2.outSize = 160;
  RIPEMD160$2.hmacStrength = 192;
  RIPEMD160$2.padLength = 64;

  RIPEMD160$2.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;

    for (var j = 0; j < 80; j++) {
      var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K$5(j)), s[j]), E);
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }

    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };

  RIPEMD160$2.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils$m.toHex32(this.h, 'little');else return utils$m.split32(this.h, 'little');
  };

  function f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);
  }

  function K$5(j) {
    if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;
  }

  function Kh(j) {
    if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;
  }

  var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

  var utils$l = utils$u;
  var assert$a = minimalisticAssert;

  function Hmac$1(hash, key, enc) {
    if (!(this instanceof Hmac$1)) return new Hmac$1(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;

    this._init(utils$l.toArray(key, enc));
  }

  var hmac$1 = Hmac$1;

  Hmac$1.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
    assert$a(key.length <= this.blockSize); // Add padding to key

    for (var i = key.length; i < this.blockSize; i++) {
      key.push(0);
    }

    for (i = 0; i < key.length; i++) {
      key[i] ^= 0x36;
    }

    this.inner = new this.Hash().update(key); // 0x36 ^ 0x5c = 0x6a

    for (i = 0; i < key.length; i++) {
      key[i] ^= 0x6a;
    }

    this.outer = new this.Hash().update(key);
  };

  Hmac$1.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };

  Hmac$1.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };

  (function (exports) {
    var hash = exports;
    hash.utils = utils$u;
    hash.common = common$5;
    hash.sha = sha$2;
    hash.ripemd = ripemd;
    hash.hmac = hmac$1; // Proxy hash functions to the main object

    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  })(hash$4);

  var secp256k1$2 = {
    doubles: {
      step: 4,
      points: [['e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a', 'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'], ['8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508', '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'], ['175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739', 'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'], ['363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640', '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'], ['8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c', '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'], ['723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda', '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'], ['eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa', '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'], ['100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0', 'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'], ['e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d', '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'], ['feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d', 'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'], ['da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1', '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'], ['53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0', '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'], ['8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047', '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'], ['385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862', '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'], ['6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7', '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'], ['3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd', '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'], ['85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83', '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'], ['948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a', '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'], ['6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8', 'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'], ['e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d', '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'], ['e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725', '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'], ['213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754', '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'], ['4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c', '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'], ['fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6', '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'], ['76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39', 'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'], ['c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891', '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'], ['d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b', 'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'], ['b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03', '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'], ['e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d', 'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'], ['a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070', '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'], ['90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4', 'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'], ['8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da', '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'], ['e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11', '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'], ['8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e', 'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'], ['e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41', '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'], ['b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef', '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'], ['d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8', 'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'], ['324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d', '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'], ['4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96', '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'], ['9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd', 'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'], ['6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5', '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'], ['a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266', '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'], ['7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71', '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'], ['928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac', 'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'], ['85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751', '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'], ['ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e', '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'], ['827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241', 'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'], ['eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3', 'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'], ['e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f', '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'], ['1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19', 'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'], ['146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be', 'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'], ['fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9', '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'], ['da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2', '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'], ['a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13', '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'], ['174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c', 'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'], ['959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba', '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'], ['d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151', 'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'], ['64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073', 'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'], ['8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458', '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'], ['13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b', '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'], ['bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366', 'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'], ['8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa', '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'], ['8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0', '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'], ['dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787', '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'], ['f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e', 'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82']]
    },
    naf: {
      wnd: 7,
      points: [['f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9', '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'], ['2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4', 'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'], ['5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc', '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'], ['acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe', 'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'], ['774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb', 'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'], ['f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8', 'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'], ['d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e', '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'], ['defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34', '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'], ['2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c', '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'], ['352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5', '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'], ['2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f', '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'], ['9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714', '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'], ['daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729', 'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'], ['c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db', '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'], ['6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4', 'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'], ['1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5', 'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'], ['605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479', '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'], ['62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d', '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'], ['80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f', '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'], ['7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb', 'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'], ['d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9', 'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'], ['49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963', '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'], ['77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74', '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'], ['f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530', 'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'], ['463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b', '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'], ['f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247', 'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'], ['caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1', 'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'], ['2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120', '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'], ['7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435', '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'], ['754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18', '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'], ['e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8', '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'], ['186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb', '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'], ['df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f', '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'], ['5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143', 'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'], ['290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba', 'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'], ['af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45', 'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'], ['766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a', '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'], ['59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e', 'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'], ['f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8', 'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'], ['7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c', '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'], ['948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519', 'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'], ['7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab', '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'], ['3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca', 'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'], ['d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf', '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'], ['1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610', '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'], ['733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4', 'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'], ['15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c', 'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'], ['a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940', 'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'], ['e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980', 'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'], ['311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3', '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'], ['34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf', '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'], ['f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63', '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'], ['d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448', 'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'], ['32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf', '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'], ['7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5', '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'], ['ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6', '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'], ['16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5', '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'], ['eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99', 'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'], ['78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51', 'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'], ['494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5', '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'], ['a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5', '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'], ['c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997', '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'], ['841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881', '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'], ['5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5', '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'], ['36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66', 'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'], ['336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726', 'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'], ['8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede', '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'], ['1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94', '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'], ['85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31', '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'], ['29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51', 'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'], ['a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252', 'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'], ['4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5', 'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'], ['d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b', '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'], ['ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4', '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'], ['af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f', '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'], ['e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889', '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'], ['591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246', 'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'], ['11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984', '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'], ['3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a', 'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'], ['cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030', 'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'], ['c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197', '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'], ['c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593', 'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'], ['a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef', '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'], ['347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38', '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'], ['da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a', '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'], ['c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111', '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'], ['4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502', '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'], ['3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea', 'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'], ['cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26', '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'], ['b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986', '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'], ['d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e', '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'], ['48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4', '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'], ['dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda', 'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'], ['6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859', 'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'], ['e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f', 'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'], ['eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c', '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'], ['13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942', 'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'], ['ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a', '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'], ['b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80', '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'], ['ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d', '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'], ['8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1', 'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'], ['52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63', 'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'], ['e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352', '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'], ['7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193', 'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'], ['5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00', '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'], ['32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58', 'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'], ['e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7', 'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'], ['8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8', 'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'], ['4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e', '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'], ['3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d', 'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'], ['674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b', '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'], ['d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f', 'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'], ['30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6', '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'], ['be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297', '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'], ['93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a', '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'], ['b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c', 'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'], ['d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52', '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'], ['d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb', 'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'], ['463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065', 'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'], ['7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917', '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'], ['74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9', 'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'], ['30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3', '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'], ['9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57', '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'], ['176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66', 'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'], ['75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8', '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'], ['809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721', '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'], ['1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180', '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9']]
    }
  };

  (function (exports) {

    var curves = exports;
    var hash = hash$4;
    var curve$1 = curve;
    var utils = utils$A;
    var assert = utils.assert;

    function PresetCurve(options) {
      if (options.type === 'short') this.curve = new curve$1.short(options);else if (options.type === 'edwards') this.curve = new curve$1.edwards(options);else this.curve = new curve$1.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), 'Invalid curve');
      assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
    }

    curves.PresetCurve = PresetCurve;

    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function get() {
          var curve = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve
          });
          return curve;
        }
      });
    }

    defineCurve('p192', {
      type: 'short',
      prime: 'p192',
      p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
      a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
      b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
      n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
      hash: hash.sha256,
      gRed: false,
      g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
    });
    defineCurve('p224', {
      type: 'short',
      prime: 'p224',
      p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
      a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
      b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
      n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
      hash: hash.sha256,
      gRed: false,
      g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
    });
    defineCurve('p256', {
      type: 'short',
      prime: null,
      p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
      a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
      b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
      n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
      hash: hash.sha256,
      gRed: false,
      g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
    });
    defineCurve('p384', {
      type: 'short',
      prime: null,
      p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 ffffffff',
      a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 fffffffc',
      b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' + '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
      n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' + 'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
      hash: hash.sha384,
      gRed: false,
      g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' + '5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' + '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']
    });
    defineCurve('p521', {
      type: 'short',
      prime: null,
      p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff',
      a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff fffffffc',
      b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' + '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' + '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
      n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
      hash: hash.sha512,
      gRed: false,
      g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' + '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' + 'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' + '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' + '3fad0761 353c7086 a272c240 88be9476 9fd16650']
    });
    defineCurve('curve25519', {
      type: 'mont',
      prime: 'p25519',
      p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
      a: '76d06',
      b: '1',
      n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
      hash: hash.sha256,
      gRed: false,
      g: ['9']
    });
    defineCurve('ed25519', {
      type: 'edwards',
      prime: 'p25519',
      p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
      a: '-1',
      c: '1',
      // -121665 * (121666^(-1)) (mod P)
      d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
      n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
      hash: hash.sha256,
      gRed: false,
      g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a', // 4/5
      '6666666666666666666666666666666666666666666666666666666666666658']
    });
    var pre;

    try {
      pre = secp256k1$2;
    } catch (e) {
      pre = undefined;
    }

    defineCurve('secp256k1', {
      type: 'short',
      prime: 'k256',
      p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
      a: '0',
      b: '7',
      n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
      h: '1',
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
      lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
      basis: [{
        a: '3086d221a7d46bcde86c90e49284eb15',
        b: '-e4437ed6010e88286f547fa90abfe4c3'
      }, {
        a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
        b: '3086d221a7d46bcde86c90e49284eb15'
      }],
      gRed: false,
      g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
    });
  })(curves$2);

  var hash$3 = hash$4;
  var utils$k = utils$z;
  var assert$9 = minimalisticAssert;

  function HmacDRBG$1(options) {
    if (!(this instanceof HmacDRBG$1)) return new HmacDRBG$1(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils$k.toArray(options.entropy, options.entropyEnc || 'hex');
    var nonce = utils$k.toArray(options.nonce, options.nonceEnc || 'hex');
    var pers = utils$k.toArray(options.pers, options.persEnc || 'hex');
    assert$9(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

    this._init(entropy, nonce, pers);
  }

  var hmacDrbg = HmacDRBG$1;

  HmacDRBG$1.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);

    for (var i = 0; i < this.V.length; i++) {
      this.K[i] = 0x00;
      this.V[i] = 0x01;
    }

    this._update(seed);

    this._reseed = 1;
    this.reseedInterval = 0x1000000000000; // 2^48
  };

  HmacDRBG$1.prototype._hmac = function hmac() {
    return new hash$3.hmac(this.hash, this.K);
  };

  HmacDRBG$1.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0x00]);

    if (seed) kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed) return;
    this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };

  HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    // Optional entropy enc
    if (typeof entropyEnc !== 'string') {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }

    entropy = utils$k.toArray(entropy, entropyEnc);
    add = utils$k.toArray(add, addEnc);
    assert$9(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

    this._update(entropy.concat(add || []));

    this._reseed = 1;
  };

  HmacDRBG$1.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval) throw new Error('Reseed is required'); // Optional encoding

    if (typeof enc !== 'string') {
      addEnc = add;
      add = enc;
      enc = null;
    } // Optional additional data


    if (add) {
      add = utils$k.toArray(add, addEnc || 'hex');

      this._update(add);
    }

    var temp = [];

    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }

    var res = temp.slice(0, len);

    this._update(add);

    this._reseed++;
    return utils$k.encode(res, enc);
  };

  var BN$5 = bn.exports;
  var utils$j = utils$A;
  var assert$8 = utils$j.assert;

  function KeyPair$3(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null; // KeyPair(ec, { priv: ..., pub: ... })

    if (options.priv) this._importPrivate(options.priv, options.privEnc);
    if (options.pub) this._importPublic(options.pub, options.pubEnc);
  }

  var key$1 = KeyPair$3;

  KeyPair$3.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair$3) return pub;
    return new KeyPair$3(ec, {
      pub: pub,
      pubEnc: enc
    });
  };

  KeyPair$3.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair$3) return priv;
    return new KeyPair$3(ec, {
      priv: priv,
      privEnc: enc
    });
  };

  KeyPair$3.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity()) return {
      result: false,
      reason: 'Invalid public key'
    };
    if (!pub.validate()) return {
      result: false,
      reason: 'Public key is not a point'
    };
    if (!pub.mul(this.ec.curve.n).isInfinity()) return {
      result: false,
      reason: 'Public key * N != O'
    };
    return {
      result: true,
      reason: null
    };
  };

  KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === 'string') {
      enc = compact;
      compact = null;
    }

    if (!this.pub) this.pub = this.ec.g.mul(this.priv);
    if (!enc) return this.pub;
    return this.pub.encode(enc, compact);
  };

  KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
    if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;
  };

  KeyPair$3.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN$5(key, enc || 16); // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method

    this.priv = this.priv.umod(this.ec.curve.n);
  };

  KeyPair$3.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      // Montgomery points only have an `x` coordinate.
      // Weierstrass/Edwards points on the other hand have both `x` and
      // `y` coordinates.
      if (this.ec.curve.type === 'mont') {
        assert$8(key.x, 'Need x coordinate');
      } else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {
        assert$8(key.x && key.y, 'Need both x and y coordinate');
      }

      this.pub = this.ec.curve.point(key.x, key.y);
      return;
    }

    this.pub = this.ec.curve.decodePoint(key, enc);
  }; // ECDH


  KeyPair$3.prototype.derive = function derive(pub) {
    if (!pub.validate()) {
      assert$8(pub.validate(), 'public point not validated');
    }

    return pub.mul(this.priv).getX();
  }; // ECDSA


  KeyPair$3.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };

  KeyPair$3.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };

  KeyPair$3.prototype.inspect = function inspect() {
    return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
  };

  var BN$4 = bn.exports;
  var utils$i = utils$A;
  var assert$7 = utils$i.assert;

  function Signature$3(options, enc) {
    if (options instanceof Signature$3) return options;
    if (this._importDER(options, enc)) return;
    assert$7(options.r && options.s, 'Signature without r or s');
    this.r = new BN$4(options.r, 16);
    this.s = new BN$4(options.s, 16);
    if (options.recoveryParam === undefined) this.recoveryParam = null;else this.recoveryParam = options.recoveryParam;
  }

  var signature$1 = Signature$3;

  function Position() {
    this.place = 0;
  }

  function getLength(buf, p) {
    var initial = buf[p.place++];

    if (!(initial & 0x80)) {
      return initial;
    }

    var octetLen = initial & 0xf; // Indefinite length or overflow

    if (octetLen === 0 || octetLen > 4) {
      return false;
    }

    var val = 0;

    for (var i = 0, off = p.place; i < octetLen; i++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    } // Leading zeroes


    if (val <= 0x7f) {
      return false;
    }

    p.place = off;
    return val;
  }

  function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;

    while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
      i++;
    }

    if (i === 0) {
      return buf;
    }

    return buf.slice(i);
  }

  Signature$3.prototype._importDER = function _importDER(data, enc) {
    data = utils$i.toArray(data, enc);
    var p = new Position();

    if (data[p.place++] !== 0x30) {
      return false;
    }

    var len = getLength(data, p);

    if (len === false) {
      return false;
    }

    if (len + p.place !== data.length) {
      return false;
    }

    if (data[p.place++] !== 0x02) {
      return false;
    }

    var rlen = getLength(data, p);

    if (rlen === false) {
      return false;
    }

    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;

    if (data[p.place++] !== 0x02) {
      return false;
    }

    var slen = getLength(data, p);

    if (slen === false) {
      return false;
    }

    if (data.length !== slen + p.place) {
      return false;
    }

    var s = data.slice(p.place, slen + p.place);

    if (r[0] === 0) {
      if (r[1] & 0x80) {
        r = r.slice(1);
      } else {
        // Leading zeroes
        return false;
      }
    }

    if (s[0] === 0) {
      if (s[1] & 0x80) {
        s = s.slice(1);
      } else {
        // Leading zeroes
        return false;
      }
    }

    this.r = new BN$4(r);
    this.s = new BN$4(s);
    this.recoveryParam = null;
    return true;
  };

  function constructLength(arr, len) {
    if (len < 0x80) {
      arr.push(len);
      return;
    }

    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);

    while (--octets) {
      arr.push(len >>> (octets << 3) & 0xff);
    }

    arr.push(len);
  }

  Signature$3.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray(); // Pad values

    if (r[0] & 0x80) r = [0].concat(r); // Pad values

    if (s[0] & 0x80) s = [0].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);

    while (!s[0] && !(s[1] & 0x80)) {
      s = s.slice(1);
    }

    var arr = [0x02];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [0x30];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils$i.encode(res, enc);
  };

  var BN$3 = bn.exports;
  var HmacDRBG = hmacDrbg;
  var utils$h = utils$A;
  var curves$1 = curves$2;
  var rand = brorand.exports;
  var assert$6 = utils$h.assert;
  var KeyPair$2 = key$1;
  var Signature$2 = signature$1;

  function EC$2(options) {
    if (!(this instanceof EC$2)) return new EC$2(options); // Shortcut `elliptic.ec(curve-name)`

    if (typeof options === 'string') {
      assert$6(Object.prototype.hasOwnProperty.call(curves$1, options), 'Unknown curve ' + options);
      options = curves$1[options];
    } // Shortcut for `elliptic.ec(elliptic.curves.curveName)`


    if (options instanceof curves$1.PresetCurve) options = {
      curve: options
    };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g; // Point on curve

    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1); // Hash for function for DRBG

    this.hash = options.hash || options.curve.hash;
  }

  var ec$1 = EC$2;

  EC$2.prototype.keyPair = function keyPair(options) {
    return new KeyPair$2(this, options);
  };

  EC$2.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair$2.fromPrivate(this, priv, enc);
  };

  EC$2.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair$2.fromPublic(this, pub, enc);
  };

  EC$2.prototype.genKeyPair = function genKeyPair(options) {
    if (!options) options = {}; // Instantiate Hmac_DRBG

    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || 'utf8',
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || 'utf8',
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN$3(2));

    for (;;) {
      var priv = new BN$3(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0) continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };

  EC$2.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0) msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);else return msg;
  };

  EC$2.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === 'object') {
      options = enc;
      enc = null;
    }

    if (!options) options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN$3(msg, 16)); // Zero-extend key to provide enough entropy

    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray('be', bytes); // Zero-extend nonce to have the same byte size as N

    var nonce = msg.toArray('be', bytes); // Instantiate Hmac_DRBG

    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce: nonce,
      pers: options.pers,
      persEnc: options.persEnc || 'utf8'
    }); // Number of bytes to generate

    var ns1 = this.n.sub(new BN$3(1));

    for (var iter = 0;; iter++) {
      var k = options.k ? options.k(iter) : new BN$3(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
      var kp = this.g.mul(k);
      if (kp.isInfinity()) continue;
      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0) continue;
      var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0) continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0); // Use complement of `s`, if it is > `n / 2`

      if (options.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }

      return new Signature$2({
        r: r,
        s: s,
        recoveryParam: recoveryParam
      });
    }
  };

  EC$2.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN$3(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature$2(signature, 'hex'); // Perform primitive values validation

    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false; // Validate signature

    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;

    if (!this.curve._maxwellTrick) {
      p = this.g.mulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity()) return false;
      return p.getX().umod(this.n).cmp(r) === 0;
    } // NOTE: Greg Maxwell's trick, inspired by:
    // https://git.io/vad3K


    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false; // Compare `p.x` of Jacobian point with `r`,
    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    // inverse of `p.z^2`

    return p.eqXToP(r);
  };

  EC$2.prototype.recoverPubKey = function (msg, signature, j, enc) {
    assert$6((3 & j) === j, 'The recovery param is more than two bits');
    signature = new Signature$2(signature, enc);
    var n = this.n;
    var e = new BN$3(msg);
    var r = signature.r;
    var s = signature.s; // A set LSB signifies that the y-coordinate is odd

    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate'); // 1.1. Let x = r + jn.

    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);else r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //               Q = r^-1 (sR + -eG)

    return this.g.mulAdd(s1, r, s2);
  };

  EC$2.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {
    signature = new Signature$2(signature, enc);
    if (signature.recoveryParam !== null) return signature.recoveryParam;

    for (var i = 0; i < 4; i++) {
      var Qprime;

      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e) {
        continue;
      }

      if (Qprime.eq(Q)) return i;
    }

    throw new Error('Unable to find valid recovery factor');
  };

  var utils$g = utils$A;
  var assert$5 = utils$g.assert;
  var parseBytes$2 = utils$g.parseBytes;
  var cachedProperty$1 = utils$g.cachedProperty;
  /**
  * @param {EDDSA} eddsa - instance
  * @param {Object} params - public/private key parameters
  *
  * @param {Array<Byte>} [params.secret] - secret seed bytes
  * @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
  * @param {Array<Byte>} [params.pub] - public key point encoded as bytes
  *
  */

  function KeyPair$1(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes$2(params.secret);
    if (eddsa.isPoint(params.pub)) this._pub = params.pub;else this._pubBytes = parseBytes$2(params.pub);
  }

  KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair$1) return pub;
    return new KeyPair$1(eddsa, {
      pub: pub
    });
  };

  KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair$1) return secret;
    return new KeyPair$1(eddsa, {
      secret: secret
    });
  };

  KeyPair$1.prototype.secret = function secret() {
    return this._secret;
  };

  cachedProperty$1(KeyPair$1, 'pubBytes', function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty$1(KeyPair$1, 'pub', function pub() {
    if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty$1(KeyPair$1, 'privBytes', function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
  });
  cachedProperty$1(KeyPair$1, 'priv', function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty$1(KeyPair$1, 'hash', function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty$1(KeyPair$1, 'messagePrefix', function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });

  KeyPair$1.prototype.sign = function sign(message) {
    assert$5(this._secret, 'KeyPair can only verify');
    return this.eddsa.sign(message, this);
  };

  KeyPair$1.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };

  KeyPair$1.prototype.getSecret = function getSecret(enc) {
    assert$5(this._secret, 'KeyPair is public only');
    return utils$g.encode(this.secret(), enc);
  };

  KeyPair$1.prototype.getPublic = function getPublic(enc) {
    return utils$g.encode(this.pubBytes(), enc);
  };

  var key = KeyPair$1;

  var BN$2 = bn.exports;
  var utils$f = utils$A;
  var assert$4 = utils$f.assert;
  var cachedProperty = utils$f.cachedProperty;
  var parseBytes$1 = utils$f.parseBytes;
  /**
  * @param {EDDSA} eddsa - eddsa instance
  * @param {Array<Bytes>|Object} sig -
  * @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
  * @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
  * @param {Array<Bytes>} [sig.Rencoded] - R point encoded
  * @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
  */

  function Signature$1(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== 'object') sig = parseBytes$1(sig);

    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength)
      };
    }

    assert$4(sig.R && sig.S, 'Signature without R or S');
    if (eddsa.isPoint(sig.R)) this._R = sig.R;
    if (sig.S instanceof BN$2) this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }

  cachedProperty(Signature$1, 'S', function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature$1, 'R', function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature$1, 'Rencoded', function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature$1, 'Sencoded', function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });

  Signature$1.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };

  Signature$1.prototype.toHex = function toHex() {
    return utils$f.encode(this.toBytes(), 'hex').toUpperCase();
  };

  var signature = Signature$1;

  var hash$2 = hash$4;
  var curves = curves$2;
  var utils$e = utils$A;
  var assert$3 = utils$e.assert;
  var parseBytes = utils$e.parseBytes;
  var KeyPair = key;
  var Signature = signature;

  function EDDSA(curve) {
    assert$3(curve === 'ed25519', 'only tested with ed25519 so far');
    if (!(this instanceof EDDSA)) return new EDDSA(curve);
    curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash$2.sha512;
  }

  var eddsa = EDDSA;
  /**
  * @param {Array|String} message - message bytes
  * @param {Array|String|KeyPair} secret - secret bytes or a keypair
  * @returns {Signature} - signature
  */

  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({
      R: R,
      S: S,
      Rencoded: Rencoded
    });
  };
  /**
  * @param {Array} message - message bytes
  * @param {Array|String|Signature} sig - sig bytes
  * @param {Array|String|Point|KeyPair} pub - public key
  * @returns {Boolean} - true if public key matches sig of message
  */


  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
  };

  EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();

    for (var i = 0; i < arguments.length; i++) {
      hash.update(arguments[i]);
    }

    return utils$e.intFromLE(hash.digest()).umod(this.curve.n);
  };

  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };

  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };

  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature) return sig;
    return new Signature(this, sig);
  };
  /**
  * * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
  *
  * EDDSA defines methods for encoding and decoding points and integers. These are
  * helper convenience methods, that pass along to utility functions implied
  * parameters.
  *
  */


  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray('le', this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
  };

  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils$e.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
    var y = utils$e.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };

  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray('le', this.encodingLength);
  };

  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils$e.intFromLE(bytes);
  };

  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };

  (function (exports) {

    var elliptic = exports;
    elliptic.version = require$$0$3.version;
    elliptic.utils = utils$A;
    elliptic.rand = brorand.exports;
    elliptic.curve = curve;
    elliptic.curves = curves$2; // Protocols

    elliptic.ec = ec$1;
    elliptic.eddsa = eddsa;
  })(elliptic$2);

  var createHmac = createHmac$2;
  var ONE1 = Buffer.alloc(1, 1);
  var ZERO1 = Buffer.alloc(1, 0); // https://tools.ietf.org/html/rfc6979#section-3.2

  function deterministicGenerateK$1(hash, x, checkSig, isPrivate, extraEntropy) {
    // Step A, ignored as hash already provided
    // Step B
    // Step C
    var k = Buffer.alloc(32, 0);
    var v = Buffer.alloc(32, 1); // Step D

    k = createHmac('sha256', k).update(v).update(ZERO1).update(x).update(hash).update(extraEntropy || '').digest(); // Step E

    v = createHmac('sha256', k).update(v).digest(); // Step F

    k = createHmac('sha256', k).update(v).update(ONE1).update(x).update(hash).update(extraEntropy || '').digest(); // Step G

    v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, ignored as tlen === qlen (256 bit)
    // Step H2b

    v = createHmac('sha256', k).update(v).digest();
    var T = v; // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA

    while (!isPrivate(T) || !checkSig(T)) {
      k = createHmac('sha256', k).update(v).update(ZERO1).digest();
      v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
      // Step H2b again

      v = createHmac('sha256', k).update(v).digest();
      T = v;
    }

    return T;
  }

  var rfc6979 = deterministicGenerateK$1;

  var BN$1 = bn$1.exports;
  var EC$1 = elliptic$2.ec;
  var secp256k1$1 = new EC$1('secp256k1');
  var deterministicGenerateK = rfc6979;
  var ZERO32 = Buffer.alloc(32, 0);
  var EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');
  var EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex');
  var n = secp256k1$1.curve.n;
  var nDiv2 = n.shrn(1);
  var G$1 = secp256k1$1.curve.g;
  var THROW_BAD_PRIVATE = 'Expected Private';
  var THROW_BAD_POINT = 'Expected Point';
  var THROW_BAD_TWEAK = 'Expected Tweak';
  var THROW_BAD_HASH = 'Expected Hash';
  var THROW_BAD_SIGNATURE = 'Expected Signature';
  var THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)';

  function isScalar(x) {
    return Buffer.isBuffer(x) && x.length === 32;
  }

  function isOrderScalar(x) {
    if (!isScalar(x)) return false;
    return x.compare(EC_GROUP_ORDER) < 0; // < G
  }

  function isPoint(p) {
    if (!Buffer.isBuffer(p)) return false;
    if (p.length < 33) return false;
    var t = p[0];
    var x = p.slice(1, 33);
    if (x.compare(ZERO32) === 0) return false;
    if (x.compare(EC_P) >= 0) return false;

    if ((t === 0x02 || t === 0x03) && p.length === 33) {
      try {
        decodeFrom(p);
      } catch (e) {
        return false;
      } // TODO: temporary


      return true;
    }

    var y = p.slice(33);
    if (y.compare(ZERO32) === 0) return false;
    if (y.compare(EC_P) >= 0) return false;
    if (t === 0x04 && p.length === 65) return true;
    return false;
  }

  function __isPointCompressed(p) {
    return p[0] !== 0x04;
  }

  function isPointCompressed(p) {
    if (!isPoint(p)) return false;
    return __isPointCompressed(p);
  }

  function isPrivate(x) {
    if (!isScalar(x)) return false;
    return x.compare(ZERO32) > 0 && // > 0
    x.compare(EC_GROUP_ORDER) < 0; // < G
  }

  function isSignature(value) {
    var r = value.slice(0, 32);
    var s = value.slice(32, 64);
    return Buffer.isBuffer(value) && value.length === 64 && r.compare(EC_GROUP_ORDER) < 0 && s.compare(EC_GROUP_ORDER) < 0;
  }

  function assumeCompression(value, pubkey) {
    if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey);
    if (value === undefined) return true;
    return value;
  }

  function fromBuffer(d) {
    return new BN$1(d);
  }

  function toBuffer$9(d) {
    return d.toArrayLike(Buffer, 'be', 32);
  }

  function decodeFrom(P) {
    return secp256k1$1.curve.decodePoint(P);
  }

  function getEncoded(P, compressed) {
    return Buffer.from(P._encode(compressed));
  }

  function pointAdd(pA, pB, __compressed) {
    if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT);
    if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT);
    var a = decodeFrom(pA);
    var b = decodeFrom(pB);
    var pp = a.add(b);
    if (pp.isInfinity()) return null;
    var compressed = assumeCompression(__compressed, pA);
    return getEncoded(pp, compressed);
  }

  function pointAddScalar(p, tweak, __compressed) {
    if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
    var compressed = assumeCompression(__compressed, p);
    var pp = decodeFrom(p);
    if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed);
    var tt = fromBuffer(tweak);
    var qq = G$1.mul(tt);
    var uu = pp.add(qq);
    if (uu.isInfinity()) return null;
    return getEncoded(uu, compressed);
  }

  function pointCompress(p, __compressed) {
    if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
    var pp = decodeFrom(p);
    if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT);
    var compressed = assumeCompression(__compressed, p);
    return getEncoded(pp, compressed);
  }

  function pointFromScalar(d, __compressed) {
    if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
    var dd = fromBuffer(d);
    var pp = G$1.mul(dd);
    if (pp.isInfinity()) return null;
    var compressed = assumeCompression(__compressed);
    return getEncoded(pp, compressed);
  }

  function pointMultiply(p, tweak, __compressed) {
    if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
    var compressed = assumeCompression(__compressed, p);
    var pp = decodeFrom(p);
    var tt = fromBuffer(tweak);
    var qq = pp.mul(tt);
    if (qq.isInfinity()) return null;
    return getEncoded(qq, compressed);
  }

  function privateAdd(d, tweak) {
    if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
    var dd = fromBuffer(d);
    var tt = fromBuffer(tweak);
    var dt = toBuffer$9(dd.add(tt).umod(n));
    if (!isPrivate(dt)) return null;
    return dt;
  }

  function privateSub(d, tweak) {
    if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
    var dd = fromBuffer(d);
    var tt = fromBuffer(tweak);
    var dt = toBuffer$9(dd.sub(tt).umod(n));
    if (!isPrivate(dt)) return null;
    return dt;
  }

  function sign(hash, x) {
    return __sign(hash, x);
  }

  function signWithEntropy(hash, x, addData) {
    return __sign(hash, x, addData);
  }

  function __sign(hash, x, addData) {
    if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);
    if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE);
    if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA);
    var d = fromBuffer(x);
    var e = fromBuffer(hash);
    var r, s;

    var checkSig = function checkSig(k) {
      var kI = fromBuffer(k);
      var Q = G$1.mul(kI);
      if (Q.isInfinity()) return false;
      r = Q.x.umod(n);
      if (r.isZero() === 0) return false;
      s = kI.invm(n).mul(e.add(d.mul(r))).umod(n);
      if (s.isZero() === 0) return false;
      return true;
    };

    deterministicGenerateK(hash, x, checkSig, isPrivate, addData); // enforce low S values, see bip62: 'low s values in signatures'

    if (s.cmp(nDiv2) > 0) {
      s = n.sub(s);
    }

    var buffer = Buffer.allocUnsafe(64);
    toBuffer$9(r).copy(buffer, 0);
    toBuffer$9(s).copy(buffer, 32);
    return buffer;
  }

  function verify(hash, q, signature, strict) {
    if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);
    if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT); // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')

    if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE);
    var Q = decodeFrom(q);
    var r = fromBuffer(signature.slice(0, 32));
    var s = fromBuffer(signature.slice(32, 64));

    if (strict && s.cmp(nDiv2) > 0) {
      return false;
    } // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')


    if (r.gtn(0) <= 0
    /* || r.compareTo(n) >= 0 */
    ) return false;
    if (s.gtn(0) <= 0
    /* || s.compareTo(n) >= 0 */
    ) return false; // 1.4.2 H = Hash(M), already done by the user
    // 1.4.3 e = H

    var e = fromBuffer(hash); // Compute s^-1

    var sInv = s.invm(n); // 1.4.4 Compute u1 = es^−1 mod n
    //               u2 = rs^−1 mod n

    var u1 = e.mul(sInv).umod(n);
    var u2 = r.mul(sInv).umod(n); // 1.4.5 Compute R = (xR, yR)
    //               R = u1G + u2Q

    var R = G$1.mulAdd(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity

    if (R.isInfinity()) return false; // 1.4.6 Convert the field element R.x to an integer

    var xR = R.x; // 1.4.7 Set v = xR mod n

    var v = xR.umod(n); // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"

    return v.eq(r);
  }

  var js = {
    isPoint: isPoint,
    isPointCompressed: isPointCompressed,
    isPrivate: isPrivate,
    pointAdd: pointAdd,
    pointAddScalar: pointAddScalar,
    pointCompress: pointCompress,
    pointFromScalar: pointFromScalar,
    pointMultiply: pointMultiply,
    privateAdd: privateAdd,
    privateSub: privateSub,
    sign: sign,
    signWithEntropy: signWithEntropy,
    verify: verify
  };

  var types$2 = {
    Array: function (_Array) {
      function Array(_x) {
        return _Array.apply(this, arguments);
      }

      Array.toString = function () {
        return _Array.toString();
      };

      return Array;
    }(function (value) {
      return value !== null && value !== undefined && value.constructor === Array;
    }),
    Boolean: function Boolean(value) {
      return typeof value === 'boolean';
    },
    Function: function Function(value) {
      return typeof value === 'function';
    },
    Nil: function Nil(value) {
      return value === undefined || value === null;
    },
    Number: function Number(value) {
      return typeof value === 'number';
    },
    Object: function Object(value) {
      return typeof value === 'object';
    },
    String: function String(value) {
      return typeof value === 'string';
    },
    '': function _() {
      return true;
    }
  }; // TODO: deprecate

  types$2.Null = types$2.Nil;

  for (var typeName$2 in types$2) {
    types$2[typeName$2].toJSON = function (t) {
      return t;
    }.bind(null, typeName$2);
  }

  var native$1 = types$2;

  var native = native$1;

  function getTypeName(fn) {
    return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
  }

  function getValueTypeName$1(value) {
    return native.Nil(value) ? '' : getTypeName(value.constructor);
  }

  function getValue(value) {
    if (native.Function(value)) return '';
    if (native.String(value)) return JSON.stringify(value);
    if (value && native.Object(value)) return '';
    return value;
  }

  function captureStackTrace(e, t) {
    if (Error.captureStackTrace) {
      Error.captureStackTrace(e, t);
    }
  }

  function tfJSON$1(type) {
    if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
    if (native.Array(type)) return 'Array';
    if (type && native.Object(type)) return 'Object';
    return type !== undefined ? type : '';
  }

  function tfErrorString(type, value, valueTypeName) {
    var valueJson = getValue(value);
    return 'Expected ' + tfJSON$1(type) + ', got' + (valueTypeName !== '' ? ' ' + valueTypeName : '') + (valueJson !== '' ? ' ' + valueJson : '');
  }

  function TfTypeError$1(type, value, valueTypeName) {
    valueTypeName = valueTypeName || getValueTypeName$1(value);
    this.message = tfErrorString(type, value, valueTypeName);
    captureStackTrace(this, TfTypeError$1);
    this.__type = type;
    this.__value = value;
    this.__valueTypeName = valueTypeName;
  }

  TfTypeError$1.prototype = Object.create(Error.prototype);
  TfTypeError$1.prototype.constructor = TfTypeError$1;

  function tfPropertyErrorString(type, label, name, value, valueTypeName) {
    var description = '" of type ';
    if (label === 'key') description = '" with key type ';
    return tfErrorString('property "' + tfJSON$1(name) + description + tfJSON$1(type), value, valueTypeName);
  }

  function TfPropertyTypeError$1(type, property, label, value, valueTypeName) {
    if (type) {
      valueTypeName = valueTypeName || getValueTypeName$1(value);
      this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
    } else {
      this.message = 'Unexpected property "' + property + '"';
    }

    captureStackTrace(this, TfTypeError$1);
    this.__label = label;
    this.__property = property;
    this.__type = type;
    this.__value = value;
    this.__valueTypeName = valueTypeName;
  }

  TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
  TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;

  function tfCustomError(expected, actual) {
    return new TfTypeError$1(expected, {}, actual);
  }

  function tfSubError$1(e, property, label) {
    // sub child?
    if (e instanceof TfPropertyTypeError$1) {
      property = property + '.' + e.__property;
      e = new TfPropertyTypeError$1(e.__type, property, e.__label, e.__value, e.__valueTypeName); // child?
    } else if (e instanceof TfTypeError$1) {
      e = new TfPropertyTypeError$1(e.__type, property, label, e.__value, e.__valueTypeName);
    }

    captureStackTrace(e);
    return e;
  }

  var errors$2 = {
    TfTypeError: TfTypeError$1,
    TfPropertyTypeError: TfPropertyTypeError$1,
    tfCustomError: tfCustomError,
    tfSubError: tfSubError$1,
    tfJSON: tfJSON$1,
    getValueTypeName: getValueTypeName$1
  };

  var NATIVE$1 = native$1;
  var ERRORS$1 = errors$2;

  function _Buffer(value) {
    return Buffer.isBuffer(value);
  }

  function Hex(value) {
    return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value);
  }

  function _LengthN(type, length) {
    var name = type.toJSON();

    function Length(value) {
      if (!type(value)) return false;
      if (value.length === length) return true;
      throw ERRORS$1.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')');
    }

    Length.toJSON = function () {
      return name;
    };

    return Length;
  }

  var _ArrayN = _LengthN.bind(null, NATIVE$1.Array);

  var _BufferN = _LengthN.bind(null, _Buffer);

  var _HexN = _LengthN.bind(null, Hex);

  var _StringN = _LengthN.bind(null, NATIVE$1.String);

  function Range(a, b, f) {
    f = f || NATIVE$1.Number;

    function _range(value, strict) {
      return f(value, strict) && value > a && value < b;
    }

    _range.toJSON = function () {
      return f.toJSON() + " between [" + a + ", " + b + "]";
    };

    return _range;
  }

  var INT53_MAX = Math.pow(2, 53) - 1;

  function Finite(value) {
    return typeof value === 'number' && isFinite(value);
  }

  function Int8(value) {
    return value << 24 >> 24 === value;
  }

  function Int16(value) {
    return value << 16 >> 16 === value;
  }

  function Int32(value) {
    return (value | 0) === value;
  }

  function Int53(value) {
    return typeof value === 'number' && value >= -INT53_MAX && value <= INT53_MAX && Math.floor(value) === value;
  }

  function UInt8(value) {
    return (value & 0xff) === value;
  }

  function UInt16(value) {
    return (value & 0xffff) === value;
  }

  function UInt32(value) {
    return value >>> 0 === value;
  }

  function UInt53(value) {
    return typeof value === 'number' && value >= 0 && value <= INT53_MAX && Math.floor(value) === value;
  }

  var types$1 = {
    ArrayN: _ArrayN,
    Buffer: _Buffer,
    BufferN: _BufferN,
    Finite: Finite,
    Hex: Hex,
    HexN: _HexN,
    Int8: Int8,
    Int16: Int16,
    Int32: Int32,
    Int53: Int53,
    Range: Range,
    StringN: _StringN,
    UInt8: UInt8,
    UInt16: UInt16,
    UInt32: UInt32,
    UInt53: UInt53
  };

  for (var typeName$1 in types$1) {
    types$1[typeName$1].toJSON = function (t) {
      return t;
    }.bind(null, typeName$1);
  }

  var extra = types$1;

  var ERRORS = errors$2;
  var NATIVE = native$1; // short-hand

  var tfJSON = ERRORS.tfJSON;
  var TfTypeError = ERRORS.TfTypeError;
  var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
  var tfSubError = ERRORS.tfSubError;
  var getValueTypeName = ERRORS.getValueTypeName;
  var TYPES = {
    arrayOf: function arrayOf(type, options) {
      type = compile(type);
      options = options || {};

      function _arrayOf(array, strict) {
        if (!NATIVE.Array(array)) return false;
        if (NATIVE.Nil(array)) return false;
        if (options.minLength !== undefined && array.length < options.minLength) return false;
        if (options.maxLength !== undefined && array.length > options.maxLength) return false;
        if (options.length !== undefined && array.length !== options.length) return false;
        return array.every(function (value, i) {
          try {
            return typeforce$1(type, value, strict);
          } catch (e) {
            throw tfSubError(e, i);
          }
        });
      }

      _arrayOf.toJSON = function () {
        var str = '[' + tfJSON(type) + ']';

        if (options.length !== undefined) {
          str += '{' + options.length + '}';
        } else if (options.minLength !== undefined || options.maxLength !== undefined) {
          str += '{' + (options.minLength === undefined ? 0 : options.minLength) + ',' + (options.maxLength === undefined ? Infinity : options.maxLength) + '}';
        }

        return str;
      };

      return _arrayOf;
    },
    maybe: function maybe(type) {
      type = compile(type);

      function _maybe(value, strict) {
        return NATIVE.Nil(value) || type(value, strict, maybe);
      }

      _maybe.toJSON = function () {
        return '?' + tfJSON(type);
      };

      return _maybe;
    },
    map: function map(propertyType, propertyKeyType) {
      propertyType = compile(propertyType);
      if (propertyKeyType) propertyKeyType = compile(propertyKeyType);

      function _map(value, strict) {
        if (!NATIVE.Object(value)) return false;
        if (NATIVE.Nil(value)) return false;

        for (var propertyName in value) {
          try {
            if (propertyKeyType) {
              typeforce$1(propertyKeyType, propertyName, strict);
            }
          } catch (e) {
            throw tfSubError(e, propertyName, 'key');
          }

          try {
            var propertyValue = value[propertyName];
            typeforce$1(propertyType, propertyValue, strict);
          } catch (e) {
            throw tfSubError(e, propertyName);
          }
        }

        return true;
      }

      if (propertyKeyType) {
        _map.toJSON = function () {
          return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}';
        };
      } else {
        _map.toJSON = function () {
          return '{' + tfJSON(propertyType) + '}';
        };
      }

      return _map;
    },
    object: function object(uncompiled) {
      var type = {};

      for (var typePropertyName in uncompiled) {
        type[typePropertyName] = compile(uncompiled[typePropertyName]);
      }

      function _object(value, strict) {
        if (!NATIVE.Object(value)) return false;
        if (NATIVE.Nil(value)) return false;
        var propertyName;

        try {
          for (propertyName in type) {
            var propertyType = type[propertyName];
            var propertyValue = value[propertyName];
            typeforce$1(propertyType, propertyValue, strict);
          }
        } catch (e) {
          throw tfSubError(e, propertyName);
        }

        if (strict) {
          for (propertyName in value) {
            if (type[propertyName]) continue;
            throw new TfPropertyTypeError(undefined, propertyName);
          }
        }

        return true;
      }

      _object.toJSON = function () {
        return tfJSON(type);
      };

      return _object;
    },
    anyOf: function anyOf() {
      var types = [].slice.call(arguments).map(compile);

      function _anyOf(value, strict) {
        return types.some(function (type) {
          try {
            return typeforce$1(type, value, strict);
          } catch (e) {
            return false;
          }
        });
      }

      _anyOf.toJSON = function () {
        return types.map(tfJSON).join('|');
      };

      return _anyOf;
    },
    allOf: function allOf() {
      var types = [].slice.call(arguments).map(compile);

      function _allOf(value, strict) {
        return types.every(function (type) {
          try {
            return typeforce$1(type, value, strict);
          } catch (e) {
            return false;
          }
        });
      }

      _allOf.toJSON = function () {
        return types.map(tfJSON).join(' & ');
      };

      return _allOf;
    },
    quacksLike: function quacksLike(type) {
      function _quacksLike(value) {
        return type === getValueTypeName(value);
      }

      _quacksLike.toJSON = function () {
        return type;
      };

      return _quacksLike;
    },
    tuple: function tuple() {
      var types = [].slice.call(arguments).map(compile);

      function _tuple(values, strict) {
        if (NATIVE.Nil(values)) return false;
        if (NATIVE.Nil(values.length)) return false;
        if (strict && values.length !== types.length) return false;
        return types.every(function (type, i) {
          try {
            return typeforce$1(type, values[i], strict);
          } catch (e) {
            throw tfSubError(e, i);
          }
        });
      }

      _tuple.toJSON = function () {
        return '(' + types.map(tfJSON).join(', ') + ')';
      };

      return _tuple;
    },
    value: function value(expected) {
      function _value(actual) {
        return actual === expected;
      }

      _value.toJSON = function () {
        return expected;
      };

      return _value;
    }
  }; // TODO: deprecate

  TYPES.oneOf = TYPES.anyOf;

  function compile(type) {
    if (NATIVE.String(type)) {
      if (type[0] === '?') return TYPES.maybe(type.slice(1));
      return NATIVE[type] || TYPES.quacksLike(type);
    } else if (type && NATIVE.Object(type)) {
      if (NATIVE.Array(type)) {
        if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1');
        return TYPES.arrayOf(type[0]);
      }

      return TYPES.object(type);
    } else if (NATIVE.Function(type)) {
      return type;
    }

    return TYPES.value(type);
  }

  function typeforce$1(type, value, strict, surrogate) {
    if (NATIVE.Function(type)) {
      if (type(value, strict)) return true;
      throw new TfTypeError(surrogate || type, value);
    } // JIT


    return typeforce$1(compile(type), value, strict);
  } // assign types to typeforce function


  for (var typeName in NATIVE) {
    typeforce$1[typeName] = NATIVE[typeName];
  }

  for (typeName in TYPES) {
    typeforce$1[typeName] = TYPES[typeName];
  }

  var EXTRA = extra;

  for (typeName in EXTRA) {
    typeforce$1[typeName] = EXTRA[typeName];
  }

  typeforce$1.compile = compile;
  typeforce$1.TfTypeError = TfTypeError;
  typeforce$1.TfPropertyTypeError = TfPropertyTypeError;
  var typeforce_1 = typeforce$1;

  var bs58check$1 = bs58check$2;

  function decodeRaw(buffer, version) {
    // check version only if defined
    if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version'); // uncompressed

    if (buffer.length === 33) {
      return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: false
      };
    } // invalid length


    if (buffer.length !== 34) throw new Error('Invalid WIF length'); // invalid compression flag

    if (buffer[33] !== 0x01) throw new Error('Invalid compression flag');
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: true
    };
  }

  function encodeRaw(version, privateKey, compressed) {
    var result = new Buffer(compressed ? 34 : 33);
    result.writeUInt8(version, 0);
    privateKey.copy(result, 1);

    if (compressed) {
      result[33] = 0x01;
    }

    return result;
  }

  function decode$1(string, version) {
    return decodeRaw(bs58check$1.decode(string), version);
  }

  function encode$1(version, privateKey, compressed) {
    if (typeof version === 'number') return bs58check$1.encode(encodeRaw(version, privateKey, compressed));
    return bs58check$1.encode(encodeRaw(version.version, version.privateKey, version.compressed));
  }

  var wif$1 = {
    decode: decode$1,
    decodeRaw: decodeRaw,
    encode: encode$1,
    encodeRaw: encodeRaw
  };

  Object.defineProperty(bip32, "__esModule", {
    value: true
  });
  var crypto$3 = crypto$5;
  var bs58check = bs58check$2;
  var ecc = js;
  var typeforce = typeforce_1;
  var wif = wif$1;
  var UINT256_TYPE = typeforce.BufferN(32);
  var NETWORK_TYPE = typeforce.compile({
    wif: typeforce.UInt8,
    bip32: {
      public: typeforce.UInt32,
      private: typeforce.UInt32
    }
  });
  var BITCOIN = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bip32: {
      public: 0x0488b21e,
      private: 0x0488ade4
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80
  };
  var HIGHEST_BIT = 0x80000000;
  var UINT31_MAX = Math.pow(2, 31) - 1;

  function BIP32Path(value) {
    return typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
  }

  function UInt31(value) {
    return typeforce.UInt32(value) && value <= UINT31_MAX;
  }

  var BIP32 = /*#__PURE__*/function () {
    function BIP32(__D, __Q, chainCode, network, __DEPTH, __INDEX, __PARENT_FINGERPRINT) {
      if (__DEPTH === void 0) {
        __DEPTH = 0;
      }

      if (__INDEX === void 0) {
        __INDEX = 0;
      }

      if (__PARENT_FINGERPRINT === void 0) {
        __PARENT_FINGERPRINT = 0x00000000;
      }

      this.__D = __D;
      this.__Q = __Q;
      this.chainCode = chainCode;
      this.network = network;
      this.__DEPTH = __DEPTH;
      this.__INDEX = __INDEX;
      this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
      typeforce(NETWORK_TYPE, network);
      this.lowR = false;
    }

    var _proto = BIP32.prototype;

    // Private === not neutered
    // Public === neutered
    _proto.isNeutered = function isNeutered() {
      return this.__D === undefined;
    };

    _proto.neutered = function neutered() {
      return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    };

    _proto.toBase58 = function toBase58() {
      var network = this.network;
      var version = !this.isNeutered() ? network.bip32.private : network.bip32.public;
      var buffer = Buffer.allocUnsafe(78); // 4 bytes: version bytes

      buffer.writeUInt32BE(version, 0); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....

      buffer.writeUInt8(this.depth, 4); // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)

      buffer.writeUInt32BE(this.parentFingerprint, 5); // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
      // This is encoded in big endian. (0x00000000 if master key)

      buffer.writeUInt32BE(this.index, 9); // 32 bytes: the chain code

      this.chainCode.copy(buffer, 13); // 33 bytes: the public key or private key data

      if (!this.isNeutered()) {
        // 0x00 + k for private keys
        buffer.writeUInt8(0, 45);
        this.privateKey.copy(buffer, 46); // 33 bytes: the public key
      } else {
        // X9.62 encoding for public keys
        this.publicKey.copy(buffer, 45);
      }

      return bs58check.encode(buffer);
    };

    _proto.toWIF = function toWIF() {
      if (!this.privateKey) throw new TypeError('Missing private key');
      return wif.encode(this.network.wif, this.privateKey, true);
    } // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    ;

    _proto.derive = function derive(index) {
      typeforce(typeforce.UInt32, index);
      var isHardened = index >= HIGHEST_BIT;
      var data = Buffer.allocUnsafe(37); // Hardened child

      if (isHardened) {
        if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key'); // data = 0x00 || ser256(kpar) || ser32(index)

        data[0] = 0x00;
        this.privateKey.copy(data, 1);
        data.writeUInt32BE(index, 33); // Normal child
      } else {
        // data = serP(point(kpar)) || ser32(index)
        //      = serP(Kpar) || ser32(index)
        this.publicKey.copy(data, 0);
        data.writeUInt32BE(index, 33);
      }

      var I = crypto$3.hmacSHA512(this.chainCode, data);
      var IL = I.slice(0, 32);
      var IR = I.slice(32); // if parse256(IL) >= n, proceed with the next value for i

      if (!ecc.isPrivate(IL)) return this.derive(index + 1); // Private parent key -> private child key

      var hd;

      if (!this.isNeutered()) {
        // ki = parse256(IL) + kpar (mod n)
        var ki = ecc.privateAdd(this.privateKey, IL); // In case ki == 0, proceed with the next value for i

        if (ki == null) return this.derive(index + 1);
        hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0)); // Public parent key -> public child key
      } else {
        // Ki = point(parse256(IL)) + Kpar
        //    = G*IL + Kpar
        var Ki = ecc.pointAddScalar(this.publicKey, IL, true); // In case Ki is the point at infinity, proceed with the next value for i

        if (Ki === null) return this.derive(index + 1);
        hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
      }

      return hd;
    };

    _proto.deriveHardened = function deriveHardened(index) {
      typeforce(UInt31, index); // Only derives hardened private keys by default

      return this.derive(index + HIGHEST_BIT);
    };

    _proto.derivePath = function derivePath(path) {
      typeforce(BIP32Path, path);
      var splitPath = path.split('/');

      if (splitPath[0] === 'm') {
        if (this.parentFingerprint) throw new TypeError('Expected master, got child');
        splitPath = splitPath.slice(1);
      }

      return splitPath.reduce(function (prevHd, indexStr) {
        var index;

        if (indexStr.slice(-1) === "'") {
          index = parseInt(indexStr.slice(0, -1), 10);
          return prevHd.deriveHardened(index);
        } else {
          index = parseInt(indexStr, 10);
          return prevHd.derive(index);
        }
      }, this);
    };

    _proto.sign = function sign(hash, lowR) {
      if (!this.privateKey) throw new Error('Missing private key');
      if (lowR === undefined) lowR = this.lowR;

      if (lowR === false) {
        return ecc.sign(hash, this.privateKey);
      } else {
        var sig = ecc.sign(hash, this.privateKey);
        var extraData = Buffer.alloc(32, 0);
        var counter = 0; // if first try is lowR, skip the loop
        // for second try and on, add extra entropy counting up

        while (sig[0] > 0x7f) {
          counter++;
          extraData.writeUIntLE(counter, 0, 6);
          sig = ecc.signWithEntropy(hash, this.privateKey, extraData);
        }

        return sig;
      }
    };

    _proto.verify = function verify(hash, signature) {
      return ecc.verify(hash, this.publicKey, signature);
    };

    _createClass$2(BIP32, [{
      key: "depth",
      get: function get() {
        return this.__DEPTH;
      }
    }, {
      key: "index",
      get: function get() {
        return this.__INDEX;
      }
    }, {
      key: "parentFingerprint",
      get: function get() {
        return this.__PARENT_FINGERPRINT;
      }
    }, {
      key: "publicKey",
      get: function get() {
        if (this.__Q === undefined) this.__Q = ecc.pointFromScalar(this.__D, true);
        return this.__Q;
      }
    }, {
      key: "privateKey",
      get: function get() {
        return this.__D;
      }
    }, {
      key: "identifier",
      get: function get() {
        return crypto$3.hash160(this.publicKey);
      }
    }, {
      key: "fingerprint",
      get: function get() {
        return this.identifier.slice(0, 4);
      }
    }, {
      key: "compressed",
      get: function get() {
        return true;
      }
    }]);

    return BIP32;
  }();

  function fromBase58(inString, network) {
    var buffer = bs58check.decode(inString);
    if (buffer.length !== 78) throw new TypeError('Invalid buffer length');
    network = network || BITCOIN; // 4 bytes: version bytes

    var version = buffer.readUInt32BE(0);
    if (version !== network.bip32.private && version !== network.bip32.public) throw new TypeError('Invalid network version'); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...

    var depth = buffer[4]; // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)

    var parentFingerprint = buffer.readUInt32BE(5);

    if (depth === 0) {
      if (parentFingerprint !== 0x00000000) throw new TypeError('Invalid parent fingerprint');
    } // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
    // This is encoded in MSB order. (0x00000000 if master key)


    var index = buffer.readUInt32BE(9);
    if (depth === 0 && index !== 0) throw new TypeError('Invalid index'); // 32 bytes: the chain code

    var chainCode = buffer.slice(13, 45);
    var hd; // 33 bytes: private key data (0x00 + k)

    if (version === network.bip32.private) {
      if (buffer.readUInt8(45) !== 0x00) throw new TypeError('Invalid private key');
      var k = buffer.slice(46, 78);
      hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint); // 33 bytes: public key data (0x02 + X or 0x03 + X)
    } else {
      var X = buffer.slice(45, 78);
      hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
    }

    return hd;
  }

  bip32.fromBase58 = fromBase58;

  function fromPrivateKey(privateKey, chainCode, network) {
    return fromPrivateKeyLocal(privateKey, chainCode, network);
  }

  bip32.fromPrivateKey = fromPrivateKey;

  function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
    typeforce({
      privateKey: UINT256_TYPE,
      chainCode: UINT256_TYPE
    }, {
      privateKey: privateKey,
      chainCode: chainCode
    });
    network = network || BITCOIN;
    if (!ecc.isPrivate(privateKey)) throw new TypeError('Private key not in range [1, n)');
    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
  }

  function fromPublicKey(publicKey, chainCode, network) {
    return fromPublicKeyLocal(publicKey, chainCode, network);
  }

  bip32.fromPublicKey = fromPublicKey;

  function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
    typeforce({
      publicKey: typeforce.BufferN(33),
      chainCode: UINT256_TYPE
    }, {
      publicKey: publicKey,
      chainCode: chainCode
    });
    network = network || BITCOIN; // verify the X coordinate is a point on the curve

    if (!ecc.isPoint(publicKey)) throw new TypeError('Point is not on the curve');
    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
  }

  function fromSeed(seed, network) {
    typeforce(typeforce.Buffer, seed);
    if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');
    if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');
    network = network || BITCOIN;
    var I = crypto$3.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);
    var IL = I.slice(0, 32);
    var IR = I.slice(32);
    return fromPrivateKey(IL, IR, network);
  }

  bip32.fromSeed = fromSeed;

  Object.defineProperty(src$2, "__esModule", {
    value: true
  });
  var bip32_1 = bip32;
  src$2.fromSeed = bip32_1.fromSeed;
  src$2.fromBase58 = bip32_1.fromBase58;
  src$2.fromPublicKey = bip32_1.fromPublicKey;
  src$2.fromPrivateKey = bip32_1.fromPrivateKey;

  var src = {};

  var browser$2 = {};

  var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

  var precondition = function precondition(iterations, keylen) {
    if (typeof iterations !== 'number') {
      throw new TypeError('Iterations not a number');
    }

    if (iterations < 0) {
      throw new TypeError('Bad iterations');
    }

    if (typeof keylen !== 'number') {
      throw new TypeError('Key length not a number');
    }

    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
      /* eslint no-self-compare: 0 */
      throw new TypeError('Bad key length');
    }
  };

  var defaultEncoding$2;
  /* istanbul ignore next */

  if (commonjsGlobal.process && commonjsGlobal.process.browser) {
    defaultEncoding$2 = 'utf-8';
  } else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);
    defaultEncoding$2 = pVersionMajor >= 6 ? 'utf-8' : 'binary';
  } else {
    defaultEncoding$2 = 'utf-8';
  }

  var defaultEncoding_1 = defaultEncoding$2;

  var readableBrowser = {exports: {}};

  var streamBrowser = require$$0__default$3["default"].EventEmitter;

  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$1(Object(source), true).forEach(function (key) {
          _defineProperty$2(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$1(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
  }

  var _require$2 = require$$0__default$1["default"],
      Buffer$g = _require$2.Buffer;
  var _require2 = require$$0__default$2["default"],
      inspect = _require2.inspect;
  var custom = inspect && inspect.custom || 'inspect';

  function copyBuffer(src, target, offset) {
    Buffer$g.prototype.copy.call(src, target, offset);
  }

  var buffer_list = /*#__PURE__*/function () {
    function BufferList() {
      _classCallCheck$1(this, BufferList);

      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    _createClass$1(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0) return '';
        var p = this.head;
        var ret = '' + p.data;

        while (p = p.next) {
          ret += s + p.data;
        }

        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer$g.alloc(0);
        var ret = Buffer$g.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;

        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }

        return ret;
      } // Consumes a specified amount of bytes or characters from the buffered data.

    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;

        if (n < this.head.data.length) {
          // `slice` is the same for buffers and strings.
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          // First chunk is a perfect match.
          ret = this.shift();
        } else {
          // Result spans more than one buffer.
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }

        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      } // Consumes a specified amount of characters from the buffered data.

    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;

        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;else ret += str.slice(0, n);
          n -= nb;

          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }

            break;
          }

          ++c;
        }

        this.length -= c;
        return ret;
      } // Consumes a specified amount of bytes from the buffered data.

    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer$g.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;

        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;

          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }

            break;
          }

          ++c;
        }

        this.length -= c;
        return ret;
      } // Make sure the linked list only shows the minimal necessary information.

    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread$1({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);

    return BufferList;
  }();

  function destroy(err, cb) {
    var _this = this;

    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;

    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }

      return this;
    } // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks


    if (this._readableState) {
      this._readableState.destroyed = true;
    } // if this is a duplex stream mark the writable part as destroyed as well


    if (this._writableState) {
      this._writableState.destroyed = true;
    }

    this._destroy(err || null, function (err) {
      if (!cb && err) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });

    return this;
  }

  function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
  }

  function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit('close');
  }

  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }

    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }

  function emitErrorNT(self, err) {
    self.emit('error', err);
  }

  function errorOrDestroy$2(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
  }

  var destroy_1 = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy$2
  };

  var errorsBrowser = {};

  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var codes = {};

  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }

    function getMessage(arg1, arg2, arg3) {
      if (typeof message === 'string') {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }

    var NodeError = /*#__PURE__*/function (_Base) {
      _inheritsLoose$1(NodeError, _Base);

      function NodeError(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }

      return NodeError;
    }(Base);

    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function (i) {
        return String(i);
      });

      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


  function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }

    return str.substring(this_len - search.length, this_len) === search;
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


  function includes(str, search, start) {
    if (typeof start !== 'number') {
      start = 0;
    }

    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }

  createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;

    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
      determiner = 'must not be';
      expected = expected.replace(/^not /, '');
    } else {
      determiner = 'must be';
    }

    var msg;

    if (endsWith(name, ' argument')) {
      // For cases like 'first argument'
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    } else {
      var type = includes(name, '.') ? 'property' : 'argument';
      msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    }

    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
  createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
    return 'The ' + name + ' method is not implemented';
  });
  createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
  createErrorType('ERR_STREAM_DESTROYED', function (name) {
    return 'Cannot call ' + name + ' after a stream was destroyed';
  });
  createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
  createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
  createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
  createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
  createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
    return 'Unknown encoding: ' + arg;
  }, TypeError);
  createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
  errorsBrowser.codes = codes;

  var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;

  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }

  function getHighWaterMark$2(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : 'highWaterMark';
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }

      return Math.floor(hwm);
    } // Default value


    return state.objectMode ? 16 : 16 * 1024;
  }

  var state = {
    getHighWaterMark: getHighWaterMark$2
  };

  /**
   * For Node.js, simply re-export the core `util.deprecate` function.
   */

  var node$3 = require$$0__default$2["default"].deprecate;

  var _stream_writable = Writable$3;
  // there will be only 2 of these for each stream


  function CorkedRequest(state) {
    var _this = this;

    this.next = null;
    this.entry = null;

    this.finish = function () {
      onCorkedFinish(_this, state);
    };
  }
  /* </replacement> */

  /*<replacement>*/


  var Duplex$5;
  /*</replacement>*/

  Writable$3.WritableState = WritableState;
  /*<replacement>*/

  var internalUtil = {
    deprecate: node$3
  };
  /*</replacement>*/

  /*<replacement>*/

  var Stream$1 = streamBrowser;
  /*</replacement>*/

  var Buffer$f = require$$0__default$1["default"].Buffer;

  var OurUint8Array$1 = commonjsGlobal.Uint8Array || function () {};

  function _uint8ArrayToBuffer$1(chunk) {
    return Buffer$f.from(chunk);
  }

  function _isUint8Array$1(obj) {
    return Buffer$f.isBuffer(obj) || obj instanceof OurUint8Array$1;
  }

  var destroyImpl$1 = destroy_1;
  var _require$1 = state,
      getHighWaterMark$1 = _require$1.getHighWaterMark;
  var _require$codes$3 = errorsBrowser.codes,
      ERR_INVALID_ARG_TYPE$1 = _require$codes$3.ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE = _require$codes$3.ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED$1 = _require$codes$3.ERR_STREAM_DESTROYED,
      ERR_STREAM_NULL_VALUES = _require$codes$3.ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END = _require$codes$3.ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING = _require$codes$3.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
  inherits$d.exports(Writable$3, Stream$1);

  function nop() {}

  function WritableState(options, stream, isDuplex) {
    Duplex$5 = Duplex$5 || _stream_duplex;
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$5; // object stream flag to indicate whether or not this stream
    // contains buffers or objects.

    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()

    this.highWaterMark = getHighWaterMark$1(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

    this.finalCalled = false; // drain event flag.

    this.needDrain = false; // at the start of calling end()

    this.ending = false; // when end() has been called, and returned

    this.ended = false; // when 'finish' is emitted

    this.finished = false; // has it been destroyed

    this.destroyed = false; // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.

    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.

    this.length = 0; // a flag to see when we're in the middle of a write.

    this.writing = false; // when true all writes will be buffered until .uncork() call

    this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.

    this.sync = true; // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.

    this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

    this.onwrite = function (er) {
      onwrite(stream, er);
    }; // the callback that the user supplies to write(chunk,encoding,cb)


    this.writecb = null; // the amount that is being written when _write is called.

    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted

    this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams

    this.prefinished = false; // True if the error was already emitted and should not be thrown again

    this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

    this.autoDestroy = !!options.autoDestroy; // count buffered requests

    this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two

    this.corkedRequestsFree = new CorkedRequest(this);
  }

  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];

    while (current) {
      out.push(current);
      current = current.next;
    }

    return out;
  };

  (function () {
    try {
      Object.defineProperty(WritableState.prototype, 'buffer', {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
      });
    } catch (_) {}
  })(); // Test _writableState for inheritance to account for Duplex streams,
  // whose prototype chain only points to Readable.


  var realHasInstance;

  if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable$3, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable$3) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }

  function Writable$3(options) {
    Duplex$5 = Duplex$5 || _stream_duplex; // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5

    var isDuplex = this instanceof Duplex$5;
    if (!isDuplex && !realHasInstance.call(Writable$3, this)) return new Writable$3(options);
    this._writableState = new WritableState(options, this, isDuplex); // legacy.

    this.writable = true;

    if (options) {
      if (typeof options.write === 'function') this._write = options.write;
      if (typeof options.writev === 'function') this._writev = options.writev;
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
      if (typeof options.final === 'function') this._final = options.final;
    }

    Stream$1.call(this);
  } // Otherwise people can pipe Writable streams, which is just wrong.


  Writable$3.prototype.pipe = function () {
    errorOrDestroy$1(this, new ERR_STREAM_CANNOT_PIPE());
  };

  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

    errorOrDestroy$1(stream, er);
    process.nextTick(cb, er);
  } // Checks that a user-supplied chunk is valid, especially for the particular
  // mode the stream is in. Currently this means that `null` is never accepted
  // and undefined/non-string values are only allowed in object mode.


  function validChunk(stream, state, chunk, cb) {
    var er;

    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== 'string' && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE$1('chunk', ['string', 'Buffer'], chunk);
    }

    if (er) {
      errorOrDestroy$1(stream, er);
      process.nextTick(cb, er);
      return false;
    }

    return true;
  }

  Writable$3.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;

    var isBuf = !state.objectMode && _isUint8Array$1(chunk);

    if (isBuf && !Buffer$f.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer$1(chunk);
    }

    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== 'function') cb = nop;
    if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };

  Writable$3.prototype.cork = function () {
    this._writableState.corked++;
  };

  Writable$3.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };

  Writable$3.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  Object.defineProperty(Writable$3.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });

  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = Buffer$f.from(chunk, encoding);
    }

    return chunk;
  }

  Object.defineProperty(Writable$3.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  }); // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.

  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);

      if (chunk !== newChunk) {
        isBuf = true;
        encoding = 'buffer';
        chunk = newChunk;
      }
    }

    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

    if (!ret) state.needDrain = true;

    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk: chunk,
        encoding: encoding,
        isBuf: isBuf,
        callback: cb,
        next: null
      };

      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }

      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }

    return ret;
  }

  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED$1('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;

    if (sync) {
      // defer the callback if we are being called synchronously
      // to avoid piling up things on the stack
      process.nextTick(cb, er); // this can emit finish, and it will always happen
      // after error

      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy$1(stream, er);
    } else {
      // the caller expect this to happen before if
      // it is async
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy$1(stream, er); // this can emit finish, but finish must
      // always follow error

      finishMaybe(stream, state);
    }
  }

  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }

  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK$1();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish(state) || stream.destroyed;

      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }

      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }

  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  } // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.


  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  } // if there's something in the buffer waiting, then process it


  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;

    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;

      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }

      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite

      state.pendingcb++;
      state.lastBufferedRequest = null;

      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }

      state.bufferedRequestCount = 0;
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.

        if (state.writing) {
          break;
        }
      }

      if (entry === null) state.lastBufferedRequest = null;
    }

    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }

  Writable$3.prototype._write = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED$2('_write()'));
  };

  Writable$3.prototype._writev = null;

  Writable$3.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

    if (state.corked) {
      state.corked = 1;
      this.uncork();
    } // ignore unnecessary end() calls.


    if (!state.ending) endWritable(this, state, cb);
    return this;
  };

  Object.defineProperty(Writable$3.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });

  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }

  function callFinal(stream, state) {
    stream._final(function (err) {
      state.pendingcb--;

      if (err) {
        errorOrDestroy$1(stream, err);
      }

      state.prefinished = true;
      stream.emit('prefinish');
      finishMaybe(stream, state);
    });
  }

  function prefinish$1(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === 'function' && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
  }

  function finishMaybe(stream, state) {
    var need = needFinish(state);

    if (need) {
      prefinish$1(stream, state);

      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit('finish');

        if (state.autoDestroy) {
          // In case of duplex streams we need a way to detect
          // if the readable side is ready for autoDestroy as well
          var rState = stream._readableState;

          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }

    return need;
  }

  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);

    if (cb) {
      if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
    }

    state.ended = true;
    stream.writable = false;
  }

  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;

    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    } // reuse the free corkReq.


    state.corkedRequestsFree.next = corkReq;
  }

  Object.defineProperty(Writable$3.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }

      return this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._writableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._writableState.destroyed = value;
    }
  });
  Writable$3.prototype.destroy = destroyImpl$1.destroy;
  Writable$3.prototype._undestroy = destroyImpl$1.undestroy;

  Writable$3.prototype._destroy = function (err, cb) {
    cb(err);
  };

  /*<replacement>*/


  var objectKeys = Object.keys || function (obj) {
    var keys = [];

    for (var key in obj) {
      keys.push(key);
    }

    return keys;
  };
  /*</replacement>*/


  var _stream_duplex = Duplex$4;
  var Readable$1 = _stream_readable;
  var Writable$2 = _stream_writable;
  inherits$d.exports(Duplex$4, Readable$1);
  {
    // Allow the keys array to be GC'ed.
    var keys = objectKeys(Writable$2.prototype);

    for (var v$1 = 0; v$1 < keys.length; v$1++) {
      var method = keys[v$1];
      if (!Duplex$4.prototype[method]) Duplex$4.prototype[method] = Writable$2.prototype[method];
    }
  }

  function Duplex$4(options) {
    if (!(this instanceof Duplex$4)) return new Duplex$4(options);
    Readable$1.call(this, options);
    Writable$2.call(this, options);
    this.allowHalfOpen = true;

    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;

      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once('end', onend);
      }
    }
  }

  Object.defineProperty(Duplex$4.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex$4.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex$4.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  }); // the no-half-open enforcer

  function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return; // no more data can be written.
    // But allow more writes to happen in this tick.

    process.nextTick(onEndNT, this);
  }

  function onEndNT(self) {
    self.end();
  }

  Object.defineProperty(Duplex$4.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }

      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });

  var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;

  function once$1(callback) {
    var called = false;
    return function () {
      if (called) return;
      called = true;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      callback.apply(this, args);
    };
  }

  function noop$3() {}

  function isRequest$1(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
  }

  function eos$1(stream, opts, callback) {
    if (typeof opts === 'function') return eos$1(stream, null, opts);
    if (!opts) opts = {};
    callback = once$1(callback || noop$3);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;

    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable) onfinish();
    };

    var writableEnded = stream._writableState && stream._writableState.finished;

    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };

    var readableEnded = stream._readableState && stream._readableState.endEmitted;

    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };

    var onerror = function onerror(err) {
      callback.call(stream, err);
    };

    var onclose = function onclose() {
      var err;

      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }

      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };

    var onrequest = function onrequest() {
      stream.req.on('finish', onfinish);
    };

    if (isRequest$1(stream)) {
      stream.on('complete', onfinish);
      stream.on('abort', onclose);
      if (stream.req) onrequest();else stream.on('request', onrequest);
    } else if (writable && !stream._writableState) {
      // legacy streams
      stream.on('end', onlegacyfinish);
      stream.on('close', onlegacyfinish);
    }

    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false) stream.on('error', onerror);
    stream.on('close', onclose);
    return function () {
      stream.removeListener('complete', onfinish);
      stream.removeListener('abort', onclose);
      stream.removeListener('request', onrequest);
      if (stream.req) stream.req.removeListener('finish', onfinish);
      stream.removeListener('end', onlegacyfinish);
      stream.removeListener('close', onlegacyfinish);
      stream.removeListener('finish', onfinish);
      stream.removeListener('end', onend);
      stream.removeListener('error', onerror);
      stream.removeListener('close', onclose);
    };
  }

  var endOfStream = eos$1;

  var _Object$setPrototypeO;

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var finished = endOfStream;
  var kLastResolve = Symbol('lastResolve');
  var kLastReject = Symbol('lastReject');
  var kError$2 = Symbol('error');
  var kEnded = Symbol('ended');
  var kLastPromise = Symbol('lastPromise');
  var kHandlePromise = Symbol('handlePromise');
  var kStream = Symbol('stream');

  function createIterResult(value, done) {
    return {
      value: value,
      done: done
    };
  }

  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];

    if (resolve !== null) {
      var data = iter[kStream].read(); // we defer if data is null
      // we can be expecting either 'end' or
      // 'error'

      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }

  function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
  }

  function wrapForNext(lastPromise, iter) {
    return function (resolve, reject) {
      lastPromise.then(function () {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }

        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }

  var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },

    next: function next() {
      var _this = this; // if we have detected an error in the meanwhile
      // reject straight away


      var error = this[kError$2];

      if (error !== null) {
        return Promise.reject(error);
      }

      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }

      if (this[kStream].destroyed) {
        // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function (resolve, reject) {
          process.nextTick(function () {
            if (_this[kError$2]) {
              reject(_this[kError$2]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      } // if we have multiple next() calls
      // we will wait for the previous Promise to finish
      // this logic is optimized to support for await loops,
      // where next() is only called once at a time


      var lastPromise = this[kLastPromise];
      var promise;

      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        // fast path needed to support multiple this.push()
        // without triggering the next() queue
        var data = this[kStream].read();

        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }

        promise = new Promise(this[kHandlePromise]);
      }

      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty$1(_Object$setPrototypeO, Symbol.asyncIterator, function () {
    return this;
  }), _defineProperty$1(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this; // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to


    return new Promise(function (resolve, reject) {
      _this2[kStream].destroy(null, function (err) {
        if (err) {
          reject(err);
          return;
        }

        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);

  var createReadableStreamAsyncIterator$1 = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;

    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty$1(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty$1(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty$1(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty$1(_Object$create, kError$2, {
      value: null,
      writable: true
    }), _defineProperty$1(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty$1(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();

        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function (err) {
      if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
        var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
        // returned by next() and store the error

        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }

        iterator[kError$2] = err;
        return;
      }

      var resolve = iterator[kLastResolve];

      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }

      iterator[kEnded] = true;
    });
    stream.on('readable', onReadable.bind(null, iterator));
    return iterator;
  };

  var async_iterator = createReadableStreamAsyncIterator$1;

  var fromBrowser = function fromBrowser() {
    throw new Error('Readable.from is not available in the browser');
  };

  var _stream_readable = Readable;
  /*<replacement>*/

  var Duplex$3;
  /*</replacement>*/

  Readable.ReadableState = ReadableState;
  /*<replacement>*/

  require$$0__default$3["default"].EventEmitter;

  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  /*</replacement>*/

  /*<replacement>*/


  var Stream = streamBrowser;
  /*</replacement>*/

  var Buffer$e = require$$0__default$1["default"].Buffer;

  var OurUint8Array = commonjsGlobal.Uint8Array || function () {};

  function _uint8ArrayToBuffer(chunk) {
    return Buffer$e.from(chunk);
  }

  function _isUint8Array(obj) {
    return Buffer$e.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  /*<replacement>*/


  var debugUtil = require$$0__default$2["default"];
  var debug;

  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog('stream');
  } else {
    debug = function debug() {};
  }
  /*</replacement>*/


  var BufferList = buffer_list;
  var destroyImpl = destroy_1;
  var _require = state,
      getHighWaterMark = _require.getHighWaterMark;
  var _require$codes$2 = errorsBrowser.codes,
      ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE,
      ERR_STREAM_PUSH_AFTER_EOF = _require$codes$2.ERR_STREAM_PUSH_AFTER_EOF,
      ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.

  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  inherits$d.exports(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

  function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.

    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }

  function ReadableState(options, stream, isDuplex) {
    Duplex$3 = Duplex$3 || _stream_duplex;
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.

    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$3; // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away

    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"

    this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()

    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.

    this.sync = true; // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.

    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true; // Should close be emitted on destroy. Defaults to true.

    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

    this.autoDestroy = !!options.autoDestroy; // has it been destroyed

    this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

    this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;

    if (options.encoding) {
      if (!StringDecoder) StringDecoder = require$$10__default["default"].StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }

  function Readable(options) {
    Duplex$3 = Duplex$3 || _stream_duplex;
    if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5

    var isDuplex = this instanceof Duplex$3;
    this._readableState = new ReadableState(options, this, isDuplex); // legacy

    this.readable = true;

    if (options) {
      if (typeof options.read === 'function') this._read = options.read;
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
    }

    Stream.call(this);
  }

  Object.defineProperty(Readable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }

      return this._readableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._readableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;

  Readable.prototype._destroy = function (err, cb) {
    cb(err);
  }; // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.


  Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;

    if (!state.objectMode) {
      if (typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;

        if (encoding !== state.encoding) {
          chunk = Buffer$e.from(chunk, encoding);
          encoding = '';
        }

        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }

    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  }; // Unshift should *always* be something directly out of read()


  Readable.prototype.unshift = function (chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };

  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug('readableAddChunk', chunk);
    var state = stream._readableState;

    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state, chunk);

      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer$e.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }

        if (addToFront) {
          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;

          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    } // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.


    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }

  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit('data', chunk);
    } else {
      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
      if (state.needReadable) emitReadable(stream);
    }

    maybeReadMore(stream, state);
  }

  function chunkInvalid(state, chunk) {
    var er;

    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
    }

    return er;
  }

  Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  }; // backwards compatibility.


  Readable.prototype.setEncoding = function (enc) {
    if (!StringDecoder) StringDecoder = require$$10__default["default"].StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

    this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

    var p = this._readableState.buffer.head;
    var content = '';

    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }

    this._readableState.buffer.clear();

    if (content !== '') this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  }; // Don't raise the hwm > 1GB


  var MAX_HWM = 0x40000000;

  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
      n = MAX_HWM;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }

    return n;
  } // This function is designed to be inlinable, so please take care when making
  // changes to the function body.


  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;

    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    } // If we're asking for more than the current hwm, then raise the hwm.


    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n; // Don't have enough

    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }

    return state.length;
  } // you can override either this method, or the async _read(n) below.


  Readable.prototype.read = function (n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.

    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
      return null;
    }

    n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.


    var doRead = state.needReadable;
    debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug('length less than watermark', doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.


    if (state.ended || state.reading) {
      doRead = false;
      debug('reading or ended', doRead);
    } else if (doRead) {
      debug('do read');
      state.reading = true;
      state.sync = true; // if the length is currently zero, then we *need* a readable event.

      if (state.length === 0) state.needReadable = true; // call internal read method

      this._read(state.highWaterMark);

      state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.

      if (!state.reading) n = howMuchToRead(nOrig, state);
    }

    var ret;
    if (n > 0) ret = fromList(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

      if (nOrig !== n && state.ended) endReadable(this);
    }

    if (ret !== null) this.emit('data', ret);
    return ret;
  };

  function onEofChunk(stream, state) {
    debug('onEofChunk');
    if (state.ended) return;

    if (state.decoder) {
      var chunk = state.decoder.end();

      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }

    state.ended = true;

    if (state.sync) {
      // if we are sync, wait until next tick to emit the data.
      // Otherwise we risk emitting data in the flow()
      // the readable code triggers during a read() call
      emitReadable(stream);
    } else {
      // emit 'readable' now to make sure it gets picked up.
      state.needReadable = false;

      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  } // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.


  function emitReadable(stream) {
    var state = stream._readableState;
    debug('emitReadable', state.needReadable, state.emittedReadable);
    state.needReadable = false;

    if (!state.emittedReadable) {
      debug('emitReadable', state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }

  function emitReadable_(stream) {
    var state = stream._readableState;
    debug('emitReadable_', state.destroyed, state.length, state.ended);

    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit('readable');
      state.emittedReadable = false;
    } // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.


    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  } // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.


  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }

  function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length) // didn't get any data, stop spinning.
        break;
    }

    state.readingMore = false;
  } // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.


  Readable.prototype._read = function (n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED$1('_read()'));
  };

  Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;

      case 1:
        state.pipes = [state.pipes, dest];
        break;

      default:
        state.pipes.push(dest);
        break;
    }

    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
    dest.on('unpipe', onunpipe);

    function onunpipe(readable, unpipeInfo) {
      debug('onunpipe');

      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }

    function onend() {
      debug('onend');
      dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.


    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;

    function cleanup() {
      debug('cleanup'); // cleanup event handlers once the pipe is broken

      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', unpipe);
      src.removeListener('data', ondata);
      cleanedUp = true; // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.

      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }

    src.on('data', ondata);

    function ondata(chunk) {
      debug('ondata');
      var ret = dest.write(chunk);
      debug('dest.write', ret);

      if (ret === false) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug('false write response, pause', state.awaitDrain);
          state.awaitDrain++;
        }

        src.pause();
      }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.


    function onerror(er) {
      debug('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
    } // Make sure our error handler is attached before userland ones.


    prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }

    dest.once('close', onclose);

    function onfinish() {
      debug('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }

    dest.once('finish', onfinish);

    function unpipe() {
      debug('unpipe');
      src.unpipe(dest);
    } // tell the dest that it's being piped to


    dest.emit('pipe', src); // start the flow if it hasn't been started already.

    if (!state.flowing) {
      debug('pipe resume');
      src.resume();
    }

    return dest;
  };

  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;

      if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
        state.flowing = true;
        flow(src);
      }
    };
  }

  Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    }; // if we're not piping anywhere, then do nothing.

    if (state.pipesCount === 0) return this; // just one destination.  most common case.

    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes; // got a match.

      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this, unpipeInfo);
      return this;
    } // slow case. multiple pipe destinations.


    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var i = 0; i < len; i++) {
        dests[i].emit('unpipe', this, {
          hasUnpiped: false
        });
      }

      return this;
    } // try to find the right one.


    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit('unpipe', this, unpipeInfo);
    return this;
  }; // set up data events if they are asked for
  // Ensure readable listeners eventually get something


  Readable.prototype.on = function (ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;

    if (ev === 'data') {
      // update readableListening so that resume() may be a no-op
      // a few lines down. This is needed to support once('readable').
      state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

      if (state.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug('on readable', state.length, state.reading);

        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }

    return res;
  };

  Readable.prototype.addListener = Readable.prototype.on;

  Readable.prototype.removeListener = function (ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);

    if (ev === 'readable') {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      process.nextTick(updateReadableListening, this);
    }

    return res;
  };

  Readable.prototype.removeAllListeners = function (ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);

    if (ev === 'readable' || ev === undefined) {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      process.nextTick(updateReadableListening, this);
    }

    return res;
  };

  function updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount('readable') > 0;

    if (state.resumeScheduled && !state.paused) {
      // flowing needs to be set to true now, otherwise
      // the upcoming resume will not flow.
      state.flowing = true; // crude way to check if we should resume
    } else if (self.listenerCount('data') > 0) {
      self.resume();
    }
  }

  function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
  } // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.


  Readable.prototype.resume = function () {
    var state = this._readableState;

    if (!state.flowing) {
      debug('resume'); // we flow only if there is no one listening
      // for readable, but we still have to call
      // resume()

      state.flowing = !state.readableListening;
      resume$1(this, state);
    }

    state.paused = false;
    return this;
  };

  function resume$1(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }

  function resume_(stream, state) {
    debug('resume', state.reading);

    if (!state.reading) {
      stream.read(0);
    }

    state.resumeScheduled = false;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }

  Readable.prototype.pause = function () {
    debug('call pause flowing=%j', this._readableState.flowing);

    if (this._readableState.flowing !== false) {
      debug('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }

    this._readableState.paused = true;
    return this;
  };

  function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);

    while (state.flowing && stream.read() !== null) {
    }
  } // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.


  Readable.prototype.wrap = function (stream) {
    var _this = this;

    var state = this._readableState;
    var paused = false;
    stream.on('end', function () {
      debug('wrapped end');

      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }

      _this.push(null);
    });
    stream.on('data', function (chunk) {
      debug('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

      var ret = _this.push(chunk);

      if (!ret) {
        paused = true;
        stream.pause();
      }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.

    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    } // proxy certain important events.


    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    } // when we try to consume some more bytes, simply unpause the
    // underlying stream.


    this._read = function (n) {
      debug('wrapped _read', n);

      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return this;
  };

  if (typeof Symbol === 'function') {
    Readable.prototype[Symbol.asyncIterator] = function () {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = async_iterator;
      }

      return createReadableStreamAsyncIterator(this);
    };
  }

  Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, 'readableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, 'readableFlowing', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  }); // exposed for testing purposes only.

  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, 'readableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  }); // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.

  function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }

  function endReadable(stream) {
    var state = stream._readableState;
    debug('endReadable', state.endEmitted);

    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }

  function endReadableNT(state, stream) {
    debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the writable side is ready for autoDestroy as well
        var wState = stream._writableState;

        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }

  if (typeof Symbol === 'function') {
    Readable.from = function (iterable, opts) {
      if (from === undefined) {
        from = fromBrowser;
      }

      return from(Readable, iterable, opts);
    };
  }

  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }

    return -1;
  }

  var _stream_transform = Transform$2;
  var _require$codes$1 = errorsBrowser.codes,
      ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK,
      ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING,
      ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex$2 = _stream_duplex;
  inherits$d.exports(Transform$2, Duplex$2);

  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;

    if (cb === null) {
      return this.emit('error', new ERR_MULTIPLE_CALLBACK());
    }

    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;

    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }

  function Transform$2(options) {
    if (!(this instanceof Transform$2)) return new Transform$2(options);
    Duplex$2.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }; // start out asking for a readable event once data is transformed.

    this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.

    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;
      if (typeof options.flush === 'function') this._flush = options.flush;
    } // When the writable side finishes, then flush out anything remaining.


    this.on('prefinish', prefinish);
  }

  function prefinish() {
    var _this = this;

    if (typeof this._flush === 'function' && !this._readableState.destroyed) {
      this._flush(function (er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }

  Transform$2.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex$2.prototype.push.call(this, chunk, encoding);
  }; // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.


  Transform$2.prototype._transform = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
  };

  Transform$2.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;

    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  }; // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.


  Transform$2.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;

      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  Transform$2.prototype._destroy = function (err, cb) {
    Duplex$2.prototype._destroy.call(this, err, function (err2) {
      cb(err2);
    });
  };

  function done(stream, er, data) {
    if (er) return stream.emit('error', er);
    if (data != null) // single equals check for both `null` and `undefined`
      stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided

    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }

  var _stream_passthrough = PassThrough;
  var Transform$1 = _stream_transform;
  inherits$d.exports(PassThrough, Transform$1);

  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform$1.call(this, options);
  }

  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  var eos;

  function once(callback) {
    var called = false;
    return function () {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }

  var _require$codes = errorsBrowser.codes,
      ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

  function noop$2(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
  }

  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
  }

  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on('close', function () {
      closed = true;
    });
    if (eos === undefined) eos = endOfStream;
    eos(stream, {
      readable: reading,
      writable: writing
    }, function (err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function (err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true; // request.destroy just do .end - .abort is what we want

      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === 'function') return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED('pipe'));
    };
  }

  function call(fn) {
    fn();
  }

  function pipe(from, to) {
    return from.pipe(to);
  }

  function popCallback(streams) {
    if (!streams.length) return noop$2;
    if (typeof streams[streams.length - 1] !== 'function') return noop$2;
    return streams.pop();
  }

  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }

    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];

    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS('streams');
    }

    var error;
    var destroys = streams.map(function (stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function (err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }

  var pipeline_1 = pipeline;

  (function (module, exports) {
    exports = module.exports = _stream_readable;
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = _stream_writable;
    exports.Duplex = _stream_duplex;
    exports.Transform = _stream_transform;
    exports.PassThrough = _stream_passthrough;
    exports.finished = endOfStream;
    exports.pipeline = pipeline_1;
  })(readableBrowser, readableBrowser.exports);

  var Buffer$d = safeBuffer.exports.Buffer;
  var Transform = readableBrowser.exports.Transform;
  var inherits$8 = inherits$d.exports;

  function throwIfNotStringOrBuffer(val, prefix) {
    if (!Buffer$d.isBuffer(val) && typeof val !== 'string') {
      throw new TypeError(prefix + ' must be a string or a buffer');
    }
  }

  function HashBase$2(blockSize) {
    Transform.call(this);
    this._block = Buffer$d.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [0, 0, 0, 0];
    this._finalized = false;
  }

  inherits$8(HashBase$2, Transform);

  HashBase$2.prototype._transform = function (chunk, encoding, callback) {
    var error = null;

    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }

    callback(error);
  };

  HashBase$2.prototype._flush = function (callback) {
    var error = null;

    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }

    callback(error);
  };

  HashBase$2.prototype.update = function (data, encoding) {
    throwIfNotStringOrBuffer(data, 'Data');
    if (this._finalized) throw new Error('Digest already called');
    if (!Buffer$d.isBuffer(data)) data = Buffer$d.from(data, encoding); // consume data

    var block = this._block;
    var offset = 0;

    while (this._blockOffset + data.length - offset >= this._blockSize) {
      for (var i = this._blockOffset; i < this._blockSize;) {
        block[i++] = data[offset++];
      }

      this._update();

      this._blockOffset = 0;
    }

    while (offset < data.length) {
      block[this._blockOffset++] = data[offset++];
    } // update length


    for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
      this._length[j] += carry;
      carry = this._length[j] / 0x0100000000 | 0;
      if (carry > 0) this._length[j] -= 0x0100000000 * carry;
    }

    return this;
  };

  HashBase$2.prototype._update = function () {
    throw new Error('_update is not implemented');
  };

  HashBase$2.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error('Digest already called');
    this._finalized = true;

    var digest = this._digest();

    if (encoding !== undefined) digest = digest.toString(encoding); // reset state

    this._block.fill(0);

    this._blockOffset = 0;

    for (var i = 0; i < 4; ++i) {
      this._length[i] = 0;
    }

    return digest;
  };

  HashBase$2.prototype._digest = function () {
    throw new Error('_digest is not implemented');
  };

  var hashBase = HashBase$2;

  var inherits$7 = inherits$d.exports;
  var HashBase$1 = hashBase;
  var Buffer$c = safeBuffer.exports.Buffer;
  var ARRAY16$1 = new Array(16);

  function MD5$1() {
    HashBase$1.call(this, 64); // state

    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
  }

  inherits$7(MD5$1, HashBase$1);

  MD5$1.prototype._update = function () {
    var M = ARRAY16$1;

    for (var i = 0; i < 16; ++i) {
      M[i] = this._block.readInt32LE(i * 4);
    }

    var a = this._a;
    var b = this._b;
    var c = this._c;
    var d = this._d;
    a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
    d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
    c = fnF(c, d, a, b, M[2], 0x242070db, 17);
    b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
    a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
    d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
    c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
    b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
    a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
    d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
    c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
    b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
    a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
    d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
    c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
    b = fnF(b, c, d, a, M[15], 0x49b40821, 22);
    a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
    d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
    c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
    b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
    a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
    d = fnG(d, a, b, c, M[10], 0x02441453, 9);
    c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
    b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
    a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
    d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
    c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
    b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
    a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
    d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
    c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
    b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);
    a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
    d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
    c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
    b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
    a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
    d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
    c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
    b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
    a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
    d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
    c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
    b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
    a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
    d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
    c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
    b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);
    a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
    d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
    c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
    b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
    a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
    d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
    c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
    b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
    a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
    d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
    c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
    b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
    a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
    d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
    c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
    b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);
    this._a = this._a + a | 0;
    this._b = this._b + b | 0;
    this._c = this._c + c | 0;
    this._d = this._d + d | 0;
  };

  MD5$1.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80;

    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);

      this._update();

      this._blockOffset = 0;
    }

    this._block.fill(0, this._blockOffset, 56);

    this._block.writeUInt32LE(this._length[0], 56);

    this._block.writeUInt32LE(this._length[1], 60);

    this._update(); // produce result


    var buffer = Buffer$c.allocUnsafe(16);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    return buffer;
  };

  function rotl$1(x, n) {
    return x << n | x >>> 32 - n;
  }

  function fnF(a, b, c, d, m, k, s) {
    return rotl$1(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
  }

  function fnG(a, b, c, d, m, k, s) {
    return rotl$1(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
  }

  function fnH(a, b, c, d, m, k, s) {
    return rotl$1(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
  }

  function fnI(a, b, c, d, m, k, s) {
    return rotl$1(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
  }

  var md5_js = MD5$1;

  var MD5 = md5_js;

  var md5$1 = function md5(buffer) {
    return new MD5().update(buffer).digest();
  };

  var Buffer$b = require$$0__default$1["default"].Buffer;
  var inherits$6 = inherits$d.exports;
  var HashBase = hashBase;
  var ARRAY16 = new Array(16);
  var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
  var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

  function RIPEMD160$1() {
    HashBase.call(this, 64); // state

    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
  }

  inherits$6(RIPEMD160$1, HashBase);

  RIPEMD160$1.prototype._update = function () {
    var words = ARRAY16;

    for (var j = 0; j < 16; ++j) {
      words[j] = this._block.readInt32LE(j * 4);
    }

    var al = this._a | 0;
    var bl = this._b | 0;
    var cl = this._c | 0;
    var dl = this._d | 0;
    var el = this._e | 0;
    var ar = this._a | 0;
    var br = this._b | 0;
    var cr = this._c | 0;
    var dr = this._d | 0;
    var er = this._e | 0; // computation

    for (var i = 0; i < 80; i += 1) {
      var tl;
      var tr;

      if (i < 16) {
        tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
        tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
      } else if (i < 32) {
        tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
        tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
      } else if (i < 48) {
        tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
        tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
      } else if (i < 64) {
        tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
        tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
      } else {
        // if (i<80) {
        tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
        tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
      }

      al = el;
      el = dl;
      dl = rotl(cl, 10);
      cl = bl;
      bl = tl;
      ar = er;
      er = dr;
      dr = rotl(cr, 10);
      cr = br;
      br = tr;
    } // update state


    var t = this._b + cl + dr | 0;
    this._b = this._c + dl + er | 0;
    this._c = this._d + el + ar | 0;
    this._d = this._e + al + br | 0;
    this._e = this._a + bl + cr | 0;
    this._a = t;
  };

  RIPEMD160$1.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80;

    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);

      this._update();

      this._blockOffset = 0;
    }

    this._block.fill(0, this._blockOffset, 56);

    this._block.writeUInt32LE(this._length[0], 56);

    this._block.writeUInt32LE(this._length[1], 60);

    this._update(); // produce result


    var buffer = Buffer$b.alloc ? Buffer$b.alloc(20) : new Buffer$b(20);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    buffer.writeInt32LE(this._e, 16);
    return buffer;
  };

  function rotl(x, n) {
    return x << n | x >>> 32 - n;
  }

  function fn1(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
  }

  function fn2(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
  }

  function fn3(a, b, c, d, e, m, k, s) {
    return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
  }

  function fn4(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
  }

  function fn5(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
  }

  var ripemd160$1 = RIPEMD160$1;

  var sha_js = {exports: {}};

  var Buffer$a = safeBuffer.exports.Buffer; // prototype class for hash functions

  function Hash$6(blockSize, finalSize) {
    this._block = Buffer$a.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
  }

  Hash$6.prototype.update = function (data, enc) {
    if (typeof data === 'string') {
      enc = enc || 'utf8';
      data = Buffer$a.from(data, enc);
    }

    var block = this._block;
    var blockSize = this._blockSize;
    var length = data.length;
    var accum = this._len;

    for (var offset = 0; offset < length;) {
      var assigned = accum % blockSize;
      var remainder = Math.min(length - offset, blockSize - assigned);

      for (var i = 0; i < remainder; i++) {
        block[assigned + i] = data[offset + i];
      }

      accum += remainder;
      offset += remainder;

      if (accum % blockSize === 0) {
        this._update(block);
      }
    }

    this._len += length;
    return this;
  };

  Hash$6.prototype.digest = function (enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 0x80; // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
    // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize

    this._block.fill(0, rem + 1);

    if (rem >= this._finalSize) {
      this._update(this._block);

      this._block.fill(0);
    }

    var bits = this._len * 8; // uint32

    if (bits <= 0xffffffff) {
      this._block.writeUInt32BE(bits, this._blockSize - 4); // uint64

    } else {
      var lowBits = (bits & 0xffffffff) >>> 0;
      var highBits = (bits - lowBits) / 0x100000000;

      this._block.writeUInt32BE(highBits, this._blockSize - 8);

      this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }

    this._update(this._block);

    var hash = this._hash();

    return enc ? hash.toString(enc) : hash;
  };

  Hash$6.prototype._update = function () {
    throw new Error('_update must be implemented by subclass');
  };

  var hash$1 = Hash$6;

  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
   * in FIPS PUB 180-1
   * This source code is derived from sha1.js of the same repository.
   * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
   * operation was added.
   */
  var inherits$5 = inherits$d.exports;
  var Hash$5 = hash$1;
  var Buffer$9 = safeBuffer.exports.Buffer;
  var K$4 = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
  var W$6 = new Array(80);

  function Sha() {
    this.init();
    this._w = W$6;
    Hash$5.call(this, 64, 56);
  }

  inherits$5(Sha, Hash$5);

  Sha.prototype.init = function () {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
  };

  function rotl5$1(num) {
    return num << 5 | num >>> 27;
  }

  function rotl30$1(num) {
    return num << 30 | num >>> 2;
  }

  function ft$1(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }

  Sha.prototype._update = function (M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;

    for (var i = 0; i < 16; ++i) {
      W[i] = M.readInt32BE(i * 4);
    }

    for (; i < 80; ++i) {
      W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
    }

    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5$1(a) + ft$1(s, b, c, d) + e + W[j] + K$4[s] | 0;
      e = d;
      d = c;
      c = rotl30$1(b);
      b = a;
      a = t;
    }

    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };

  Sha.prototype._hash = function () {
    var H = Buffer$9.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };

  var sha$1 = Sha;

  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
   * in FIPS PUB 180-1
   * Version 2.1a Copyright Paul Johnston 2000 - 2002.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   * Distributed under the BSD License
   * See http://pajhome.org.uk/crypt/md5 for details.
   */
  var inherits$4 = inherits$d.exports;
  var Hash$4 = hash$1;
  var Buffer$8 = safeBuffer.exports.Buffer;
  var K$3 = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
  var W$5 = new Array(80);

  function Sha1() {
    this.init();
    this._w = W$5;
    Hash$4.call(this, 64, 56);
  }

  inherits$4(Sha1, Hash$4);

  Sha1.prototype.init = function () {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
  };

  function rotl1(num) {
    return num << 1 | num >>> 31;
  }

  function rotl5(num) {
    return num << 5 | num >>> 27;
  }

  function rotl30(num) {
    return num << 30 | num >>> 2;
  }

  function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }

  Sha1.prototype._update = function (M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;

    for (var i = 0; i < 16; ++i) {
      W[i] = M.readInt32BE(i * 4);
    }

    for (; i < 80; ++i) {
      W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
    }

    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K$3[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t;
    }

    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };

  Sha1.prototype._hash = function () {
    var H = Buffer$8.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };

  var sha1 = Sha1;

  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */
  var inherits$3 = inherits$d.exports;
  var Hash$3 = hash$1;
  var Buffer$7 = safeBuffer.exports.Buffer;
  var K$2 = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
  var W$4 = new Array(64);

  function Sha256$1() {
    this.init();
    this._w = W$4; // new Array(64)

    Hash$3.call(this, 64, 56);
  }

  inherits$3(Sha256$1, Hash$3);

  Sha256$1.prototype.init = function () {
    this._a = 0x6a09e667;
    this._b = 0xbb67ae85;
    this._c = 0x3c6ef372;
    this._d = 0xa54ff53a;
    this._e = 0x510e527f;
    this._f = 0x9b05688c;
    this._g = 0x1f83d9ab;
    this._h = 0x5be0cd19;
    return this;
  };

  function ch(x, y, z) {
    return z ^ x & (y ^ z);
  }

  function maj$1(x, y, z) {
    return x & y | z & (x | y);
  }

  function sigma0$1(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }

  function sigma1$1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }

  function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }

  function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }

  Sha256$1.prototype._update = function (M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f = this._f | 0;
    var g = this._g | 0;
    var h = this._h | 0;

    for (var i = 0; i < 16; ++i) {
      W[i] = M.readInt32BE(i * 4);
    }

    for (; i < 64; ++i) {
      W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
    }

    for (var j = 0; j < 64; ++j) {
      var T1 = h + sigma1$1(e) + ch(e, f, g) + K$2[j] + W[j] | 0;
      var T2 = sigma0$1(a) + maj$1(a, b, c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + T1 | 0;
      d = c;
      c = b;
      b = a;
      a = T1 + T2 | 0;
    }

    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f + this._f | 0;
    this._g = g + this._g | 0;
    this._h = h + this._h | 0;
  };

  Sha256$1.prototype._hash = function () {
    var H = Buffer$7.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
  };

  var sha256$1 = Sha256$1;

  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */
  var inherits$2 = inherits$d.exports;
  var Sha256 = sha256$1;
  var Hash$2 = hash$1;
  var Buffer$6 = safeBuffer.exports.Buffer;
  var W$3 = new Array(64);

  function Sha224() {
    this.init();
    this._w = W$3; // new Array(64)

    Hash$2.call(this, 64, 56);
  }

  inherits$2(Sha224, Sha256);

  Sha224.prototype.init = function () {
    this._a = 0xc1059ed8;
    this._b = 0x367cd507;
    this._c = 0x3070dd17;
    this._d = 0xf70e5939;
    this._e = 0xffc00b31;
    this._f = 0x68581511;
    this._g = 0x64f98fa7;
    this._h = 0xbefa4fa4;
    return this;
  };

  Sha224.prototype._hash = function () {
    var H = Buffer$6.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
  };

  var sha224 = Sha224;

  var inherits$1 = inherits$d.exports;
  var Hash$1 = hash$1;
  var Buffer$5 = safeBuffer.exports.Buffer;
  var K$1 = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
  var W$2 = new Array(160);

  function Sha512() {
    this.init();
    this._w = W$2;
    Hash$1.call(this, 128, 112);
  }

  inherits$1(Sha512, Hash$1);

  Sha512.prototype.init = function () {
    this._ah = 0x6a09e667;
    this._bh = 0xbb67ae85;
    this._ch = 0x3c6ef372;
    this._dh = 0xa54ff53a;
    this._eh = 0x510e527f;
    this._fh = 0x9b05688c;
    this._gh = 0x1f83d9ab;
    this._hh = 0x5be0cd19;
    this._al = 0xf3bcc908;
    this._bl = 0x84caa73b;
    this._cl = 0xfe94f82b;
    this._dl = 0x5f1d36f1;
    this._el = 0xade682d1;
    this._fl = 0x2b3e6c1f;
    this._gl = 0xfb41bd6b;
    this._hl = 0x137e2179;
    return this;
  };

  function Ch(x, y, z) {
    return z ^ x & (y ^ z);
  }

  function maj(x, y, z) {
    return x & y | z & (x | y);
  }

  function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
  }

  function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
  }

  function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
  }

  function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
  }

  function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
  }

  function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
  }

  function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
  }

  Sha512.prototype._update = function (M) {
    var W = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;

    for (var i = 0; i < 32; i += 2) {
      W[i] = M.readInt32BE(i * 4);
      W[i + 1] = M.readInt32BE(i * 4 + 4);
    }

    for (; i < 160; i += 2) {
      var xh = W[i - 15 * 2];
      var xl = W[i - 15 * 2 + 1];
      var gamma0 = Gamma0(xh, xl);
      var gamma0l = Gamma0l(xl, xh);
      xh = W[i - 2 * 2];
      xl = W[i - 2 * 2 + 1];
      var gamma1 = Gamma1(xh, xl);
      var gamma1l = Gamma1l(xl, xh); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]

      var Wi7h = W[i - 7 * 2];
      var Wi7l = W[i - 7 * 2 + 1];
      var Wi16h = W[i - 16 * 2];
      var Wi16l = W[i - 16 * 2 + 1];
      var Wil = gamma0l + Wi7l | 0;
      var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
      Wil = Wil + gamma1l | 0;
      Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
      Wil = Wil + Wi16l | 0;
      Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
      W[i] = Wih;
      W[i + 1] = Wil;
    }

    for (var j = 0; j < 160; j += 2) {
      Wih = W[j];
      Wil = W[j + 1];
      var majh = maj(ah, bh, ch);
      var majl = maj(al, bl, cl);
      var sigma0h = sigma0(ah, al);
      var sigma0l = sigma0(al, ah);
      var sigma1h = sigma1(eh, el);
      var sigma1l = sigma1(el, eh); // t1 = h + sigma1 + ch + K[j] + W[j]

      var Kih = K$1[j];
      var Kil = K$1[j + 1];
      var chh = Ch(eh, fh, gh);
      var chl = Ch(el, fl, gl);
      var t1l = hl + sigma1l | 0;
      var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
      t1l = t1l + chl | 0;
      t1h = t1h + chh + getCarry(t1l, chl) | 0;
      t1l = t1l + Kil | 0;
      t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
      t1l = t1l + Wil | 0;
      t1h = t1h + Wih + getCarry(t1l, Wil) | 0; // t2 = sigma0 + maj

      var t2l = sigma0l + majl | 0;
      var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = dl + t1l | 0;
      eh = dh + t1h + getCarry(el, dl) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = t1l + t2l | 0;
      ah = t1h + t2h + getCarry(al, t1l) | 0;
    }

    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
  };

  Sha512.prototype._hash = function () {
    var H = Buffer$5.allocUnsafe(64);

    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }

    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
  };

  var sha512$1 = Sha512;

  var inherits = inherits$d.exports;
  var SHA512 = sha512$1;
  var Hash = hash$1;
  var Buffer$4 = safeBuffer.exports.Buffer;
  var W$1 = new Array(160);

  function Sha384() {
    this.init();
    this._w = W$1;
    Hash.call(this, 128, 112);
  }

  inherits(Sha384, SHA512);

  Sha384.prototype.init = function () {
    this._ah = 0xcbbb9d5d;
    this._bh = 0x629a292a;
    this._ch = 0x9159015a;
    this._dh = 0x152fecd8;
    this._eh = 0x67332667;
    this._fh = 0x8eb44a87;
    this._gh = 0xdb0c2e0d;
    this._hh = 0x47b5481d;
    this._al = 0xc1059ed8;
    this._bl = 0x367cd507;
    this._cl = 0x3070dd17;
    this._dl = 0xf70e5939;
    this._el = 0xffc00b31;
    this._fl = 0x68581511;
    this._gl = 0x64f98fa7;
    this._hl = 0xbefa4fa4;
    return this;
  };

  Sha384.prototype._hash = function () {
    var H = Buffer$4.allocUnsafe(48);

    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }

    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
  };

  var sha384 = Sha384;

  var exports$1 = sha_js.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports$1[algorithm];
    if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');
    return new Algorithm();
  };

  exports$1.sha = sha$1;
  exports$1.sha1 = sha1;
  exports$1.sha224 = sha224;
  exports$1.sha256 = sha256$1;
  exports$1.sha384 = sha384;
  exports$1.sha512 = sha512$1;

  var Buffer$3 = safeBuffer.exports.Buffer;

  var toBuffer$8 = function toBuffer(thing, encoding, name) {
    if (Buffer$3.isBuffer(thing)) {
      return thing;
    } else if (typeof thing === 'string') {
      return Buffer$3.from(thing, encoding);
    } else if (ArrayBuffer.isView(thing)) {
      return Buffer$3.from(thing.buffer);
    } else {
      throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView');
    }
  };

  var md5 = md5$1;
  var RIPEMD160 = ripemd160$1;
  var sha = sha_js.exports;
  var Buffer$2 = safeBuffer.exports.Buffer;
  var checkParameters$1 = precondition;
  var defaultEncoding$1 = defaultEncoding_1;
  var toBuffer$7 = toBuffer$8;
  var ZEROS = Buffer$2.alloc(128);
  var sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };

  function Hmac(alg, key, saltLen) {
    var hash = getDigest(alg);
    var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;

    if (key.length > blocksize) {
      key = hash(key);
    } else if (key.length < blocksize) {
      key = Buffer$2.concat([key, ZEROS], blocksize);
    }

    var ipad = Buffer$2.allocUnsafe(blocksize + sizes[alg]);
    var opad = Buffer$2.allocUnsafe(blocksize + sizes[alg]);

    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 0x36;
      opad[i] = key[i] ^ 0x5C;
    }

    var ipad1 = Buffer$2.allocUnsafe(blocksize + saltLen + 4);
    ipad.copy(ipad1, 0, 0, blocksize);
    this.ipad1 = ipad1;
    this.ipad2 = ipad;
    this.opad = opad;
    this.alg = alg;
    this.blocksize = blocksize;
    this.hash = hash;
    this.size = sizes[alg];
  }

  Hmac.prototype.run = function (data, ipad) {
    data.copy(ipad, this.blocksize);
    var h = this.hash(ipad);
    h.copy(this.opad, this.blocksize);
    return this.hash(this.opad);
  };

  function getDigest(alg) {
    function shaFunc(data) {
      return sha(alg).update(data).digest();
    }

    function rmd160Func(data) {
      return new RIPEMD160().update(data).digest();
    }

    if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func;
    if (alg === 'md5') return md5;
    return shaFunc;
  }

  function pbkdf2(password, salt, iterations, keylen, digest) {
    checkParameters$1(iterations, keylen);
    password = toBuffer$7(password, defaultEncoding$1, 'Password');
    salt = toBuffer$7(salt, defaultEncoding$1, 'Salt');
    digest = digest || 'sha1';
    var hmac = new Hmac(digest, password, salt.length);
    var DK = Buffer$2.allocUnsafe(keylen);
    var block1 = Buffer$2.allocUnsafe(salt.length + 4);
    salt.copy(block1, 0, 0, salt.length);
    var destPos = 0;
    var hLen = sizes[digest];
    var l = Math.ceil(keylen / hLen);

    for (var i = 1; i <= l; i++) {
      block1.writeUInt32BE(i, salt.length);
      var T = hmac.run(block1, hmac.ipad1);
      var U = T;

      for (var j = 1; j < iterations; j++) {
        U = hmac.run(U, hmac.ipad2);

        for (var k = 0; k < hLen; k++) {
          T[k] ^= U[k];
        }
      }

      T.copy(DK, destPos);
      destPos += hLen;
    }

    return DK;
  }

  var syncBrowser = pbkdf2;

  var Buffer$1 = safeBuffer.exports.Buffer;
  var checkParameters = precondition;
  var defaultEncoding = defaultEncoding_1;
  var sync = syncBrowser;
  var toBuffer$6 = toBuffer$8;
  var ZERO_BUF;
  var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;
  var toBrowser = {
    sha: 'SHA-1',
    'sha-1': 'SHA-1',
    sha1: 'SHA-1',
    sha256: 'SHA-256',
    'sha-256': 'SHA-256',
    sha384: 'SHA-384',
    'sha-384': 'SHA-384',
    'sha-512': 'SHA-512',
    sha512: 'SHA-512'
  };
  var checks = [];

  function checkNative(algo) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser) {
      return Promise.resolve(false);
    }

    if (!subtle || !subtle.importKey || !subtle.deriveBits) {
      return Promise.resolve(false);
    }

    if (checks[algo] !== undefined) {
      return checks[algo];
    }

    ZERO_BUF = ZERO_BUF || Buffer$1.alloc(8);
    var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function () {
      return true;
    }).catch(function () {
      return false;
    });
    checks[algo] = prom;
    return prom;
  }

  var nextTick;

  function getNextTick() {
    if (nextTick) {
      return nextTick;
    }

    if (commonjsGlobal.process && commonjsGlobal.process.nextTick) {
      nextTick = commonjsGlobal.process.nextTick;
    } else if (commonjsGlobal.queueMicrotask) {
      nextTick = commonjsGlobal.queueMicrotask;
    } else if (commonjsGlobal.setImmediate) {
      nextTick = commonjsGlobal.setImmediate;
    } else {
      nextTick = commonjsGlobal.setTimeout;
    }

    return nextTick;
  }

  function browserPbkdf2(password, salt, iterations, length, algo) {
    return subtle.importKey('raw', password, {
      name: 'PBKDF2'
    }, false, ['deriveBits']).then(function (key) {
      return subtle.deriveBits({
        name: 'PBKDF2',
        salt: salt,
        iterations: iterations,
        hash: {
          name: algo
        }
      }, key, length << 3);
    }).then(function (res) {
      return Buffer$1.from(res);
    });
  }

  function resolvePromise(promise, callback) {
    promise.then(function (out) {
      getNextTick()(function () {
        callback(null, out);
      });
    }, function (e) {
      getNextTick()(function () {
        callback(e);
      });
    });
  }

  var async = function async(password, salt, iterations, keylen, digest, callback) {
    if (typeof digest === 'function') {
      callback = digest;
      digest = undefined;
    }

    digest = digest || 'sha1';
    var algo = toBrowser[digest.toLowerCase()];

    if (!algo || typeof commonjsGlobal.Promise !== 'function') {
      getNextTick()(function () {
        var out;

        try {
          out = sync(password, salt, iterations, keylen, digest);
        } catch (e) {
          return callback(e);
        }

        callback(null, out);
      });
      return;
    }

    checkParameters(iterations, keylen);
    password = toBuffer$6(password, defaultEncoding, 'Password');
    salt = toBuffer$6(salt, defaultEncoding, 'Salt');
    if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2');
    resolvePromise(checkNative(algo).then(function (resp) {
      if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);
      return sync(password, salt, iterations, keylen, digest);
    }), callback);
  };

  browser$2.pbkdf2 = async;
  browser$2.pbkdf2Sync = syncBrowser;

  var randombytes = require$$0__default["default"].randomBytes;

  var _wordlists = {};

  var require$$0$2 = ["abdikace", "abeceda", "adresa", "agrese", "akce", "aktovka", "alej", "alkohol", "amputace", "ananas", "andulka", "anekdota", "anketa", "antika", "anulovat", "archa", "arogance", "asfalt", "asistent", "aspirace", "astma", "astronom", "atlas", "atletika", "atol", "autobus", "azyl", "babka", "bachor", "bacil", "baculka", "badatel", "bageta", "bagr", "bahno", "bakterie", "balada", "baletka", "balkon", "balonek", "balvan", "balza", "bambus", "bankomat", "barbar", "baret", "barman", "baroko", "barva", "baterka", "batoh", "bavlna", "bazalka", "bazilika", "bazuka", "bedna", "beran", "beseda", "bestie", "beton", "bezinka", "bezmoc", "beztak", "bicykl", "bidlo", "biftek", "bikiny", "bilance", "biograf", "biolog", "bitva", "bizon", "blahobyt", "blatouch", "blecha", "bledule", "blesk", "blikat", "blizna", "blokovat", "bloudit", "blud", "bobek", "bobr", "bodlina", "bodnout", "bohatost", "bojkot", "bojovat", "bokorys", "bolest", "borec", "borovice", "bota", "boubel", "bouchat", "bouda", "boule", "bourat", "boxer", "bradavka", "brambora", "branka", "bratr", "brepta", "briketa", "brko", "brloh", "bronz", "broskev", "brunetka", "brusinka", "brzda", "brzy", "bublina", "bubnovat", "buchta", "buditel", "budka", "budova", "bufet", "bujarost", "bukvice", "buldok", "bulva", "bunda", "bunkr", "burza", "butik", "buvol", "buzola", "bydlet", "bylina", "bytovka", "bzukot", "capart", "carevna", "cedr", "cedule", "cejch", "cejn", "cela", "celer", "celkem", "celnice", "cenina", "cennost", "cenovka", "centrum", "cenzor", "cestopis", "cetka", "chalupa", "chapadlo", "charita", "chata", "chechtat", "chemie", "chichot", "chirurg", "chlad", "chleba", "chlubit", "chmel", "chmura", "chobot", "chochol", "chodba", "cholera", "chomout", "chopit", "choroba", "chov", "chrapot", "chrlit", "chrt", "chrup", "chtivost", "chudina", "chutnat", "chvat", "chvilka", "chvost", "chyba", "chystat", "chytit", "cibule", "cigareta", "cihelna", "cihla", "cinkot", "cirkus", "cisterna", "citace", "citrus", "cizinec", "cizost", "clona", "cokoliv", "couvat", "ctitel", "ctnost", "cudnost", "cuketa", "cukr", "cupot", "cvaknout", "cval", "cvik", "cvrkot", "cyklista", "daleko", "dareba", "datel", "datum", "dcera", "debata", "dechovka", "decibel", "deficit", "deflace", "dekl", "dekret", "demokrat", "deprese", "derby", "deska", "detektiv", "dikobraz", "diktovat", "dioda", "diplom", "disk", "displej", "divadlo", "divoch", "dlaha", "dlouho", "dluhopis", "dnes", "dobro", "dobytek", "docent", "dochutit", "dodnes", "dohled", "dohoda", "dohra", "dojem", "dojnice", "doklad", "dokola", "doktor", "dokument", "dolar", "doleva", "dolina", "doma", "dominant", "domluvit", "domov", "donutit", "dopad", "dopis", "doplnit", "doposud", "doprovod", "dopustit", "dorazit", "dorost", "dort", "dosah", "doslov", "dostatek", "dosud", "dosyta", "dotaz", "dotek", "dotknout", "doufat", "doutnat", "dovozce", "dozadu", "doznat", "dozorce", "drahota", "drak", "dramatik", "dravec", "draze", "drdol", "drobnost", "drogerie", "drozd", "drsnost", "drtit", "drzost", "duben", "duchovno", "dudek", "duha", "duhovka", "dusit", "dusno", "dutost", "dvojice", "dvorec", "dynamit", "ekolog", "ekonomie", "elektron", "elipsa", "email", "emise", "emoce", "empatie", "epizoda", "epocha", "epopej", "epos", "esej", "esence", "eskorta", "eskymo", "etiketa", "euforie", "evoluce", "exekuce", "exkurze", "expedice", "exploze", "export", "extrakt", "facka", "fajfka", "fakulta", "fanatik", "fantazie", "farmacie", "favorit", "fazole", "federace", "fejeton", "fenka", "fialka", "figurant", "filozof", "filtr", "finance", "finta", "fixace", "fjord", "flanel", "flirt", "flotila", "fond", "fosfor", "fotbal", "fotka", "foton", "frakce", "freska", "fronta", "fukar", "funkce", "fyzika", "galeje", "garant", "genetika", "geolog", "gilotina", "glazura", "glejt", "golem", "golfista", "gotika", "graf", "gramofon", "granule", "grep", "gril", "grog", "groteska", "guma", "hadice", "hadr", "hala", "halenka", "hanba", "hanopis", "harfa", "harpuna", "havran", "hebkost", "hejkal", "hejno", "hejtman", "hektar", "helma", "hematom", "herec", "herna", "heslo", "hezky", "historik", "hladovka", "hlasivky", "hlava", "hledat", "hlen", "hlodavec", "hloh", "hloupost", "hltat", "hlubina", "hluchota", "hmat", "hmota", "hmyz", "hnis", "hnojivo", "hnout", "hoblina", "hoboj", "hoch", "hodiny", "hodlat", "hodnota", "hodovat", "hojnost", "hokej", "holinka", "holka", "holub", "homole", "honitba", "honorace", "horal", "horda", "horizont", "horko", "horlivec", "hormon", "hornina", "horoskop", "horstvo", "hospoda", "hostina", "hotovost", "houba", "houf", "houpat", "houska", "hovor", "hradba", "hranice", "hravost", "hrazda", "hrbolek", "hrdina", "hrdlo", "hrdost", "hrnek", "hrobka", "hromada", "hrot", "hrouda", "hrozen", "hrstka", "hrubost", "hryzat", "hubenost", "hubnout", "hudba", "hukot", "humr", "husita", "hustota", "hvozd", "hybnost", "hydrant", "hygiena", "hymna", "hysterik", "idylka", "ihned", "ikona", "iluze", "imunita", "infekce", "inflace", "inkaso", "inovace", "inspekce", "internet", "invalida", "investor", "inzerce", "ironie", "jablko", "jachta", "jahoda", "jakmile", "jakost", "jalovec", "jantar", "jarmark", "jaro", "jasan", "jasno", "jatka", "javor", "jazyk", "jedinec", "jedle", "jednatel", "jehlan", "jekot", "jelen", "jelito", "jemnost", "jenom", "jepice", "jeseter", "jevit", "jezdec", "jezero", "jinak", "jindy", "jinoch", "jiskra", "jistota", "jitrnice", "jizva", "jmenovat", "jogurt", "jurta", "kabaret", "kabel", "kabinet", "kachna", "kadet", "kadidlo", "kahan", "kajak", "kajuta", "kakao", "kaktus", "kalamita", "kalhoty", "kalibr", "kalnost", "kamera", "kamkoliv", "kamna", "kanibal", "kanoe", "kantor", "kapalina", "kapela", "kapitola", "kapka", "kaple", "kapota", "kapr", "kapusta", "kapybara", "karamel", "karotka", "karton", "kasa", "katalog", "katedra", "kauce", "kauza", "kavalec", "kazajka", "kazeta", "kazivost", "kdekoliv", "kdesi", "kedluben", "kemp", "keramika", "kino", "klacek", "kladivo", "klam", "klapot", "klasika", "klaun", "klec", "klenba", "klepat", "klesnout", "klid", "klima", "klisna", "klobouk", "klokan", "klopa", "kloub", "klubovna", "klusat", "kluzkost", "kmen", "kmitat", "kmotr", "kniha", "knot", "koalice", "koberec", "kobka", "kobliha", "kobyla", "kocour", "kohout", "kojenec", "kokos", "koktejl", "kolaps", "koleda", "kolize", "kolo", "komando", "kometa", "komik", "komnata", "komora", "kompas", "komunita", "konat", "koncept", "kondice", "konec", "konfese", "kongres", "konina", "konkurs", "kontakt", "konzerva", "kopanec", "kopie", "kopnout", "koprovka", "korbel", "korektor", "kormidlo", "koroptev", "korpus", "koruna", "koryto", "korzet", "kosatec", "kostka", "kotel", "kotleta", "kotoul", "koukat", "koupelna", "kousek", "kouzlo", "kovboj", "koza", "kozoroh", "krabice", "krach", "krajina", "kralovat", "krasopis", "kravata", "kredit", "krejcar", "kresba", "kreveta", "kriket", "kritik", "krize", "krkavec", "krmelec", "krmivo", "krocan", "krok", "kronika", "kropit", "kroupa", "krovka", "krtek", "kruhadlo", "krupice", "krutost", "krvinka", "krychle", "krypta", "krystal", "kryt", "kudlanka", "kufr", "kujnost", "kukla", "kulajda", "kulich", "kulka", "kulomet", "kultura", "kuna", "kupodivu", "kurt", "kurzor", "kutil", "kvalita", "kvasinka", "kvestor", "kynolog", "kyselina", "kytara", "kytice", "kytka", "kytovec", "kyvadlo", "labrador", "lachtan", "ladnost", "laik", "lakomec", "lamela", "lampa", "lanovka", "lasice", "laso", "lastura", "latinka", "lavina", "lebka", "leckdy", "leden", "lednice", "ledovka", "ledvina", "legenda", "legie", "legrace", "lehce", "lehkost", "lehnout", "lektvar", "lenochod", "lentilka", "lepenka", "lepidlo", "letadlo", "letec", "letmo", "letokruh", "levhart", "levitace", "levobok", "libra", "lichotka", "lidojed", "lidskost", "lihovina", "lijavec", "lilek", "limetka", "linie", "linka", "linoleum", "listopad", "litina", "litovat", "lobista", "lodivod", "logika", "logoped", "lokalita", "loket", "lomcovat", "lopata", "lopuch", "lord", "losos", "lotr", "loudal", "louh", "louka", "louskat", "lovec", "lstivost", "lucerna", "lucifer", "lump", "lusk", "lustrace", "lvice", "lyra", "lyrika", "lysina", "madam", "madlo", "magistr", "mahagon", "majetek", "majitel", "majorita", "makak", "makovice", "makrela", "malba", "malina", "malovat", "malvice", "maminka", "mandle", "manko", "marnost", "masakr", "maskot", "masopust", "matice", "matrika", "maturita", "mazanec", "mazivo", "mazlit", "mazurka", "mdloba", "mechanik", "meditace", "medovina", "melasa", "meloun", "mentolka", "metla", "metoda", "metr", "mezera", "migrace", "mihnout", "mihule", "mikina", "mikrofon", "milenec", "milimetr", "milost", "mimika", "mincovna", "minibar", "minomet", "minulost", "miska", "mistr", "mixovat", "mladost", "mlha", "mlhovina", "mlok", "mlsat", "mluvit", "mnich", "mnohem", "mobil", "mocnost", "modelka", "modlitba", "mohyla", "mokro", "molekula", "momentka", "monarcha", "monokl", "monstrum", "montovat", "monzun", "mosaz", "moskyt", "most", "motivace", "motorka", "motyka", "moucha", "moudrost", "mozaika", "mozek", "mozol", "mramor", "mravenec", "mrkev", "mrtvola", "mrzet", "mrzutost", "mstitel", "mudrc", "muflon", "mulat", "mumie", "munice", "muset", "mutace", "muzeum", "muzikant", "myslivec", "mzda", "nabourat", "nachytat", "nadace", "nadbytek", "nadhoz", "nadobro", "nadpis", "nahlas", "nahnat", "nahodile", "nahradit", "naivita", "najednou", "najisto", "najmout", "naklonit", "nakonec", "nakrmit", "nalevo", "namazat", "namluvit", "nanometr", "naoko", "naopak", "naostro", "napadat", "napevno", "naplnit", "napnout", "naposled", "naprosto", "narodit", "naruby", "narychlo", "nasadit", "nasekat", "naslepo", "nastat", "natolik", "navenek", "navrch", "navzdory", "nazvat", "nebe", "nechat", "necky", "nedaleko", "nedbat", "neduh", "negace", "nehet", "nehoda", "nejen", "nejprve", "neklid", "nelibost", "nemilost", "nemoc", "neochota", "neonka", "nepokoj", "nerost", "nerv", "nesmysl", "nesoulad", "netvor", "neuron", "nevina", "nezvykle", "nicota", "nijak", "nikam", "nikdy", "nikl", "nikterak", "nitro", "nocleh", "nohavice", "nominace", "nora", "norek", "nositel", "nosnost", "nouze", "noviny", "novota", "nozdra", "nuda", "nudle", "nuget", "nutit", "nutnost", "nutrie", "nymfa", "obal", "obarvit", "obava", "obdiv", "obec", "obehnat", "obejmout", "obezita", "obhajoba", "obilnice", "objasnit", "objekt", "obklopit", "oblast", "oblek", "obliba", "obloha", "obluda", "obnos", "obohatit", "obojek", "obout", "obrazec", "obrna", "obruba", "obrys", "obsah", "obsluha", "obstarat", "obuv", "obvaz", "obvinit", "obvod", "obvykle", "obyvatel", "obzor", "ocas", "ocel", "ocenit", "ochladit", "ochota", "ochrana", "ocitnout", "odboj", "odbyt", "odchod", "odcizit", "odebrat", "odeslat", "odevzdat", "odezva", "odhadce", "odhodit", "odjet", "odjinud", "odkaz", "odkoupit", "odliv", "odluka", "odmlka", "odolnost", "odpad", "odpis", "odplout", "odpor", "odpustit", "odpykat", "odrazka", "odsoudit", "odstup", "odsun", "odtok", "odtud", "odvaha", "odveta", "odvolat", "odvracet", "odznak", "ofina", "ofsajd", "ohlas", "ohnisko", "ohrada", "ohrozit", "ohryzek", "okap", "okenice", "oklika", "okno", "okouzlit", "okovy", "okrasa", "okres", "okrsek", "okruh", "okupant", "okurka", "okusit", "olejnina", "olizovat", "omak", "omeleta", "omezit", "omladina", "omlouvat", "omluva", "omyl", "onehdy", "opakovat", "opasek", "operace", "opice", "opilost", "opisovat", "opora", "opozice", "opravdu", "oproti", "orbital", "orchestr", "orgie", "orlice", "orloj", "ortel", "osada", "oschnout", "osika", "osivo", "oslava", "oslepit", "oslnit", "oslovit", "osnova", "osoba", "osolit", "ospalec", "osten", "ostraha", "ostuda", "ostych", "osvojit", "oteplit", "otisk", "otop", "otrhat", "otrlost", "otrok", "otruby", "otvor", "ovanout", "ovar", "oves", "ovlivnit", "ovoce", "oxid", "ozdoba", "pachatel", "pacient", "padouch", "pahorek", "pakt", "palanda", "palec", "palivo", "paluba", "pamflet", "pamlsek", "panenka", "panika", "panna", "panovat", "panstvo", "pantofle", "paprika", "parketa", "parodie", "parta", "paruka", "paryba", "paseka", "pasivita", "pastelka", "patent", "patrona", "pavouk", "pazneht", "pazourek", "pecka", "pedagog", "pejsek", "peklo", "peloton", "penalta", "pendrek", "penze", "periskop", "pero", "pestrost", "petarda", "petice", "petrolej", "pevnina", "pexeso", "pianista", "piha", "pijavice", "pikle", "piknik", "pilina", "pilnost", "pilulka", "pinzeta", "pipeta", "pisatel", "pistole", "pitevna", "pivnice", "pivovar", "placenta", "plakat", "plamen", "planeta", "plastika", "platit", "plavidlo", "plaz", "plech", "plemeno", "plenta", "ples", "pletivo", "plevel", "plivat", "plnit", "plno", "plocha", "plodina", "plomba", "plout", "pluk", "plyn", "pobavit", "pobyt", "pochod", "pocit", "poctivec", "podat", "podcenit", "podepsat", "podhled", "podivit", "podklad", "podmanit", "podnik", "podoba", "podpora", "podraz", "podstata", "podvod", "podzim", "poezie", "pohanka", "pohnutka", "pohovor", "pohroma", "pohyb", "pointa", "pojistka", "pojmout", "pokazit", "pokles", "pokoj", "pokrok", "pokuta", "pokyn", "poledne", "polibek", "polknout", "poloha", "polynom", "pomalu", "pominout", "pomlka", "pomoc", "pomsta", "pomyslet", "ponechat", "ponorka", "ponurost", "popadat", "popel", "popisek", "poplach", "poprosit", "popsat", "popud", "poradce", "porce", "porod", "porucha", "poryv", "posadit", "posed", "posila", "poskok", "poslanec", "posoudit", "pospolu", "postava", "posudek", "posyp", "potah", "potkan", "potlesk", "potomek", "potrava", "potupa", "potvora", "poukaz", "pouto", "pouzdro", "povaha", "povidla", "povlak", "povoz", "povrch", "povstat", "povyk", "povzdech", "pozdrav", "pozemek", "poznatek", "pozor", "pozvat", "pracovat", "prahory", "praktika", "prales", "praotec", "praporek", "prase", "pravda", "princip", "prkno", "probudit", "procento", "prodej", "profese", "prohra", "projekt", "prolomit", "promile", "pronikat", "propad", "prorok", "prosba", "proton", "proutek", "provaz", "prskavka", "prsten", "prudkost", "prut", "prvek", "prvohory", "psanec", "psovod", "pstruh", "ptactvo", "puberta", "puch", "pudl", "pukavec", "puklina", "pukrle", "pult", "pumpa", "punc", "pupen", "pusa", "pusinka", "pustina", "putovat", "putyka", "pyramida", "pysk", "pytel", "racek", "rachot", "radiace", "radnice", "radon", "raft", "ragby", "raketa", "rakovina", "rameno", "rampouch", "rande", "rarach", "rarita", "rasovna", "rastr", "ratolest", "razance", "razidlo", "reagovat", "reakce", "recept", "redaktor", "referent", "reflex", "rejnok", "reklama", "rekord", "rekrut", "rektor", "reputace", "revize", "revma", "revolver", "rezerva", "riskovat", "riziko", "robotika", "rodokmen", "rohovka", "rokle", "rokoko", "romaneto", "ropovod", "ropucha", "rorejs", "rosol", "rostlina", "rotmistr", "rotoped", "rotunda", "roubenka", "roucho", "roup", "roura", "rovina", "rovnice", "rozbor", "rozchod", "rozdat", "rozeznat", "rozhodce", "rozinka", "rozjezd", "rozkaz", "rozloha", "rozmar", "rozpad", "rozruch", "rozsah", "roztok", "rozum", "rozvod", "rubrika", "ruchadlo", "rukavice", "rukopis", "ryba", "rybolov", "rychlost", "rydlo", "rypadlo", "rytina", "ryzost", "sadista", "sahat", "sako", "samec", "samizdat", "samota", "sanitka", "sardinka", "sasanka", "satelit", "sazba", "sazenice", "sbor", "schovat", "sebranka", "secese", "sedadlo", "sediment", "sedlo", "sehnat", "sejmout", "sekera", "sekta", "sekunda", "sekvoje", "semeno", "seno", "servis", "sesadit", "seshora", "seskok", "seslat", "sestra", "sesuv", "sesypat", "setba", "setina", "setkat", "setnout", "setrvat", "sever", "seznam", "shoda", "shrnout", "sifon", "silnice", "sirka", "sirotek", "sirup", "situace", "skafandr", "skalisko", "skanzen", "skaut", "skeptik", "skica", "skladba", "sklenice", "sklo", "skluz", "skoba", "skokan", "skoro", "skripta", "skrz", "skupina", "skvost", "skvrna", "slabika", "sladidlo", "slanina", "slast", "slavnost", "sledovat", "slepec", "sleva", "slezina", "slib", "slina", "sliznice", "slon", "sloupek", "slovo", "sluch", "sluha", "slunce", "slupka", "slza", "smaragd", "smetana", "smilstvo", "smlouva", "smog", "smrad", "smrk", "smrtka", "smutek", "smysl", "snad", "snaha", "snob", "sobota", "socha", "sodovka", "sokol", "sopka", "sotva", "souboj", "soucit", "soudce", "souhlas", "soulad", "soumrak", "souprava", "soused", "soutok", "souviset", "spalovna", "spasitel", "spis", "splav", "spodek", "spojenec", "spolu", "sponzor", "spornost", "spousta", "sprcha", "spustit", "sranda", "sraz", "srdce", "srna", "srnec", "srovnat", "srpen", "srst", "srub", "stanice", "starosta", "statika", "stavba", "stehno", "stezka", "stodola", "stolek", "stopa", "storno", "stoupat", "strach", "stres", "strhnout", "strom", "struna", "studna", "stupnice", "stvol", "styk", "subjekt", "subtropy", "suchar", "sudost", "sukno", "sundat", "sunout", "surikata", "surovina", "svah", "svalstvo", "svetr", "svatba", "svazek", "svisle", "svitek", "svoboda", "svodidlo", "svorka", "svrab", "sykavka", "sykot", "synek", "synovec", "sypat", "sypkost", "syrovost", "sysel", "sytost", "tabletka", "tabule", "tahoun", "tajemno", "tajfun", "tajga", "tajit", "tajnost", "taktika", "tamhle", "tampon", "tancovat", "tanec", "tanker", "tapeta", "tavenina", "tazatel", "technika", "tehdy", "tekutina", "telefon", "temnota", "tendence", "tenista", "tenor", "teplota", "tepna", "teprve", "terapie", "termoska", "textil", "ticho", "tiskopis", "titulek", "tkadlec", "tkanina", "tlapka", "tleskat", "tlukot", "tlupa", "tmel", "toaleta", "topinka", "topol", "torzo", "touha", "toulec", "tradice", "traktor", "tramp", "trasa", "traverza", "trefit", "trest", "trezor", "trhavina", "trhlina", "trochu", "trojice", "troska", "trouba", "trpce", "trpitel", "trpkost", "trubec", "truchlit", "truhlice", "trus", "trvat", "tudy", "tuhnout", "tuhost", "tundra", "turista", "turnaj", "tuzemsko", "tvaroh", "tvorba", "tvrdost", "tvrz", "tygr", "tykev", "ubohost", "uboze", "ubrat", "ubrousek", "ubrus", "ubytovna", "ucho", "uctivost", "udivit", "uhradit", "ujednat", "ujistit", "ujmout", "ukazatel", "uklidnit", "uklonit", "ukotvit", "ukrojit", "ulice", "ulita", "ulovit", "umyvadlo", "unavit", "uniforma", "uniknout", "upadnout", "uplatnit", "uplynout", "upoutat", "upravit", "uran", "urazit", "usednout", "usilovat", "usmrtit", "usnadnit", "usnout", "usoudit", "ustlat", "ustrnout", "utahovat", "utkat", "utlumit", "utonout", "utopenec", "utrousit", "uvalit", "uvolnit", "uvozovka", "uzdravit", "uzel", "uzenina", "uzlina", "uznat", "vagon", "valcha", "valoun", "vana", "vandal", "vanilka", "varan", "varhany", "varovat", "vcelku", "vchod", "vdova", "vedro", "vegetace", "vejce", "velbloud", "veletrh", "velitel", "velmoc", "velryba", "venkov", "veranda", "verze", "veselka", "veskrze", "vesnice", "vespodu", "vesta", "veterina", "veverka", "vibrace", "vichr", "videohra", "vidina", "vidle", "vila", "vinice", "viset", "vitalita", "vize", "vizitka", "vjezd", "vklad", "vkus", "vlajka", "vlak", "vlasec", "vlevo", "vlhkost", "vliv", "vlnovka", "vloupat", "vnucovat", "vnuk", "voda", "vodivost", "vodoznak", "vodstvo", "vojensky", "vojna", "vojsko", "volant", "volba", "volit", "volno", "voskovka", "vozidlo", "vozovna", "vpravo", "vrabec", "vracet", "vrah", "vrata", "vrba", "vrcholek", "vrhat", "vrstva", "vrtule", "vsadit", "vstoupit", "vstup", "vtip", "vybavit", "vybrat", "vychovat", "vydat", "vydra", "vyfotit", "vyhledat", "vyhnout", "vyhodit", "vyhradit", "vyhubit", "vyjasnit", "vyjet", "vyjmout", "vyklopit", "vykonat", "vylekat", "vymazat", "vymezit", "vymizet", "vymyslet", "vynechat", "vynikat", "vynutit", "vypadat", "vyplatit", "vypravit", "vypustit", "vyrazit", "vyrovnat", "vyrvat", "vyslovit", "vysoko", "vystavit", "vysunout", "vysypat", "vytasit", "vytesat", "vytratit", "vyvinout", "vyvolat", "vyvrhel", "vyzdobit", "vyznat", "vzadu", "vzbudit", "vzchopit", "vzdor", "vzduch", "vzdychat", "vzestup", "vzhledem", "vzkaz", "vzlykat", "vznik", "vzorek", "vzpoura", "vztah", "vztek", "xylofon", "zabrat", "zabydlet", "zachovat", "zadarmo", "zadusit", "zafoukat", "zahltit", "zahodit", "zahrada", "zahynout", "zajatec", "zajet", "zajistit", "zaklepat", "zakoupit", "zalepit", "zamezit", "zamotat", "zamyslet", "zanechat", "zanikat", "zaplatit", "zapojit", "zapsat", "zarazit", "zastavit", "zasunout", "zatajit", "zatemnit", "zatknout", "zaujmout", "zavalit", "zavelet", "zavinit", "zavolat", "zavrtat", "zazvonit", "zbavit", "zbrusu", "zbudovat", "zbytek", "zdaleka", "zdarma", "zdatnost", "zdivo", "zdobit", "zdroj", "zdvih", "zdymadlo", "zelenina", "zeman", "zemina", "zeptat", "zezadu", "zezdola", "zhatit", "zhltnout", "zhluboka", "zhotovit", "zhruba", "zima", "zimnice", "zjemnit", "zklamat", "zkoumat", "zkratka", "zkumavka", "zlato", "zlehka", "zloba", "zlom", "zlost", "zlozvyk", "zmapovat", "zmar", "zmatek", "zmije", "zmizet", "zmocnit", "zmodrat", "zmrzlina", "zmutovat", "znak", "znalost", "znamenat", "znovu", "zobrazit", "zotavit", "zoubek", "zoufale", "zplodit", "zpomalit", "zprava", "zprostit", "zprudka", "zprvu", "zrada", "zranit", "zrcadlo", "zrnitost", "zrno", "zrovna", "zrychlit", "zrzavost", "zticha", "ztratit", "zubovina", "zubr", "zvednout", "zvenku", "zvesela", "zvon", "zvrat", "zvukovod", "zvyk"];

  var require$$1$1 = ["的", "一", "是", "在", "不", "了", "有", "和", "人", "这", "中", "大", "为", "上", "个", "国", "我", "以", "要", "他", "时", "来", "用", "们", "生", "到", "作", "地", "于", "出", "就", "分", "对", "成", "会", "可", "主", "发", "年", "动", "同", "工", "也", "能", "下", "过", "子", "说", "产", "种", "面", "而", "方", "后", "多", "定", "行", "学", "法", "所", "民", "得", "经", "十", "三", "之", "进", "着", "等", "部", "度", "家", "电", "力", "里", "如", "水", "化", "高", "自", "二", "理", "起", "小", "物", "现", "实", "加", "量", "都", "两", "体", "制", "机", "当", "使", "点", "从", "业", "本", "去", "把", "性", "好", "应", "开", "它", "合", "还", "因", "由", "其", "些", "然", "前", "外", "天", "政", "四", "日", "那", "社", "义", "事", "平", "形", "相", "全", "表", "间", "样", "与", "关", "各", "重", "新", "线", "内", "数", "正", "心", "反", "你", "明", "看", "原", "又", "么", "利", "比", "或", "但", "质", "气", "第", "向", "道", "命", "此", "变", "条", "只", "没", "结", "解", "问", "意", "建", "月", "公", "无", "系", "军", "很", "情", "者", "最", "立", "代", "想", "已", "通", "并", "提", "直", "题", "党", "程", "展", "五", "果", "料", "象", "员", "革", "位", "入", "常", "文", "总", "次", "品", "式", "活", "设", "及", "管", "特", "件", "长", "求", "老", "头", "基", "资", "边", "流", "路", "级", "少", "图", "山", "统", "接", "知", "较", "将", "组", "见", "计", "别", "她", "手", "角", "期", "根", "论", "运", "农", "指", "几", "九", "区", "强", "放", "决", "西", "被", "干", "做", "必", "战", "先", "回", "则", "任", "取", "据", "处", "队", "南", "给", "色", "光", "门", "即", "保", "治", "北", "造", "百", "规", "热", "领", "七", "海", "口", "东", "导", "器", "压", "志", "世", "金", "增", "争", "济", "阶", "油", "思", "术", "极", "交", "受", "联", "什", "认", "六", "共", "权", "收", "证", "改", "清", "美", "再", "采", "转", "更", "单", "风", "切", "打", "白", "教", "速", "花", "带", "安", "场", "身", "车", "例", "真", "务", "具", "万", "每", "目", "至", "达", "走", "积", "示", "议", "声", "报", "斗", "完", "类", "八", "离", "华", "名", "确", "才", "科", "张", "信", "马", "节", "话", "米", "整", "空", "元", "况", "今", "集", "温", "传", "土", "许", "步", "群", "广", "石", "记", "需", "段", "研", "界", "拉", "林", "律", "叫", "且", "究", "观", "越", "织", "装", "影", "算", "低", "持", "音", "众", "书", "布", "复", "容", "儿", "须", "际", "商", "非", "验", "连", "断", "深", "难", "近", "矿", "千", "周", "委", "素", "技", "备", "半", "办", "青", "省", "列", "习", "响", "约", "支", "般", "史", "感", "劳", "便", "团", "往", "酸", "历", "市", "克", "何", "除", "消", "构", "府", "称", "太", "准", "精", "值", "号", "率", "族", "维", "划", "选", "标", "写", "存", "候", "毛", "亲", "快", "效", "斯", "院", "查", "江", "型", "眼", "王", "按", "格", "养", "易", "置", "派", "层", "片", "始", "却", "专", "状", "育", "厂", "京", "识", "适", "属", "圆", "包", "火", "住", "调", "满", "县", "局", "照", "参", "红", "细", "引", "听", "该", "铁", "价", "严", "首", "底", "液", "官", "德", "随", "病", "苏", "失", "尔", "死", "讲", "配", "女", "黄", "推", "显", "谈", "罪", "神", "艺", "呢", "席", "含", "企", "望", "密", "批", "营", "项", "防", "举", "球", "英", "氧", "势", "告", "李", "台", "落", "木", "帮", "轮", "破", "亚", "师", "围", "注", "远", "字", "材", "排", "供", "河", "态", "封", "另", "施", "减", "树", "溶", "怎", "止", "案", "言", "士", "均", "武", "固", "叶", "鱼", "波", "视", "仅", "费", "紧", "爱", "左", "章", "早", "朝", "害", "续", "轻", "服", "试", "食", "充", "兵", "源", "判", "护", "司", "足", "某", "练", "差", "致", "板", "田", "降", "黑", "犯", "负", "击", "范", "继", "兴", "似", "余", "坚", "曲", "输", "修", "故", "城", "夫", "够", "送", "笔", "船", "占", "右", "财", "吃", "富", "春", "职", "觉", "汉", "画", "功", "巴", "跟", "虽", "杂", "飞", "检", "吸", "助", "升", "阳", "互", "初", "创", "抗", "考", "投", "坏", "策", "古", "径", "换", "未", "跑", "留", "钢", "曾", "端", "责", "站", "简", "述", "钱", "副", "尽", "帝", "射", "草", "冲", "承", "独", "令", "限", "阿", "宣", "环", "双", "请", "超", "微", "让", "控", "州", "良", "轴", "找", "否", "纪", "益", "依", "优", "顶", "础", "载", "倒", "房", "突", "坐", "粉", "敌", "略", "客", "袁", "冷", "胜", "绝", "析", "块", "剂", "测", "丝", "协", "诉", "念", "陈", "仍", "罗", "盐", "友", "洋", "错", "苦", "夜", "刑", "移", "频", "逐", "靠", "混", "母", "短", "皮", "终", "聚", "汽", "村", "云", "哪", "既", "距", "卫", "停", "烈", "央", "察", "烧", "迅", "境", "若", "印", "洲", "刻", "括", "激", "孔", "搞", "甚", "室", "待", "核", "校", "散", "侵", "吧", "甲", "游", "久", "菜", "味", "旧", "模", "湖", "货", "损", "预", "阻", "毫", "普", "稳", "乙", "妈", "植", "息", "扩", "银", "语", "挥", "酒", "守", "拿", "序", "纸", "医", "缺", "雨", "吗", "针", "刘", "啊", "急", "唱", "误", "训", "愿", "审", "附", "获", "茶", "鲜", "粮", "斤", "孩", "脱", "硫", "肥", "善", "龙", "演", "父", "渐", "血", "欢", "械", "掌", "歌", "沙", "刚", "攻", "谓", "盾", "讨", "晚", "粒", "乱", "燃", "矛", "乎", "杀", "药", "宁", "鲁", "贵", "钟", "煤", "读", "班", "伯", "香", "介", "迫", "句", "丰", "培", "握", "兰", "担", "弦", "蛋", "沉", "假", "穿", "执", "答", "乐", "谁", "顺", "烟", "缩", "征", "脸", "喜", "松", "脚", "困", "异", "免", "背", "星", "福", "买", "染", "井", "概", "慢", "怕", "磁", "倍", "祖", "皇", "促", "静", "补", "评", "翻", "肉", "践", "尼", "衣", "宽", "扬", "棉", "希", "伤", "操", "垂", "秋", "宜", "氢", "套", "督", "振", "架", "亮", "末", "宪", "庆", "编", "牛", "触", "映", "雷", "销", "诗", "座", "居", "抓", "裂", "胞", "呼", "娘", "景", "威", "绿", "晶", "厚", "盟", "衡", "鸡", "孙", "延", "危", "胶", "屋", "乡", "临", "陆", "顾", "掉", "呀", "灯", "岁", "措", "束", "耐", "剧", "玉", "赵", "跳", "哥", "季", "课", "凯", "胡", "额", "款", "绍", "卷", "齐", "伟", "蒸", "殖", "永", "宗", "苗", "川", "炉", "岩", "弱", "零", "杨", "奏", "沿", "露", "杆", "探", "滑", "镇", "饭", "浓", "航", "怀", "赶", "库", "夺", "伊", "灵", "税", "途", "灭", "赛", "归", "召", "鼓", "播", "盘", "裁", "险", "康", "唯", "录", "菌", "纯", "借", "糖", "盖", "横", "符", "私", "努", "堂", "域", "枪", "润", "幅", "哈", "竟", "熟", "虫", "泽", "脑", "壤", "碳", "欧", "遍", "侧", "寨", "敢", "彻", "虑", "斜", "薄", "庭", "纳", "弹", "饲", "伸", "折", "麦", "湿", "暗", "荷", "瓦", "塞", "床", "筑", "恶", "户", "访", "塔", "奇", "透", "梁", "刀", "旋", "迹", "卡", "氯", "遇", "份", "毒", "泥", "退", "洗", "摆", "灰", "彩", "卖", "耗", "夏", "择", "忙", "铜", "献", "硬", "予", "繁", "圈", "雪", "函", "亦", "抽", "篇", "阵", "阴", "丁", "尺", "追", "堆", "雄", "迎", "泛", "爸", "楼", "避", "谋", "吨", "野", "猪", "旗", "累", "偏", "典", "馆", "索", "秦", "脂", "潮", "爷", "豆", "忽", "托", "惊", "塑", "遗", "愈", "朱", "替", "纤", "粗", "倾", "尚", "痛", "楚", "谢", "奋", "购", "磨", "君", "池", "旁", "碎", "骨", "监", "捕", "弟", "暴", "割", "贯", "殊", "释", "词", "亡", "壁", "顿", "宝", "午", "尘", "闻", "揭", "炮", "残", "冬", "桥", "妇", "警", "综", "招", "吴", "付", "浮", "遭", "徐", "您", "摇", "谷", "赞", "箱", "隔", "订", "男", "吹", "园", "纷", "唐", "败", "宋", "玻", "巨", "耕", "坦", "荣", "闭", "湾", "键", "凡", "驻", "锅", "救", "恩", "剥", "凝", "碱", "齿", "截", "炼", "麻", "纺", "禁", "废", "盛", "版", "缓", "净", "睛", "昌", "婚", "涉", "筒", "嘴", "插", "岸", "朗", "庄", "街", "藏", "姑", "贸", "腐", "奴", "啦", "惯", "乘", "伙", "恢", "匀", "纱", "扎", "辩", "耳", "彪", "臣", "亿", "璃", "抵", "脉", "秀", "萨", "俄", "网", "舞", "店", "喷", "纵", "寸", "汗", "挂", "洪", "贺", "闪", "柬", "爆", "烯", "津", "稻", "墙", "软", "勇", "像", "滚", "厘", "蒙", "芳", "肯", "坡", "柱", "荡", "腿", "仪", "旅", "尾", "轧", "冰", "贡", "登", "黎", "削", "钻", "勒", "逃", "障", "氨", "郭", "峰", "币", "港", "伏", "轨", "亩", "毕", "擦", "莫", "刺", "浪", "秘", "援", "株", "健", "售", "股", "岛", "甘", "泡", "睡", "童", "铸", "汤", "阀", "休", "汇", "舍", "牧", "绕", "炸", "哲", "磷", "绩", "朋", "淡", "尖", "启", "陷", "柴", "呈", "徒", "颜", "泪", "稍", "忘", "泵", "蓝", "拖", "洞", "授", "镜", "辛", "壮", "锋", "贫", "虚", "弯", "摩", "泰", "幼", "廷", "尊", "窗", "纲", "弄", "隶", "疑", "氏", "宫", "姐", "震", "瑞", "怪", "尤", "琴", "循", "描", "膜", "违", "夹", "腰", "缘", "珠", "穷", "森", "枝", "竹", "沟", "催", "绳", "忆", "邦", "剩", "幸", "浆", "栏", "拥", "牙", "贮", "礼", "滤", "钠", "纹", "罢", "拍", "咱", "喊", "袖", "埃", "勤", "罚", "焦", "潜", "伍", "墨", "欲", "缝", "姓", "刊", "饱", "仿", "奖", "铝", "鬼", "丽", "跨", "默", "挖", "链", "扫", "喝", "袋", "炭", "污", "幕", "诸", "弧", "励", "梅", "奶", "洁", "灾", "舟", "鉴", "苯", "讼", "抱", "毁", "懂", "寒", "智", "埔", "寄", "届", "跃", "渡", "挑", "丹", "艰", "贝", "碰", "拔", "爹", "戴", "码", "梦", "芽", "熔", "赤", "渔", "哭", "敬", "颗", "奔", "铅", "仲", "虎", "稀", "妹", "乏", "珍", "申", "桌", "遵", "允", "隆", "螺", "仓", "魏", "锐", "晓", "氮", "兼", "隐", "碍", "赫", "拨", "忠", "肃", "缸", "牵", "抢", "博", "巧", "壳", "兄", "杜", "讯", "诚", "碧", "祥", "柯", "页", "巡", "矩", "悲", "灌", "龄", "伦", "票", "寻", "桂", "铺", "圣", "恐", "恰", "郑", "趣", "抬", "荒", "腾", "贴", "柔", "滴", "猛", "阔", "辆", "妻", "填", "撤", "储", "签", "闹", "扰", "紫", "砂", "递", "戏", "吊", "陶", "伐", "喂", "疗", "瓶", "婆", "抚", "臂", "摸", "忍", "虾", "蜡", "邻", "胸", "巩", "挤", "偶", "弃", "槽", "劲", "乳", "邓", "吉", "仁", "烂", "砖", "租", "乌", "舰", "伴", "瓜", "浅", "丙", "暂", "燥", "橡", "柳", "迷", "暖", "牌", "秧", "胆", "详", "簧", "踏", "瓷", "谱", "呆", "宾", "糊", "洛", "辉", "愤", "竞", "隙", "怒", "粘", "乃", "绪", "肩", "籍", "敏", "涂", "熙", "皆", "侦", "悬", "掘", "享", "纠", "醒", "狂", "锁", "淀", "恨", "牲", "霸", "爬", "赏", "逆", "玩", "陵", "祝", "秒", "浙", "貌", "役", "彼", "悉", "鸭", "趋", "凤", "晨", "畜", "辈", "秩", "卵", "署", "梯", "炎", "滩", "棋", "驱", "筛", "峡", "冒", "啥", "寿", "译", "浸", "泉", "帽", "迟", "硅", "疆", "贷", "漏", "稿", "冠", "嫩", "胁", "芯", "牢", "叛", "蚀", "奥", "鸣", "岭", "羊", "凭", "串", "塘", "绘", "酵", "融", "盆", "锡", "庙", "筹", "冻", "辅", "摄", "袭", "筋", "拒", "僚", "旱", "钾", "鸟", "漆", "沈", "眉", "疏", "添", "棒", "穗", "硝", "韩", "逼", "扭", "侨", "凉", "挺", "碗", "栽", "炒", "杯", "患", "馏", "劝", "豪", "辽", "勃", "鸿", "旦", "吏", "拜", "狗", "埋", "辊", "掩", "饮", "搬", "骂", "辞", "勾", "扣", "估", "蒋", "绒", "雾", "丈", "朵", "姆", "拟", "宇", "辑", "陕", "雕", "偿", "蓄", "崇", "剪", "倡", "厅", "咬", "驶", "薯", "刷", "斥", "番", "赋", "奉", "佛", "浇", "漫", "曼", "扇", "钙", "桃", "扶", "仔", "返", "俗", "亏", "腔", "鞋", "棱", "覆", "框", "悄", "叔", "撞", "骗", "勘", "旺", "沸", "孤", "吐", "孟", "渠", "屈", "疾", "妙", "惜", "仰", "狠", "胀", "谐", "抛", "霉", "桑", "岗", "嘛", "衰", "盗", "渗", "脏", "赖", "涌", "甜", "曹", "阅", "肌", "哩", "厉", "烃", "纬", "毅", "昨", "伪", "症", "煮", "叹", "钉", "搭", "茎", "笼", "酷", "偷", "弓", "锥", "恒", "杰", "坑", "鼻", "翼", "纶", "叙", "狱", "逮", "罐", "络", "棚", "抑", "膨", "蔬", "寺", "骤", "穆", "冶", "枯", "册", "尸", "凸", "绅", "坯", "牺", "焰", "轰", "欣", "晋", "瘦", "御", "锭", "锦", "丧", "旬", "锻", "垄", "搜", "扑", "邀", "亭", "酯", "迈", "舒", "脆", "酶", "闲", "忧", "酚", "顽", "羽", "涨", "卸", "仗", "陪", "辟", "惩", "杭", "姚", "肚", "捉", "飘", "漂", "昆", "欺", "吾", "郎", "烷", "汁", "呵", "饰", "萧", "雅", "邮", "迁", "燕", "撒", "姻", "赴", "宴", "烦", "债", "帐", "斑", "铃", "旨", "醇", "董", "饼", "雏", "姿", "拌", "傅", "腹", "妥", "揉", "贤", "拆", "歪", "葡", "胺", "丢", "浩", "徽", "昂", "垫", "挡", "览", "贪", "慰", "缴", "汪", "慌", "冯", "诺", "姜", "谊", "凶", "劣", "诬", "耀", "昏", "躺", "盈", "骑", "乔", "溪", "丛", "卢", "抹", "闷", "咨", "刮", "驾", "缆", "悟", "摘", "铒", "掷", "颇", "幻", "柄", "惠", "惨", "佳", "仇", "腊", "窝", "涤", "剑", "瞧", "堡", "泼", "葱", "罩", "霍", "捞", "胎", "苍", "滨", "俩", "捅", "湘", "砍", "霞", "邵", "萄", "疯", "淮", "遂", "熊", "粪", "烘", "宿", "档", "戈", "驳", "嫂", "裕", "徙", "箭", "捐", "肠", "撑", "晒", "辨", "殿", "莲", "摊", "搅", "酱", "屏", "疫", "哀", "蔡", "堵", "沫", "皱", "畅", "叠", "阁", "莱", "敲", "辖", "钩", "痕", "坝", "巷", "饿", "祸", "丘", "玄", "溜", "曰", "逻", "彭", "尝", "卿", "妨", "艇", "吞", "韦", "怨", "矮", "歇"];

  var require$$2$1 = ["的", "一", "是", "在", "不", "了", "有", "和", "人", "這", "中", "大", "為", "上", "個", "國", "我", "以", "要", "他", "時", "來", "用", "們", "生", "到", "作", "地", "於", "出", "就", "分", "對", "成", "會", "可", "主", "發", "年", "動", "同", "工", "也", "能", "下", "過", "子", "說", "產", "種", "面", "而", "方", "後", "多", "定", "行", "學", "法", "所", "民", "得", "經", "十", "三", "之", "進", "著", "等", "部", "度", "家", "電", "力", "裡", "如", "水", "化", "高", "自", "二", "理", "起", "小", "物", "現", "實", "加", "量", "都", "兩", "體", "制", "機", "當", "使", "點", "從", "業", "本", "去", "把", "性", "好", "應", "開", "它", "合", "還", "因", "由", "其", "些", "然", "前", "外", "天", "政", "四", "日", "那", "社", "義", "事", "平", "形", "相", "全", "表", "間", "樣", "與", "關", "各", "重", "新", "線", "內", "數", "正", "心", "反", "你", "明", "看", "原", "又", "麼", "利", "比", "或", "但", "質", "氣", "第", "向", "道", "命", "此", "變", "條", "只", "沒", "結", "解", "問", "意", "建", "月", "公", "無", "系", "軍", "很", "情", "者", "最", "立", "代", "想", "已", "通", "並", "提", "直", "題", "黨", "程", "展", "五", "果", "料", "象", "員", "革", "位", "入", "常", "文", "總", "次", "品", "式", "活", "設", "及", "管", "特", "件", "長", "求", "老", "頭", "基", "資", "邊", "流", "路", "級", "少", "圖", "山", "統", "接", "知", "較", "將", "組", "見", "計", "別", "她", "手", "角", "期", "根", "論", "運", "農", "指", "幾", "九", "區", "強", "放", "決", "西", "被", "幹", "做", "必", "戰", "先", "回", "則", "任", "取", "據", "處", "隊", "南", "給", "色", "光", "門", "即", "保", "治", "北", "造", "百", "規", "熱", "領", "七", "海", "口", "東", "導", "器", "壓", "志", "世", "金", "增", "爭", "濟", "階", "油", "思", "術", "極", "交", "受", "聯", "什", "認", "六", "共", "權", "收", "證", "改", "清", "美", "再", "採", "轉", "更", "單", "風", "切", "打", "白", "教", "速", "花", "帶", "安", "場", "身", "車", "例", "真", "務", "具", "萬", "每", "目", "至", "達", "走", "積", "示", "議", "聲", "報", "鬥", "完", "類", "八", "離", "華", "名", "確", "才", "科", "張", "信", "馬", "節", "話", "米", "整", "空", "元", "況", "今", "集", "溫", "傳", "土", "許", "步", "群", "廣", "石", "記", "需", "段", "研", "界", "拉", "林", "律", "叫", "且", "究", "觀", "越", "織", "裝", "影", "算", "低", "持", "音", "眾", "書", "布", "复", "容", "兒", "須", "際", "商", "非", "驗", "連", "斷", "深", "難", "近", "礦", "千", "週", "委", "素", "技", "備", "半", "辦", "青", "省", "列", "習", "響", "約", "支", "般", "史", "感", "勞", "便", "團", "往", "酸", "歷", "市", "克", "何", "除", "消", "構", "府", "稱", "太", "準", "精", "值", "號", "率", "族", "維", "劃", "選", "標", "寫", "存", "候", "毛", "親", "快", "效", "斯", "院", "查", "江", "型", "眼", "王", "按", "格", "養", "易", "置", "派", "層", "片", "始", "卻", "專", "狀", "育", "廠", "京", "識", "適", "屬", "圓", "包", "火", "住", "調", "滿", "縣", "局", "照", "參", "紅", "細", "引", "聽", "該", "鐵", "價", "嚴", "首", "底", "液", "官", "德", "隨", "病", "蘇", "失", "爾", "死", "講", "配", "女", "黃", "推", "顯", "談", "罪", "神", "藝", "呢", "席", "含", "企", "望", "密", "批", "營", "項", "防", "舉", "球", "英", "氧", "勢", "告", "李", "台", "落", "木", "幫", "輪", "破", "亞", "師", "圍", "注", "遠", "字", "材", "排", "供", "河", "態", "封", "另", "施", "減", "樹", "溶", "怎", "止", "案", "言", "士", "均", "武", "固", "葉", "魚", "波", "視", "僅", "費", "緊", "愛", "左", "章", "早", "朝", "害", "續", "輕", "服", "試", "食", "充", "兵", "源", "判", "護", "司", "足", "某", "練", "差", "致", "板", "田", "降", "黑", "犯", "負", "擊", "范", "繼", "興", "似", "餘", "堅", "曲", "輸", "修", "故", "城", "夫", "夠", "送", "筆", "船", "佔", "右", "財", "吃", "富", "春", "職", "覺", "漢", "畫", "功", "巴", "跟", "雖", "雜", "飛", "檢", "吸", "助", "昇", "陽", "互", "初", "創", "抗", "考", "投", "壞", "策", "古", "徑", "換", "未", "跑", "留", "鋼", "曾", "端", "責", "站", "簡", "述", "錢", "副", "盡", "帝", "射", "草", "衝", "承", "獨", "令", "限", "阿", "宣", "環", "雙", "請", "超", "微", "讓", "控", "州", "良", "軸", "找", "否", "紀", "益", "依", "優", "頂", "礎", "載", "倒", "房", "突", "坐", "粉", "敵", "略", "客", "袁", "冷", "勝", "絕", "析", "塊", "劑", "測", "絲", "協", "訴", "念", "陳", "仍", "羅", "鹽", "友", "洋", "錯", "苦", "夜", "刑", "移", "頻", "逐", "靠", "混", "母", "短", "皮", "終", "聚", "汽", "村", "雲", "哪", "既", "距", "衛", "停", "烈", "央", "察", "燒", "迅", "境", "若", "印", "洲", "刻", "括", "激", "孔", "搞", "甚", "室", "待", "核", "校", "散", "侵", "吧", "甲", "遊", "久", "菜", "味", "舊", "模", "湖", "貨", "損", "預", "阻", "毫", "普", "穩", "乙", "媽", "植", "息", "擴", "銀", "語", "揮", "酒", "守", "拿", "序", "紙", "醫", "缺", "雨", "嗎", "針", "劉", "啊", "急", "唱", "誤", "訓", "願", "審", "附", "獲", "茶", "鮮", "糧", "斤", "孩", "脫", "硫", "肥", "善", "龍", "演", "父", "漸", "血", "歡", "械", "掌", "歌", "沙", "剛", "攻", "謂", "盾", "討", "晚", "粒", "亂", "燃", "矛", "乎", "殺", "藥", "寧", "魯", "貴", "鐘", "煤", "讀", "班", "伯", "香", "介", "迫", "句", "豐", "培", "握", "蘭", "擔", "弦", "蛋", "沉", "假", "穿", "執", "答", "樂", "誰", "順", "煙", "縮", "徵", "臉", "喜", "松", "腳", "困", "異", "免", "背", "星", "福", "買", "染", "井", "概", "慢", "怕", "磁", "倍", "祖", "皇", "促", "靜", "補", "評", "翻", "肉", "踐", "尼", "衣", "寬", "揚", "棉", "希", "傷", "操", "垂", "秋", "宜", "氫", "套", "督", "振", "架", "亮", "末", "憲", "慶", "編", "牛", "觸", "映", "雷", "銷", "詩", "座", "居", "抓", "裂", "胞", "呼", "娘", "景", "威", "綠", "晶", "厚", "盟", "衡", "雞", "孫", "延", "危", "膠", "屋", "鄉", "臨", "陸", "顧", "掉", "呀", "燈", "歲", "措", "束", "耐", "劇", "玉", "趙", "跳", "哥", "季", "課", "凱", "胡", "額", "款", "紹", "卷", "齊", "偉", "蒸", "殖", "永", "宗", "苗", "川", "爐", "岩", "弱", "零", "楊", "奏", "沿", "露", "桿", "探", "滑", "鎮", "飯", "濃", "航", "懷", "趕", "庫", "奪", "伊", "靈", "稅", "途", "滅", "賽", "歸", "召", "鼓", "播", "盤", "裁", "險", "康", "唯", "錄", "菌", "純", "借", "糖", "蓋", "橫", "符", "私", "努", "堂", "域", "槍", "潤", "幅", "哈", "竟", "熟", "蟲", "澤", "腦", "壤", "碳", "歐", "遍", "側", "寨", "敢", "徹", "慮", "斜", "薄", "庭", "納", "彈", "飼", "伸", "折", "麥", "濕", "暗", "荷", "瓦", "塞", "床", "築", "惡", "戶", "訪", "塔", "奇", "透", "梁", "刀", "旋", "跡", "卡", "氯", "遇", "份", "毒", "泥", "退", "洗", "擺", "灰", "彩", "賣", "耗", "夏", "擇", "忙", "銅", "獻", "硬", "予", "繁", "圈", "雪", "函", "亦", "抽", "篇", "陣", "陰", "丁", "尺", "追", "堆", "雄", "迎", "泛", "爸", "樓", "避", "謀", "噸", "野", "豬", "旗", "累", "偏", "典", "館", "索", "秦", "脂", "潮", "爺", "豆", "忽", "托", "驚", "塑", "遺", "愈", "朱", "替", "纖", "粗", "傾", "尚", "痛", "楚", "謝", "奮", "購", "磨", "君", "池", "旁", "碎", "骨", "監", "捕", "弟", "暴", "割", "貫", "殊", "釋", "詞", "亡", "壁", "頓", "寶", "午", "塵", "聞", "揭", "炮", "殘", "冬", "橋", "婦", "警", "綜", "招", "吳", "付", "浮", "遭", "徐", "您", "搖", "谷", "贊", "箱", "隔", "訂", "男", "吹", "園", "紛", "唐", "敗", "宋", "玻", "巨", "耕", "坦", "榮", "閉", "灣", "鍵", "凡", "駐", "鍋", "救", "恩", "剝", "凝", "鹼", "齒", "截", "煉", "麻", "紡", "禁", "廢", "盛", "版", "緩", "淨", "睛", "昌", "婚", "涉", "筒", "嘴", "插", "岸", "朗", "莊", "街", "藏", "姑", "貿", "腐", "奴", "啦", "慣", "乘", "夥", "恢", "勻", "紗", "扎", "辯", "耳", "彪", "臣", "億", "璃", "抵", "脈", "秀", "薩", "俄", "網", "舞", "店", "噴", "縱", "寸", "汗", "掛", "洪", "賀", "閃", "柬", "爆", "烯", "津", "稻", "牆", "軟", "勇", "像", "滾", "厘", "蒙", "芳", "肯", "坡", "柱", "盪", "腿", "儀", "旅", "尾", "軋", "冰", "貢", "登", "黎", "削", "鑽", "勒", "逃", "障", "氨", "郭", "峰", "幣", "港", "伏", "軌", "畝", "畢", "擦", "莫", "刺", "浪", "秘", "援", "株", "健", "售", "股", "島", "甘", "泡", "睡", "童", "鑄", "湯", "閥", "休", "匯", "舍", "牧", "繞", "炸", "哲", "磷", "績", "朋", "淡", "尖", "啟", "陷", "柴", "呈", "徒", "顏", "淚", "稍", "忘", "泵", "藍", "拖", "洞", "授", "鏡", "辛", "壯", "鋒", "貧", "虛", "彎", "摩", "泰", "幼", "廷", "尊", "窗", "綱", "弄", "隸", "疑", "氏", "宮", "姐", "震", "瑞", "怪", "尤", "琴", "循", "描", "膜", "違", "夾", "腰", "緣", "珠", "窮", "森", "枝", "竹", "溝", "催", "繩", "憶", "邦", "剩", "幸", "漿", "欄", "擁", "牙", "貯", "禮", "濾", "鈉", "紋", "罷", "拍", "咱", "喊", "袖", "埃", "勤", "罰", "焦", "潛", "伍", "墨", "欲", "縫", "姓", "刊", "飽", "仿", "獎", "鋁", "鬼", "麗", "跨", "默", "挖", "鏈", "掃", "喝", "袋", "炭", "污", "幕", "諸", "弧", "勵", "梅", "奶", "潔", "災", "舟", "鑑", "苯", "訟", "抱", "毀", "懂", "寒", "智", "埔", "寄", "屆", "躍", "渡", "挑", "丹", "艱", "貝", "碰", "拔", "爹", "戴", "碼", "夢", "芽", "熔", "赤", "漁", "哭", "敬", "顆", "奔", "鉛", "仲", "虎", "稀", "妹", "乏", "珍", "申", "桌", "遵", "允", "隆", "螺", "倉", "魏", "銳", "曉", "氮", "兼", "隱", "礙", "赫", "撥", "忠", "肅", "缸", "牽", "搶", "博", "巧", "殼", "兄", "杜", "訊", "誠", "碧", "祥", "柯", "頁", "巡", "矩", "悲", "灌", "齡", "倫", "票", "尋", "桂", "鋪", "聖", "恐", "恰", "鄭", "趣", "抬", "荒", "騰", "貼", "柔", "滴", "猛", "闊", "輛", "妻", "填", "撤", "儲", "簽", "鬧", "擾", "紫", "砂", "遞", "戲", "吊", "陶", "伐", "餵", "療", "瓶", "婆", "撫", "臂", "摸", "忍", "蝦", "蠟", "鄰", "胸", "鞏", "擠", "偶", "棄", "槽", "勁", "乳", "鄧", "吉", "仁", "爛", "磚", "租", "烏", "艦", "伴", "瓜", "淺", "丙", "暫", "燥", "橡", "柳", "迷", "暖", "牌", "秧", "膽", "詳", "簧", "踏", "瓷", "譜", "呆", "賓", "糊", "洛", "輝", "憤", "競", "隙", "怒", "粘", "乃", "緒", "肩", "籍", "敏", "塗", "熙", "皆", "偵", "懸", "掘", "享", "糾", "醒", "狂", "鎖", "淀", "恨", "牲", "霸", "爬", "賞", "逆", "玩", "陵", "祝", "秒", "浙", "貌", "役", "彼", "悉", "鴨", "趨", "鳳", "晨", "畜", "輩", "秩", "卵", "署", "梯", "炎", "灘", "棋", "驅", "篩", "峽", "冒", "啥", "壽", "譯", "浸", "泉", "帽", "遲", "矽", "疆", "貸", "漏", "稿", "冠", "嫩", "脅", "芯", "牢", "叛", "蝕", "奧", "鳴", "嶺", "羊", "憑", "串", "塘", "繪", "酵", "融", "盆", "錫", "廟", "籌", "凍", "輔", "攝", "襲", "筋", "拒", "僚", "旱", "鉀", "鳥", "漆", "沈", "眉", "疏", "添", "棒", "穗", "硝", "韓", "逼", "扭", "僑", "涼", "挺", "碗", "栽", "炒", "杯", "患", "餾", "勸", "豪", "遼", "勃", "鴻", "旦", "吏", "拜", "狗", "埋", "輥", "掩", "飲", "搬", "罵", "辭", "勾", "扣", "估", "蔣", "絨", "霧", "丈", "朵", "姆", "擬", "宇", "輯", "陝", "雕", "償", "蓄", "崇", "剪", "倡", "廳", "咬", "駛", "薯", "刷", "斥", "番", "賦", "奉", "佛", "澆", "漫", "曼", "扇", "鈣", "桃", "扶", "仔", "返", "俗", "虧", "腔", "鞋", "棱", "覆", "框", "悄", "叔", "撞", "騙", "勘", "旺", "沸", "孤", "吐", "孟", "渠", "屈", "疾", "妙", "惜", "仰", "狠", "脹", "諧", "拋", "黴", "桑", "崗", "嘛", "衰", "盜", "滲", "臟", "賴", "湧", "甜", "曹", "閱", "肌", "哩", "厲", "烴", "緯", "毅", "昨", "偽", "症", "煮", "嘆", "釘", "搭", "莖", "籠", "酷", "偷", "弓", "錐", "恆", "傑", "坑", "鼻", "翼", "綸", "敘", "獄", "逮", "罐", "絡", "棚", "抑", "膨", "蔬", "寺", "驟", "穆", "冶", "枯", "冊", "屍", "凸", "紳", "坯", "犧", "焰", "轟", "欣", "晉", "瘦", "禦", "錠", "錦", "喪", "旬", "鍛", "壟", "搜", "撲", "邀", "亭", "酯", "邁", "舒", "脆", "酶", "閒", "憂", "酚", "頑", "羽", "漲", "卸", "仗", "陪", "闢", "懲", "杭", "姚", "肚", "捉", "飄", "漂", "昆", "欺", "吾", "郎", "烷", "汁", "呵", "飾", "蕭", "雅", "郵", "遷", "燕", "撒", "姻", "赴", "宴", "煩", "債", "帳", "斑", "鈴", "旨", "醇", "董", "餅", "雛", "姿", "拌", "傅", "腹", "妥", "揉", "賢", "拆", "歪", "葡", "胺", "丟", "浩", "徽", "昂", "墊", "擋", "覽", "貪", "慰", "繳", "汪", "慌", "馮", "諾", "姜", "誼", "兇", "劣", "誣", "耀", "昏", "躺", "盈", "騎", "喬", "溪", "叢", "盧", "抹", "悶", "諮", "刮", "駕", "纜", "悟", "摘", "鉺", "擲", "頗", "幻", "柄", "惠", "慘", "佳", "仇", "臘", "窩", "滌", "劍", "瞧", "堡", "潑", "蔥", "罩", "霍", "撈", "胎", "蒼", "濱", "倆", "捅", "湘", "砍", "霞", "邵", "萄", "瘋", "淮", "遂", "熊", "糞", "烘", "宿", "檔", "戈", "駁", "嫂", "裕", "徙", "箭", "捐", "腸", "撐", "曬", "辨", "殿", "蓮", "攤", "攪", "醬", "屏", "疫", "哀", "蔡", "堵", "沫", "皺", "暢", "疊", "閣", "萊", "敲", "轄", "鉤", "痕", "壩", "巷", "餓", "禍", "丘", "玄", "溜", "曰", "邏", "彭", "嘗", "卿", "妨", "艇", "吞", "韋", "怨", "矮", "歇"];

  var require$$3$1 = ["가격", "가끔", "가난", "가능", "가득", "가르침", "가뭄", "가방", "가상", "가슴", "가운데", "가을", "가이드", "가입", "가장", "가정", "가족", "가죽", "각오", "각자", "간격", "간부", "간섭", "간장", "간접", "간판", "갈등", "갈비", "갈색", "갈증", "감각", "감기", "감소", "감수성", "감자", "감정", "갑자기", "강남", "강당", "강도", "강력히", "강변", "강북", "강사", "강수량", "강아지", "강원도", "강의", "강제", "강조", "같이", "개구리", "개나리", "개방", "개별", "개선", "개성", "개인", "객관적", "거실", "거액", "거울", "거짓", "거품", "걱정", "건강", "건물", "건설", "건조", "건축", "걸음", "검사", "검토", "게시판", "게임", "겨울", "견해", "결과", "결국", "결론", "결석", "결승", "결심", "결정", "결혼", "경계", "경고", "경기", "경력", "경복궁", "경비", "경상도", "경영", "경우", "경쟁", "경제", "경주", "경찰", "경치", "경향", "경험", "계곡", "계단", "계란", "계산", "계속", "계약", "계절", "계층", "계획", "고객", "고구려", "고궁", "고급", "고등학생", "고무신", "고민", "고양이", "고장", "고전", "고집", "고춧가루", "고통", "고향", "곡식", "골목", "골짜기", "골프", "공간", "공개", "공격", "공군", "공급", "공기", "공동", "공무원", "공부", "공사", "공식", "공업", "공연", "공원", "공장", "공짜", "공책", "공통", "공포", "공항", "공휴일", "과목", "과일", "과장", "과정", "과학", "관객", "관계", "관광", "관념", "관람", "관련", "관리", "관습", "관심", "관점", "관찰", "광경", "광고", "광장", "광주", "괴로움", "굉장히", "교과서", "교문", "교복", "교실", "교양", "교육", "교장", "교직", "교통", "교환", "교훈", "구경", "구름", "구멍", "구별", "구분", "구석", "구성", "구속", "구역", "구입", "구청", "구체적", "국가", "국기", "국내", "국립", "국물", "국민", "국수", "국어", "국왕", "국적", "국제", "국회", "군대", "군사", "군인", "궁극적", "권리", "권위", "권투", "귀국", "귀신", "규정", "규칙", "균형", "그날", "그냥", "그늘", "그러나", "그룹", "그릇", "그림", "그제서야", "그토록", "극복", "극히", "근거", "근교", "근래", "근로", "근무", "근본", "근원", "근육", "근처", "글씨", "글자", "금강산", "금고", "금년", "금메달", "금액", "금연", "금요일", "금지", "긍정적", "기간", "기관", "기념", "기능", "기독교", "기둥", "기록", "기름", "기법", "기본", "기분", "기쁨", "기숙사", "기술", "기억", "기업", "기온", "기운", "기원", "기적", "기준", "기침", "기혼", "기획", "긴급", "긴장", "길이", "김밥", "김치", "김포공항", "깍두기", "깜빡", "깨달음", "깨소금", "껍질", "꼭대기", "꽃잎", "나들이", "나란히", "나머지", "나물", "나침반", "나흘", "낙엽", "난방", "날개", "날씨", "날짜", "남녀", "남대문", "남매", "남산", "남자", "남편", "남학생", "낭비", "낱말", "내년", "내용", "내일", "냄비", "냄새", "냇물", "냉동", "냉면", "냉방", "냉장고", "넥타이", "넷째", "노동", "노란색", "노력", "노인", "녹음", "녹차", "녹화", "논리", "논문", "논쟁", "놀이", "농구", "농담", "농민", "농부", "농업", "농장", "농촌", "높이", "눈동자", "눈물", "눈썹", "뉴욕", "느낌", "늑대", "능동적", "능력", "다방", "다양성", "다음", "다이어트", "다행", "단계", "단골", "단독", "단맛", "단순", "단어", "단위", "단점", "단체", "단추", "단편", "단풍", "달걀", "달러", "달력", "달리", "닭고기", "담당", "담배", "담요", "담임", "답변", "답장", "당근", "당분간", "당연히", "당장", "대규모", "대낮", "대단히", "대답", "대도시", "대략", "대량", "대륙", "대문", "대부분", "대신", "대응", "대장", "대전", "대접", "대중", "대책", "대출", "대충", "대통령", "대학", "대한민국", "대합실", "대형", "덩어리", "데이트", "도대체", "도덕", "도둑", "도망", "도서관", "도심", "도움", "도입", "도자기", "도저히", "도전", "도중", "도착", "독감", "독립", "독서", "독일", "독창적", "동화책", "뒷모습", "뒷산", "딸아이", "마누라", "마늘", "마당", "마라톤", "마련", "마무리", "마사지", "마약", "마요네즈", "마을", "마음", "마이크", "마중", "마지막", "마찬가지", "마찰", "마흔", "막걸리", "막내", "막상", "만남", "만두", "만세", "만약", "만일", "만점", "만족", "만화", "많이", "말기", "말씀", "말투", "맘대로", "망원경", "매년", "매달", "매력", "매번", "매스컴", "매일", "매장", "맥주", "먹이", "먼저", "먼지", "멀리", "메일", "며느리", "며칠", "면담", "멸치", "명단", "명령", "명예", "명의", "명절", "명칭", "명함", "모금", "모니터", "모델", "모든", "모범", "모습", "모양", "모임", "모조리", "모집", "모퉁이", "목걸이", "목록", "목사", "목소리", "목숨", "목적", "목표", "몰래", "몸매", "몸무게", "몸살", "몸속", "몸짓", "몸통", "몹시", "무관심", "무궁화", "무더위", "무덤", "무릎", "무슨", "무엇", "무역", "무용", "무조건", "무지개", "무척", "문구", "문득", "문법", "문서", "문제", "문학", "문화", "물가", "물건", "물결", "물고기", "물론", "물리학", "물음", "물질", "물체", "미국", "미디어", "미사일", "미술", "미역", "미용실", "미움", "미인", "미팅", "미혼", "민간", "민족", "민주", "믿음", "밀가루", "밀리미터", "밑바닥", "바가지", "바구니", "바나나", "바늘", "바닥", "바닷가", "바람", "바이러스", "바탕", "박물관", "박사", "박수", "반대", "반드시", "반말", "반발", "반성", "반응", "반장", "반죽", "반지", "반찬", "받침", "발가락", "발걸음", "발견", "발달", "발레", "발목", "발바닥", "발생", "발음", "발자국", "발전", "발톱", "발표", "밤하늘", "밥그릇", "밥맛", "밥상", "밥솥", "방금", "방면", "방문", "방바닥", "방법", "방송", "방식", "방안", "방울", "방지", "방학", "방해", "방향", "배경", "배꼽", "배달", "배드민턴", "백두산", "백색", "백성", "백인", "백제", "백화점", "버릇", "버섯", "버튼", "번개", "번역", "번지", "번호", "벌금", "벌레", "벌써", "범위", "범인", "범죄", "법률", "법원", "법적", "법칙", "베이징", "벨트", "변경", "변동", "변명", "변신", "변호사", "변화", "별도", "별명", "별일", "병실", "병아리", "병원", "보관", "보너스", "보라색", "보람", "보름", "보상", "보안", "보자기", "보장", "보전", "보존", "보통", "보편적", "보험", "복도", "복사", "복숭아", "복습", "볶음", "본격적", "본래", "본부", "본사", "본성", "본인", "본질", "볼펜", "봉사", "봉지", "봉투", "부근", "부끄러움", "부담", "부동산", "부문", "부분", "부산", "부상", "부엌", "부인", "부작용", "부장", "부정", "부족", "부지런히", "부친", "부탁", "부품", "부회장", "북부", "북한", "분노", "분량", "분리", "분명", "분석", "분야", "분위기", "분필", "분홍색", "불고기", "불과", "불교", "불꽃", "불만", "불법", "불빛", "불안", "불이익", "불행", "브랜드", "비극", "비난", "비닐", "비둘기", "비디오", "비로소", "비만", "비명", "비밀", "비바람", "비빔밥", "비상", "비용", "비율", "비중", "비타민", "비판", "빌딩", "빗물", "빗방울", "빗줄기", "빛깔", "빨간색", "빨래", "빨리", "사건", "사계절", "사나이", "사냥", "사람", "사랑", "사립", "사모님", "사물", "사방", "사상", "사생활", "사설", "사슴", "사실", "사업", "사용", "사월", "사장", "사전", "사진", "사촌", "사춘기", "사탕", "사투리", "사흘", "산길", "산부인과", "산업", "산책", "살림", "살인", "살짝", "삼계탕", "삼국", "삼십", "삼월", "삼촌", "상관", "상금", "상대", "상류", "상반기", "상상", "상식", "상업", "상인", "상자", "상점", "상처", "상추", "상태", "상표", "상품", "상황", "새벽", "색깔", "색연필", "생각", "생명", "생물", "생방송", "생산", "생선", "생신", "생일", "생활", "서랍", "서른", "서명", "서민", "서비스", "서양", "서울", "서적", "서점", "서쪽", "서클", "석사", "석유", "선거", "선물", "선배", "선생", "선수", "선원", "선장", "선전", "선택", "선풍기", "설거지", "설날", "설렁탕", "설명", "설문", "설사", "설악산", "설치", "설탕", "섭씨", "성공", "성당", "성명", "성별", "성인", "성장", "성적", "성질", "성함", "세금", "세미나", "세상", "세월", "세종대왕", "세탁", "센터", "센티미터", "셋째", "소규모", "소극적", "소금", "소나기", "소년", "소득", "소망", "소문", "소설", "소속", "소아과", "소용", "소원", "소음", "소중히", "소지품", "소질", "소풍", "소형", "속담", "속도", "속옷", "손가락", "손길", "손녀", "손님", "손등", "손목", "손뼉", "손실", "손질", "손톱", "손해", "솔직히", "솜씨", "송아지", "송이", "송편", "쇠고기", "쇼핑", "수건", "수년", "수단", "수돗물", "수동적", "수면", "수명", "수박", "수상", "수석", "수술", "수시로", "수업", "수염", "수영", "수입", "수준", "수집", "수출", "수컷", "수필", "수학", "수험생", "수화기", "숙녀", "숙소", "숙제", "순간", "순서", "순수", "순식간", "순위", "숟가락", "술병", "술집", "숫자", "스님", "스물", "스스로", "스승", "스웨터", "스위치", "스케이트", "스튜디오", "스트레스", "스포츠", "슬쩍", "슬픔", "습관", "습기", "승객", "승리", "승부", "승용차", "승진", "시각", "시간", "시골", "시금치", "시나리오", "시댁", "시리즈", "시멘트", "시민", "시부모", "시선", "시설", "시스템", "시아버지", "시어머니", "시월", "시인", "시일", "시작", "시장", "시절", "시점", "시중", "시즌", "시집", "시청", "시합", "시험", "식구", "식기", "식당", "식량", "식료품", "식물", "식빵", "식사", "식생활", "식초", "식탁", "식품", "신고", "신규", "신념", "신문", "신발", "신비", "신사", "신세", "신용", "신제품", "신청", "신체", "신화", "실감", "실내", "실력", "실례", "실망", "실수", "실습", "실시", "실장", "실정", "실질적", "실천", "실체", "실컷", "실태", "실패", "실험", "실현", "심리", "심부름", "심사", "심장", "심정", "심판", "쌍둥이", "씨름", "씨앗", "아가씨", "아나운서", "아드님", "아들", "아쉬움", "아스팔트", "아시아", "아울러", "아저씨", "아줌마", "아직", "아침", "아파트", "아프리카", "아픔", "아홉", "아흔", "악기", "악몽", "악수", "안개", "안경", "안과", "안내", "안녕", "안동", "안방", "안부", "안주", "알루미늄", "알코올", "암시", "암컷", "압력", "앞날", "앞문", "애인", "애정", "액수", "앨범", "야간", "야단", "야옹", "약간", "약국", "약속", "약수", "약점", "약품", "약혼녀", "양념", "양력", "양말", "양배추", "양주", "양파", "어둠", "어려움", "어른", "어젯밤", "어쨌든", "어쩌다가", "어쩐지", "언니", "언덕", "언론", "언어", "얼굴", "얼른", "얼음", "얼핏", "엄마", "업무", "업종", "업체", "엉덩이", "엉망", "엉터리", "엊그제", "에너지", "에어컨", "엔진", "여건", "여고생", "여관", "여군", "여권", "여대생", "여덟", "여동생", "여든", "여론", "여름", "여섯", "여성", "여왕", "여인", "여전히", "여직원", "여학생", "여행", "역사", "역시", "역할", "연결", "연구", "연극", "연기", "연락", "연설", "연세", "연속", "연습", "연애", "연예인", "연인", "연장", "연주", "연출", "연필", "연합", "연휴", "열기", "열매", "열쇠", "열심히", "열정", "열차", "열흘", "염려", "엽서", "영국", "영남", "영상", "영양", "영역", "영웅", "영원히", "영하", "영향", "영혼", "영화", "옆구리", "옆방", "옆집", "예감", "예금", "예방", "예산", "예상", "예선", "예술", "예습", "예식장", "예약", "예전", "예절", "예정", "예컨대", "옛날", "오늘", "오락", "오랫동안", "오렌지", "오로지", "오른발", "오븐", "오십", "오염", "오월", "오전", "오직", "오징어", "오페라", "오피스텔", "오히려", "옥상", "옥수수", "온갖", "온라인", "온몸", "온종일", "온통", "올가을", "올림픽", "올해", "옷차림", "와이셔츠", "와인", "완성", "완전", "왕비", "왕자", "왜냐하면", "왠지", "외갓집", "외국", "외로움", "외삼촌", "외출", "외침", "외할머니", "왼발", "왼손", "왼쪽", "요금", "요일", "요즘", "요청", "용기", "용서", "용어", "우산", "우선", "우승", "우연히", "우정", "우체국", "우편", "운동", "운명", "운반", "운전", "운행", "울산", "울음", "움직임", "웃어른", "웃음", "워낙", "원고", "원래", "원서", "원숭이", "원인", "원장", "원피스", "월급", "월드컵", "월세", "월요일", "웨이터", "위반", "위법", "위성", "위원", "위험", "위협", "윗사람", "유난히", "유럽", "유명", "유물", "유산", "유적", "유치원", "유학", "유행", "유형", "육군", "육상", "육십", "육체", "은행", "음력", "음료", "음반", "음성", "음식", "음악", "음주", "의견", "의논", "의문", "의복", "의식", "의심", "의외로", "의욕", "의원", "의학", "이것", "이곳", "이념", "이놈", "이달", "이대로", "이동", "이렇게", "이력서", "이론적", "이름", "이민", "이발소", "이별", "이불", "이빨", "이상", "이성", "이슬", "이야기", "이용", "이웃", "이월", "이윽고", "이익", "이전", "이중", "이튿날", "이틀", "이혼", "인간", "인격", "인공", "인구", "인근", "인기", "인도", "인류", "인물", "인생", "인쇄", "인연", "인원", "인재", "인종", "인천", "인체", "인터넷", "인하", "인형", "일곱", "일기", "일단", "일대", "일등", "일반", "일본", "일부", "일상", "일생", "일손", "일요일", "일월", "일정", "일종", "일주일", "일찍", "일체", "일치", "일행", "일회용", "임금", "임무", "입대", "입력", "입맛", "입사", "입술", "입시", "입원", "입장", "입학", "자가용", "자격", "자극", "자동", "자랑", "자부심", "자식", "자신", "자연", "자원", "자율", "자전거", "자정", "자존심", "자판", "작가", "작년", "작성", "작업", "작용", "작은딸", "작품", "잔디", "잔뜩", "잔치", "잘못", "잠깐", "잠수함", "잠시", "잠옷", "잠자리", "잡지", "장관", "장군", "장기간", "장래", "장례", "장르", "장마", "장면", "장모", "장미", "장비", "장사", "장소", "장식", "장애인", "장인", "장점", "장차", "장학금", "재능", "재빨리", "재산", "재생", "재작년", "재정", "재채기", "재판", "재학", "재활용", "저것", "저고리", "저곳", "저녁", "저런", "저렇게", "저번", "저울", "저절로", "저축", "적극", "적당히", "적성", "적용", "적응", "전개", "전공", "전기", "전달", "전라도", "전망", "전문", "전반", "전부", "전세", "전시", "전용", "전자", "전쟁", "전주", "전철", "전체", "전통", "전혀", "전후", "절대", "절망", "절반", "절약", "절차", "점검", "점수", "점심", "점원", "점점", "점차", "접근", "접시", "접촉", "젓가락", "정거장", "정도", "정류장", "정리", "정말", "정면", "정문", "정반대", "정보", "정부", "정비", "정상", "정성", "정오", "정원", "정장", "정지", "정치", "정확히", "제공", "제과점", "제대로", "제목", "제발", "제법", "제삿날", "제안", "제일", "제작", "제주도", "제출", "제품", "제한", "조각", "조건", "조금", "조깅", "조명", "조미료", "조상", "조선", "조용히", "조절", "조정", "조직", "존댓말", "존재", "졸업", "졸음", "종교", "종로", "종류", "종소리", "종업원", "종종", "종합", "좌석", "죄인", "주관적", "주름", "주말", "주머니", "주먹", "주문", "주민", "주방", "주변", "주식", "주인", "주일", "주장", "주전자", "주택", "준비", "줄거리", "줄기", "줄무늬", "중간", "중계방송", "중국", "중년", "중단", "중독", "중반", "중부", "중세", "중소기업", "중순", "중앙", "중요", "중학교", "즉석", "즉시", "즐거움", "증가", "증거", "증권", "증상", "증세", "지각", "지갑", "지경", "지극히", "지금", "지급", "지능", "지름길", "지리산", "지방", "지붕", "지식", "지역", "지우개", "지원", "지적", "지점", "지진", "지출", "직선", "직업", "직원", "직장", "진급", "진동", "진로", "진료", "진리", "진짜", "진찰", "진출", "진통", "진행", "질문", "질병", "질서", "짐작", "집단", "집안", "집중", "짜증", "찌꺼기", "차남", "차라리", "차량", "차림", "차별", "차선", "차츰", "착각", "찬물", "찬성", "참가", "참기름", "참새", "참석", "참여", "참외", "참조", "찻잔", "창가", "창고", "창구", "창문", "창밖", "창작", "창조", "채널", "채점", "책가방", "책방", "책상", "책임", "챔피언", "처벌", "처음", "천국", "천둥", "천장", "천재", "천천히", "철도", "철저히", "철학", "첫날", "첫째", "청년", "청바지", "청소", "청춘", "체계", "체력", "체온", "체육", "체중", "체험", "초등학생", "초반", "초밥", "초상화", "초순", "초여름", "초원", "초저녁", "초점", "초청", "초콜릿", "촛불", "총각", "총리", "총장", "촬영", "최근", "최상", "최선", "최신", "최악", "최종", "추석", "추억", "추진", "추천", "추측", "축구", "축소", "축제", "축하", "출근", "출발", "출산", "출신", "출연", "출입", "출장", "출판", "충격", "충고", "충돌", "충분히", "충청도", "취업", "취직", "취향", "치약", "친구", "친척", "칠십", "칠월", "칠판", "침대", "침묵", "침실", "칫솔", "칭찬", "카메라", "카운터", "칼국수", "캐릭터", "캠퍼스", "캠페인", "커튼", "컨디션", "컬러", "컴퓨터", "코끼리", "코미디", "콘서트", "콜라", "콤플렉스", "콩나물", "쾌감", "쿠데타", "크림", "큰길", "큰딸", "큰소리", "큰아들", "큰어머니", "큰일", "큰절", "클래식", "클럽", "킬로", "타입", "타자기", "탁구", "탁자", "탄생", "태권도", "태양", "태풍", "택시", "탤런트", "터널", "터미널", "테니스", "테스트", "테이블", "텔레비전", "토론", "토마토", "토요일", "통계", "통과", "통로", "통신", "통역", "통일", "통장", "통제", "통증", "통합", "통화", "퇴근", "퇴원", "퇴직금", "튀김", "트럭", "특급", "특별", "특성", "특수", "특징", "특히", "튼튼히", "티셔츠", "파란색", "파일", "파출소", "판결", "판단", "판매", "판사", "팔십", "팔월", "팝송", "패션", "팩스", "팩시밀리", "팬티", "퍼센트", "페인트", "편견", "편의", "편지", "편히", "평가", "평균", "평생", "평소", "평양", "평일", "평화", "포스터", "포인트", "포장", "포함", "표면", "표정", "표준", "표현", "품목", "품질", "풍경", "풍속", "풍습", "프랑스", "프린터", "플라스틱", "피곤", "피망", "피아노", "필름", "필수", "필요", "필자", "필통", "핑계", "하느님", "하늘", "하드웨어", "하룻밤", "하반기", "하숙집", "하순", "하여튼", "하지만", "하천", "하품", "하필", "학과", "학교", "학급", "학기", "학년", "학력", "학번", "학부모", "학비", "학생", "학술", "학습", "학용품", "학원", "학위", "학자", "학점", "한계", "한글", "한꺼번에", "한낮", "한눈", "한동안", "한때", "한라산", "한마디", "한문", "한번", "한복", "한식", "한여름", "한쪽", "할머니", "할아버지", "할인", "함께", "함부로", "합격", "합리적", "항공", "항구", "항상", "항의", "해결", "해군", "해답", "해당", "해물", "해석", "해설", "해수욕장", "해안", "핵심", "핸드백", "햄버거", "햇볕", "햇살", "행동", "행복", "행사", "행운", "행위", "향기", "향상", "향수", "허락", "허용", "헬기", "현관", "현금", "현대", "현상", "현실", "현장", "현재", "현지", "혈액", "협력", "형부", "형사", "형수", "형식", "형제", "형태", "형편", "혜택", "호기심", "호남", "호랑이", "호박", "호텔", "호흡", "혹시", "홀로", "홈페이지", "홍보", "홍수", "홍차", "화면", "화분", "화살", "화요일", "화장", "화학", "확보", "확인", "확장", "확정", "환갑", "환경", "환영", "환율", "환자", "활기", "활동", "활발히", "활용", "활짝", "회견", "회관", "회복", "회색", "회원", "회장", "회전", "횟수", "횡단보도", "효율적", "후반", "후춧가루", "훈련", "훨씬", "휴식", "휴일", "흉내", "흐름", "흑백", "흑인", "흔적", "흔히", "흥미", "흥분", "희곡", "희망", "희생", "흰색", "힘껏"];

  var require$$4 = ["abaisser", "abandon", "abdiquer", "abeille", "abolir", "aborder", "aboutir", "aboyer", "abrasif", "abreuver", "abriter", "abroger", "abrupt", "absence", "absolu", "absurde", "abusif", "abyssal", "académie", "acajou", "acarien", "accabler", "accepter", "acclamer", "accolade", "accroche", "accuser", "acerbe", "achat", "acheter", "aciduler", "acier", "acompte", "acquérir", "acronyme", "acteur", "actif", "actuel", "adepte", "adéquat", "adhésif", "adjectif", "adjuger", "admettre", "admirer", "adopter", "adorer", "adoucir", "adresse", "adroit", "adulte", "adverbe", "aérer", "aéronef", "affaire", "affecter", "affiche", "affreux", "affubler", "agacer", "agencer", "agile", "agiter", "agrafer", "agréable", "agrume", "aider", "aiguille", "ailier", "aimable", "aisance", "ajouter", "ajuster", "alarmer", "alchimie", "alerte", "algèbre", "algue", "aliéner", "aliment", "alléger", "alliage", "allouer", "allumer", "alourdir", "alpaga", "altesse", "alvéole", "amateur", "ambigu", "ambre", "aménager", "amertume", "amidon", "amiral", "amorcer", "amour", "amovible", "amphibie", "ampleur", "amusant", "analyse", "anaphore", "anarchie", "anatomie", "ancien", "anéantir", "angle", "angoisse", "anguleux", "animal", "annexer", "annonce", "annuel", "anodin", "anomalie", "anonyme", "anormal", "antenne", "antidote", "anxieux", "apaiser", "apéritif", "aplanir", "apologie", "appareil", "appeler", "apporter", "appuyer", "aquarium", "aqueduc", "arbitre", "arbuste", "ardeur", "ardoise", "argent", "arlequin", "armature", "armement", "armoire", "armure", "arpenter", "arracher", "arriver", "arroser", "arsenic", "artériel", "article", "aspect", "asphalte", "aspirer", "assaut", "asservir", "assiette", "associer", "assurer", "asticot", "astre", "astuce", "atelier", "atome", "atrium", "atroce", "attaque", "attentif", "attirer", "attraper", "aubaine", "auberge", "audace", "audible", "augurer", "aurore", "automne", "autruche", "avaler", "avancer", "avarice", "avenir", "averse", "aveugle", "aviateur", "avide", "avion", "aviser", "avoine", "avouer", "avril", "axial", "axiome", "badge", "bafouer", "bagage", "baguette", "baignade", "balancer", "balcon", "baleine", "balisage", "bambin", "bancaire", "bandage", "banlieue", "bannière", "banquier", "barbier", "baril", "baron", "barque", "barrage", "bassin", "bastion", "bataille", "bateau", "batterie", "baudrier", "bavarder", "belette", "bélier", "belote", "bénéfice", "berceau", "berger", "berline", "bermuda", "besace", "besogne", "bétail", "beurre", "biberon", "bicycle", "bidule", "bijou", "bilan", "bilingue", "billard", "binaire", "biologie", "biopsie", "biotype", "biscuit", "bison", "bistouri", "bitume", "bizarre", "blafard", "blague", "blanchir", "blessant", "blinder", "blond", "bloquer", "blouson", "bobard", "bobine", "boire", "boiser", "bolide", "bonbon", "bondir", "bonheur", "bonifier", "bonus", "bordure", "borne", "botte", "boucle", "boueux", "bougie", "boulon", "bouquin", "bourse", "boussole", "boutique", "boxeur", "branche", "brasier", "brave", "brebis", "brèche", "breuvage", "bricoler", "brigade", "brillant", "brioche", "brique", "brochure", "broder", "bronzer", "brousse", "broyeur", "brume", "brusque", "brutal", "bruyant", "buffle", "buisson", "bulletin", "bureau", "burin", "bustier", "butiner", "butoir", "buvable", "buvette", "cabanon", "cabine", "cachette", "cadeau", "cadre", "caféine", "caillou", "caisson", "calculer", "calepin", "calibre", "calmer", "calomnie", "calvaire", "camarade", "caméra", "camion", "campagne", "canal", "caneton", "canon", "cantine", "canular", "capable", "caporal", "caprice", "capsule", "capter", "capuche", "carabine", "carbone", "caresser", "caribou", "carnage", "carotte", "carreau", "carton", "cascade", "casier", "casque", "cassure", "causer", "caution", "cavalier", "caverne", "caviar", "cédille", "ceinture", "céleste", "cellule", "cendrier", "censurer", "central", "cercle", "cérébral", "cerise", "cerner", "cerveau", "cesser", "chagrin", "chaise", "chaleur", "chambre", "chance", "chapitre", "charbon", "chasseur", "chaton", "chausson", "chavirer", "chemise", "chenille", "chéquier", "chercher", "cheval", "chien", "chiffre", "chignon", "chimère", "chiot", "chlorure", "chocolat", "choisir", "chose", "chouette", "chrome", "chute", "cigare", "cigogne", "cimenter", "cinéma", "cintrer", "circuler", "cirer", "cirque", "citerne", "citoyen", "citron", "civil", "clairon", "clameur", "claquer", "classe", "clavier", "client", "cligner", "climat", "clivage", "cloche", "clonage", "cloporte", "cobalt", "cobra", "cocasse", "cocotier", "coder", "codifier", "coffre", "cogner", "cohésion", "coiffer", "coincer", "colère", "colibri", "colline", "colmater", "colonel", "combat", "comédie", "commande", "compact", "concert", "conduire", "confier", "congeler", "connoter", "consonne", "contact", "convexe", "copain", "copie", "corail", "corbeau", "cordage", "corniche", "corpus", "correct", "cortège", "cosmique", "costume", "coton", "coude", "coupure", "courage", "couteau", "couvrir", "coyote", "crabe", "crainte", "cravate", "crayon", "créature", "créditer", "crémeux", "creuser", "crevette", "cribler", "crier", "cristal", "critère", "croire", "croquer", "crotale", "crucial", "cruel", "crypter", "cubique", "cueillir", "cuillère", "cuisine", "cuivre", "culminer", "cultiver", "cumuler", "cupide", "curatif", "curseur", "cyanure", "cycle", "cylindre", "cynique", "daigner", "damier", "danger", "danseur", "dauphin", "débattre", "débiter", "déborder", "débrider", "débutant", "décaler", "décembre", "déchirer", "décider", "déclarer", "décorer", "décrire", "décupler", "dédale", "déductif", "déesse", "défensif", "défiler", "défrayer", "dégager", "dégivrer", "déglutir", "dégrafer", "déjeuner", "délice", "déloger", "demander", "demeurer", "démolir", "dénicher", "dénouer", "dentelle", "dénuder", "départ", "dépenser", "déphaser", "déplacer", "déposer", "déranger", "dérober", "désastre", "descente", "désert", "désigner", "désobéir", "dessiner", "destrier", "détacher", "détester", "détourer", "détresse", "devancer", "devenir", "deviner", "devoir", "diable", "dialogue", "diamant", "dicter", "différer", "digérer", "digital", "digne", "diluer", "dimanche", "diminuer", "dioxyde", "directif", "diriger", "discuter", "disposer", "dissiper", "distance", "divertir", "diviser", "docile", "docteur", "dogme", "doigt", "domaine", "domicile", "dompter", "donateur", "donjon", "donner", "dopamine", "dortoir", "dorure", "dosage", "doseur", "dossier", "dotation", "douanier", "double", "douceur", "douter", "doyen", "dragon", "draper", "dresser", "dribbler", "droiture", "duperie", "duplexe", "durable", "durcir", "dynastie", "éblouir", "écarter", "écharpe", "échelle", "éclairer", "éclipse", "éclore", "écluse", "école", "économie", "écorce", "écouter", "écraser", "écrémer", "écrivain", "écrou", "écume", "écureuil", "édifier", "éduquer", "effacer", "effectif", "effigie", "effort", "effrayer", "effusion", "égaliser", "égarer", "éjecter", "élaborer", "élargir", "électron", "élégant", "éléphant", "élève", "éligible", "élitisme", "éloge", "élucider", "éluder", "emballer", "embellir", "embryon", "émeraude", "émission", "emmener", "émotion", "émouvoir", "empereur", "employer", "emporter", "emprise", "émulsion", "encadrer", "enchère", "enclave", "encoche", "endiguer", "endosser", "endroit", "enduire", "énergie", "enfance", "enfermer", "enfouir", "engager", "engin", "englober", "énigme", "enjamber", "enjeu", "enlever", "ennemi", "ennuyeux", "enrichir", "enrobage", "enseigne", "entasser", "entendre", "entier", "entourer", "entraver", "énumérer", "envahir", "enviable", "envoyer", "enzyme", "éolien", "épaissir", "épargne", "épatant", "épaule", "épicerie", "épidémie", "épier", "épilogue", "épine", "épisode", "épitaphe", "époque", "épreuve", "éprouver", "épuisant", "équerre", "équipe", "ériger", "érosion", "erreur", "éruption", "escalier", "espadon", "espèce", "espiègle", "espoir", "esprit", "esquiver", "essayer", "essence", "essieu", "essorer", "estime", "estomac", "estrade", "étagère", "étaler", "étanche", "étatique", "éteindre", "étendoir", "éternel", "éthanol", "éthique", "ethnie", "étirer", "étoffer", "étoile", "étonnant", "étourdir", "étrange", "étroit", "étude", "euphorie", "évaluer", "évasion", "éventail", "évidence", "éviter", "évolutif", "évoquer", "exact", "exagérer", "exaucer", "exceller", "excitant", "exclusif", "excuse", "exécuter", "exemple", "exercer", "exhaler", "exhorter", "exigence", "exiler", "exister", "exotique", "expédier", "explorer", "exposer", "exprimer", "exquis", "extensif", "extraire", "exulter", "fable", "fabuleux", "facette", "facile", "facture", "faiblir", "falaise", "fameux", "famille", "farceur", "farfelu", "farine", "farouche", "fasciner", "fatal", "fatigue", "faucon", "fautif", "faveur", "favori", "fébrile", "féconder", "fédérer", "félin", "femme", "fémur", "fendoir", "féodal", "fermer", "féroce", "ferveur", "festival", "feuille", "feutre", "février", "fiasco", "ficeler", "fictif", "fidèle", "figure", "filature", "filetage", "filière", "filleul", "filmer", "filou", "filtrer", "financer", "finir", "fiole", "firme", "fissure", "fixer", "flairer", "flamme", "flasque", "flatteur", "fléau", "flèche", "fleur", "flexion", "flocon", "flore", "fluctuer", "fluide", "fluvial", "folie", "fonderie", "fongible", "fontaine", "forcer", "forgeron", "formuler", "fortune", "fossile", "foudre", "fougère", "fouiller", "foulure", "fourmi", "fragile", "fraise", "franchir", "frapper", "frayeur", "frégate", "freiner", "frelon", "frémir", "frénésie", "frère", "friable", "friction", "frisson", "frivole", "froid", "fromage", "frontal", "frotter", "fruit", "fugitif", "fuite", "fureur", "furieux", "furtif", "fusion", "futur", "gagner", "galaxie", "galerie", "gambader", "garantir", "gardien", "garnir", "garrigue", "gazelle", "gazon", "géant", "gélatine", "gélule", "gendarme", "général", "génie", "genou", "gentil", "géologie", "géomètre", "géranium", "germe", "gestuel", "geyser", "gibier", "gicler", "girafe", "givre", "glace", "glaive", "glisser", "globe", "gloire", "glorieux", "golfeur", "gomme", "gonfler", "gorge", "gorille", "goudron", "gouffre", "goulot", "goupille", "gourmand", "goutte", "graduel", "graffiti", "graine", "grand", "grappin", "gratuit", "gravir", "grenat", "griffure", "griller", "grimper", "grogner", "gronder", "grotte", "groupe", "gruger", "grutier", "gruyère", "guépard", "guerrier", "guide", "guimauve", "guitare", "gustatif", "gymnaste", "gyrostat", "habitude", "hachoir", "halte", "hameau", "hangar", "hanneton", "haricot", "harmonie", "harpon", "hasard", "hélium", "hématome", "herbe", "hérisson", "hermine", "héron", "hésiter", "heureux", "hiberner", "hibou", "hilarant", "histoire", "hiver", "homard", "hommage", "homogène", "honneur", "honorer", "honteux", "horde", "horizon", "horloge", "hormone", "horrible", "houleux", "housse", "hublot", "huileux", "humain", "humble", "humide", "humour", "hurler", "hydromel", "hygiène", "hymne", "hypnose", "idylle", "ignorer", "iguane", "illicite", "illusion", "image", "imbiber", "imiter", "immense", "immobile", "immuable", "impact", "impérial", "implorer", "imposer", "imprimer", "imputer", "incarner", "incendie", "incident", "incliner", "incolore", "indexer", "indice", "inductif", "inédit", "ineptie", "inexact", "infini", "infliger", "informer", "infusion", "ingérer", "inhaler", "inhiber", "injecter", "injure", "innocent", "inoculer", "inonder", "inscrire", "insecte", "insigne", "insolite", "inspirer", "instinct", "insulter", "intact", "intense", "intime", "intrigue", "intuitif", "inutile", "invasion", "inventer", "inviter", "invoquer", "ironique", "irradier", "irréel", "irriter", "isoler", "ivoire", "ivresse", "jaguar", "jaillir", "jambe", "janvier", "jardin", "jauger", "jaune", "javelot", "jetable", "jeton", "jeudi", "jeunesse", "joindre", "joncher", "jongler", "joueur", "jouissif", "journal", "jovial", "joyau", "joyeux", "jubiler", "jugement", "junior", "jupon", "juriste", "justice", "juteux", "juvénile", "kayak", "kimono", "kiosque", "label", "labial", "labourer", "lacérer", "lactose", "lagune", "laine", "laisser", "laitier", "lambeau", "lamelle", "lampe", "lanceur", "langage", "lanterne", "lapin", "largeur", "larme", "laurier", "lavabo", "lavoir", "lecture", "légal", "léger", "légume", "lessive", "lettre", "levier", "lexique", "lézard", "liasse", "libérer", "libre", "licence", "licorne", "liège", "lièvre", "ligature", "ligoter", "ligue", "limer", "limite", "limonade", "limpide", "linéaire", "lingot", "lionceau", "liquide", "lisière", "lister", "lithium", "litige", "littoral", "livreur", "logique", "lointain", "loisir", "lombric", "loterie", "louer", "lourd", "loutre", "louve", "loyal", "lubie", "lucide", "lucratif", "lueur", "lugubre", "luisant", "lumière", "lunaire", "lundi", "luron", "lutter", "luxueux", "machine", "magasin", "magenta", "magique", "maigre", "maillon", "maintien", "mairie", "maison", "majorer", "malaxer", "maléfice", "malheur", "malice", "mallette", "mammouth", "mandater", "maniable", "manquant", "manteau", "manuel", "marathon", "marbre", "marchand", "mardi", "maritime", "marqueur", "marron", "marteler", "mascotte", "massif", "matériel", "matière", "matraque", "maudire", "maussade", "mauve", "maximal", "méchant", "méconnu", "médaille", "médecin", "méditer", "méduse", "meilleur", "mélange", "mélodie", "membre", "mémoire", "menacer", "mener", "menhir", "mensonge", "mentor", "mercredi", "mérite", "merle", "messager", "mesure", "métal", "météore", "méthode", "métier", "meuble", "miauler", "microbe", "miette", "mignon", "migrer", "milieu", "million", "mimique", "mince", "minéral", "minimal", "minorer", "minute", "miracle", "miroiter", "missile", "mixte", "mobile", "moderne", "moelleux", "mondial", "moniteur", "monnaie", "monotone", "monstre", "montagne", "monument", "moqueur", "morceau", "morsure", "mortier", "moteur", "motif", "mouche", "moufle", "moulin", "mousson", "mouton", "mouvant", "multiple", "munition", "muraille", "murène", "murmure", "muscle", "muséum", "musicien", "mutation", "muter", "mutuel", "myriade", "myrtille", "mystère", "mythique", "nageur", "nappe", "narquois", "narrer", "natation", "nation", "nature", "naufrage", "nautique", "navire", "nébuleux", "nectar", "néfaste", "négation", "négliger", "négocier", "neige", "nerveux", "nettoyer", "neurone", "neutron", "neveu", "niche", "nickel", "nitrate", "niveau", "noble", "nocif", "nocturne", "noirceur", "noisette", "nomade", "nombreux", "nommer", "normatif", "notable", "notifier", "notoire", "nourrir", "nouveau", "novateur", "novembre", "novice", "nuage", "nuancer", "nuire", "nuisible", "numéro", "nuptial", "nuque", "nutritif", "obéir", "objectif", "obliger", "obscur", "observer", "obstacle", "obtenir", "obturer", "occasion", "occuper", "océan", "octobre", "octroyer", "octupler", "oculaire", "odeur", "odorant", "offenser", "officier", "offrir", "ogive", "oiseau", "oisillon", "olfactif", "olivier", "ombrage", "omettre", "onctueux", "onduler", "onéreux", "onirique", "opale", "opaque", "opérer", "opinion", "opportun", "opprimer", "opter", "optique", "orageux", "orange", "orbite", "ordonner", "oreille", "organe", "orgueil", "orifice", "ornement", "orque", "ortie", "osciller", "osmose", "ossature", "otarie", "ouragan", "ourson", "outil", "outrager", "ouvrage", "ovation", "oxyde", "oxygène", "ozone", "paisible", "palace", "palmarès", "palourde", "palper", "panache", "panda", "pangolin", "paniquer", "panneau", "panorama", "pantalon", "papaye", "papier", "papoter", "papyrus", "paradoxe", "parcelle", "paresse", "parfumer", "parler", "parole", "parrain", "parsemer", "partager", "parure", "parvenir", "passion", "pastèque", "paternel", "patience", "patron", "pavillon", "pavoiser", "payer", "paysage", "peigne", "peintre", "pelage", "pélican", "pelle", "pelouse", "peluche", "pendule", "pénétrer", "pénible", "pensif", "pénurie", "pépite", "péplum", "perdrix", "perforer", "période", "permuter", "perplexe", "persil", "perte", "peser", "pétale", "petit", "pétrir", "peuple", "pharaon", "phobie", "phoque", "photon", "phrase", "physique", "piano", "pictural", "pièce", "pierre", "pieuvre", "pilote", "pinceau", "pipette", "piquer", "pirogue", "piscine", "piston", "pivoter", "pixel", "pizza", "placard", "plafond", "plaisir", "planer", "plaque", "plastron", "plateau", "pleurer", "plexus", "pliage", "plomb", "plonger", "pluie", "plumage", "pochette", "poésie", "poète", "pointe", "poirier", "poisson", "poivre", "polaire", "policier", "pollen", "polygone", "pommade", "pompier", "ponctuel", "pondérer", "poney", "portique", "position", "posséder", "posture", "potager", "poteau", "potion", "pouce", "poulain", "poumon", "pourpre", "poussin", "pouvoir", "prairie", "pratique", "précieux", "prédire", "préfixe", "prélude", "prénom", "présence", "prétexte", "prévoir", "primitif", "prince", "prison", "priver", "problème", "procéder", "prodige", "profond", "progrès", "proie", "projeter", "prologue", "promener", "propre", "prospère", "protéger", "prouesse", "proverbe", "prudence", "pruneau", "psychose", "public", "puceron", "puiser", "pulpe", "pulsar", "punaise", "punitif", "pupitre", "purifier", "puzzle", "pyramide", "quasar", "querelle", "question", "quiétude", "quitter", "quotient", "racine", "raconter", "radieux", "ragondin", "raideur", "raisin", "ralentir", "rallonge", "ramasser", "rapide", "rasage", "ratisser", "ravager", "ravin", "rayonner", "réactif", "réagir", "réaliser", "réanimer", "recevoir", "réciter", "réclamer", "récolter", "recruter", "reculer", "recycler", "rédiger", "redouter", "refaire", "réflexe", "réformer", "refrain", "refuge", "régalien", "région", "réglage", "régulier", "réitérer", "rejeter", "rejouer", "relatif", "relever", "relief", "remarque", "remède", "remise", "remonter", "remplir", "remuer", "renard", "renfort", "renifler", "renoncer", "rentrer", "renvoi", "replier", "reporter", "reprise", "reptile", "requin", "réserve", "résineux", "résoudre", "respect", "rester", "résultat", "rétablir", "retenir", "réticule", "retomber", "retracer", "réunion", "réussir", "revanche", "revivre", "révolte", "révulsif", "richesse", "rideau", "rieur", "rigide", "rigoler", "rincer", "riposter", "risible", "risque", "rituel", "rival", "rivière", "rocheux", "romance", "rompre", "ronce", "rondin", "roseau", "rosier", "rotatif", "rotor", "rotule", "rouge", "rouille", "rouleau", "routine", "royaume", "ruban", "rubis", "ruche", "ruelle", "rugueux", "ruiner", "ruisseau", "ruser", "rustique", "rythme", "sabler", "saboter", "sabre", "sacoche", "safari", "sagesse", "saisir", "salade", "salive", "salon", "saluer", "samedi", "sanction", "sanglier", "sarcasme", "sardine", "saturer", "saugrenu", "saumon", "sauter", "sauvage", "savant", "savonner", "scalpel", "scandale", "scélérat", "scénario", "sceptre", "schéma", "science", "scinder", "score", "scrutin", "sculpter", "séance", "sécable", "sécher", "secouer", "sécréter", "sédatif", "séduire", "seigneur", "séjour", "sélectif", "semaine", "sembler", "semence", "séminal", "sénateur", "sensible", "sentence", "séparer", "séquence", "serein", "sergent", "sérieux", "serrure", "sérum", "service", "sésame", "sévir", "sevrage", "sextuple", "sidéral", "siècle", "siéger", "siffler", "sigle", "signal", "silence", "silicium", "simple", "sincère", "sinistre", "siphon", "sirop", "sismique", "situer", "skier", "social", "socle", "sodium", "soigneux", "soldat", "soleil", "solitude", "soluble", "sombre", "sommeil", "somnoler", "sonde", "songeur", "sonnette", "sonore", "sorcier", "sortir", "sosie", "sottise", "soucieux", "soudure", "souffle", "soulever", "soupape", "source", "soutirer", "souvenir", "spacieux", "spatial", "spécial", "sphère", "spiral", "stable", "station", "sternum", "stimulus", "stipuler", "strict", "studieux", "stupeur", "styliste", "sublime", "substrat", "subtil", "subvenir", "succès", "sucre", "suffixe", "suggérer", "suiveur", "sulfate", "superbe", "supplier", "surface", "suricate", "surmener", "surprise", "sursaut", "survie", "suspect", "syllabe", "symbole", "symétrie", "synapse", "syntaxe", "système", "tabac", "tablier", "tactile", "tailler", "talent", "talisman", "talonner", "tambour", "tamiser", "tangible", "tapis", "taquiner", "tarder", "tarif", "tartine", "tasse", "tatami", "tatouage", "taupe", "taureau", "taxer", "témoin", "temporel", "tenaille", "tendre", "teneur", "tenir", "tension", "terminer", "terne", "terrible", "tétine", "texte", "thème", "théorie", "thérapie", "thorax", "tibia", "tiède", "timide", "tirelire", "tiroir", "tissu", "titane", "titre", "tituber", "toboggan", "tolérant", "tomate", "tonique", "tonneau", "toponyme", "torche", "tordre", "tornade", "torpille", "torrent", "torse", "tortue", "totem", "toucher", "tournage", "tousser", "toxine", "traction", "trafic", "tragique", "trahir", "train", "trancher", "travail", "trèfle", "tremper", "trésor", "treuil", "triage", "tribunal", "tricoter", "trilogie", "triomphe", "tripler", "triturer", "trivial", "trombone", "tronc", "tropical", "troupeau", "tuile", "tulipe", "tumulte", "tunnel", "turbine", "tuteur", "tutoyer", "tuyau", "tympan", "typhon", "typique", "tyran", "ubuesque", "ultime", "ultrason", "unanime", "unifier", "union", "unique", "unitaire", "univers", "uranium", "urbain", "urticant", "usage", "usine", "usuel", "usure", "utile", "utopie", "vacarme", "vaccin", "vagabond", "vague", "vaillant", "vaincre", "vaisseau", "valable", "valise", "vallon", "valve", "vampire", "vanille", "vapeur", "varier", "vaseux", "vassal", "vaste", "vecteur", "vedette", "végétal", "véhicule", "veinard", "véloce", "vendredi", "vénérer", "venger", "venimeux", "ventouse", "verdure", "vérin", "vernir", "verrou", "verser", "vertu", "veston", "vétéran", "vétuste", "vexant", "vexer", "viaduc", "viande", "victoire", "vidange", "vidéo", "vignette", "vigueur", "vilain", "village", "vinaigre", "violon", "vipère", "virement", "virtuose", "virus", "visage", "viseur", "vision", "visqueux", "visuel", "vital", "vitesse", "viticole", "vitrine", "vivace", "vivipare", "vocation", "voguer", "voile", "voisin", "voiture", "volaille", "volcan", "voltiger", "volume", "vorace", "vortex", "voter", "vouloir", "voyage", "voyelle", "wagon", "xénon", "yacht", "zèbre", "zénith", "zeste", "zoologie"];

  var require$$5 = ["abaco", "abbaglio", "abbinato", "abete", "abisso", "abolire", "abrasivo", "abrogato", "accadere", "accenno", "accusato", "acetone", "achille", "acido", "acqua", "acre", "acrilico", "acrobata", "acuto", "adagio", "addebito", "addome", "adeguato", "aderire", "adipe", "adottare", "adulare", "affabile", "affetto", "affisso", "affranto", "aforisma", "afoso", "africano", "agave", "agente", "agevole", "aggancio", "agire", "agitare", "agonismo", "agricolo", "agrumeto", "aguzzo", "alabarda", "alato", "albatro", "alberato", "albo", "albume", "alce", "alcolico", "alettone", "alfa", "algebra", "aliante", "alibi", "alimento", "allagato", "allegro", "allievo", "allodola", "allusivo", "almeno", "alogeno", "alpaca", "alpestre", "altalena", "alterno", "alticcio", "altrove", "alunno", "alveolo", "alzare", "amalgama", "amanita", "amarena", "ambito", "ambrato", "ameba", "america", "ametista", "amico", "ammasso", "ammenda", "ammirare", "ammonito", "amore", "ampio", "ampliare", "amuleto", "anacardo", "anagrafe", "analista", "anarchia", "anatra", "anca", "ancella", "ancora", "andare", "andrea", "anello", "angelo", "angolare", "angusto", "anima", "annegare", "annidato", "anno", "annuncio", "anonimo", "anticipo", "anzi", "apatico", "apertura", "apode", "apparire", "appetito", "appoggio", "approdo", "appunto", "aprile", "arabica", "arachide", "aragosta", "araldica", "arancio", "aratura", "arazzo", "arbitro", "archivio", "ardito", "arenile", "argento", "argine", "arguto", "aria", "armonia", "arnese", "arredato", "arringa", "arrosto", "arsenico", "arso", "artefice", "arzillo", "asciutto", "ascolto", "asepsi", "asettico", "asfalto", "asino", "asola", "aspirato", "aspro", "assaggio", "asse", "assoluto", "assurdo", "asta", "astenuto", "astice", "astratto", "atavico", "ateismo", "atomico", "atono", "attesa", "attivare", "attorno", "attrito", "attuale", "ausilio", "austria", "autista", "autonomo", "autunno", "avanzato", "avere", "avvenire", "avviso", "avvolgere", "azione", "azoto", "azzimo", "azzurro", "babele", "baccano", "bacino", "baco", "badessa", "badilata", "bagnato", "baita", "balcone", "baldo", "balena", "ballata", "balzano", "bambino", "bandire", "baraonda", "barbaro", "barca", "baritono", "barlume", "barocco", "basilico", "basso", "batosta", "battuto", "baule", "bava", "bavosa", "becco", "beffa", "belgio", "belva", "benda", "benevole", "benigno", "benzina", "bere", "berlina", "beta", "bibita", "bici", "bidone", "bifido", "biga", "bilancia", "bimbo", "binocolo", "biologo", "bipede", "bipolare", "birbante", "birra", "biscotto", "bisesto", "bisnonno", "bisonte", "bisturi", "bizzarro", "blando", "blatta", "bollito", "bonifico", "bordo", "bosco", "botanico", "bottino", "bozzolo", "braccio", "bradipo", "brama", "branca", "bravura", "bretella", "brevetto", "brezza", "briglia", "brillante", "brindare", "broccolo", "brodo", "bronzina", "brullo", "bruno", "bubbone", "buca", "budino", "buffone", "buio", "bulbo", "buono", "burlone", "burrasca", "bussola", "busta", "cadetto", "caduco", "calamaro", "calcolo", "calesse", "calibro", "calmo", "caloria", "cambusa", "camerata", "camicia", "cammino", "camola", "campale", "canapa", "candela", "cane", "canino", "canotto", "cantina", "capace", "capello", "capitolo", "capogiro", "cappero", "capra", "capsula", "carapace", "carcassa", "cardo", "carisma", "carovana", "carretto", "cartolina", "casaccio", "cascata", "caserma", "caso", "cassone", "castello", "casuale", "catasta", "catena", "catrame", "cauto", "cavillo", "cedibile", "cedrata", "cefalo", "celebre", "cellulare", "cena", "cenone", "centesimo", "ceramica", "cercare", "certo", "cerume", "cervello", "cesoia", "cespo", "ceto", "chela", "chiaro", "chicca", "chiedere", "chimera", "china", "chirurgo", "chitarra", "ciao", "ciclismo", "cifrare", "cigno", "cilindro", "ciottolo", "circa", "cirrosi", "citrico", "cittadino", "ciuffo", "civetta", "civile", "classico", "clinica", "cloro", "cocco", "codardo", "codice", "coerente", "cognome", "collare", "colmato", "colore", "colposo", "coltivato", "colza", "coma", "cometa", "commando", "comodo", "computer", "comune", "conciso", "condurre", "conferma", "congelare", "coniuge", "connesso", "conoscere", "consumo", "continuo", "convegno", "coperto", "copione", "coppia", "copricapo", "corazza", "cordata", "coricato", "cornice", "corolla", "corpo", "corredo", "corsia", "cortese", "cosmico", "costante", "cottura", "covato", "cratere", "cravatta", "creato", "credere", "cremoso", "crescita", "creta", "criceto", "crinale", "crisi", "critico", "croce", "cronaca", "crostata", "cruciale", "crusca", "cucire", "cuculo", "cugino", "cullato", "cupola", "curatore", "cursore", "curvo", "cuscino", "custode", "dado", "daino", "dalmata", "damerino", "daniela", "dannoso", "danzare", "datato", "davanti", "davvero", "debutto", "decennio", "deciso", "declino", "decollo", "decreto", "dedicato", "definito", "deforme", "degno", "delegare", "delfino", "delirio", "delta", "demenza", "denotato", "dentro", "deposito", "derapata", "derivare", "deroga", "descritto", "deserto", "desiderio", "desumere", "detersivo", "devoto", "diametro", "dicembre", "diedro", "difeso", "diffuso", "digerire", "digitale", "diluvio", "dinamico", "dinnanzi", "dipinto", "diploma", "dipolo", "diradare", "dire", "dirotto", "dirupo", "disagio", "discreto", "disfare", "disgelo", "disposto", "distanza", "disumano", "dito", "divano", "divelto", "dividere", "divorato", "doblone", "docente", "doganale", "dogma", "dolce", "domato", "domenica", "dominare", "dondolo", "dono", "dormire", "dote", "dottore", "dovuto", "dozzina", "drago", "druido", "dubbio", "dubitare", "ducale", "duna", "duomo", "duplice", "duraturo", "ebano", "eccesso", "ecco", "eclissi", "economia", "edera", "edicola", "edile", "editoria", "educare", "egemonia", "egli", "egoismo", "egregio", "elaborato", "elargire", "elegante", "elencato", "eletto", "elevare", "elfico", "elica", "elmo", "elsa", "eluso", "emanato", "emblema", "emesso", "emiro", "emotivo", "emozione", "empirico", "emulo", "endemico", "enduro", "energia", "enfasi", "enoteca", "entrare", "enzima", "epatite", "epilogo", "episodio", "epocale", "eppure", "equatore", "erario", "erba", "erboso", "erede", "eremita", "erigere", "ermetico", "eroe", "erosivo", "errante", "esagono", "esame", "esanime", "esaudire", "esca", "esempio", "esercito", "esibito", "esigente", "esistere", "esito", "esofago", "esortato", "esoso", "espanso", "espresso", "essenza", "esso", "esteso", "estimare", "estonia", "estroso", "esultare", "etilico", "etnico", "etrusco", "etto", "euclideo", "europa", "evaso", "evidenza", "evitato", "evoluto", "evviva", "fabbrica", "faccenda", "fachiro", "falco", "famiglia", "fanale", "fanfara", "fango", "fantasma", "fare", "farfalla", "farinoso", "farmaco", "fascia", "fastoso", "fasullo", "faticare", "fato", "favoloso", "febbre", "fecola", "fede", "fegato", "felpa", "feltro", "femmina", "fendere", "fenomeno", "fermento", "ferro", "fertile", "fessura", "festivo", "fetta", "feudo", "fiaba", "fiducia", "fifa", "figurato", "filo", "finanza", "finestra", "finire", "fiore", "fiscale", "fisico", "fiume", "flacone", "flamenco", "flebo", "flemma", "florido", "fluente", "fluoro", "fobico", "focaccia", "focoso", "foderato", "foglio", "folata", "folclore", "folgore", "fondente", "fonetico", "fonia", "fontana", "forbito", "forchetta", "foresta", "formica", "fornaio", "foro", "fortezza", "forzare", "fosfato", "fosso", "fracasso", "frana", "frassino", "fratello", "freccetta", "frenata", "fresco", "frigo", "frollino", "fronde", "frugale", "frutta", "fucilata", "fucsia", "fuggente", "fulmine", "fulvo", "fumante", "fumetto", "fumoso", "fune", "funzione", "fuoco", "furbo", "furgone", "furore", "fuso", "futile", "gabbiano", "gaffe", "galateo", "gallina", "galoppo", "gambero", "gamma", "garanzia", "garbo", "garofano", "garzone", "gasdotto", "gasolio", "gastrico", "gatto", "gaudio", "gazebo", "gazzella", "geco", "gelatina", "gelso", "gemello", "gemmato", "gene", "genitore", "gennaio", "genotipo", "gergo", "ghepardo", "ghiaccio", "ghisa", "giallo", "gilda", "ginepro", "giocare", "gioiello", "giorno", "giove", "girato", "girone", "gittata", "giudizio", "giurato", "giusto", "globulo", "glutine", "gnomo", "gobba", "golf", "gomito", "gommone", "gonfio", "gonna", "governo", "gracile", "grado", "grafico", "grammo", "grande", "grattare", "gravoso", "grazia", "greca", "gregge", "grifone", "grigio", "grinza", "grotta", "gruppo", "guadagno", "guaio", "guanto", "guardare", "gufo", "guidare", "ibernato", "icona", "identico", "idillio", "idolo", "idra", "idrico", "idrogeno", "igiene", "ignaro", "ignorato", "ilare", "illeso", "illogico", "illudere", "imballo", "imbevuto", "imbocco", "imbuto", "immane", "immerso", "immolato", "impacco", "impeto", "impiego", "importo", "impronta", "inalare", "inarcare", "inattivo", "incanto", "incendio", "inchino", "incisivo", "incluso", "incontro", "incrocio", "incubo", "indagine", "india", "indole", "inedito", "infatti", "infilare", "inflitto", "ingaggio", "ingegno", "inglese", "ingordo", "ingrosso", "innesco", "inodore", "inoltrare", "inondato", "insano", "insetto", "insieme", "insonnia", "insulina", "intasato", "intero", "intonaco", "intuito", "inumidire", "invalido", "invece", "invito", "iperbole", "ipnotico", "ipotesi", "ippica", "iride", "irlanda", "ironico", "irrigato", "irrorare", "isolato", "isotopo", "isterico", "istituto", "istrice", "italia", "iterare", "labbro", "labirinto", "lacca", "lacerato", "lacrima", "lacuna", "laddove", "lago", "lampo", "lancetta", "lanterna", "lardoso", "larga", "laringe", "lastra", "latenza", "latino", "lattuga", "lavagna", "lavoro", "legale", "leggero", "lembo", "lentezza", "lenza", "leone", "lepre", "lesivo", "lessato", "lesto", "letterale", "leva", "levigato", "libero", "lido", "lievito", "lilla", "limatura", "limitare", "limpido", "lineare", "lingua", "liquido", "lira", "lirica", "lisca", "lite", "litigio", "livrea", "locanda", "lode", "logica", "lombare", "londra", "longevo", "loquace", "lorenzo", "loto", "lotteria", "luce", "lucidato", "lumaca", "luminoso", "lungo", "lupo", "luppolo", "lusinga", "lusso", "lutto", "macabro", "macchina", "macero", "macinato", "madama", "magico", "maglia", "magnete", "magro", "maiolica", "malafede", "malgrado", "malinteso", "malsano", "malto", "malumore", "mana", "mancia", "mandorla", "mangiare", "manifesto", "mannaro", "manovra", "mansarda", "mantide", "manubrio", "mappa", "maratona", "marcire", "maretta", "marmo", "marsupio", "maschera", "massaia", "mastino", "materasso", "matricola", "mattone", "maturo", "mazurca", "meandro", "meccanico", "mecenate", "medesimo", "meditare", "mega", "melassa", "melis", "melodia", "meninge", "meno", "mensola", "mercurio", "merenda", "merlo", "meschino", "mese", "messere", "mestolo", "metallo", "metodo", "mettere", "miagolare", "mica", "micelio", "michele", "microbo", "midollo", "miele", "migliore", "milano", "milite", "mimosa", "minerale", "mini", "minore", "mirino", "mirtillo", "miscela", "missiva", "misto", "misurare", "mitezza", "mitigare", "mitra", "mittente", "mnemonico", "modello", "modifica", "modulo", "mogano", "mogio", "mole", "molosso", "monastero", "monco", "mondina", "monetario", "monile", "monotono", "monsone", "montato", "monviso", "mora", "mordere", "morsicato", "mostro", "motivato", "motosega", "motto", "movenza", "movimento", "mozzo", "mucca", "mucosa", "muffa", "mughetto", "mugnaio", "mulatto", "mulinello", "multiplo", "mummia", "munto", "muovere", "murale", "musa", "muscolo", "musica", "mutevole", "muto", "nababbo", "nafta", "nanometro", "narciso", "narice", "narrato", "nascere", "nastrare", "naturale", "nautica", "naviglio", "nebulosa", "necrosi", "negativo", "negozio", "nemmeno", "neofita", "neretto", "nervo", "nessuno", "nettuno", "neutrale", "neve", "nevrotico", "nicchia", "ninfa", "nitido", "nobile", "nocivo", "nodo", "nome", "nomina", "nordico", "normale", "norvegese", "nostrano", "notare", "notizia", "notturno", "novella", "nucleo", "nulla", "numero", "nuovo", "nutrire", "nuvola", "nuziale", "oasi", "obbedire", "obbligo", "obelisco", "oblio", "obolo", "obsoleto", "occasione", "occhio", "occidente", "occorrere", "occultare", "ocra", "oculato", "odierno", "odorare", "offerta", "offrire", "offuscato", "oggetto", "oggi", "ognuno", "olandese", "olfatto", "oliato", "oliva", "ologramma", "oltre", "omaggio", "ombelico", "ombra", "omega", "omissione", "ondoso", "onere", "onice", "onnivoro", "onorevole", "onta", "operato", "opinione", "opposto", "oracolo", "orafo", "ordine", "orecchino", "orefice", "orfano", "organico", "origine", "orizzonte", "orma", "ormeggio", "ornativo", "orologio", "orrendo", "orribile", "ortensia", "ortica", "orzata", "orzo", "osare", "oscurare", "osmosi", "ospedale", "ospite", "ossa", "ossidare", "ostacolo", "oste", "otite", "otre", "ottagono", "ottimo", "ottobre", "ovale", "ovest", "ovino", "oviparo", "ovocito", "ovunque", "ovviare", "ozio", "pacchetto", "pace", "pacifico", "padella", "padrone", "paese", "paga", "pagina", "palazzina", "palesare", "pallido", "palo", "palude", "pandoro", "pannello", "paolo", "paonazzo", "paprica", "parabola", "parcella", "parere", "pargolo", "pari", "parlato", "parola", "partire", "parvenza", "parziale", "passivo", "pasticca", "patacca", "patologia", "pattume", "pavone", "peccato", "pedalare", "pedonale", "peggio", "peloso", "penare", "pendice", "penisola", "pennuto", "penombra", "pensare", "pentola", "pepe", "pepita", "perbene", "percorso", "perdonato", "perforare", "pergamena", "periodo", "permesso", "perno", "perplesso", "persuaso", "pertugio", "pervaso", "pesatore", "pesista", "peso", "pestifero", "petalo", "pettine", "petulante", "pezzo", "piacere", "pianta", "piattino", "piccino", "picozza", "piega", "pietra", "piffero", "pigiama", "pigolio", "pigro", "pila", "pilifero", "pillola", "pilota", "pimpante", "pineta", "pinna", "pinolo", "pioggia", "piombo", "piramide", "piretico", "pirite", "pirolisi", "pitone", "pizzico", "placebo", "planare", "plasma", "platano", "plenario", "pochezza", "poderoso", "podismo", "poesia", "poggiare", "polenta", "poligono", "pollice", "polmonite", "polpetta", "polso", "poltrona", "polvere", "pomice", "pomodoro", "ponte", "popoloso", "porfido", "poroso", "porpora", "porre", "portata", "posa", "positivo", "possesso", "postulato", "potassio", "potere", "pranzo", "prassi", "pratica", "precluso", "predica", "prefisso", "pregiato", "prelievo", "premere", "prenotare", "preparato", "presenza", "pretesto", "prevalso", "prima", "principe", "privato", "problema", "procura", "produrre", "profumo", "progetto", "prolunga", "promessa", "pronome", "proposta", "proroga", "proteso", "prova", "prudente", "prugna", "prurito", "psiche", "pubblico", "pudica", "pugilato", "pugno", "pulce", "pulito", "pulsante", "puntare", "pupazzo", "pupilla", "puro", "quadro", "qualcosa", "quasi", "querela", "quota", "raccolto", "raddoppio", "radicale", "radunato", "raffica", "ragazzo", "ragione", "ragno", "ramarro", "ramingo", "ramo", "randagio", "rantolare", "rapato", "rapina", "rappreso", "rasatura", "raschiato", "rasente", "rassegna", "rastrello", "rata", "ravveduto", "reale", "recepire", "recinto", "recluta", "recondito", "recupero", "reddito", "redimere", "regalato", "registro", "regola", "regresso", "relazione", "remare", "remoto", "renna", "replica", "reprimere", "reputare", "resa", "residente", "responso", "restauro", "rete", "retina", "retorica", "rettifica", "revocato", "riassunto", "ribadire", "ribelle", "ribrezzo", "ricarica", "ricco", "ricevere", "riciclato", "ricordo", "ricreduto", "ridicolo", "ridurre", "rifasare", "riflesso", "riforma", "rifugio", "rigare", "rigettato", "righello", "rilassato", "rilevato", "rimanere", "rimbalzo", "rimedio", "rimorchio", "rinascita", "rincaro", "rinforzo", "rinnovo", "rinomato", "rinsavito", "rintocco", "rinuncia", "rinvenire", "riparato", "ripetuto", "ripieno", "riportare", "ripresa", "ripulire", "risata", "rischio", "riserva", "risibile", "riso", "rispetto", "ristoro", "risultato", "risvolto", "ritardo", "ritegno", "ritmico", "ritrovo", "riunione", "riva", "riverso", "rivincita", "rivolto", "rizoma", "roba", "robotico", "robusto", "roccia", "roco", "rodaggio", "rodere", "roditore", "rogito", "rollio", "romantico", "rompere", "ronzio", "rosolare", "rospo", "rotante", "rotondo", "rotula", "rovescio", "rubizzo", "rubrica", "ruga", "rullino", "rumine", "rumoroso", "ruolo", "rupe", "russare", "rustico", "sabato", "sabbiare", "sabotato", "sagoma", "salasso", "saldatura", "salgemma", "salivare", "salmone", "salone", "saltare", "saluto", "salvo", "sapere", "sapido", "saporito", "saraceno", "sarcasmo", "sarto", "sassoso", "satellite", "satira", "satollo", "saturno", "savana", "savio", "saziato", "sbadiglio", "sbalzo", "sbancato", "sbarra", "sbattere", "sbavare", "sbendare", "sbirciare", "sbloccato", "sbocciato", "sbrinare", "sbruffone", "sbuffare", "scabroso", "scadenza", "scala", "scambiare", "scandalo", "scapola", "scarso", "scatenare", "scavato", "scelto", "scenico", "scettro", "scheda", "schiena", "sciarpa", "scienza", "scindere", "scippo", "sciroppo", "scivolo", "sclerare", "scodella", "scolpito", "scomparto", "sconforto", "scoprire", "scorta", "scossone", "scozzese", "scriba", "scrollare", "scrutinio", "scuderia", "scultore", "scuola", "scuro", "scusare", "sdebitare", "sdoganare", "seccatura", "secondo", "sedano", "seggiola", "segnalato", "segregato", "seguito", "selciato", "selettivo", "sella", "selvaggio", "semaforo", "sembrare", "seme", "seminato", "sempre", "senso", "sentire", "sepolto", "sequenza", "serata", "serbato", "sereno", "serio", "serpente", "serraglio", "servire", "sestina", "setola", "settimana", "sfacelo", "sfaldare", "sfamato", "sfarzoso", "sfaticato", "sfera", "sfida", "sfilato", "sfinge", "sfocato", "sfoderare", "sfogo", "sfoltire", "sforzato", "sfratto", "sfruttato", "sfuggito", "sfumare", "sfuso", "sgabello", "sgarbato", "sgonfiare", "sgorbio", "sgrassato", "sguardo", "sibilo", "siccome", "sierra", "sigla", "signore", "silenzio", "sillaba", "simbolo", "simpatico", "simulato", "sinfonia", "singolo", "sinistro", "sino", "sintesi", "sinusoide", "sipario", "sisma", "sistole", "situato", "slitta", "slogatura", "sloveno", "smarrito", "smemorato", "smentito", "smeraldo", "smilzo", "smontare", "smottato", "smussato", "snellire", "snervato", "snodo", "sobbalzo", "sobrio", "soccorso", "sociale", "sodale", "soffitto", "sogno", "soldato", "solenne", "solido", "sollazzo", "solo", "solubile", "solvente", "somatico", "somma", "sonda", "sonetto", "sonnifero", "sopire", "soppeso", "sopra", "sorgere", "sorpasso", "sorriso", "sorso", "sorteggio", "sorvolato", "sospiro", "sosta", "sottile", "spada", "spalla", "spargere", "spatola", "spavento", "spazzola", "specie", "spedire", "spegnere", "spelatura", "speranza", "spessore", "spettrale", "spezzato", "spia", "spigoloso", "spillato", "spinoso", "spirale", "splendido", "sportivo", "sposo", "spranga", "sprecare", "spronato", "spruzzo", "spuntino", "squillo", "sradicare", "srotolato", "stabile", "stacco", "staffa", "stagnare", "stampato", "stantio", "starnuto", "stasera", "statuto", "stelo", "steppa", "sterzo", "stiletto", "stima", "stirpe", "stivale", "stizzoso", "stonato", "storico", "strappo", "stregato", "stridulo", "strozzare", "strutto", "stuccare", "stufo", "stupendo", "subentro", "succoso", "sudore", "suggerito", "sugo", "sultano", "suonare", "superbo", "supporto", "surgelato", "surrogato", "sussurro", "sutura", "svagare", "svedese", "sveglio", "svelare", "svenuto", "svezia", "sviluppo", "svista", "svizzera", "svolta", "svuotare", "tabacco", "tabulato", "tacciare", "taciturno", "tale", "talismano", "tampone", "tannino", "tara", "tardivo", "targato", "tariffa", "tarpare", "tartaruga", "tasto", "tattico", "taverna", "tavolata", "tazza", "teca", "tecnico", "telefono", "temerario", "tempo", "temuto", "tendone", "tenero", "tensione", "tentacolo", "teorema", "terme", "terrazzo", "terzetto", "tesi", "tesserato", "testato", "tetro", "tettoia", "tifare", "tigella", "timbro", "tinto", "tipico", "tipografo", "tiraggio", "tiro", "titanio", "titolo", "titubante", "tizio", "tizzone", "toccare", "tollerare", "tolto", "tombola", "tomo", "tonfo", "tonsilla", "topazio", "topologia", "toppa", "torba", "tornare", "torrone", "tortora", "toscano", "tossire", "tostatura", "totano", "trabocco", "trachea", "trafila", "tragedia", "tralcio", "tramonto", "transito", "trapano", "trarre", "trasloco", "trattato", "trave", "treccia", "tremolio", "trespolo", "tributo", "tricheco", "trifoglio", "trillo", "trincea", "trio", "tristezza", "triturato", "trivella", "tromba", "trono", "troppo", "trottola", "trovare", "truccato", "tubatura", "tuffato", "tulipano", "tumulto", "tunisia", "turbare", "turchino", "tuta", "tutela", "ubicato", "uccello", "uccisore", "udire", "uditivo", "uffa", "ufficio", "uguale", "ulisse", "ultimato", "umano", "umile", "umorismo", "uncinetto", "ungere", "ungherese", "unicorno", "unificato", "unisono", "unitario", "unte", "uovo", "upupa", "uragano", "urgenza", "urlo", "usanza", "usato", "uscito", "usignolo", "usuraio", "utensile", "utilizzo", "utopia", "vacante", "vaccinato", "vagabondo", "vagliato", "valanga", "valgo", "valico", "valletta", "valoroso", "valutare", "valvola", "vampata", "vangare", "vanitoso", "vano", "vantaggio", "vanvera", "vapore", "varano", "varcato", "variante", "vasca", "vedetta", "vedova", "veduto", "vegetale", "veicolo", "velcro", "velina", "velluto", "veloce", "venato", "vendemmia", "vento", "verace", "verbale", "vergogna", "verifica", "vero", "verruca", "verticale", "vescica", "vessillo", "vestale", "veterano", "vetrina", "vetusto", "viandante", "vibrante", "vicenda", "vichingo", "vicinanza", "vidimare", "vigilia", "vigneto", "vigore", "vile", "villano", "vimini", "vincitore", "viola", "vipera", "virgola", "virologo", "virulento", "viscoso", "visione", "vispo", "vissuto", "visura", "vita", "vitello", "vittima", "vivanda", "vivido", "viziare", "voce", "voga", "volatile", "volere", "volpe", "voragine", "vulcano", "zampogna", "zanna", "zappato", "zattera", "zavorra", "zefiro", "zelante", "zelo", "zenzero", "zerbino", "zibetto", "zinco", "zircone", "zitto", "zolla", "zotico", "zucchero", "zufolo", "zulu", "zuppa"];

  var require$$6 = ["ábaco", "abdomen", "abeja", "abierto", "abogado", "abono", "aborto", "abrazo", "abrir", "abuelo", "abuso", "acabar", "academia", "acceso", "acción", "aceite", "acelga", "acento", "aceptar", "ácido", "aclarar", "acné", "acoger", "acoso", "activo", "acto", "actriz", "actuar", "acudir", "acuerdo", "acusar", "adicto", "admitir", "adoptar", "adorno", "aduana", "adulto", "aéreo", "afectar", "afición", "afinar", "afirmar", "ágil", "agitar", "agonía", "agosto", "agotar", "agregar", "agrio", "agua", "agudo", "águila", "aguja", "ahogo", "ahorro", "aire", "aislar", "ajedrez", "ajeno", "ajuste", "alacrán", "alambre", "alarma", "alba", "álbum", "alcalde", "aldea", "alegre", "alejar", "alerta", "aleta", "alfiler", "alga", "algodón", "aliado", "aliento", "alivio", "alma", "almeja", "almíbar", "altar", "alteza", "altivo", "alto", "altura", "alumno", "alzar", "amable", "amante", "amapola", "amargo", "amasar", "ámbar", "ámbito", "ameno", "amigo", "amistad", "amor", "amparo", "amplio", "ancho", "anciano", "ancla", "andar", "andén", "anemia", "ángulo", "anillo", "ánimo", "anís", "anotar", "antena", "antiguo", "antojo", "anual", "anular", "anuncio", "añadir", "añejo", "año", "apagar", "aparato", "apetito", "apio", "aplicar", "apodo", "aporte", "apoyo", "aprender", "aprobar", "apuesta", "apuro", "arado", "araña", "arar", "árbitro", "árbol", "arbusto", "archivo", "arco", "arder", "ardilla", "arduo", "área", "árido", "aries", "armonía", "arnés", "aroma", "arpa", "arpón", "arreglo", "arroz", "arruga", "arte", "artista", "asa", "asado", "asalto", "ascenso", "asegurar", "aseo", "asesor", "asiento", "asilo", "asistir", "asno", "asombro", "áspero", "astilla", "astro", "astuto", "asumir", "asunto", "atajo", "ataque", "atar", "atento", "ateo", "ático", "atleta", "átomo", "atraer", "atroz", "atún", "audaz", "audio", "auge", "aula", "aumento", "ausente", "autor", "aval", "avance", "avaro", "ave", "avellana", "avena", "avestruz", "avión", "aviso", "ayer", "ayuda", "ayuno", "azafrán", "azar", "azote", "azúcar", "azufre", "azul", "baba", "babor", "bache", "bahía", "baile", "bajar", "balanza", "balcón", "balde", "bambú", "banco", "banda", "baño", "barba", "barco", "barniz", "barro", "báscula", "bastón", "basura", "batalla", "batería", "batir", "batuta", "baúl", "bazar", "bebé", "bebida", "bello", "besar", "beso", "bestia", "bicho", "bien", "bingo", "blanco", "bloque", "blusa", "boa", "bobina", "bobo", "boca", "bocina", "boda", "bodega", "boina", "bola", "bolero", "bolsa", "bomba", "bondad", "bonito", "bono", "bonsái", "borde", "borrar", "bosque", "bote", "botín", "bóveda", "bozal", "bravo", "brazo", "brecha", "breve", "brillo", "brinco", "brisa", "broca", "broma", "bronce", "brote", "bruja", "brusco", "bruto", "buceo", "bucle", "bueno", "buey", "bufanda", "bufón", "búho", "buitre", "bulto", "burbuja", "burla", "burro", "buscar", "butaca", "buzón", "caballo", "cabeza", "cabina", "cabra", "cacao", "cadáver", "cadena", "caer", "café", "caída", "caimán", "caja", "cajón", "cal", "calamar", "calcio", "caldo", "calidad", "calle", "calma", "calor", "calvo", "cama", "cambio", "camello", "camino", "campo", "cáncer", "candil", "canela", "canguro", "canica", "canto", "caña", "cañón", "caoba", "caos", "capaz", "capitán", "capote", "captar", "capucha", "cara", "carbón", "cárcel", "careta", "carga", "cariño", "carne", "carpeta", "carro", "carta", "casa", "casco", "casero", "caspa", "castor", "catorce", "catre", "caudal", "causa", "cazo", "cebolla", "ceder", "cedro", "celda", "célebre", "celoso", "célula", "cemento", "ceniza", "centro", "cerca", "cerdo", "cereza", "cero", "cerrar", "certeza", "césped", "cetro", "chacal", "chaleco", "champú", "chancla", "chapa", "charla", "chico", "chiste", "chivo", "choque", "choza", "chuleta", "chupar", "ciclón", "ciego", "cielo", "cien", "cierto", "cifra", "cigarro", "cima", "cinco", "cine", "cinta", "ciprés", "circo", "ciruela", "cisne", "cita", "ciudad", "clamor", "clan", "claro", "clase", "clave", "cliente", "clima", "clínica", "cobre", "cocción", "cochino", "cocina", "coco", "código", "codo", "cofre", "coger", "cohete", "cojín", "cojo", "cola", "colcha", "colegio", "colgar", "colina", "collar", "colmo", "columna", "combate", "comer", "comida", "cómodo", "compra", "conde", "conejo", "conga", "conocer", "consejo", "contar", "copa", "copia", "corazón", "corbata", "corcho", "cordón", "corona", "correr", "coser", "cosmos", "costa", "cráneo", "cráter", "crear", "crecer", "creído", "crema", "cría", "crimen", "cripta", "crisis", "cromo", "crónica", "croqueta", "crudo", "cruz", "cuadro", "cuarto", "cuatro", "cubo", "cubrir", "cuchara", "cuello", "cuento", "cuerda", "cuesta", "cueva", "cuidar", "culebra", "culpa", "culto", "cumbre", "cumplir", "cuna", "cuneta", "cuota", "cupón", "cúpula", "curar", "curioso", "curso", "curva", "cutis", "dama", "danza", "dar", "dardo", "dátil", "deber", "débil", "década", "decir", "dedo", "defensa", "definir", "dejar", "delfín", "delgado", "delito", "demora", "denso", "dental", "deporte", "derecho", "derrota", "desayuno", "deseo", "desfile", "desnudo", "destino", "desvío", "detalle", "detener", "deuda", "día", "diablo", "diadema", "diamante", "diana", "diario", "dibujo", "dictar", "diente", "dieta", "diez", "difícil", "digno", "dilema", "diluir", "dinero", "directo", "dirigir", "disco", "diseño", "disfraz", "diva", "divino", "doble", "doce", "dolor", "domingo", "don", "donar", "dorado", "dormir", "dorso", "dos", "dosis", "dragón", "droga", "ducha", "duda", "duelo", "dueño", "dulce", "dúo", "duque", "durar", "dureza", "duro", "ébano", "ebrio", "echar", "eco", "ecuador", "edad", "edición", "edificio", "editor", "educar", "efecto", "eficaz", "eje", "ejemplo", "elefante", "elegir", "elemento", "elevar", "elipse", "élite", "elixir", "elogio", "eludir", "embudo", "emitir", "emoción", "empate", "empeño", "empleo", "empresa", "enano", "encargo", "enchufe", "encía", "enemigo", "enero", "enfado", "enfermo", "engaño", "enigma", "enlace", "enorme", "enredo", "ensayo", "enseñar", "entero", "entrar", "envase", "envío", "época", "equipo", "erizo", "escala", "escena", "escolar", "escribir", "escudo", "esencia", "esfera", "esfuerzo", "espada", "espejo", "espía", "esposa", "espuma", "esquí", "estar", "este", "estilo", "estufa", "etapa", "eterno", "ética", "etnia", "evadir", "evaluar", "evento", "evitar", "exacto", "examen", "exceso", "excusa", "exento", "exigir", "exilio", "existir", "éxito", "experto", "explicar", "exponer", "extremo", "fábrica", "fábula", "fachada", "fácil", "factor", "faena", "faja", "falda", "fallo", "falso", "faltar", "fama", "familia", "famoso", "faraón", "farmacia", "farol", "farsa", "fase", "fatiga", "fauna", "favor", "fax", "febrero", "fecha", "feliz", "feo", "feria", "feroz", "fértil", "fervor", "festín", "fiable", "fianza", "fiar", "fibra", "ficción", "ficha", "fideo", "fiebre", "fiel", "fiera", "fiesta", "figura", "fijar", "fijo", "fila", "filete", "filial", "filtro", "fin", "finca", "fingir", "finito", "firma", "flaco", "flauta", "flecha", "flor", "flota", "fluir", "flujo", "flúor", "fobia", "foca", "fogata", "fogón", "folio", "folleto", "fondo", "forma", "forro", "fortuna", "forzar", "fosa", "foto", "fracaso", "frágil", "franja", "frase", "fraude", "freír", "freno", "fresa", "frío", "frito", "fruta", "fuego", "fuente", "fuerza", "fuga", "fumar", "función", "funda", "furgón", "furia", "fusil", "fútbol", "futuro", "gacela", "gafas", "gaita", "gajo", "gala", "galería", "gallo", "gamba", "ganar", "gancho", "ganga", "ganso", "garaje", "garza", "gasolina", "gastar", "gato", "gavilán", "gemelo", "gemir", "gen", "género", "genio", "gente", "geranio", "gerente", "germen", "gesto", "gigante", "gimnasio", "girar", "giro", "glaciar", "globo", "gloria", "gol", "golfo", "goloso", "golpe", "goma", "gordo", "gorila", "gorra", "gota", "goteo", "gozar", "grada", "gráfico", "grano", "grasa", "gratis", "grave", "grieta", "grillo", "gripe", "gris", "grito", "grosor", "grúa", "grueso", "grumo", "grupo", "guante", "guapo", "guardia", "guerra", "guía", "guiño", "guion", "guiso", "guitarra", "gusano", "gustar", "haber", "hábil", "hablar", "hacer", "hacha", "hada", "hallar", "hamaca", "harina", "haz", "hazaña", "hebilla", "hebra", "hecho", "helado", "helio", "hembra", "herir", "hermano", "héroe", "hervir", "hielo", "hierro", "hígado", "higiene", "hijo", "himno", "historia", "hocico", "hogar", "hoguera", "hoja", "hombre", "hongo", "honor", "honra", "hora", "hormiga", "horno", "hostil", "hoyo", "hueco", "huelga", "huerta", "hueso", "huevo", "huida", "huir", "humano", "húmedo", "humilde", "humo", "hundir", "huracán", "hurto", "icono", "ideal", "idioma", "ídolo", "iglesia", "iglú", "igual", "ilegal", "ilusión", "imagen", "imán", "imitar", "impar", "imperio", "imponer", "impulso", "incapaz", "índice", "inerte", "infiel", "informe", "ingenio", "inicio", "inmenso", "inmune", "innato", "insecto", "instante", "interés", "íntimo", "intuir", "inútil", "invierno", "ira", "iris", "ironía", "isla", "islote", "jabalí", "jabón", "jamón", "jarabe", "jardín", "jarra", "jaula", "jazmín", "jefe", "jeringa", "jinete", "jornada", "joroba", "joven", "joya", "juerga", "jueves", "juez", "jugador", "jugo", "juguete", "juicio", "junco", "jungla", "junio", "juntar", "júpiter", "jurar", "justo", "juvenil", "juzgar", "kilo", "koala", "labio", "lacio", "lacra", "lado", "ladrón", "lagarto", "lágrima", "laguna", "laico", "lamer", "lámina", "lámpara", "lana", "lancha", "langosta", "lanza", "lápiz", "largo", "larva", "lástima", "lata", "látex", "latir", "laurel", "lavar", "lazo", "leal", "lección", "leche", "lector", "leer", "legión", "legumbre", "lejano", "lengua", "lento", "leña", "león", "leopardo", "lesión", "letal", "letra", "leve", "leyenda", "libertad", "libro", "licor", "líder", "lidiar", "lienzo", "liga", "ligero", "lima", "límite", "limón", "limpio", "lince", "lindo", "línea", "lingote", "lino", "linterna", "líquido", "liso", "lista", "litera", "litio", "litro", "llaga", "llama", "llanto", "llave", "llegar", "llenar", "llevar", "llorar", "llover", "lluvia", "lobo", "loción", "loco", "locura", "lógica", "logro", "lombriz", "lomo", "lonja", "lote", "lucha", "lucir", "lugar", "lujo", "luna", "lunes", "lupa", "lustro", "luto", "luz", "maceta", "macho", "madera", "madre", "maduro", "maestro", "mafia", "magia", "mago", "maíz", "maldad", "maleta", "malla", "malo", "mamá", "mambo", "mamut", "manco", "mando", "manejar", "manga", "maniquí", "manjar", "mano", "manso", "manta", "mañana", "mapa", "máquina", "mar", "marco", "marea", "marfil", "margen", "marido", "mármol", "marrón", "martes", "marzo", "masa", "máscara", "masivo", "matar", "materia", "matiz", "matriz", "máximo", "mayor", "mazorca", "mecha", "medalla", "medio", "médula", "mejilla", "mejor", "melena", "melón", "memoria", "menor", "mensaje", "mente", "menú", "mercado", "merengue", "mérito", "mes", "mesón", "meta", "meter", "método", "metro", "mezcla", "miedo", "miel", "miembro", "miga", "mil", "milagro", "militar", "millón", "mimo", "mina", "minero", "mínimo", "minuto", "miope", "mirar", "misa", "miseria", "misil", "mismo", "mitad", "mito", "mochila", "moción", "moda", "modelo", "moho", "mojar", "molde", "moler", "molino", "momento", "momia", "monarca", "moneda", "monja", "monto", "moño", "morada", "morder", "moreno", "morir", "morro", "morsa", "mortal", "mosca", "mostrar", "motivo", "mover", "móvil", "mozo", "mucho", "mudar", "mueble", "muela", "muerte", "muestra", "mugre", "mujer", "mula", "muleta", "multa", "mundo", "muñeca", "mural", "muro", "músculo", "museo", "musgo", "música", "muslo", "nácar", "nación", "nadar", "naipe", "naranja", "nariz", "narrar", "nasal", "natal", "nativo", "natural", "náusea", "naval", "nave", "navidad", "necio", "néctar", "negar", "negocio", "negro", "neón", "nervio", "neto", "neutro", "nevar", "nevera", "nicho", "nido", "niebla", "nieto", "niñez", "niño", "nítido", "nivel", "nobleza", "noche", "nómina", "noria", "norma", "norte", "nota", "noticia", "novato", "novela", "novio", "nube", "nuca", "núcleo", "nudillo", "nudo", "nuera", "nueve", "nuez", "nulo", "número", "nutria", "oasis", "obeso", "obispo", "objeto", "obra", "obrero", "observar", "obtener", "obvio", "oca", "ocaso", "océano", "ochenta", "ocho", "ocio", "ocre", "octavo", "octubre", "oculto", "ocupar", "ocurrir", "odiar", "odio", "odisea", "oeste", "ofensa", "oferta", "oficio", "ofrecer", "ogro", "oído", "oír", "ojo", "ola", "oleada", "olfato", "olivo", "olla", "olmo", "olor", "olvido", "ombligo", "onda", "onza", "opaco", "opción", "ópera", "opinar", "oponer", "optar", "óptica", "opuesto", "oración", "orador", "oral", "órbita", "orca", "orden", "oreja", "órgano", "orgía", "orgullo", "oriente", "origen", "orilla", "oro", "orquesta", "oruga", "osadía", "oscuro", "osezno", "oso", "ostra", "otoño", "otro", "oveja", "óvulo", "óxido", "oxígeno", "oyente", "ozono", "pacto", "padre", "paella", "página", "pago", "país", "pájaro", "palabra", "palco", "paleta", "pálido", "palma", "paloma", "palpar", "pan", "panal", "pánico", "pantera", "pañuelo", "papá", "papel", "papilla", "paquete", "parar", "parcela", "pared", "parir", "paro", "párpado", "parque", "párrafo", "parte", "pasar", "paseo", "pasión", "paso", "pasta", "pata", "patio", "patria", "pausa", "pauta", "pavo", "payaso", "peatón", "pecado", "pecera", "pecho", "pedal", "pedir", "pegar", "peine", "pelar", "peldaño", "pelea", "peligro", "pellejo", "pelo", "peluca", "pena", "pensar", "peñón", "peón", "peor", "pepino", "pequeño", "pera", "percha", "perder", "pereza", "perfil", "perico", "perla", "permiso", "perro", "persona", "pesa", "pesca", "pésimo", "pestaña", "pétalo", "petróleo", "pez", "pezuña", "picar", "pichón", "pie", "piedra", "pierna", "pieza", "pijama", "pilar", "piloto", "pimienta", "pino", "pintor", "pinza", "piña", "piojo", "pipa", "pirata", "pisar", "piscina", "piso", "pista", "pitón", "pizca", "placa", "plan", "plata", "playa", "plaza", "pleito", "pleno", "plomo", "pluma", "plural", "pobre", "poco", "poder", "podio", "poema", "poesía", "poeta", "polen", "policía", "pollo", "polvo", "pomada", "pomelo", "pomo", "pompa", "poner", "porción", "portal", "posada", "poseer", "posible", "poste", "potencia", "potro", "pozo", "prado", "precoz", "pregunta", "premio", "prensa", "preso", "previo", "primo", "príncipe", "prisión", "privar", "proa", "probar", "proceso", "producto", "proeza", "profesor", "programa", "prole", "promesa", "pronto", "propio", "próximo", "prueba", "público", "puchero", "pudor", "pueblo", "puerta", "puesto", "pulga", "pulir", "pulmón", "pulpo", "pulso", "puma", "punto", "puñal", "puño", "pupa", "pupila", "puré", "quedar", "queja", "quemar", "querer", "queso", "quieto", "química", "quince", "quitar", "rábano", "rabia", "rabo", "ración", "radical", "raíz", "rama", "rampa", "rancho", "rango", "rapaz", "rápido", "rapto", "rasgo", "raspa", "rato", "rayo", "raza", "razón", "reacción", "realidad", "rebaño", "rebote", "recaer", "receta", "rechazo", "recoger", "recreo", "recto", "recurso", "red", "redondo", "reducir", "reflejo", "reforma", "refrán", "refugio", "regalo", "regir", "regla", "regreso", "rehén", "reino", "reír", "reja", "relato", "relevo", "relieve", "relleno", "reloj", "remar", "remedio", "remo", "rencor", "rendir", "renta", "reparto", "repetir", "reposo", "reptil", "res", "rescate", "resina", "respeto", "resto", "resumen", "retiro", "retorno", "retrato", "reunir", "revés", "revista", "rey", "rezar", "rico", "riego", "rienda", "riesgo", "rifa", "rígido", "rigor", "rincón", "riñón", "río", "riqueza", "risa", "ritmo", "rito", "rizo", "roble", "roce", "rociar", "rodar", "rodeo", "rodilla", "roer", "rojizo", "rojo", "romero", "romper", "ron", "ronco", "ronda", "ropa", "ropero", "rosa", "rosca", "rostro", "rotar", "rubí", "rubor", "rudo", "rueda", "rugir", "ruido", "ruina", "ruleta", "rulo", "rumbo", "rumor", "ruptura", "ruta", "rutina", "sábado", "saber", "sabio", "sable", "sacar", "sagaz", "sagrado", "sala", "saldo", "salero", "salir", "salmón", "salón", "salsa", "salto", "salud", "salvar", "samba", "sanción", "sandía", "sanear", "sangre", "sanidad", "sano", "santo", "sapo", "saque", "sardina", "sartén", "sastre", "satán", "sauna", "saxofón", "sección", "seco", "secreto", "secta", "sed", "seguir", "seis", "sello", "selva", "semana", "semilla", "senda", "sensor", "señal", "señor", "separar", "sepia", "sequía", "ser", "serie", "sermón", "servir", "sesenta", "sesión", "seta", "setenta", "severo", "sexo", "sexto", "sidra", "siesta", "siete", "siglo", "signo", "sílaba", "silbar", "silencio", "silla", "símbolo", "simio", "sirena", "sistema", "sitio", "situar", "sobre", "socio", "sodio", "sol", "solapa", "soldado", "soledad", "sólido", "soltar", "solución", "sombra", "sondeo", "sonido", "sonoro", "sonrisa", "sopa", "soplar", "soporte", "sordo", "sorpresa", "sorteo", "sostén", "sótano", "suave", "subir", "suceso", "sudor", "suegra", "suelo", "sueño", "suerte", "sufrir", "sujeto", "sultán", "sumar", "superar", "suplir", "suponer", "supremo", "sur", "surco", "sureño", "surgir", "susto", "sutil", "tabaco", "tabique", "tabla", "tabú", "taco", "tacto", "tajo", "talar", "talco", "talento", "talla", "talón", "tamaño", "tambor", "tango", "tanque", "tapa", "tapete", "tapia", "tapón", "taquilla", "tarde", "tarea", "tarifa", "tarjeta", "tarot", "tarro", "tarta", "tatuaje", "tauro", "taza", "tazón", "teatro", "techo", "tecla", "técnica", "tejado", "tejer", "tejido", "tela", "teléfono", "tema", "temor", "templo", "tenaz", "tender", "tener", "tenis", "tenso", "teoría", "terapia", "terco", "término", "ternura", "terror", "tesis", "tesoro", "testigo", "tetera", "texto", "tez", "tibio", "tiburón", "tiempo", "tienda", "tierra", "tieso", "tigre", "tijera", "tilde", "timbre", "tímido", "timo", "tinta", "tío", "típico", "tipo", "tira", "tirón", "titán", "títere", "título", "tiza", "toalla", "tobillo", "tocar", "tocino", "todo", "toga", "toldo", "tomar", "tono", "tonto", "topar", "tope", "toque", "tórax", "torero", "tormenta", "torneo", "toro", "torpedo", "torre", "torso", "tortuga", "tos", "tosco", "toser", "tóxico", "trabajo", "tractor", "traer", "tráfico", "trago", "traje", "tramo", "trance", "trato", "trauma", "trazar", "trébol", "tregua", "treinta", "tren", "trepar", "tres", "tribu", "trigo", "tripa", "triste", "triunfo", "trofeo", "trompa", "tronco", "tropa", "trote", "trozo", "truco", "trueno", "trufa", "tubería", "tubo", "tuerto", "tumba", "tumor", "túnel", "túnica", "turbina", "turismo", "turno", "tutor", "ubicar", "úlcera", "umbral", "unidad", "unir", "universo", "uno", "untar", "uña", "urbano", "urbe", "urgente", "urna", "usar", "usuario", "útil", "utopía", "uva", "vaca", "vacío", "vacuna", "vagar", "vago", "vaina", "vajilla", "vale", "válido", "valle", "valor", "válvula", "vampiro", "vara", "variar", "varón", "vaso", "vecino", "vector", "vehículo", "veinte", "vejez", "vela", "velero", "veloz", "vena", "vencer", "venda", "veneno", "vengar", "venir", "venta", "venus", "ver", "verano", "verbo", "verde", "vereda", "verja", "verso", "verter", "vía", "viaje", "vibrar", "vicio", "víctima", "vida", "vídeo", "vidrio", "viejo", "viernes", "vigor", "vil", "villa", "vinagre", "vino", "viñedo", "violín", "viral", "virgo", "virtud", "visor", "víspera", "vista", "vitamina", "viudo", "vivaz", "vivero", "vivir", "vivo", "volcán", "volumen", "volver", "voraz", "votar", "voto", "voz", "vuelo", "vulgar", "yacer", "yate", "yegua", "yema", "yerno", "yeso", "yodo", "yoga", "yogur", "zafiro", "zanja", "zapato", "zarza", "zona", "zorro", "zumo", "zurdo"];

  var require$$7 = ["あいこくしん", "あいさつ", "あいだ", "あおぞら", "あかちゃん", "あきる", "あけがた", "あける", "あこがれる", "あさい", "あさひ", "あしあと", "あじわう", "あずかる", "あずき", "あそぶ", "あたえる", "あたためる", "あたりまえ", "あたる", "あつい", "あつかう", "あっしゅく", "あつまり", "あつめる", "あてな", "あてはまる", "あひる", "あぶら", "あぶる", "あふれる", "あまい", "あまど", "あまやかす", "あまり", "あみもの", "あめりか", "あやまる", "あゆむ", "あらいぐま", "あらし", "あらすじ", "あらためる", "あらゆる", "あらわす", "ありがとう", "あわせる", "あわてる", "あんい", "あんがい", "あんこ", "あんぜん", "あんてい", "あんない", "あんまり", "いいだす", "いおん", "いがい", "いがく", "いきおい", "いきなり", "いきもの", "いきる", "いくじ", "いくぶん", "いけばな", "いけん", "いこう", "いこく", "いこつ", "いさましい", "いさん", "いしき", "いじゅう", "いじょう", "いじわる", "いずみ", "いずれ", "いせい", "いせえび", "いせかい", "いせき", "いぜん", "いそうろう", "いそがしい", "いだい", "いだく", "いたずら", "いたみ", "いたりあ", "いちおう", "いちじ", "いちど", "いちば", "いちぶ", "いちりゅう", "いつか", "いっしゅん", "いっせい", "いっそう", "いったん", "いっち", "いってい", "いっぽう", "いてざ", "いてん", "いどう", "いとこ", "いない", "いなか", "いねむり", "いのち", "いのる", "いはつ", "いばる", "いはん", "いびき", "いひん", "いふく", "いへん", "いほう", "いみん", "いもうと", "いもたれ", "いもり", "いやがる", "いやす", "いよかん", "いよく", "いらい", "いらすと", "いりぐち", "いりょう", "いれい", "いれもの", "いれる", "いろえんぴつ", "いわい", "いわう", "いわかん", "いわば", "いわゆる", "いんげんまめ", "いんさつ", "いんしょう", "いんよう", "うえき", "うえる", "うおざ", "うがい", "うかぶ", "うかべる", "うきわ", "うくらいな", "うくれれ", "うけたまわる", "うけつけ", "うけとる", "うけもつ", "うける", "うごかす", "うごく", "うこん", "うさぎ", "うしなう", "うしろがみ", "うすい", "うすぎ", "うすぐらい", "うすめる", "うせつ", "うちあわせ", "うちがわ", "うちき", "うちゅう", "うっかり", "うつくしい", "うったえる", "うつる", "うどん", "うなぎ", "うなじ", "うなずく", "うなる", "うねる", "うのう", "うぶげ", "うぶごえ", "うまれる", "うめる", "うもう", "うやまう", "うよく", "うらがえす", "うらぐち", "うらない", "うりあげ", "うりきれ", "うるさい", "うれしい", "うれゆき", "うれる", "うろこ", "うわき", "うわさ", "うんこう", "うんちん", "うんてん", "うんどう", "えいえん", "えいが", "えいきょう", "えいご", "えいせい", "えいぶん", "えいよう", "えいわ", "えおり", "えがお", "えがく", "えきたい", "えくせる", "えしゃく", "えすて", "えつらん", "えのぐ", "えほうまき", "えほん", "えまき", "えもじ", "えもの", "えらい", "えらぶ", "えりあ", "えんえん", "えんかい", "えんぎ", "えんげき", "えんしゅう", "えんぜつ", "えんそく", "えんちょう", "えんとつ", "おいかける", "おいこす", "おいしい", "おいつく", "おうえん", "おうさま", "おうじ", "おうせつ", "おうたい", "おうふく", "おうべい", "おうよう", "おえる", "おおい", "おおう", "おおどおり", "おおや", "おおよそ", "おかえり", "おかず", "おがむ", "おかわり", "おぎなう", "おきる", "おくさま", "おくじょう", "おくりがな", "おくる", "おくれる", "おこす", "おこなう", "おこる", "おさえる", "おさない", "おさめる", "おしいれ", "おしえる", "おじぎ", "おじさん", "おしゃれ", "おそらく", "おそわる", "おたがい", "おたく", "おだやか", "おちつく", "おっと", "おつり", "おでかけ", "おとしもの", "おとなしい", "おどり", "おどろかす", "おばさん", "おまいり", "おめでとう", "おもいで", "おもう", "おもたい", "おもちゃ", "おやつ", "おやゆび", "およぼす", "おらんだ", "おろす", "おんがく", "おんけい", "おんしゃ", "おんせん", "おんだん", "おんちゅう", "おんどけい", "かあつ", "かいが", "がいき", "がいけん", "がいこう", "かいさつ", "かいしゃ", "かいすいよく", "かいぜん", "かいぞうど", "かいつう", "かいてん", "かいとう", "かいふく", "がいへき", "かいほう", "かいよう", "がいらい", "かいわ", "かえる", "かおり", "かかえる", "かがく", "かがし", "かがみ", "かくご", "かくとく", "かざる", "がぞう", "かたい", "かたち", "がちょう", "がっきゅう", "がっこう", "がっさん", "がっしょう", "かなざわし", "かのう", "がはく", "かぶか", "かほう", "かほご", "かまう", "かまぼこ", "かめれおん", "かゆい", "かようび", "からい", "かるい", "かろう", "かわく", "かわら", "がんか", "かんけい", "かんこう", "かんしゃ", "かんそう", "かんたん", "かんち", "がんばる", "きあい", "きあつ", "きいろ", "ぎいん", "きうい", "きうん", "きえる", "きおう", "きおく", "きおち", "きおん", "きかい", "きかく", "きかんしゃ", "ききて", "きくばり", "きくらげ", "きけんせい", "きこう", "きこえる", "きこく", "きさい", "きさく", "きさま", "きさらぎ", "ぎじかがく", "ぎしき", "ぎじたいけん", "ぎじにってい", "ぎじゅつしゃ", "きすう", "きせい", "きせき", "きせつ", "きそう", "きぞく", "きぞん", "きたえる", "きちょう", "きつえん", "ぎっちり", "きつつき", "きつね", "きてい", "きどう", "きどく", "きない", "きなが", "きなこ", "きぬごし", "きねん", "きのう", "きのした", "きはく", "きびしい", "きひん", "きふく", "きぶん", "きぼう", "きほん", "きまる", "きみつ", "きむずかしい", "きめる", "きもだめし", "きもち", "きもの", "きゃく", "きやく", "ぎゅうにく", "きよう", "きょうりゅう", "きらい", "きらく", "きりん", "きれい", "きれつ", "きろく", "ぎろん", "きわめる", "ぎんいろ", "きんかくじ", "きんじょ", "きんようび", "ぐあい", "くいず", "くうかん", "くうき", "くうぐん", "くうこう", "ぐうせい", "くうそう", "ぐうたら", "くうふく", "くうぼ", "くかん", "くきょう", "くげん", "ぐこう", "くさい", "くさき", "くさばな", "くさる", "くしゃみ", "くしょう", "くすのき", "くすりゆび", "くせげ", "くせん", "ぐたいてき", "くださる", "くたびれる", "くちこみ", "くちさき", "くつした", "ぐっすり", "くつろぐ", "くとうてん", "くどく", "くなん", "くねくね", "くのう", "くふう", "くみあわせ", "くみたてる", "くめる", "くやくしょ", "くらす", "くらべる", "くるま", "くれる", "くろう", "くわしい", "ぐんかん", "ぐんしょく", "ぐんたい", "ぐんて", "けあな", "けいかく", "けいけん", "けいこ", "けいさつ", "げいじゅつ", "けいたい", "げいのうじん", "けいれき", "けいろ", "けおとす", "けおりもの", "げきか", "げきげん", "げきだん", "げきちん", "げきとつ", "げきは", "げきやく", "げこう", "げこくじょう", "げざい", "けさき", "げざん", "けしき", "けしごむ", "けしょう", "げすと", "けたば", "けちゃっぷ", "けちらす", "けつあつ", "けつい", "けつえき", "けっこん", "けつじょ", "けっせき", "けってい", "けつまつ", "げつようび", "げつれい", "けつろん", "げどく", "けとばす", "けとる", "けなげ", "けなす", "けなみ", "けぬき", "げねつ", "けねん", "けはい", "げひん", "けぶかい", "げぼく", "けまり", "けみかる", "けむし", "けむり", "けもの", "けらい", "けろけろ", "けわしい", "けんい", "けんえつ", "けんお", "けんか", "げんき", "けんげん", "けんこう", "けんさく", "けんしゅう", "けんすう", "げんそう", "けんちく", "けんてい", "けんとう", "けんない", "けんにん", "げんぶつ", "けんま", "けんみん", "けんめい", "けんらん", "けんり", "こあくま", "こいぬ", "こいびと", "ごうい", "こうえん", "こうおん", "こうかん", "ごうきゅう", "ごうけい", "こうこう", "こうさい", "こうじ", "こうすい", "ごうせい", "こうそく", "こうたい", "こうちゃ", "こうつう", "こうてい", "こうどう", "こうない", "こうはい", "ごうほう", "ごうまん", "こうもく", "こうりつ", "こえる", "こおり", "ごかい", "ごがつ", "ごかん", "こくご", "こくさい", "こくとう", "こくない", "こくはく", "こぐま", "こけい", "こける", "ここのか", "こころ", "こさめ", "こしつ", "こすう", "こせい", "こせき", "こぜん", "こそだて", "こたい", "こたえる", "こたつ", "こちょう", "こっか", "こつこつ", "こつばん", "こつぶ", "こてい", "こてん", "ことがら", "ことし", "ことば", "ことり", "こなごな", "こねこね", "このまま", "このみ", "このよ", "ごはん", "こひつじ", "こふう", "こふん", "こぼれる", "ごまあぶら", "こまかい", "ごますり", "こまつな", "こまる", "こむぎこ", "こもじ", "こもち", "こもの", "こもん", "こやく", "こやま", "こゆう", "こゆび", "こよい", "こよう", "こりる", "これくしょん", "ころっけ", "こわもて", "こわれる", "こんいん", "こんかい", "こんき", "こんしゅう", "こんすい", "こんだて", "こんとん", "こんなん", "こんびに", "こんぽん", "こんまけ", "こんや", "こんれい", "こんわく", "ざいえき", "さいかい", "さいきん", "ざいげん", "ざいこ", "さいしょ", "さいせい", "ざいたく", "ざいちゅう", "さいてき", "ざいりょう", "さうな", "さかいし", "さがす", "さかな", "さかみち", "さがる", "さぎょう", "さくし", "さくひん", "さくら", "さこく", "さこつ", "さずかる", "ざせき", "さたん", "さつえい", "ざつおん", "ざっか", "ざつがく", "さっきょく", "ざっし", "さつじん", "ざっそう", "さつたば", "さつまいも", "さてい", "さといも", "さとう", "さとおや", "さとし", "さとる", "さのう", "さばく", "さびしい", "さべつ", "さほう", "さほど", "さます", "さみしい", "さみだれ", "さむけ", "さめる", "さやえんどう", "さゆう", "さよう", "さよく", "さらだ", "ざるそば", "さわやか", "さわる", "さんいん", "さんか", "さんきゃく", "さんこう", "さんさい", "ざんしょ", "さんすう", "さんせい", "さんそ", "さんち", "さんま", "さんみ", "さんらん", "しあい", "しあげ", "しあさって", "しあわせ", "しいく", "しいん", "しうち", "しえい", "しおけ", "しかい", "しかく", "じかん", "しごと", "しすう", "じだい", "したうけ", "したぎ", "したて", "したみ", "しちょう", "しちりん", "しっかり", "しつじ", "しつもん", "してい", "してき", "してつ", "じてん", "じどう", "しなぎれ", "しなもの", "しなん", "しねま", "しねん", "しのぐ", "しのぶ", "しはい", "しばかり", "しはつ", "しはらい", "しはん", "しひょう", "しふく", "じぶん", "しへい", "しほう", "しほん", "しまう", "しまる", "しみん", "しむける", "じむしょ", "しめい", "しめる", "しもん", "しゃいん", "しゃうん", "しゃおん", "じゃがいも", "しやくしょ", "しゃくほう", "しゃけん", "しゃこ", "しゃざい", "しゃしん", "しゃせん", "しゃそう", "しゃたい", "しゃちょう", "しゃっきん", "じゃま", "しゃりん", "しゃれい", "じゆう", "じゅうしょ", "しゅくはく", "じゅしん", "しゅっせき", "しゅみ", "しゅらば", "じゅんばん", "しょうかい", "しょくたく", "しょっけん", "しょどう", "しょもつ", "しらせる", "しらべる", "しんか", "しんこう", "じんじゃ", "しんせいじ", "しんちく", "しんりん", "すあげ", "すあし", "すあな", "ずあん", "すいえい", "すいか", "すいとう", "ずいぶん", "すいようび", "すうがく", "すうじつ", "すうせん", "すおどり", "すきま", "すくう", "すくない", "すける", "すごい", "すこし", "ずさん", "すずしい", "すすむ", "すすめる", "すっかり", "ずっしり", "ずっと", "すてき", "すてる", "すねる", "すのこ", "すはだ", "すばらしい", "ずひょう", "ずぶぬれ", "すぶり", "すふれ", "すべて", "すべる", "ずほう", "すぼん", "すまい", "すめし", "すもう", "すやき", "すらすら", "するめ", "すれちがう", "すろっと", "すわる", "すんぜん", "すんぽう", "せあぶら", "せいかつ", "せいげん", "せいじ", "せいよう", "せおう", "せかいかん", "せきにん", "せきむ", "せきゆ", "せきらんうん", "せけん", "せこう", "せすじ", "せたい", "せたけ", "せっかく", "せっきゃく", "ぜっく", "せっけん", "せっこつ", "せっさたくま", "せつぞく", "せつだん", "せつでん", "せっぱん", "せつび", "せつぶん", "せつめい", "せつりつ", "せなか", "せのび", "せはば", "せびろ", "せぼね", "せまい", "せまる", "せめる", "せもたれ", "せりふ", "ぜんあく", "せんい", "せんえい", "せんか", "せんきょ", "せんく", "せんげん", "ぜんご", "せんさい", "せんしゅ", "せんすい", "せんせい", "せんぞ", "せんたく", "せんちょう", "せんてい", "せんとう", "せんぬき", "せんねん", "せんぱい", "ぜんぶ", "ぜんぽう", "せんむ", "せんめんじょ", "せんもん", "せんやく", "せんゆう", "せんよう", "ぜんら", "ぜんりゃく", "せんれい", "せんろ", "そあく", "そいとげる", "そいね", "そうがんきょう", "そうき", "そうご", "そうしん", "そうだん", "そうなん", "そうび", "そうめん", "そうり", "そえもの", "そえん", "そがい", "そげき", "そこう", "そこそこ", "そざい", "そしな", "そせい", "そせん", "そそぐ", "そだてる", "そつう", "そつえん", "そっかん", "そつぎょう", "そっけつ", "そっこう", "そっせん", "そっと", "そとがわ", "そとづら", "そなえる", "そなた", "そふぼ", "そぼく", "そぼろ", "そまつ", "そまる", "そむく", "そむりえ", "そめる", "そもそも", "そよかぜ", "そらまめ", "そろう", "そんかい", "そんけい", "そんざい", "そんしつ", "そんぞく", "そんちょう", "ぞんび", "ぞんぶん", "そんみん", "たあい", "たいいん", "たいうん", "たいえき", "たいおう", "だいがく", "たいき", "たいぐう", "たいけん", "たいこ", "たいざい", "だいじょうぶ", "だいすき", "たいせつ", "たいそう", "だいたい", "たいちょう", "たいてい", "だいどころ", "たいない", "たいねつ", "たいのう", "たいはん", "だいひょう", "たいふう", "たいへん", "たいほ", "たいまつばな", "たいみんぐ", "たいむ", "たいめん", "たいやき", "たいよう", "たいら", "たいりょく", "たいる", "たいわん", "たうえ", "たえる", "たおす", "たおる", "たおれる", "たかい", "たかね", "たきび", "たくさん", "たこく", "たこやき", "たさい", "たしざん", "だじゃれ", "たすける", "たずさわる", "たそがれ", "たたかう", "たたく", "ただしい", "たたみ", "たちばな", "だっかい", "だっきゃく", "だっこ", "だっしゅつ", "だったい", "たてる", "たとえる", "たなばた", "たにん", "たぬき", "たのしみ", "たはつ", "たぶん", "たべる", "たぼう", "たまご", "たまる", "だむる", "ためいき", "ためす", "ためる", "たもつ", "たやすい", "たよる", "たらす", "たりきほんがん", "たりょう", "たりる", "たると", "たれる", "たれんと", "たろっと", "たわむれる", "だんあつ", "たんい", "たんおん", "たんか", "たんき", "たんけん", "たんご", "たんさん", "たんじょうび", "だんせい", "たんそく", "たんたい", "だんち", "たんてい", "たんとう", "だんな", "たんにん", "だんねつ", "たんのう", "たんぴん", "だんぼう", "たんまつ", "たんめい", "だんれつ", "だんろ", "だんわ", "ちあい", "ちあん", "ちいき", "ちいさい", "ちえん", "ちかい", "ちから", "ちきゅう", "ちきん", "ちけいず", "ちけん", "ちこく", "ちさい", "ちしき", "ちしりょう", "ちせい", "ちそう", "ちたい", "ちたん", "ちちおや", "ちつじょ", "ちてき", "ちてん", "ちぬき", "ちぬり", "ちのう", "ちひょう", "ちへいせん", "ちほう", "ちまた", "ちみつ", "ちみどろ", "ちめいど", "ちゃんこなべ", "ちゅうい", "ちゆりょく", "ちょうし", "ちょさくけん", "ちらし", "ちらみ", "ちりがみ", "ちりょう", "ちるど", "ちわわ", "ちんたい", "ちんもく", "ついか", "ついたち", "つうか", "つうじょう", "つうはん", "つうわ", "つかう", "つかれる", "つくね", "つくる", "つけね", "つける", "つごう", "つたえる", "つづく", "つつじ", "つつむ", "つとめる", "つながる", "つなみ", "つねづね", "つのる", "つぶす", "つまらない", "つまる", "つみき", "つめたい", "つもり", "つもる", "つよい", "つるぼ", "つるみく", "つわもの", "つわり", "てあし", "てあて", "てあみ", "ていおん", "ていか", "ていき", "ていけい", "ていこく", "ていさつ", "ていし", "ていせい", "ていたい", "ていど", "ていねい", "ていひょう", "ていへん", "ていぼう", "てうち", "ておくれ", "てきとう", "てくび", "でこぼこ", "てさぎょう", "てさげ", "てすり", "てそう", "てちがい", "てちょう", "てつがく", "てつづき", "でっぱ", "てつぼう", "てつや", "でぬかえ", "てぬき", "てぬぐい", "てのひら", "てはい", "てぶくろ", "てふだ", "てほどき", "てほん", "てまえ", "てまきずし", "てみじか", "てみやげ", "てらす", "てれび", "てわけ", "てわたし", "でんあつ", "てんいん", "てんかい", "てんき", "てんぐ", "てんけん", "てんごく", "てんさい", "てんし", "てんすう", "でんち", "てんてき", "てんとう", "てんない", "てんぷら", "てんぼうだい", "てんめつ", "てんらんかい", "でんりょく", "でんわ", "どあい", "といれ", "どうかん", "とうきゅう", "どうぐ", "とうし", "とうむぎ", "とおい", "とおか", "とおく", "とおす", "とおる", "とかい", "とかす", "ときおり", "ときどき", "とくい", "とくしゅう", "とくてん", "とくに", "とくべつ", "とけい", "とける", "とこや", "とさか", "としょかん", "とそう", "とたん", "とちゅう", "とっきゅう", "とっくん", "とつぜん", "とつにゅう", "とどける", "ととのえる", "とない", "となえる", "となり", "とのさま", "とばす", "どぶがわ", "とほう", "とまる", "とめる", "ともだち", "ともる", "どようび", "とらえる", "とんかつ", "どんぶり", "ないかく", "ないこう", "ないしょ", "ないす", "ないせん", "ないそう", "なおす", "ながい", "なくす", "なげる", "なこうど", "なさけ", "なたでここ", "なっとう", "なつやすみ", "ななおし", "なにごと", "なにもの", "なにわ", "なのか", "なふだ", "なまいき", "なまえ", "なまみ", "なみだ", "なめらか", "なめる", "なやむ", "ならう", "ならび", "ならぶ", "なれる", "なわとび", "なわばり", "にあう", "にいがた", "にうけ", "におい", "にかい", "にがて", "にきび", "にくしみ", "にくまん", "にげる", "にさんかたんそ", "にしき", "にせもの", "にちじょう", "にちようび", "にっか", "にっき", "にっけい", "にっこう", "にっさん", "にっしょく", "にっすう", "にっせき", "にってい", "になう", "にほん", "にまめ", "にもつ", "にやり", "にゅういん", "にりんしゃ", "にわとり", "にんい", "にんか", "にんき", "にんげん", "にんしき", "にんずう", "にんそう", "にんたい", "にんち", "にんてい", "にんにく", "にんぷ", "にんまり", "にんむ", "にんめい", "にんよう", "ぬいくぎ", "ぬかす", "ぬぐいとる", "ぬぐう", "ぬくもり", "ぬすむ", "ぬまえび", "ぬめり", "ぬらす", "ぬんちゃく", "ねあげ", "ねいき", "ねいる", "ねいろ", "ねぐせ", "ねくたい", "ねくら", "ねこぜ", "ねこむ", "ねさげ", "ねすごす", "ねそべる", "ねだん", "ねつい", "ねっしん", "ねつぞう", "ねったいぎょ", "ねぶそく", "ねふだ", "ねぼう", "ねほりはほり", "ねまき", "ねまわし", "ねみみ", "ねむい", "ねむたい", "ねもと", "ねらう", "ねわざ", "ねんいり", "ねんおし", "ねんかん", "ねんきん", "ねんぐ", "ねんざ", "ねんし", "ねんちゃく", "ねんど", "ねんぴ", "ねんぶつ", "ねんまつ", "ねんりょう", "ねんれい", "のいず", "のおづま", "のがす", "のきなみ", "のこぎり", "のこす", "のこる", "のせる", "のぞく", "のぞむ", "のたまう", "のちほど", "のっく", "のばす", "のはら", "のべる", "のぼる", "のみもの", "のやま", "のらいぬ", "のらねこ", "のりもの", "のりゆき", "のれん", "のんき", "ばあい", "はあく", "ばあさん", "ばいか", "ばいく", "はいけん", "はいご", "はいしん", "はいすい", "はいせん", "はいそう", "はいち", "ばいばい", "はいれつ", "はえる", "はおる", "はかい", "ばかり", "はかる", "はくしゅ", "はけん", "はこぶ", "はさみ", "はさん", "はしご", "ばしょ", "はしる", "はせる", "ぱそこん", "はそん", "はたん", "はちみつ", "はつおん", "はっかく", "はづき", "はっきり", "はっくつ", "はっけん", "はっこう", "はっさん", "はっしん", "はったつ", "はっちゅう", "はってん", "はっぴょう", "はっぽう", "はなす", "はなび", "はにかむ", "はぶらし", "はみがき", "はむかう", "はめつ", "はやい", "はやし", "はらう", "はろうぃん", "はわい", "はんい", "はんえい", "はんおん", "はんかく", "はんきょう", "ばんぐみ", "はんこ", "はんしゃ", "はんすう", "はんだん", "ぱんち", "ぱんつ", "はんてい", "はんとし", "はんのう", "はんぱ", "はんぶん", "はんぺん", "はんぼうき", "はんめい", "はんらん", "はんろん", "ひいき", "ひうん", "ひえる", "ひかく", "ひかり", "ひかる", "ひかん", "ひくい", "ひけつ", "ひこうき", "ひこく", "ひさい", "ひさしぶり", "ひさん", "びじゅつかん", "ひしょ", "ひそか", "ひそむ", "ひたむき", "ひだり", "ひたる", "ひつぎ", "ひっこし", "ひっし", "ひつじゅひん", "ひっす", "ひつぜん", "ぴったり", "ぴっちり", "ひつよう", "ひてい", "ひとごみ", "ひなまつり", "ひなん", "ひねる", "ひはん", "ひびく", "ひひょう", "ひほう", "ひまわり", "ひまん", "ひみつ", "ひめい", "ひめじし", "ひやけ", "ひやす", "ひよう", "びょうき", "ひらがな", "ひらく", "ひりつ", "ひりょう", "ひるま", "ひるやすみ", "ひれい", "ひろい", "ひろう", "ひろき", "ひろゆき", "ひんかく", "ひんけつ", "ひんこん", "ひんしゅ", "ひんそう", "ぴんち", "ひんぱん", "びんぼう", "ふあん", "ふいうち", "ふうけい", "ふうせん", "ぷうたろう", "ふうとう", "ふうふ", "ふえる", "ふおん", "ふかい", "ふきん", "ふくざつ", "ふくぶくろ", "ふこう", "ふさい", "ふしぎ", "ふじみ", "ふすま", "ふせい", "ふせぐ", "ふそく", "ぶたにく", "ふたん", "ふちょう", "ふつう", "ふつか", "ふっかつ", "ふっき", "ふっこく", "ぶどう", "ふとる", "ふとん", "ふのう", "ふはい", "ふひょう", "ふへん", "ふまん", "ふみん", "ふめつ", "ふめん", "ふよう", "ふりこ", "ふりる", "ふるい", "ふんいき", "ぶんがく", "ぶんぐ", "ふんしつ", "ぶんせき", "ふんそう", "ぶんぽう", "へいあん", "へいおん", "へいがい", "へいき", "へいげん", "へいこう", "へいさ", "へいしゃ", "へいせつ", "へいそ", "へいたく", "へいてん", "へいねつ", "へいわ", "へきが", "へこむ", "べにいろ", "べにしょうが", "へらす", "へんかん", "べんきょう", "べんごし", "へんさい", "へんたい", "べんり", "ほあん", "ほいく", "ぼうぎょ", "ほうこく", "ほうそう", "ほうほう", "ほうもん", "ほうりつ", "ほえる", "ほおん", "ほかん", "ほきょう", "ぼきん", "ほくろ", "ほけつ", "ほけん", "ほこう", "ほこる", "ほしい", "ほしつ", "ほしゅ", "ほしょう", "ほせい", "ほそい", "ほそく", "ほたて", "ほたる", "ぽちぶくろ", "ほっきょく", "ほっさ", "ほったん", "ほとんど", "ほめる", "ほんい", "ほんき", "ほんけ", "ほんしつ", "ほんやく", "まいにち", "まかい", "まかせる", "まがる", "まける", "まこと", "まさつ", "まじめ", "ますく", "まぜる", "まつり", "まとめ", "まなぶ", "まぬけ", "まねく", "まほう", "まもる", "まゆげ", "まよう", "まろやか", "まわす", "まわり", "まわる", "まんが", "まんきつ", "まんぞく", "まんなか", "みいら", "みうち", "みえる", "みがく", "みかた", "みかん", "みけん", "みこん", "みじかい", "みすい", "みすえる", "みせる", "みっか", "みつかる", "みつける", "みてい", "みとめる", "みなと", "みなみかさい", "みねらる", "みのう", "みのがす", "みほん", "みもと", "みやげ", "みらい", "みりょく", "みわく", "みんか", "みんぞく", "むいか", "むえき", "むえん", "むかい", "むかう", "むかえ", "むかし", "むぎちゃ", "むける", "むげん", "むさぼる", "むしあつい", "むしば", "むじゅん", "むしろ", "むすう", "むすこ", "むすぶ", "むすめ", "むせる", "むせん", "むちゅう", "むなしい", "むのう", "むやみ", "むよう", "むらさき", "むりょう", "むろん", "めいあん", "めいうん", "めいえん", "めいかく", "めいきょく", "めいさい", "めいし", "めいそう", "めいぶつ", "めいれい", "めいわく", "めぐまれる", "めざす", "めした", "めずらしい", "めだつ", "めまい", "めやす", "めんきょ", "めんせき", "めんどう", "もうしあげる", "もうどうけん", "もえる", "もくし", "もくてき", "もくようび", "もちろん", "もどる", "もらう", "もんく", "もんだい", "やおや", "やける", "やさい", "やさしい", "やすい", "やすたろう", "やすみ", "やせる", "やそう", "やたい", "やちん", "やっと", "やっぱり", "やぶる", "やめる", "ややこしい", "やよい", "やわらかい", "ゆうき", "ゆうびんきょく", "ゆうべ", "ゆうめい", "ゆけつ", "ゆしゅつ", "ゆせん", "ゆそう", "ゆたか", "ゆちゃく", "ゆでる", "ゆにゅう", "ゆびわ", "ゆらい", "ゆれる", "ようい", "ようか", "ようきゅう", "ようじ", "ようす", "ようちえん", "よかぜ", "よかん", "よきん", "よくせい", "よくぼう", "よけい", "よごれる", "よさん", "よしゅう", "よそう", "よそく", "よっか", "よてい", "よどがわく", "よねつ", "よやく", "よゆう", "よろこぶ", "よろしい", "らいう", "らくがき", "らくご", "らくさつ", "らくだ", "らしんばん", "らせん", "らぞく", "らたい", "らっか", "られつ", "りえき", "りかい", "りきさく", "りきせつ", "りくぐん", "りくつ", "りけん", "りこう", "りせい", "りそう", "りそく", "りてん", "りねん", "りゆう", "りゅうがく", "りよう", "りょうり", "りょかん", "りょくちゃ", "りょこう", "りりく", "りれき", "りろん", "りんご", "るいけい", "るいさい", "るいじ", "るいせき", "るすばん", "るりがわら", "れいかん", "れいぎ", "れいせい", "れいぞうこ", "れいとう", "れいぼう", "れきし", "れきだい", "れんあい", "れんけい", "れんこん", "れんさい", "れんしゅう", "れんぞく", "れんらく", "ろうか", "ろうご", "ろうじん", "ろうそく", "ろくが", "ろこつ", "ろじうら", "ろしゅつ", "ろせん", "ろてん", "ろめん", "ろれつ", "ろんぎ", "ろんぱ", "ろんぶん", "ろんり", "わかす", "わかめ", "わかやま", "わかれる", "わしつ", "わじまし", "わすれもの", "わらう", "われる"];

  var require$$8 = ["abacate", "abaixo", "abalar", "abater", "abduzir", "abelha", "aberto", "abismo", "abotoar", "abranger", "abreviar", "abrigar", "abrupto", "absinto", "absoluto", "absurdo", "abutre", "acabado", "acalmar", "acampar", "acanhar", "acaso", "aceitar", "acelerar", "acenar", "acervo", "acessar", "acetona", "achatar", "acidez", "acima", "acionado", "acirrar", "aclamar", "aclive", "acolhida", "acomodar", "acoplar", "acordar", "acumular", "acusador", "adaptar", "adega", "adentro", "adepto", "adequar", "aderente", "adesivo", "adeus", "adiante", "aditivo", "adjetivo", "adjunto", "admirar", "adorar", "adquirir", "adubo", "adverso", "advogado", "aeronave", "afastar", "aferir", "afetivo", "afinador", "afivelar", "aflito", "afluente", "afrontar", "agachar", "agarrar", "agasalho", "agenciar", "agilizar", "agiota", "agitado", "agora", "agradar", "agreste", "agrupar", "aguardar", "agulha", "ajoelhar", "ajudar", "ajustar", "alameda", "alarme", "alastrar", "alavanca", "albergue", "albino", "alcatra", "aldeia", "alecrim", "alegria", "alertar", "alface", "alfinete", "algum", "alheio", "aliar", "alicate", "alienar", "alinhar", "aliviar", "almofada", "alocar", "alpiste", "alterar", "altitude", "alucinar", "alugar", "aluno", "alusivo", "alvo", "amaciar", "amador", "amarelo", "amassar", "ambas", "ambiente", "ameixa", "amenizar", "amido", "amistoso", "amizade", "amolador", "amontoar", "amoroso", "amostra", "amparar", "ampliar", "ampola", "anagrama", "analisar", "anarquia", "anatomia", "andaime", "anel", "anexo", "angular", "animar", "anjo", "anomalia", "anotado", "ansioso", "anterior", "anuidade", "anunciar", "anzol", "apagador", "apalpar", "apanhado", "apego", "apelido", "apertada", "apesar", "apetite", "apito", "aplauso", "aplicada", "apoio", "apontar", "aposta", "aprendiz", "aprovar", "aquecer", "arame", "aranha", "arara", "arcada", "ardente", "areia", "arejar", "arenito", "aresta", "argiloso", "argola", "arma", "arquivo", "arraial", "arrebate", "arriscar", "arroba", "arrumar", "arsenal", "arterial", "artigo", "arvoredo", "asfaltar", "asilado", "aspirar", "assador", "assinar", "assoalho", "assunto", "astral", "atacado", "atadura", "atalho", "atarefar", "atear", "atender", "aterro", "ateu", "atingir", "atirador", "ativo", "atoleiro", "atracar", "atrevido", "atriz", "atual", "atum", "auditor", "aumentar", "aura", "aurora", "autismo", "autoria", "autuar", "avaliar", "avante", "avaria", "avental", "avesso", "aviador", "avisar", "avulso", "axila", "azarar", "azedo", "azeite", "azulejo", "babar", "babosa", "bacalhau", "bacharel", "bacia", "bagagem", "baiano", "bailar", "baioneta", "bairro", "baixista", "bajular", "baleia", "baliza", "balsa", "banal", "bandeira", "banho", "banir", "banquete", "barato", "barbado", "baronesa", "barraca", "barulho", "baseado", "bastante", "batata", "batedor", "batida", "batom", "batucar", "baunilha", "beber", "beijo", "beirada", "beisebol", "beldade", "beleza", "belga", "beliscar", "bendito", "bengala", "benzer", "berimbau", "berlinda", "berro", "besouro", "bexiga", "bezerro", "bico", "bicudo", "bienal", "bifocal", "bifurcar", "bigorna", "bilhete", "bimestre", "bimotor", "biologia", "biombo", "biosfera", "bipolar", "birrento", "biscoito", "bisneto", "bispo", "bissexto", "bitola", "bizarro", "blindado", "bloco", "bloquear", "boato", "bobagem", "bocado", "bocejo", "bochecha", "boicotar", "bolada", "boletim", "bolha", "bolo", "bombeiro", "bonde", "boneco", "bonita", "borbulha", "borda", "boreal", "borracha", "bovino", "boxeador", "branco", "brasa", "braveza", "breu", "briga", "brilho", "brincar", "broa", "brochura", "bronzear", "broto", "bruxo", "bucha", "budismo", "bufar", "bule", "buraco", "busca", "busto", "buzina", "cabana", "cabelo", "cabide", "cabo", "cabrito", "cacau", "cacetada", "cachorro", "cacique", "cadastro", "cadeado", "cafezal", "caiaque", "caipira", "caixote", "cajado", "caju", "calafrio", "calcular", "caldeira", "calibrar", "calmante", "calota", "camada", "cambista", "camisa", "camomila", "campanha", "camuflar", "canavial", "cancelar", "caneta", "canguru", "canhoto", "canivete", "canoa", "cansado", "cantar", "canudo", "capacho", "capela", "capinar", "capotar", "capricho", "captador", "capuz", "caracol", "carbono", "cardeal", "careca", "carimbar", "carneiro", "carpete", "carreira", "cartaz", "carvalho", "casaco", "casca", "casebre", "castelo", "casulo", "catarata", "cativar", "caule", "causador", "cautelar", "cavalo", "caverna", "cebola", "cedilha", "cegonha", "celebrar", "celular", "cenoura", "censo", "centeio", "cercar", "cerrado", "certeiro", "cerveja", "cetim", "cevada", "chacota", "chaleira", "chamado", "chapada", "charme", "chatice", "chave", "chefe", "chegada", "cheiro", "cheque", "chicote", "chifre", "chinelo", "chocalho", "chover", "chumbo", "chutar", "chuva", "cicatriz", "ciclone", "cidade", "cidreira", "ciente", "cigana", "cimento", "cinto", "cinza", "ciranda", "circuito", "cirurgia", "citar", "clareza", "clero", "clicar", "clone", "clube", "coado", "coagir", "cobaia", "cobertor", "cobrar", "cocada", "coelho", "coentro", "coeso", "cogumelo", "coibir", "coifa", "coiote", "colar", "coleira", "colher", "colidir", "colmeia", "colono", "coluna", "comando", "combinar", "comentar", "comitiva", "comover", "complexo", "comum", "concha", "condor", "conectar", "confuso", "congelar", "conhecer", "conjugar", "consumir", "contrato", "convite", "cooperar", "copeiro", "copiador", "copo", "coquetel", "coragem", "cordial", "corneta", "coronha", "corporal", "correio", "cortejo", "coruja", "corvo", "cosseno", "costela", "cotonete", "couro", "couve", "covil", "cozinha", "cratera", "cravo", "creche", "credor", "creme", "crer", "crespo", "criada", "criminal", "crioulo", "crise", "criticar", "crosta", "crua", "cruzeiro", "cubano", "cueca", "cuidado", "cujo", "culatra", "culminar", "culpar", "cultura", "cumprir", "cunhado", "cupido", "curativo", "curral", "cursar", "curto", "cuspir", "custear", "cutelo", "damasco", "datar", "debater", "debitar", "deboche", "debulhar", "decalque", "decimal", "declive", "decote", "decretar", "dedal", "dedicado", "deduzir", "defesa", "defumar", "degelo", "degrau", "degustar", "deitado", "deixar", "delator", "delegado", "delinear", "delonga", "demanda", "demitir", "demolido", "dentista", "depenado", "depilar", "depois", "depressa", "depurar", "deriva", "derramar", "desafio", "desbotar", "descanso", "desenho", "desfiado", "desgaste", "desigual", "deslize", "desmamar", "desova", "despesa", "destaque", "desviar", "detalhar", "detentor", "detonar", "detrito", "deusa", "dever", "devido", "devotado", "dezena", "diagrama", "dialeto", "didata", "difuso", "digitar", "dilatado", "diluente", "diminuir", "dinastia", "dinheiro", "diocese", "direto", "discreta", "disfarce", "disparo", "disquete", "dissipar", "distante", "ditador", "diurno", "diverso", "divisor", "divulgar", "dizer", "dobrador", "dolorido", "domador", "dominado", "donativo", "donzela", "dormente", "dorsal", "dosagem", "dourado", "doutor", "drenagem", "drible", "drogaria", "duelar", "duende", "dueto", "duplo", "duquesa", "durante", "duvidoso", "eclodir", "ecoar", "ecologia", "edificar", "edital", "educado", "efeito", "efetivar", "ejetar", "elaborar", "eleger", "eleitor", "elenco", "elevador", "eliminar", "elogiar", "embargo", "embolado", "embrulho", "embutido", "emenda", "emergir", "emissor", "empatia", "empenho", "empinado", "empolgar", "emprego", "empurrar", "emulador", "encaixe", "encenado", "enchente", "encontro", "endeusar", "endossar", "enfaixar", "enfeite", "enfim", "engajado", "engenho", "englobar", "engomado", "engraxar", "enguia", "enjoar", "enlatar", "enquanto", "enraizar", "enrolado", "enrugar", "ensaio", "enseada", "ensino", "ensopado", "entanto", "enteado", "entidade", "entortar", "entrada", "entulho", "envergar", "enviado", "envolver", "enxame", "enxerto", "enxofre", "enxuto", "epiderme", "equipar", "ereto", "erguido", "errata", "erva", "ervilha", "esbanjar", "esbelto", "escama", "escola", "escrita", "escuta", "esfinge", "esfolar", "esfregar", "esfumado", "esgrima", "esmalte", "espanto", "espelho", "espiga", "esponja", "espreita", "espumar", "esquerda", "estaca", "esteira", "esticar", "estofado", "estrela", "estudo", "esvaziar", "etanol", "etiqueta", "euforia", "europeu", "evacuar", "evaporar", "evasivo", "eventual", "evidente", "evoluir", "exagero", "exalar", "examinar", "exato", "exausto", "excesso", "excitar", "exclamar", "executar", "exemplo", "exibir", "exigente", "exonerar", "expandir", "expelir", "expirar", "explanar", "exposto", "expresso", "expulsar", "externo", "extinto", "extrato", "fabricar", "fabuloso", "faceta", "facial", "fada", "fadiga", "faixa", "falar", "falta", "familiar", "fandango", "fanfarra", "fantoche", "fardado", "farelo", "farinha", "farofa", "farpa", "fartura", "fatia", "fator", "favorita", "faxina", "fazenda", "fechado", "feijoada", "feirante", "felino", "feminino", "fenda", "feno", "fera", "feriado", "ferrugem", "ferver", "festejar", "fetal", "feudal", "fiapo", "fibrose", "ficar", "ficheiro", "figurado", "fileira", "filho", "filme", "filtrar", "firmeza", "fisgada", "fissura", "fita", "fivela", "fixador", "fixo", "flacidez", "flamingo", "flanela", "flechada", "flora", "flutuar", "fluxo", "focal", "focinho", "fofocar", "fogo", "foguete", "foice", "folgado", "folheto", "forjar", "formiga", "forno", "forte", "fosco", "fossa", "fragata", "fralda", "frango", "frasco", "fraterno", "freira", "frente", "fretar", "frieza", "friso", "fritura", "fronha", "frustrar", "fruteira", "fugir", "fulano", "fuligem", "fundar", "fungo", "funil", "furador", "furioso", "futebol", "gabarito", "gabinete", "gado", "gaiato", "gaiola", "gaivota", "galega", "galho", "galinha", "galocha", "ganhar", "garagem", "garfo", "gargalo", "garimpo", "garoupa", "garrafa", "gasoduto", "gasto", "gata", "gatilho", "gaveta", "gazela", "gelado", "geleia", "gelo", "gemada", "gemer", "gemido", "generoso", "gengiva", "genial", "genoma", "genro", "geologia", "gerador", "germinar", "gesso", "gestor", "ginasta", "gincana", "gingado", "girafa", "girino", "glacial", "glicose", "global", "glorioso", "goela", "goiaba", "golfe", "golpear", "gordura", "gorjeta", "gorro", "gostoso", "goteira", "governar", "gracejo", "gradual", "grafite", "gralha", "grampo", "granada", "gratuito", "graveto", "graxa", "grego", "grelhar", "greve", "grilo", "grisalho", "gritaria", "grosso", "grotesco", "grudado", "grunhido", "gruta", "guache", "guarani", "guaxinim", "guerrear", "guiar", "guincho", "guisado", "gula", "guloso", "guru", "habitar", "harmonia", "haste", "haver", "hectare", "herdar", "heresia", "hesitar", "hiato", "hibernar", "hidratar", "hiena", "hino", "hipismo", "hipnose", "hipoteca", "hoje", "holofote", "homem", "honesto", "honrado", "hormonal", "hospedar", "humorado", "iate", "ideia", "idoso", "ignorado", "igreja", "iguana", "ileso", "ilha", "iludido", "iluminar", "ilustrar", "imagem", "imediato", "imenso", "imersivo", "iminente", "imitador", "imortal", "impacto", "impedir", "implante", "impor", "imprensa", "impune", "imunizar", "inalador", "inapto", "inativo", "incenso", "inchar", "incidir", "incluir", "incolor", "indeciso", "indireto", "indutor", "ineficaz", "inerente", "infantil", "infestar", "infinito", "inflamar", "informal", "infrator", "ingerir", "inibido", "inicial", "inimigo", "injetar", "inocente", "inodoro", "inovador", "inox", "inquieto", "inscrito", "inseto", "insistir", "inspetor", "instalar", "insulto", "intacto", "integral", "intimar", "intocado", "intriga", "invasor", "inverno", "invicto", "invocar", "iogurte", "iraniano", "ironizar", "irreal", "irritado", "isca", "isento", "isolado", "isqueiro", "italiano", "janeiro", "jangada", "janta", "jararaca", "jardim", "jarro", "jasmim", "jato", "javali", "jazida", "jejum", "joaninha", "joelhada", "jogador", "joia", "jornal", "jorrar", "jovem", "juba", "judeu", "judoca", "juiz", "julgador", "julho", "jurado", "jurista", "juro", "justa", "labareda", "laboral", "lacre", "lactante", "ladrilho", "lagarta", "lagoa", "laje", "lamber", "lamentar", "laminar", "lampejo", "lanche", "lapidar", "lapso", "laranja", "lareira", "largura", "lasanha", "lastro", "lateral", "latido", "lavanda", "lavoura", "lavrador", "laxante", "lazer", "lealdade", "lebre", "legado", "legendar", "legista", "leigo", "leiloar", "leitura", "lembrete", "leme", "lenhador", "lentilha", "leoa", "lesma", "leste", "letivo", "letreiro", "levar", "leveza", "levitar", "liberal", "libido", "liderar", "ligar", "ligeiro", "limitar", "limoeiro", "limpador", "linda", "linear", "linhagem", "liquidez", "listagem", "lisura", "litoral", "livro", "lixa", "lixeira", "locador", "locutor", "lojista", "lombo", "lona", "longe", "lontra", "lorde", "lotado", "loteria", "loucura", "lousa", "louvar", "luar", "lucidez", "lucro", "luneta", "lustre", "lutador", "luva", "macaco", "macete", "machado", "macio", "madeira", "madrinha", "magnata", "magreza", "maior", "mais", "malandro", "malha", "malote", "maluco", "mamilo", "mamoeiro", "mamute", "manada", "mancha", "mandato", "manequim", "manhoso", "manivela", "manobrar", "mansa", "manter", "manusear", "mapeado", "maquinar", "marcador", "maresia", "marfim", "margem", "marinho", "marmita", "maroto", "marquise", "marreco", "martelo", "marujo", "mascote", "masmorra", "massagem", "mastigar", "matagal", "materno", "matinal", "matutar", "maxilar", "medalha", "medida", "medusa", "megafone", "meiga", "melancia", "melhor", "membro", "memorial", "menino", "menos", "mensagem", "mental", "merecer", "mergulho", "mesada", "mesclar", "mesmo", "mesquita", "mestre", "metade", "meteoro", "metragem", "mexer", "mexicano", "micro", "migalha", "migrar", "milagre", "milenar", "milhar", "mimado", "minerar", "minhoca", "ministro", "minoria", "miolo", "mirante", "mirtilo", "misturar", "mocidade", "moderno", "modular", "moeda", "moer", "moinho", "moita", "moldura", "moleza", "molho", "molinete", "molusco", "montanha", "moqueca", "morango", "morcego", "mordomo", "morena", "mosaico", "mosquete", "mostarda", "motel", "motim", "moto", "motriz", "muda", "muito", "mulata", "mulher", "multar", "mundial", "munido", "muralha", "murcho", "muscular", "museu", "musical", "nacional", "nadador", "naja", "namoro", "narina", "narrado", "nascer", "nativa", "natureza", "navalha", "navegar", "navio", "neblina", "nebuloso", "negativa", "negociar", "negrito", "nervoso", "neta", "neural", "nevasca", "nevoeiro", "ninar", "ninho", "nitidez", "nivelar", "nobreza", "noite", "noiva", "nomear", "nominal", "nordeste", "nortear", "notar", "noticiar", "noturno", "novelo", "novilho", "novo", "nublado", "nudez", "numeral", "nupcial", "nutrir", "nuvem", "obcecado", "obedecer", "objetivo", "obrigado", "obscuro", "obstetra", "obter", "obturar", "ocidente", "ocioso", "ocorrer", "oculista", "ocupado", "ofegante", "ofensiva", "oferenda", "oficina", "ofuscado", "ogiva", "olaria", "oleoso", "olhar", "oliveira", "ombro", "omelete", "omisso", "omitir", "ondulado", "oneroso", "ontem", "opcional", "operador", "oponente", "oportuno", "oposto", "orar", "orbitar", "ordem", "ordinal", "orfanato", "orgasmo", "orgulho", "oriental", "origem", "oriundo", "orla", "ortodoxo", "orvalho", "oscilar", "ossada", "osso", "ostentar", "otimismo", "ousadia", "outono", "outubro", "ouvido", "ovelha", "ovular", "oxidar", "oxigenar", "pacato", "paciente", "pacote", "pactuar", "padaria", "padrinho", "pagar", "pagode", "painel", "pairar", "paisagem", "palavra", "palestra", "palheta", "palito", "palmada", "palpitar", "pancada", "panela", "panfleto", "panqueca", "pantanal", "papagaio", "papelada", "papiro", "parafina", "parcial", "pardal", "parede", "partida", "pasmo", "passado", "pastel", "patamar", "patente", "patinar", "patrono", "paulada", "pausar", "peculiar", "pedalar", "pedestre", "pediatra", "pedra", "pegada", "peitoral", "peixe", "pele", "pelicano", "penca", "pendurar", "peneira", "penhasco", "pensador", "pente", "perceber", "perfeito", "pergunta", "perito", "permitir", "perna", "perplexo", "persiana", "pertence", "peruca", "pescado", "pesquisa", "pessoa", "petiscar", "piada", "picado", "piedade", "pigmento", "pilastra", "pilhado", "pilotar", "pimenta", "pincel", "pinguim", "pinha", "pinote", "pintar", "pioneiro", "pipoca", "piquete", "piranha", "pires", "pirueta", "piscar", "pistola", "pitanga", "pivete", "planta", "plaqueta", "platina", "plebeu", "plumagem", "pluvial", "pneu", "poda", "poeira", "poetisa", "polegada", "policiar", "poluente", "polvilho", "pomar", "pomba", "ponderar", "pontaria", "populoso", "porta", "possuir", "postal", "pote", "poupar", "pouso", "povoar", "praia", "prancha", "prato", "praxe", "prece", "predador", "prefeito", "premiar", "prensar", "preparar", "presilha", "pretexto", "prevenir", "prezar", "primata", "princesa", "prisma", "privado", "processo", "produto", "profeta", "proibido", "projeto", "prometer", "propagar", "prosa", "protetor", "provador", "publicar", "pudim", "pular", "pulmonar", "pulseira", "punhal", "punir", "pupilo", "pureza", "puxador", "quadra", "quantia", "quarto", "quase", "quebrar", "queda", "queijo", "quente", "querido", "quimono", "quina", "quiosque", "rabanada", "rabisco", "rachar", "racionar", "radial", "raiar", "rainha", "raio", "raiva", "rajada", "ralado", "ramal", "ranger", "ranhura", "rapadura", "rapel", "rapidez", "raposa", "raquete", "raridade", "rasante", "rascunho", "rasgar", "raspador", "rasteira", "rasurar", "ratazana", "ratoeira", "realeza", "reanimar", "reaver", "rebaixar", "rebelde", "rebolar", "recado", "recente", "recheio", "recibo", "recordar", "recrutar", "recuar", "rede", "redimir", "redonda", "reduzida", "reenvio", "refinar", "refletir", "refogar", "refresco", "refugiar", "regalia", "regime", "regra", "reinado", "reitor", "rejeitar", "relativo", "remador", "remendo", "remorso", "renovado", "reparo", "repelir", "repleto", "repolho", "represa", "repudiar", "requerer", "resenha", "resfriar", "resgatar", "residir", "resolver", "respeito", "ressaca", "restante", "resumir", "retalho", "reter", "retirar", "retomada", "retratar", "revelar", "revisor", "revolta", "riacho", "rica", "rigidez", "rigoroso", "rimar", "ringue", "risada", "risco", "risonho", "robalo", "rochedo", "rodada", "rodeio", "rodovia", "roedor", "roleta", "romano", "roncar", "rosado", "roseira", "rosto", "rota", "roteiro", "rotina", "rotular", "rouco", "roupa", "roxo", "rubro", "rugido", "rugoso", "ruivo", "rumo", "rupestre", "russo", "sabor", "saciar", "sacola", "sacudir", "sadio", "safira", "saga", "sagrada", "saibro", "salada", "saleiro", "salgado", "saliva", "salpicar", "salsicha", "saltar", "salvador", "sambar", "samurai", "sanar", "sanfona", "sangue", "sanidade", "sapato", "sarda", "sargento", "sarjeta", "saturar", "saudade", "saxofone", "sazonal", "secar", "secular", "seda", "sedento", "sediado", "sedoso", "sedutor", "segmento", "segredo", "segundo", "seiva", "seleto", "selvagem", "semanal", "semente", "senador", "senhor", "sensual", "sentado", "separado", "sereia", "seringa", "serra", "servo", "setembro", "setor", "sigilo", "silhueta", "silicone", "simetria", "simpatia", "simular", "sinal", "sincero", "singular", "sinopse", "sintonia", "sirene", "siri", "situado", "soberano", "sobra", "socorro", "sogro", "soja", "solda", "soletrar", "solteiro", "sombrio", "sonata", "sondar", "sonegar", "sonhador", "sono", "soprano", "soquete", "sorrir", "sorteio", "sossego", "sotaque", "soterrar", "sovado", "sozinho", "suavizar", "subida", "submerso", "subsolo", "subtrair", "sucata", "sucesso", "suco", "sudeste", "sufixo", "sugador", "sugerir", "sujeito", "sulfato", "sumir", "suor", "superior", "suplicar", "suposto", "suprimir", "surdina", "surfista", "surpresa", "surreal", "surtir", "suspiro", "sustento", "tabela", "tablete", "tabuada", "tacho", "tagarela", "talher", "talo", "talvez", "tamanho", "tamborim", "tampa", "tangente", "tanto", "tapar", "tapioca", "tardio", "tarefa", "tarja", "tarraxa", "tatuagem", "taurino", "taxativo", "taxista", "teatral", "tecer", "tecido", "teclado", "tedioso", "teia", "teimar", "telefone", "telhado", "tempero", "tenente", "tensor", "tentar", "termal", "terno", "terreno", "tese", "tesoura", "testado", "teto", "textura", "texugo", "tiara", "tigela", "tijolo", "timbrar", "timidez", "tingido", "tinteiro", "tiragem", "titular", "toalha", "tocha", "tolerar", "tolice", "tomada", "tomilho", "tonel", "tontura", "topete", "tora", "torcido", "torneio", "torque", "torrada", "torto", "tostar", "touca", "toupeira", "toxina", "trabalho", "tracejar", "tradutor", "trafegar", "trajeto", "trama", "trancar", "trapo", "traseiro", "tratador", "travar", "treino", "tremer", "trepidar", "trevo", "triagem", "tribo", "triciclo", "tridente", "trilogia", "trindade", "triplo", "triturar", "triunfal", "trocar", "trombeta", "trova", "trunfo", "truque", "tubular", "tucano", "tudo", "tulipa", "tupi", "turbo", "turma", "turquesa", "tutelar", "tutorial", "uivar", "umbigo", "unha", "unidade", "uniforme", "urologia", "urso", "urtiga", "urubu", "usado", "usina", "usufruir", "vacina", "vadiar", "vagaroso", "vaidoso", "vala", "valente", "validade", "valores", "vantagem", "vaqueiro", "varanda", "vareta", "varrer", "vascular", "vasilha", "vassoura", "vazar", "vazio", "veado", "vedar", "vegetar", "veicular", "veleiro", "velhice", "veludo", "vencedor", "vendaval", "venerar", "ventre", "verbal", "verdade", "vereador", "vergonha", "vermelho", "verniz", "versar", "vertente", "vespa", "vestido", "vetorial", "viaduto", "viagem", "viajar", "viatura", "vibrador", "videira", "vidraria", "viela", "viga", "vigente", "vigiar", "vigorar", "vilarejo", "vinco", "vinheta", "vinil", "violeta", "virada", "virtude", "visitar", "visto", "vitral", "viveiro", "vizinho", "voador", "voar", "vogal", "volante", "voleibol", "voltagem", "volumoso", "vontade", "vulto", "vuvuzela", "xadrez", "xarope", "xeque", "xeretar", "xerife", "xingar", "zangado", "zarpar", "zebu", "zelador", "zombar", "zoologia", "zumbido"];

  var require$$9 = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];

  Object.defineProperty(_wordlists, "__esModule", {
    value: true
  }); // browserify by default only pulls in files that are hard coded in requires
  // In order of last to first in this file, the default wordlist will be chosen
  // based on what is present. (Bundles may remove wordlists they don't need)

  var wordlists = {};
  _wordlists.wordlists = wordlists;

  var _default$1;

  var _default_1 = _wordlists._default = _default$1;

  try {
    _default_1 = _wordlists._default = _default$1 = require$$0$2;
    wordlists.czech = _default$1;
  } catch (err) {}

  try {
    _default_1 = _wordlists._default = _default$1 = require$$1$1;
    wordlists.chinese_simplified = _default$1;
  } catch (err) {}

  try {
    _default_1 = _wordlists._default = _default$1 = require$$2$1;
    wordlists.chinese_traditional = _default$1;
  } catch (err) {}

  try {
    _default_1 = _wordlists._default = _default$1 = require$$3$1;
    wordlists.korean = _default$1;
  } catch (err) {}

  try {
    _default_1 = _wordlists._default = _default$1 = require$$4;
    wordlists.french = _default$1;
  } catch (err) {}

  try {
    _default_1 = _wordlists._default = _default$1 = require$$5;
    wordlists.italian = _default$1;
  } catch (err) {}

  try {
    _default_1 = _wordlists._default = _default$1 = require$$6;
    wordlists.spanish = _default$1;
  } catch (err) {}

  try {
    _default_1 = _wordlists._default = _default$1 = require$$7;
    wordlists.japanese = _default$1;
    wordlists.JA = _default$1;
  } catch (err) {}

  try {
    _default_1 = _wordlists._default = _default$1 = require$$8;
    wordlists.portuguese = _default$1;
  } catch (err) {}

  try {
    _default_1 = _wordlists._default = _default$1 = require$$9;
    wordlists.english = _default$1;
    wordlists.EN = _default$1;
  } catch (err) {}

  Object.defineProperty(src, "__esModule", {
    value: true
  });
  var createHash$4 = createHash$7;
  var pbkdf2_1 = browser$2;
  var randomBytes$3 = randombytes;
  var _wordlists_1 = _wordlists;
  var DEFAULT_WORDLIST = _wordlists_1._default;
  var INVALID_MNEMONIC = 'Invalid mnemonic';
  var INVALID_ENTROPY = 'Invalid entropy';
  var INVALID_CHECKSUM = 'Invalid mnemonic checksum';
  var WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' + 'Please pass a 2048 word array explicitly.';

  function pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {
    return Promise.resolve().then(function () {
      return new Promise(function (resolve, reject) {
        var callback = function callback(err, derivedKey) {
          if (err) {
            return reject(err);
          } else {
            return resolve(derivedKey);
          }
        };

        pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);
      });
    });
  }

  function normalize(str) {
    return (str || '').normalize('NFKD');
  }

  function lpad(str, padString, length) {
    while (str.length < length) {
      str = padString + str;
    }

    return str;
  }

  function binaryToByte(bin) {
    return parseInt(bin, 2);
  }

  function bytesToBinary(bytes) {
    return bytes.map(function (x) {
      return lpad(x.toString(2), '0', 8);
    }).join('');
  }

  function deriveChecksumBits(entropyBuffer) {
    var ENT = entropyBuffer.length * 8;
    var CS = ENT / 32;
    var hash = createHash$4('sha256').update(entropyBuffer).digest();
    return bytesToBinary(Array.from(hash)).slice(0, CS);
  }

  function salt(password) {
    return 'mnemonic' + (password || '');
  }

  function mnemonicToSeedSync(mnemonic, password) {
    var mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
    var saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
  }

  src.mnemonicToSeedSync = mnemonicToSeedSync;

  function mnemonicToSeed(mnemonic, password) {
    return Promise.resolve().then(function () {
      var mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
      var saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
      return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
    });
  }

  src.mnemonicToSeed = mnemonicToSeed;

  function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = wordlist || DEFAULT_WORDLIST;

    if (!wordlist) {
      throw new Error(WORDLIST_REQUIRED);
    }

    var words = normalize(mnemonic).split(' ');

    if (words.length % 3 !== 0) {
      throw new Error(INVALID_MNEMONIC);
    } // convert word indices to 11 bit binary strings


    var bits = words.map(function (word) {
      var index = wordlist.indexOf(word);

      if (index === -1) {
        throw new Error(INVALID_MNEMONIC);
      }

      return lpad(index.toString(2), '0', 11);
    }).join(''); // split the binary string into ENT/CS

    var dividerIndex = Math.floor(bits.length / 33) * 32;
    var entropyBits = bits.slice(0, dividerIndex);
    var checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare

    var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);

    if (entropyBytes.length < 16) {
      throw new Error(INVALID_ENTROPY);
    }

    if (entropyBytes.length > 32) {
      throw new Error(INVALID_ENTROPY);
    }

    if (entropyBytes.length % 4 !== 0) {
      throw new Error(INVALID_ENTROPY);
    }

    var entropy = Buffer.from(entropyBytes);
    var newChecksum = deriveChecksumBits(entropy);

    if (newChecksum !== checksumBits) {
      throw new Error(INVALID_CHECKSUM);
    }

    return entropy.toString('hex');
  }

  src.mnemonicToEntropy = mnemonicToEntropy;

  function entropyToMnemonic(entropy, wordlist) {
    if (!Buffer.isBuffer(entropy)) {
      entropy = Buffer.from(entropy, 'hex');
    }

    wordlist = wordlist || DEFAULT_WORDLIST;

    if (!wordlist) {
      throw new Error(WORDLIST_REQUIRED);
    } // 128 <= ENT <= 256


    if (entropy.length < 16) {
      throw new TypeError(INVALID_ENTROPY);
    }

    if (entropy.length > 32) {
      throw new TypeError(INVALID_ENTROPY);
    }

    if (entropy.length % 4 !== 0) {
      throw new TypeError(INVALID_ENTROPY);
    }

    var entropyBits = bytesToBinary(Array.from(entropy));
    var checksumBits = deriveChecksumBits(entropy);
    var bits = entropyBits + checksumBits;
    var chunks = bits.match(/(.{1,11})/g);
    var words = chunks.map(function (binary) {
      var index = binaryToByte(binary);
      return wordlist[index];
    });
    return wordlist[0] === "\u3042\u3044\u3053\u304F\u3057\u3093" // Japanese wordlist
    ? words.join("\u3000") : words.join(' ');
  }

  src.entropyToMnemonic = entropyToMnemonic;

  function generateMnemonic(strength, rng, wordlist) {
    strength = strength || 128;

    if (strength % 32 !== 0) {
      throw new TypeError(INVALID_ENTROPY);
    }

    rng = rng || randomBytes$3;
    return entropyToMnemonic(rng(strength / 8), wordlist);
  }

  src.generateMnemonic = generateMnemonic;

  function validateMnemonic(mnemonic, wordlist) {
    try {
      mnemonicToEntropy(mnemonic, wordlist);
    } catch (e) {
      return false;
    }

    return true;
  }

  src.validateMnemonic = validateMnemonic;

  function setDefaultWordlist(language) {
    var result = _wordlists_1.wordlists[language];

    if (result) {
      DEFAULT_WORDLIST = result;
    } else {
      throw new Error('Could not find wordlist for language "' + language + '"');
    }
  }

  src.setDefaultWordlist = setDefaultWordlist;

  function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
      throw new Error('No Default Wordlist set');
    }

    return Object.keys(_wordlists_1.wordlists).filter(function (lang) {
      if (lang === 'JA' || lang === 'EN') {
        return false;
      }

      return _wordlists_1.wordlists[lang].every(function (word, index) {
        return word === DEFAULT_WORDLIST[index];
      });
    })[0];
  }

  src.getDefaultWordlist = getDefaultWordlist;
  var _wordlists_2 = _wordlists;
  src.wordlists = _wordlists_2.wordlists;

  var RawKey$1 = {};

  function _createForOfIteratorHelperLoose$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

  function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var errors$1 = {
    IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
    TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',
    TWEAK_MUL: 'The tweak was out of range or equal to zero',
    CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
    SECKEY_INVALID: 'Private Key is invalid',
    PUBKEY_PARSE: 'Public Key could not be parsed',
    PUBKEY_SERIALIZE: 'Public Key serialization error',
    PUBKEY_COMBINE: 'The sum of the public keys is not valid',
    SIG_PARSE: 'Signature could not be parsed',
    SIGN: 'The nonce generation function failed, or the private key was invalid',
    RECOVER: 'Public key could not be recover',
    ECDH: 'Scalar was invalid (zero or overflow)'
  };

  function assert$2(cond, msg) {
    if (!cond) throw new Error(msg);
  }

  function isUint8Array(name, value, length) {
    assert$2(value instanceof Uint8Array, "Expected " + name + " to be an Uint8Array");

    if (length !== undefined) {
      if (Array.isArray(length)) {
        var numbers = length.join(', ');
        var msg = "Expected " + name + " to be an Uint8Array with length [" + numbers + "]";
        assert$2(length.includes(value.length), msg);
      } else {
        var _msg = "Expected " + name + " to be an Uint8Array with length " + length;

        assert$2(value.length === length, _msg);
      }
    }
  }

  function isCompressed(value) {
    assert$2(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');
  }

  function getAssertedOutput(output, length) {
    if (output === void 0) {
      output = function output(len) {
        return new Uint8Array(len);
      };
    }

    if (typeof output === 'function') output = output(length);
    isUint8Array('output', output, length);
    return output;
  }

  function toTypeString(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }

  var lib$1 = function lib(secp256k1) {
    return {
      contextRandomize: function contextRandomize(seed) {
        assert$2(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');
        if (seed !== null) isUint8Array('seed', seed, 32);

        switch (secp256k1.contextRandomize(seed)) {
          case 1:
            throw new Error(errors$1.CONTEXT_RANDOMIZE_UNKNOW);
        }
      },
      privateKeyVerify: function privateKeyVerify(seckey) {
        isUint8Array('private key', seckey, 32);
        return secp256k1.privateKeyVerify(seckey) === 0;
      },
      privateKeyNegate: function privateKeyNegate(seckey) {
        isUint8Array('private key', seckey, 32);

        switch (secp256k1.privateKeyNegate(seckey)) {
          case 0:
            return seckey;

          case 1:
            throw new Error(errors$1.IMPOSSIBLE_CASE);
        }
      },
      privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {
        isUint8Array('private key', seckey, 32);
        isUint8Array('tweak', tweak, 32);

        switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
          case 0:
            return seckey;

          case 1:
            throw new Error(errors$1.TWEAK_ADD);
        }
      },
      privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {
        isUint8Array('private key', seckey, 32);
        isUint8Array('tweak', tweak, 32);

        switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
          case 0:
            return seckey;

          case 1:
            throw new Error(errors$1.TWEAK_MUL);
        }
      },
      publicKeyVerify: function publicKeyVerify(pubkey) {
        isUint8Array('public key', pubkey, [33, 65]);
        return secp256k1.publicKeyVerify(pubkey) === 0;
      },
      publicKeyCreate: function publicKeyCreate(seckey, compressed, output) {
        if (compressed === void 0) {
          compressed = true;
        }

        isUint8Array('private key', seckey, 32);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);

        switch (secp256k1.publicKeyCreate(output, seckey)) {
          case 0:
            return output;

          case 1:
            throw new Error(errors$1.SECKEY_INVALID);

          case 2:
            throw new Error(errors$1.PUBKEY_SERIALIZE);
        }
      },
      publicKeyConvert: function publicKeyConvert(pubkey, compressed, output) {
        if (compressed === void 0) {
          compressed = true;
        }

        isUint8Array('public key', pubkey, [33, 65]);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);

        switch (secp256k1.publicKeyConvert(output, pubkey)) {
          case 0:
            return output;

          case 1:
            throw new Error(errors$1.PUBKEY_PARSE);

          case 2:
            throw new Error(errors$1.PUBKEY_SERIALIZE);
        }
      },
      publicKeyNegate: function publicKeyNegate(pubkey, compressed, output) {
        if (compressed === void 0) {
          compressed = true;
        }

        isUint8Array('public key', pubkey, [33, 65]);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);

        switch (secp256k1.publicKeyNegate(output, pubkey)) {
          case 0:
            return output;

          case 1:
            throw new Error(errors$1.PUBKEY_PARSE);

          case 2:
            throw new Error(errors$1.IMPOSSIBLE_CASE);

          case 3:
            throw new Error(errors$1.PUBKEY_SERIALIZE);
        }
      },
      publicKeyCombine: function publicKeyCombine(pubkeys, compressed, output) {
        if (compressed === void 0) {
          compressed = true;
        }

        assert$2(Array.isArray(pubkeys), 'Expected public keys to be an Array');
        assert$2(pubkeys.length > 0, 'Expected public keys array will have more than zero items');

        for (var _iterator = _createForOfIteratorHelperLoose$3(pubkeys), _step; !(_step = _iterator()).done;) {
          var pubkey = _step.value;
          isUint8Array('public key', pubkey, [33, 65]);
        }

        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);

        switch (secp256k1.publicKeyCombine(output, pubkeys)) {
          case 0:
            return output;

          case 1:
            throw new Error(errors$1.PUBKEY_PARSE);

          case 2:
            throw new Error(errors$1.PUBKEY_COMBINE);

          case 3:
            throw new Error(errors$1.PUBKEY_SERIALIZE);
        }
      },
      publicKeyTweakAdd: function publicKeyTweakAdd(pubkey, tweak, compressed, output) {
        if (compressed === void 0) {
          compressed = true;
        }

        isUint8Array('public key', pubkey, [33, 65]);
        isUint8Array('tweak', tweak, 32);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);

        switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
          case 0:
            return output;

          case 1:
            throw new Error(errors$1.PUBKEY_PARSE);

          case 2:
            throw new Error(errors$1.TWEAK_ADD);
        }
      },
      publicKeyTweakMul: function publicKeyTweakMul(pubkey, tweak, compressed, output) {
        if (compressed === void 0) {
          compressed = true;
        }

        isUint8Array('public key', pubkey, [33, 65]);
        isUint8Array('tweak', tweak, 32);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);

        switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
          case 0:
            return output;

          case 1:
            throw new Error(errors$1.PUBKEY_PARSE);

          case 2:
            throw new Error(errors$1.TWEAK_MUL);
        }
      },
      signatureNormalize: function signatureNormalize(sig) {
        isUint8Array('signature', sig, 64);

        switch (secp256k1.signatureNormalize(sig)) {
          case 0:
            return sig;

          case 1:
            throw new Error(errors$1.SIG_PARSE);
        }
      },
      signatureExport: function signatureExport(sig, output) {
        isUint8Array('signature', sig, 64);
        output = getAssertedOutput(output, 72);
        var obj = {
          output: output,
          outputlen: 72
        };

        switch (secp256k1.signatureExport(obj, sig)) {
          case 0:
            return output.slice(0, obj.outputlen);

          case 1:
            throw new Error(errors$1.SIG_PARSE);

          case 2:
            throw new Error(errors$1.IMPOSSIBLE_CASE);
        }
      },
      signatureImport: function signatureImport(sig, output) {
        isUint8Array('signature', sig);
        output = getAssertedOutput(output, 64);

        switch (secp256k1.signatureImport(output, sig)) {
          case 0:
            return output;

          case 1:
            throw new Error(errors$1.SIG_PARSE);

          case 2:
            throw new Error(errors$1.IMPOSSIBLE_CASE);
        }
      },
      ecdsaSign: function ecdsaSign(msg32, seckey, options, output) {
        if (options === void 0) {
          options = {};
        }

        isUint8Array('message', msg32, 32);
        isUint8Array('private key', seckey, 32);
        assert$2(toTypeString(options) === 'Object', 'Expected options to be an Object');
        if (options.data !== undefined) isUint8Array('options.data', options.data);
        if (options.noncefn !== undefined) assert$2(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');
        output = getAssertedOutput(output, 64);
        var obj = {
          signature: output,
          recid: null
        };

        switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
          case 0:
            return obj;

          case 1:
            throw new Error(errors$1.SIGN);

          case 2:
            throw new Error(errors$1.IMPOSSIBLE_CASE);
        }
      },
      ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {
        isUint8Array('signature', sig, 64);
        isUint8Array('message', msg32, 32);
        isUint8Array('public key', pubkey, [33, 65]);

        switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
          case 0:
            return true;

          case 3:
            return false;

          case 1:
            throw new Error(errors$1.SIG_PARSE);

          case 2:
            throw new Error(errors$1.PUBKEY_PARSE);
        }
      },
      ecdsaRecover: function ecdsaRecover(sig, recid, msg32, compressed, output) {
        if (compressed === void 0) {
          compressed = true;
        }

        isUint8Array('signature', sig, 64);
        assert$2(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');
        isUint8Array('message', msg32, 32);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);

        switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
          case 0:
            return output;

          case 1:
            throw new Error(errors$1.SIG_PARSE);

          case 2:
            throw new Error(errors$1.RECOVER);

          case 3:
            throw new Error(errors$1.IMPOSSIBLE_CASE);
        }
      },
      ecdh: function ecdh(pubkey, seckey, options, output) {
        if (options === void 0) {
          options = {};
        }

        isUint8Array('public key', pubkey, [33, 65]);
        isUint8Array('private key', seckey, 32);
        assert$2(toTypeString(options) === 'Object', 'Expected options to be an Object');
        if (options.data !== undefined) isUint8Array('options.data', options.data);

        if (options.hashfn !== undefined) {
          assert$2(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');
          if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);
          if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);
          isUint8Array('output', output);
        } else {
          output = getAssertedOutput(output, 32);
        }

        switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
          case 0:
            return output;

          case 1:
            throw new Error(errors$1.PUBKEY_PARSE);

          case 2:
            throw new Error(errors$1.ECDH);
        }
      }
    };
  };

  var EC = elliptic$2.ec;
  var ec = new EC('secp256k1');
  var ecparams = ec.curve; // Hack, we can not use bn.js@5, while elliptic uses bn.js@4
  // See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758

  var BN = ecparams.n.constructor;

  function loadCompressedPublicKey(first, xbuf) {
    var x = new BN(xbuf); // overflow

    if (x.cmp(ecparams.p) >= 0) return null;
    x = x.toRed(ecparams.red); // compute corresponding Y

    var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
    if (first === 0x03 !== y.isOdd()) y = y.redNeg();
    return ec.keyPair({
      pub: {
        x: x,
        y: y
      }
    });
  }

  function loadUncompressedPublicKey(first, xbuf, ybuf) {
    var x = new BN(xbuf);
    var y = new BN(ybuf); // overflow

    if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;
    x = x.toRed(ecparams.red);
    y = y.toRed(ecparams.red); // is odd flag

    if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null; // x*x*x + b = y*y

    var x3 = x.redSqr().redIMul(x);
    if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
    return ec.keyPair({
      pub: {
        x: x,
        y: y
      }
    });
  }

  function loadPublicKey(pubkey) {
    // length should be validated in interface
    var first = pubkey[0];

    switch (first) {
      case 0x02:
      case 0x03:
        if (pubkey.length !== 33) return null;
        return loadCompressedPublicKey(first, pubkey.subarray(1, 33));

      case 0x04:
      case 0x06:
      case 0x07:
        if (pubkey.length !== 65) return null;
        return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));

      default:
        return null;
    }
  }

  function savePublicKey(output, point) {
    var pubkey = point.encode(null, output.length === 33); // Loop should be faster because we do not need create extra Uint8Array
    // output.set(new Uint8Array(pubkey))

    for (var i = 0; i < output.length; ++i) {
      output[i] = pubkey[i];
    }
  }

  var elliptic$1 = {
    contextRandomize: function contextRandomize() {
      return 0;
    },
    privateKeyVerify: function privateKeyVerify(seckey) {
      var bn = new BN(seckey);
      return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
    },
    privateKeyNegate: function privateKeyNegate(seckey) {
      var bn = new BN(seckey);
      var negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32);
      seckey.set(negate);
      return 0;
    },
    privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {
      var bn = new BN(tweak);
      if (bn.cmp(ecparams.n) >= 0) return 1;
      bn.iadd(new BN(seckey));
      if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
      if (bn.isZero()) return 1;
      var tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
      seckey.set(tweaked);
      return 0;
    },
    privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {
      var bn = new BN(tweak);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
      bn.imul(new BN(seckey));
      if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);
      var tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
      seckey.set(tweaked);
      return 0;
    },
    publicKeyVerify: function publicKeyVerify(pubkey) {
      var pair = loadPublicKey(pubkey);
      return pair === null ? 1 : 0;
    },
    publicKeyCreate: function publicKeyCreate(output, seckey) {
      var bn = new BN(seckey);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
      var point = ec.keyFromPrivate(seckey).getPublic();
      savePublicKey(output, point);
      return 0;
    },
    publicKeyConvert: function publicKeyConvert(output, pubkey) {
      var pair = loadPublicKey(pubkey);
      if (pair === null) return 1;
      var point = pair.getPublic();
      savePublicKey(output, point);
      return 0;
    },
    publicKeyNegate: function publicKeyNegate(output, pubkey) {
      var pair = loadPublicKey(pubkey);
      if (pair === null) return 1;
      var point = pair.getPublic();
      point.y = point.y.redNeg();
      savePublicKey(output, point);
      return 0;
    },
    publicKeyCombine: function publicKeyCombine(output, pubkeys) {
      var pairs = new Array(pubkeys.length);

      for (var i = 0; i < pubkeys.length; ++i) {
        pairs[i] = loadPublicKey(pubkeys[i]);
        if (pairs[i] === null) return 1;
      }

      var point = pairs[0].getPublic();

      for (var _i = 1; _i < pairs.length; ++_i) {
        point = point.add(pairs[_i].pub);
      }

      if (point.isInfinity()) return 2;
      savePublicKey(output, point);
      return 0;
    },
    publicKeyTweakAdd: function publicKeyTweakAdd(output, pubkey, tweak) {
      var pair = loadPublicKey(pubkey);
      if (pair === null) return 1;
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0) return 2;
      var point = pair.getPublic().add(ecparams.g.mul(tweak));
      if (point.isInfinity()) return 2;
      savePublicKey(output, point);
      return 0;
    },
    publicKeyTweakMul: function publicKeyTweakMul(output, pubkey, tweak) {
      var pair = loadPublicKey(pubkey);
      if (pair === null) return 1;
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;
      var point = pair.getPublic().mul(tweak);
      savePublicKey(output, point);
      return 0;
    },
    signatureNormalize: function signatureNormalize(sig) {
      var r = new BN(sig.subarray(0, 32));
      var s = new BN(sig.subarray(32, 64));
      if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;

      if (s.cmp(ec.nh) === 1) {
        sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32);
      }

      return 0;
    },
    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
    // Adapted for Uint8Array instead Buffer
    signatureExport: function signatureExport(obj, sig) {
      var sigR = sig.subarray(0, 32);
      var sigS = sig.subarray(32, 64);
      if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;
      if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;
      var output = obj.output; // Prepare R

      var r = output.subarray(4, 4 + 33);
      r[0] = 0x00;
      r.set(sigR, 1);
      var lenR = 33;
      var posR = 0;

      for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR) {
      }

      r = r.subarray(posR);
      if (r[0] & 0x80) return 1;
      if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) return 1; // Prepare S

      var s = output.subarray(6 + 33, 6 + 33 + 33);
      s[0] = 0x00;
      s.set(sigS, 1);
      var lenS = 33;
      var posS = 0;

      for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS) {
      }

      s = s.subarray(posS);
      if (s[0] & 0x80) return 1;
      if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) return 1; // Set output length for return

      obj.outputlen = 6 + lenR + lenS; // Output in specified format
      // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]

      output[0] = 0x30;
      output[1] = obj.outputlen - 2;
      output[2] = 0x02;
      output[3] = r.length;
      output.set(r, 4);
      output[4 + lenR] = 0x02;
      output[5 + lenR] = s.length;
      output.set(s, 6 + lenR);
      return 0;
    },
    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
    // Adapted for Uint8Array instead Buffer
    signatureImport: function signatureImport(output, sig) {
      if (sig.length < 8) return 1;
      if (sig.length > 72) return 1;
      if (sig[0] !== 0x30) return 1;
      if (sig[1] !== sig.length - 2) return 1;
      if (sig[2] !== 0x02) return 1;
      var lenR = sig[3];
      if (lenR === 0) return 1;
      if (5 + lenR >= sig.length) return 1;
      if (sig[4 + lenR] !== 0x02) return 1;
      var lenS = sig[5 + lenR];
      if (lenS === 0) return 1;
      if (6 + lenR + lenS !== sig.length) return 1;
      if (sig[4] & 0x80) return 1;
      if (lenR > 1 && sig[4] === 0x00 && !(sig[5] & 0x80)) return 1;
      if (sig[lenR + 6] & 0x80) return 1;
      if (lenS > 1 && sig[lenR + 6] === 0x00 && !(sig[lenR + 7] & 0x80)) return 1;
      var sigR = sig.subarray(4, 4 + lenR);
      if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);
      if (sigR.length > 32) return 1;
      var sigS = sig.subarray(6 + lenR);
      if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);
      if (sigS.length > 32) throw new Error('S length is too long');
      var r = new BN(sigR);
      if (r.cmp(ecparams.n) >= 0) r = new BN(0);
      var s = new BN(sig.subarray(6 + lenR));
      if (s.cmp(ecparams.n) >= 0) s = new BN(0);
      output.set(r.toArrayLike(Uint8Array, 'be', 32), 0);
      output.set(s.toArrayLike(Uint8Array, 'be', 32), 32);
      return 0;
    },
    ecdsaSign: function ecdsaSign(obj, message, seckey, data, noncefn) {
      if (noncefn) {
        var _noncefn = noncefn;

        noncefn = function noncefn(counter) {
          var nonce = _noncefn(message, seckey, null, data, counter);

          var isValid = nonce instanceof Uint8Array && nonce.length === 32;
          if (!isValid) throw new Error('This is the way');
          return new BN(nonce);
        };
      }

      var d = new BN(seckey);
      if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;
      var sig;

      try {
        sig = ec.sign(message, seckey, {
          canonical: true,
          k: noncefn,
          pers: data
        });
      } catch (err) {
        return 1;
      }

      obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0);
      obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32);
      obj.recid = sig.recoveryParam;
      return 0;
    },
    ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {
      var sigObj = {
        r: sig.subarray(0, 32),
        s: sig.subarray(32, 64)
      };
      var sigr = new BN(sigObj.r);
      var sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
      if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;
      var pair = loadPublicKey(pubkey);
      if (pair === null) return 2;
      var point = pair.getPublic();
      var isValid = ec.verify(msg32, sigObj, point);
      return isValid ? 0 : 3;
    },
    ecdsaRecover: function ecdsaRecover(output, sig, recid, msg32) {
      var sigObj = {
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
      var sigr = new BN(sigObj.r);
      var sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
      if (sigr.isZero() || sigs.isZero()) return 2; // Can throw `throw new Error('Unable to find sencond key candinate');`

      var point;

      try {
        point = ec.recoverPubKey(msg32, sigObj, recid);
      } catch (err) {
        return 2;
      }

      savePublicKey(output, point);
      return 0;
    },
    ecdh: function ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
      var pair = loadPublicKey(pubkey);
      if (pair === null) return 1;
      var scalar = new BN(seckey);
      if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;
      var point = pair.getPublic().mul(scalar);

      if (hashfn === undefined) {
        var _data = point.encode(null, true);

        var sha256 = ec.hash().update(_data).digest();

        for (var i = 0; i < 32; ++i) {
          output[i] = sha256[i];
        }
      } else {
        if (!xbuf) xbuf = new Uint8Array(32);
        var x = point.getX().toArray('be', 32);

        for (var _i2 = 0; _i2 < 32; ++_i2) {
          xbuf[_i2] = x[_i2];
        }

        if (!ybuf) ybuf = new Uint8Array(32);
        var y = point.getY().toArray('be', 32);

        for (var _i3 = 0; _i3 < 32; ++_i3) {
          ybuf[_i3] = y[_i3];
        }

        var hash = hashfn(xbuf, ybuf, data);
        var isValid = hash instanceof Uint8Array && hash.length === output.length;
        if (!isValid) return 2;
        output.set(hash);
      }

      return 0;
    }
  };

  var elliptic = lib$1(elliptic$1);

  var __extends$i = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });

  var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });

  var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    }

    __setModuleDefault$1(result, mod);

    return result;
  };

  var __awaiter$m = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$j = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(RawKey$1, "__esModule", {
    value: true
  });
  RawKey$1.RawKey = void 0;
  var SHA256_1$1 = SHA256$2.exports;

  var secp256k1 = __importStar$1(elliptic);

  var Key_1 = Key$1;
  /**
   * An implementation of the Key interfaces that uses a raw private key.
   */

  var RawKey =
  /** @class */
  function (_super) {
    __extends$i(RawKey, _super);

    function RawKey(privateKey) {
      var _this = this;

      var publicKey = secp256k1.publicKeyCreate(new Uint8Array(privateKey), true);
      _this = _super.call(this, Buffer.from(publicKey)) || this;
      _this.privateKey = privateKey;
      return _this;
    }

    RawKey.prototype.ecdsaSign = function (payload) {
      var hash = Buffer.from(SHA256_1$1.SHA256.hash(payload.toString()).toString(), 'hex');
      return secp256k1.ecdsaSign(Uint8Array.from(hash), Uint8Array.from(this.privateKey));
    };

    RawKey.prototype.sign = function (payload) {
      return __awaiter$m(this, void 0, void 0, function () {
        var signature;
        return __generator$j(this, function (_a) {
          signature = this.ecdsaSign(payload).signature;
          return [2
          /*return*/
          , Buffer.from(signature)];
        });
      });
    };

    return RawKey;
  }(Key_1.Key);

  RawKey$1.RawKey = RawKey;

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    var __assign = commonjsGlobal && commonjsGlobal.__assign || function () {
      __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return __assign.apply(this, arguments);
    };

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });

    var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) {
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }

      __setModuleDefault(result, mod);

      return result;
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MnemonicKey = exports.LUNA_COIN_TYPE = void 0;

    var bip32 = __importStar(src$2);

    var bip39 = __importStar(src);

    var RawKey_1 = RawKey$1;
    exports.LUNA_COIN_TYPE = 330;
    var DEFAULT_OPTIONS = {
      account: 0,
      index: 0,
      coinType: exports.LUNA_COIN_TYPE
    };
    /**
     * Implements a BIP39 mnemonic wallet with standard key derivation from a word list. Note
     * that this implementation exposes the private key in memory, so it is not advised to use
     * for applications requiring high security.
     */

    var MnemonicKey =
    /** @class */
    function (_super) {
      __extends(MnemonicKey, _super);
      /**
       * Creates a new signing key from a mnemonic phrase. If no mnemonic is provided, one
       * will be automatically generated.
       *
       * ### Providing a mnemonic
       *
       * ```ts
       * import { MnemonicKey } from 'terra.js';
       *
       * const mk = new MnemonicKey({ mnemonic: '...' });
       * console.log(mk.accAddress);
       * ```
       *
       * ### Generating a random mnemonic
       *
       * ```ts
       * const mk2 = new MnemonicKey();
       * console.log(mk2.mnemonic);
       * ```
       *
       * @param options
       */


      function MnemonicKey(options) {
        if (options === void 0) {
          options = {};
        }

        var _this = this;

        var _a = __assign(__assign({}, DEFAULT_OPTIONS), options),
            account = _a.account,
            index = _a.index,
            coinType = _a.coinType;

        var mnemonic = options.mnemonic;

        if (mnemonic === undefined) {
          mnemonic = bip39.generateMnemonic(256);
        }

        var seed = bip39.mnemonicToSeedSync(mnemonic);
        var masterKey = bip32.fromSeed(seed);
        var hdPathLuna = "m/44'/" + coinType + "'/" + account + "'/0/" + index;
        var terraHD = masterKey.derivePath(hdPathLuna);
        var privateKey = terraHD.privateKey;

        if (!privateKey) {
          throw new Error('Failed to derive key pair');
        }

        _this = _super.call(this, privateKey) || this;
        _this.mnemonic = mnemonic;
        return _this;
      }

      return MnemonicKey;
    }(RawKey_1.RawKey);

    exports.MnemonicKey = MnemonicKey;
  })(MnemonicKey);

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(Key$1, exports);

    __exportStar(MnemonicKey, exports);

    __exportStar(RawKey$1, exports);
  })(key$2);

  var client = {};

  var LCDClient$1 = {};

  var APIRequester$1 = {};

  var axios$2 = {exports: {}};

  var bind$2 = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      return fn.apply(thisArg, args);
    };
  };

  var bind$1 = bind$2; // utils is a library of generic helper functions non-specific to axios

  var toString$1 = Object.prototype.toString;
  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */

  function isArray(val) {
    return toString$1.call(val) === '[object Array]';
  }
  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */


  function isUndefined$1(val) {
    return typeof val === 'undefined';
  }
  /**
   * Determine if a value is a Buffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Buffer, otherwise false
   */


  function isBuffer$2(val) {
    return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
  }
  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */


  function isArrayBuffer$2(val) {
    return toString$1.call(val) === '[object ArrayBuffer]';
  }
  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */


  function isFormData(val) {
    return typeof FormData !== 'undefined' && val instanceof FormData;
  }
  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */


  function isArrayBufferView(val) {
    var result;

    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }

    return result;
  }
  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */


  function isString(val) {
    return typeof val === 'string';
  }
  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */


  function isNumber(val) {
    return typeof val === 'number';
  }
  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */


  function isObject(val) {
    return val !== null && typeof val === 'object';
  }
  /**
   * Determine if a value is a plain Object
   *
   * @param {Object} val The value to test
   * @return {boolean} True if value is a plain Object, otherwise false
   */


  function isPlainObject$1(val) {
    if (toString$1.call(val) !== '[object Object]') {
      return false;
    }

    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */


  function isDate(val) {
    return toString$1.call(val) === '[object Date]';
  }
  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */


  function isFile(val) {
    return toString$1.call(val) === '[object File]';
  }
  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */


  function isBlob(val) {
    return toString$1.call(val) === '[object Blob]';
  }
  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */


  function isFunction(val) {
    return toString$1.call(val) === '[object Function]';
  }
  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */


  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */


  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }
  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */


  function trim$2(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  }
  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */


  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
      return false;
    }

    return typeof window !== 'undefined' && typeof document !== 'undefined';
  }
  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */


  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    } // Force an array if not already something iterable


    if (typeof obj !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */


  function merge() {
    var result = {};

    function assignValue(val, key) {
      if (isPlainObject$1(result[key]) && isPlainObject$1(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject$1(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }

    return result;
  }
  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */


  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  /**
   * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
   *
   * @param {string} content with BOM
   * @return {string} content value without BOM
   */


  function stripBOM(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
      content = content.slice(1);
    }

    return content;
  }

  var utils$d = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer$2,
    isBuffer: isBuffer$2,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isPlainObject: isPlainObject$1,
    isUndefined: isUndefined$1,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim$2,
    stripBOM: stripBOM
  };

  var utils$c = utils$d;

  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  }
  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */


  var buildURL$2 = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;

    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$c.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$c.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils$c.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils$c.forEach(val, function parseValue(v) {
          if (utils$c.isDate(v)) {
            v = v.toISOString();
          } else if (utils$c.isObject(v)) {
            v = JSON.stringify(v);
          }

          parts.push(encode(key) + '=' + encode(v));
        });
      });
      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');

      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  var utils$b = utils$d;

  function InterceptorManager$1() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */


  InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  };
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */


  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */


  InterceptorManager$1.prototype.forEach = function forEach(fn) {
    utils$b.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager$1;

  var utils$a = utils$d;

  var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
    utils$a.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */


  var enhanceError$2 = function enhanceError(error, config, code, request, response) {
    error.config = config;

    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };

    return error;
  };

  var enhanceError$1 = enhanceError$2;
  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */

  var createError$2 = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError$1(error, config, code, request, response);
  };

  var createError$1 = createError$2;
  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */

  var settle$1 = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;

    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError$1('Request failed with status code ' + response.status, response.config, null, response.request, response));
    }
  };

  var utils$9 = utils$d;
  var cookies$1 = utils$9.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils$9.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils$9.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils$9.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  }() : // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() {
        return null;
      },
      remove: function remove() {}
    };
  }();

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */


  var isAbsoluteURL$1 = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */


  var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
  };

  var isAbsoluteURL = isAbsoluteURL$1;
  var combineURLs = combineURLs$1;
  /**
   * Creates a new URL by combining the baseURL with the requestedURL,
   * only when the requestedURL is not already an absolute URL.
   * If the requestURL is absolute, this function returns the requestedURL untouched.
   *
   * @param {string} baseURL The base URL
   * @param {string} requestedURL Absolute or relative URL to combine
   * @returns {string} The combined full path
   */

  var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }

    return requestedURL;
  };

  var utils$8 = utils$d; // Headers whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers

  var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */

  var parseHeaders$1 = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) {
      return parsed;
    }

    utils$8.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils$8.trim(line.substr(0, i)).toLowerCase();
      val = utils$8.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }

        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });
    return parsed;
  };

  var utils$7 = utils$d;
  var isURLSameOrigin$1 = utils$7.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */

    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */

    return function isURLSameOrigin(requestURL) {
      var parsed = utils$7.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();

  var utils$6 = utils$d;
  var settle = settle$1;
  var cookies = cookies$1;
  var buildURL$1 = buildURL$2;
  var buildFullPath = buildFullPath$1;
  var parseHeaders = parseHeaders$1;
  var isURLSameOrigin = isURLSameOrigin$1;
  var createError = createError$2;

  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;

      if (utils$6.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest(); // HTTP basic authentication

      if (config.auth) {
        var username = config.auth.username || '';
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

      request.timeout = config.timeout;

      function onloadend() {
        if (!request) {
          return;
        } // Prepare the response


        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };
        settle(resolve, reject, response); // Clean up request

        request = null;
      }

      if ('onloadend' in request) {
        // Use onloadend if available
        request.onloadend = onloadend;
      } else {
        // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          } // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request


          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          } // readystate handler is calling before onerror or ontimeout handlers,
          // so we should call onloadend on the next 'tick'


          setTimeout(onloadend);
        };
      } // Handle browser request cancellation (as opposed to a manual cancellation)


      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Handle low level network errors


      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request)); // Clean up request

        request = null;
      }; // Handle timeout


      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }

        reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.


      if (utils$6.isStandardBrowserEnv()) {
        // Add xsrf header
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      } // Add headers to the request


      if ('setRequestHeader' in request) {
        utils$6.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      } // Add withCredentials to request if needed


      if (!utils$6.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      } // Add responseType to request if needed


      if (responseType && responseType !== 'json') {
        request.responseType = config.responseType;
      } // Handle progress if needed


      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      } // Not all browsers support upload events


      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel); // Clean up request

          request = null;
        });
      }

      if (!requestData) {
        requestData = null;
      } // Send the request


      request.send(requestData);
    });
  };

  var utils$5 = utils$d;
  var normalizeHeaderName = normalizeHeaderName$1;
  var enhanceError = enhanceError$2;
  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter;

    if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    }

    return adapter;
  }

  function stringifySafely(rawValue, parser, encoder) {
    if (utils$5.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$5.trim(rawValue);
      } catch (e) {
        if (e.name !== 'SyntaxError') {
          throw e;
        }
      }
    }

    return (encoder || JSON.stringify)(rawValue);
  }

  var defaults$3 = {
    transitional: {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    },
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');

      if (utils$5.isFormData(data) || utils$5.isArrayBuffer(data) || utils$5.isBuffer(data) || utils$5.isStream(data) || utils$5.isFile(data) || utils$5.isBlob(data)) {
        return data;
      }

      if (utils$5.isArrayBufferView(data)) {
        return data.buffer;
      }

      if (utils$5.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }

      if (utils$5.isObject(data) || headers && headers['Content-Type'] === 'application/json') {
        setContentTypeIfUnset(headers, 'application/json');
        return stringifySafely(data);
      }

      return data;
    }],
    transformResponse: [function transformResponse(data) {
      var transitional = this.transitional;
      var silentJSONParsing = transitional && transitional.silentJSONParsing;
      var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

      if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data) && data.length) {
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === 'SyntaxError') {
              throw enhanceError(e, this, 'E_JSON_PARSE');
            }

            throw e;
          }
        }
      }

      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults$3.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };
  utils$5.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults$3.headers[method] = {};
  });
  utils$5.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$3;

  var utils$4 = utils$d;
  var defaults$2 = defaults_1;
  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */

  var transformData$1 = function transformData(data, headers, fns) {
    var context = this || defaults$2;
    /*eslint no-param-reassign:0*/

    utils$4.forEach(fns, function transform(fn) {
      data = fn.call(context, data, headers);
    });
    return data;
  };

  var isCancel$1 = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  var utils$3 = utils$d;
  var transformData = transformData$1;
  var isCancel = isCancel$1;
  var defaults$1 = defaults_1;
  /**
   * Throws a `Cancel` if cancellation has been requested.
   */

  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */


  var dispatchRequest$1 = function dispatchRequest(config) {
    throwIfCancellationRequested(config); // Ensure headers exist

    config.headers = config.headers || {}; // Transform request data

    config.data = transformData.call(config, config.data, config.headers, config.transformRequest); // Flatten headers

    config.headers = utils$3.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils$3.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults$1.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config); // Transform response data

      response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config); // Transform response data

        if (reason && reason.response) {
          reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
        }
      }

      return Promise.reject(reason);
    });
  };

  var utils$2 = utils$d;
  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */

  var mergeConfig$2 = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ['url', 'method', 'data'];
    var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
    var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
    var directMergeKeys = ['validateStatus'];

    function getMergedValue(target, source) {
      if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
        return utils$2.merge(target, source);
      } else if (utils$2.isPlainObject(source)) {
        return utils$2.merge({}, source);
      } else if (utils$2.isArray(source)) {
        return source.slice();
      }

      return source;
    }

    function mergeDeepProperties(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    }

    utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(undefined, config2[prop]);
      }
    });
    utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(undefined, config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    });
    utils$2.forEach(directMergeKeys, function merge(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils$2.forEach(otherKeys, mergeDeepProperties);
    return config;
  };

  var name = "axios";
  var version = "0.21.4";
  var description = "Promise based HTTP client for the browser and node.js";
  var main = "index.js";
  var scripts = {
    test: "grunt test",
    start: "node ./sandbox/server.js",
    build: "NODE_ENV=production grunt build",
    preversion: "npm test",
    version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
    postversion: "git push && git push --tags",
    examples: "node ./examples/server.js",
    coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    fix: "eslint --fix lib/**/*.js"
  };
  var repository = {
    type: "git",
    url: "https://github.com/axios/axios.git"
  };
  var keywords = ["xhr", "http", "ajax", "promise", "node"];
  var author = "Matt Zabriskie";
  var license = "MIT";
  var bugs = {
    url: "https://github.com/axios/axios/issues"
  };
  var homepage = "https://axios-http.com";
  var devDependencies = {
    coveralls: "^3.0.0",
    "es6-promise": "^4.2.4",
    grunt: "^1.3.0",
    "grunt-banner": "^0.6.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-clean": "^1.1.0",
    "grunt-contrib-watch": "^1.0.0",
    "grunt-eslint": "^23.0.0",
    "grunt-karma": "^4.0.0",
    "grunt-mocha-test": "^0.13.3",
    "grunt-ts": "^6.0.0-beta.19",
    "grunt-webpack": "^4.0.2",
    "istanbul-instrumenter-loader": "^1.0.0",
    "jasmine-core": "^2.4.1",
    karma: "^6.3.2",
    "karma-chrome-launcher": "^3.1.0",
    "karma-firefox-launcher": "^2.1.0",
    "karma-jasmine": "^1.1.1",
    "karma-jasmine-ajax": "^0.1.13",
    "karma-safari-launcher": "^1.0.0",
    "karma-sauce-launcher": "^4.3.6",
    "karma-sinon": "^1.0.5",
    "karma-sourcemap-loader": "^0.3.8",
    "karma-webpack": "^4.0.2",
    "load-grunt-tasks": "^3.5.2",
    minimist: "^1.2.0",
    mocha: "^8.2.1",
    sinon: "^4.5.0",
    "terser-webpack-plugin": "^4.2.3",
    typescript: "^4.0.5",
    "url-search-params": "^0.10.0",
    webpack: "^4.44.2",
    "webpack-dev-server": "^3.11.0"
  };
  var browser$1 = {
    "./lib/adapters/http.js": "./lib/adapters/xhr.js"
  };
  var jsdelivr = "dist/axios.min.js";
  var unpkg = "dist/axios.min.js";
  var typings = "./index.d.ts";
  var dependencies = {
    "follow-redirects": "^1.14.0"
  };
  var bundlesize = [{
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }];
  var require$$0$1 = {
    name: name,
    version: version,
    description: description,
    main: main,
    scripts: scripts,
    repository: repository,
    keywords: keywords,
    author: author,
    license: license,
    bugs: bugs,
    homepage: homepage,
    devDependencies: devDependencies,
    browser: browser$1,
    jsdelivr: jsdelivr,
    unpkg: unpkg,
    typings: typings,
    dependencies: dependencies,
    bundlesize: bundlesize
  };

  var pkg = require$$0$1;
  var validators$3 = {}; // eslint-disable-next-line func-names

  ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {
    validators$3[type] = function validator(thing) {
      return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
    };
  });
  var deprecatedWarnings = {};
  var currentVerArr = pkg.version.split('.');
  /**
   * Compare package versions
   * @param {string} version
   * @param {string?} thanVersion
   * @returns {boolean}
   */

  function isOlderVersion(version, thanVersion) {
    var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
    var destVer = version.split('.');

    for (var i = 0; i < 3; i++) {
      if (pkgVersionArr[i] > destVer[i]) {
        return true;
      } else if (pkgVersionArr[i] < destVer[i]) {
        return false;
      }
    }

    return false;
  }
  /**
   * Transitional option validator
   * @param {function|boolean?} validator
   * @param {string?} version
   * @param {string} message
   * @returns {function}
   */


  validators$3.transitional = function transitional(validator, version, message) {
    var isDeprecated = version && isOlderVersion(version);

    function formatMessage(opt, desc) {
      return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
    } // eslint-disable-next-line func-names


    return function (value, opt, opts) {
      if (validator === false) {
        throw new Error(formatMessage(opt, ' has been removed in ' + version));
      }

      if (isDeprecated && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true; // eslint-disable-next-line no-console

        console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
      }

      return validator ? validator(value, opt, opts) : true;
    };
  };
  /**
   * Assert object's properties type
   * @param {object} options
   * @param {object} schema
   * @param {boolean?} allowUnknown
   */


  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }

    var keys = Object.keys(options);
    var i = keys.length;

    while (i-- > 0) {
      var opt = keys[i];
      var validator = schema[opt];

      if (validator) {
        var value = options[opt];
        var result = value === undefined || validator(value, opt, options);

        if (result !== true) {
          throw new TypeError('option ' + opt + ' must be ' + result);
        }

        continue;
      }

      if (allowUnknown !== true) {
        throw Error('Unknown option ' + opt);
      }
    }
  }

  var validator$1 = {
    isOlderVersion: isOlderVersion,
    assertOptions: assertOptions,
    validators: validators$3
  };

  var utils$1 = utils$d;
  var buildURL = buildURL$2;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  var validator = validator$1;
  var validators$2 = validator.validators;
  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */

  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */


  Axios$1.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig$1(this.defaults, config); // Set config.method

    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = 'get';
    }

    var transitional = config.transitional;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators$2.transitional(validators$2.boolean, '1.0.0'),
        forcedJSONParsing: validators$2.transitional(validators$2.boolean, '1.0.0'),
        clarifyTimeoutError: validators$2.transitional(validators$2.boolean, '1.0.0')
      }, false);
    } // filter out skipped interceptors


    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;

    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest, undefined];
      Array.prototype.unshift.apply(chain, requestInterceptorChain);
      chain = chain.concat(responseInterceptorChain);
      promise = Promise.resolve(config);

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    }

    var newConfig = config;

    while (requestInterceptorChain.length) {
      var onFulfilled = requestInterceptorChain.shift();
      var onRejected = requestInterceptorChain.shift();

      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected(error);
        break;
      }
    }

    try {
      promise = dispatchRequest(newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    while (responseInterceptorChain.length) {
      promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }

    return promise;
  };

  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  }; // Provide aliases for supported request methods


  utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios$1.prototype[method] = function (url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method: method,
        url: url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios$1.prototype[method] = function (url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });
  var Axios_1 = Axios$1;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */


  function Cancel$1(message) {
    this.message = message;
  }

  Cancel$1.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel$1.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel$1;

  var Cancel = Cancel_1;
  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */

  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `Cancel` if cancellation has been requested.
   */


  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */


  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */


  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Determines whether the payload is an error thrown by Axios
   *
   * @param {*} payload The value to test
   * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
   */


  var isAxiosError = function isAxiosError(payload) {
    return typeof payload === 'object' && payload.isAxiosError === true;
  };

  var utils = utils$d;
  var bind = bind$2;
  var Axios = Axios_1;
  var mergeConfig = mergeConfig$2;
  var defaults = defaults_1;
  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */

  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

    utils.extend(instance, Axios.prototype, context); // Copy context to instance

    utils.extend(instance, context);
    return instance;
  } // Create the default instance to be exported


  var axios$1 = createInstance(defaults); // Expose Axios class to allow class inheritance

  axios$1.Axios = Axios; // Factory for creating new instances

  axios$1.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
  }; // Expose Cancel & CancelToken


  axios$1.Cancel = Cancel_1;
  axios$1.CancelToken = CancelToken_1;
  axios$1.isCancel = isCancel$1; // Expose all/spread

  axios$1.all = function all(promises) {
    return Promise.all(promises);
  };

  axios$1.spread = spread; // Expose isAxiosError

  axios$1.isAxiosError = isAxiosError;
  axios$2.exports = axios$1; // Allow use of default import syntax in TypeScript

  axios$2.exports.default = axios$1;

  var axios = axios$2.exports;

  var __awaiter$l = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$i = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(APIRequester$1, "__esModule", {
    value: true
  });
  APIRequester$1.APIRequester = void 0;

  var axios_1 = __importDefault$6(axios);

  var APIRequester =
  /** @class */
  function () {
    function APIRequester(baseURL) {
      this.axios = axios_1.default.create({
        baseURL: baseURL,
        headers: {
          Accept: 'application/json'
        },
        timeout: 30000
      });
    }

    APIRequester.prototype.getRaw = function (endpoint, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$l(this, void 0, void 0, function () {
        return __generator$i(this, function (_a) {
          return [2
          /*return*/
          , this.axios.get(endpoint, {
            params: params
          }).then(function (d) {
            return d.data;
          })];
        });
      });
    };

    APIRequester.prototype.get = function (endpoint, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$l(this, void 0, void 0, function () {
        return __generator$i(this, function (_a) {
          return [2
          /*return*/
          , this.axios.get(endpoint, {
            params: params
          }).then(function (d) {
            return d.data;
          })];
        });
      });
    };

    APIRequester.prototype.postRaw = function (endpoint, data) {
      return __awaiter$l(this, void 0, void 0, function () {
        return __generator$i(this, function (_a) {
          return [2
          /*return*/
          , this.axios.post(endpoint, data).then(function (d) {
            return d.data;
          })];
        });
      });
    };

    APIRequester.prototype.post = function (endpoint, data) {
      return __awaiter$l(this, void 0, void 0, function () {
        return __generator$i(this, function (_a) {
          return [2
          /*return*/
          , this.axios.post(endpoint, data).then(function (d) {
            return d.data;
          })];
        });
      });
    };

    return APIRequester;
  }();

  APIRequester$1.APIRequester = APIRequester;

  var api = {};

  var AuthAPI$1 = {};

  var BaseAPI$1 = {};

  Object.defineProperty(BaseAPI$1, "__esModule", {
    value: true
  });
  BaseAPI$1.BaseAPI = void 0;

  var BaseAPI =
  /** @class */
  function () {
    function BaseAPI(c) {
      this.c = c;
    }

    return BaseAPI;
  }();

  BaseAPI$1.BaseAPI = BaseAPI;

  var __extends$h = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$k = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$h = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(AuthAPI$1, "__esModule", {
    value: true
  });
  AuthAPI$1.AuthAPI = void 0;
  var core_1$a = core;
  var BaseAPI_1$d = BaseAPI$1;

  var AuthAPI =
  /** @class */
  function (_super) {
    __extends$h(AuthAPI, _super);

    function AuthAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Looks up the account information using its Terra account address. If the account has
     * vesting, it will be a [[LazyGradedVestingAccount]].
     *
     * @param address address of account to look up
     */


    AuthAPI.prototype.accountInfo = function (address, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$k(this, void 0, void 0, function () {
        var result;
        return __generator$h(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.c.get("/auth/accounts/" + address, params)];

            case 1:
              result = _a.sent().result;

              if (result.type === 'core/Account') {
                return [2
                /*return*/
                , core_1$a.Account.fromData(result)];
              } else {
                return [2
                /*return*/
                , core_1$a.LazyGradedVestingAccount.fromData(result)];
              }
          }
        });
      });
    };

    return AuthAPI;
  }(BaseAPI_1$d.BaseAPI);

  AuthAPI$1.AuthAPI = AuthAPI;

  var BankAPI$1 = {};

  var __extends$g = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$j = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$g = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(BankAPI$1, "__esModule", {
    value: true
  });
  BankAPI$1.BankAPI = void 0;
  var BaseAPI_1$c = BaseAPI$1;
  var core_1$9 = core;

  var BankAPI =
  /** @class */
  function (_super) {
    __extends$g(BankAPI, _super);

    function BankAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Look up the balance of an account by its address.
     * @param address address of account to look up.
     */


    BankAPI.prototype.balance = function (address, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$j(this, void 0, void 0, function () {
        return __generator$g(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/bank/balances/" + address, params).then(function (d) {
            return core_1$9.Coins.fromData(d.result);
          })];
        });
      });
    };
    /**
     * Get the total supply of tokens in circulation for all denominations.
     */


    BankAPI.prototype.total = function () {
      return __awaiter$j(this, void 0, void 0, function () {
        return __generator$g(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/bank/total").then(function (d) {
            return core_1$9.Coins.fromData(d.result.supply);
          })];
        });
      });
    };

    return BankAPI;
  }(BaseAPI_1$c.BaseAPI);

  BankAPI$1.BankAPI = BankAPI;

  var DistributionAPI$1 = {};

  var __extends$f = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$i = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$f = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(DistributionAPI$1, "__esModule", {
    value: true
  });
  DistributionAPI$1.DistributionAPI = void 0;
  var BaseAPI_1$b = BaseAPI$1;
  var core_1$8 = core;

  var DistributionAPI =
  /** @class */
  function (_super) {
    __extends$f(DistributionAPI, _super);

    function DistributionAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a delegator's rewards.
     * @param delegator delegator's account address
     */


    DistributionAPI.prototype.rewards = function (delegator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$i(this, void 0, void 0, function () {
        var rewardsData, rewards, _i, _a, reward;

        return __generator$f(this, function (_b) {
          switch (_b.label) {
            case 0:
              return [4
              /*yield*/
              , this.c.get("/distribution/delegators/" + delegator + "/rewards", params).then(function (d) {
                return d.result;
              })];

            case 1:
              rewardsData = _b.sent();
              rewards = {};

              for (_i = 0, _a = rewardsData.rewards; _i < _a.length; _i++) {
                reward = _a[_i];
                rewards[reward.validator_address] = core_1$8.Coins.fromData(reward.reward);
              }

              return [2
              /*return*/
              , {
                rewards: rewards,
                total: core_1$8.Coins.fromData(rewardsData.total)
              }];
          }
        });
      });
    };
    /**
     * Gets a validator's rewards.
     * @param validator validator's operator address
     */


    DistributionAPI.prototype.validatorRewards = function (validator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$i(this, void 0, void 0, function () {
        return __generator$f(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/distribution/validators/" + validator, params).then(function (d) {
            return d.result;
          }).then(function (d) {
            return {
              self_bond_rewards: core_1$8.Coins.fromData(d.self_bond_rewards),
              val_commission: core_1$8.Coins.fromData(d.val_commission)
            };
          })];
        });
      });
    };
    /**
     * Gets the withdraw address of a delegator, the address to which rewards are withdrawn.
     * @param delegator
     */


    DistributionAPI.prototype.withdrawAddress = function (delegator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$i(this, void 0, void 0, function () {
        return __generator$f(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/distribution/delegators/" + delegator + "/withdraw_address", params).then(function (d) {
            return d.result;
          })];
        });
      });
    };
    /**
     * Gets the current value of the community pool.
     */


    DistributionAPI.prototype.communityPool = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$i(this, void 0, void 0, function () {
        return __generator$f(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/distribution/community_pool", params).then(function (d) {
            return core_1$8.Coins.fromData(d.result);
          })];
        });
      });
    };
    /**
     * Gets the current distribution parameters.
     */


    DistributionAPI.prototype.parameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$i(this, void 0, void 0, function () {
        return __generator$f(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/distribution/parameters", params).then(function (_a) {
            var d = _a.result;
            return {
              base_proposer_reward: new core_1$8.Dec(d.base_proposer_reward),
              community_tax: new core_1$8.Dec(d.community_tax),
              bonus_proposer_reward: new core_1$8.Dec(d.bonus_proposer_reward),
              withdraw_addr_enabled: d.withdraw_addr_enabled
            };
          })];
        });
      });
    };

    return DistributionAPI;
  }(BaseAPI_1$b.BaseAPI);

  DistributionAPI$1.DistributionAPI = DistributionAPI;

  var GovAPI$1 = {};

  var __extends$e = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$h = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$e = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(GovAPI$1, "__esModule", {
    value: true
  });
  GovAPI$1.GovAPI = void 0;
  var BaseAPI_1$a = BaseAPI$1;
  var core_1$7 = core;

  var GovAPI =
  /** @class */
  function (_super) {
    __extends$e(GovAPI, _super);

    function GovAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets all proposals.
     */


    GovAPI.prototype.proposals = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        return __generator$e(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/gov/proposals", params).then(function (d) {
            return d.result.map(core_1$7.Proposal.fromData);
          })];
        });
      });
    };
    /**
     * Get a specific proposal by its ID
     * @param proposalId proposal's ID
     */


    GovAPI.prototype.proposal = function (proposalId, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        return __generator$e(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/gov/proposals/" + proposalId, params).then(function (d) {
            return core_1$7.Proposal.fromData(d.result);
          })];
        });
      });
    };
    /**
     * Get the proposal's proposer
     * @param proposalId proposal's ID
     */


    GovAPI.prototype.proposer = function (proposalId, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        return __generator$e(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/gov/proposals/" + proposalId + "/proposer", params).then(function (d) {
            return d.result.proposer;
          })];
        });
      });
    };
    /**
     * Get the deposits for a proposal
     * @param proposalId proposal's ID
     */


    GovAPI.prototype.deposits = function (proposalId, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        return __generator$e(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/gov/proposals/" + proposalId + "/deposits", params).then(function (d) {
            return d.result.map(core_1$7.Deposit.fromData);
          })];
        });
      });
    };
    /**
     * Get the current votes for a proposal
     * @param proposalId proposal's ID
     */


    GovAPI.prototype.votes = function (proposalId, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        return __generator$e(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/gov/proposals/" + proposalId + "/votes", params).then(function (d) {
            return d.result.map(core_1$7.Vote.fromData);
          })];
        });
      });
    };
    /**
     * Gets the current tally for a proposal.
     * @param proposalId proposal's ID
     */


    GovAPI.prototype.tally = function (proposalId, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        return __generator$e(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/gov/proposals/" + proposalId + "/tally", params).then(function (_a) {
            var d = _a.result;
            return {
              yes: new core_1$7.Int(d.yes),
              no: new core_1$7.Int(d.no),
              no_with_veto: new core_1$7.Int(d.no_with_veto),
              abstain: new core_1$7.Int(d.abstain)
            };
          })];
        });
      });
    };
    /** Gets the Gov module's deposit parameters */


    GovAPI.prototype.depositParameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        return __generator$e(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/gov/parameters/deposit", params).then(function (_a) {
            var d = _a.result;
            return {
              max_deposit_period: Number.parseInt(d.max_deposit_period),
              min_deposit: core_1$7.Coins.fromData(d.min_deposit)
            };
          })];
        });
      });
    };
    /** Gets the Gov module's voting parameters */


    GovAPI.prototype.votingParameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        return __generator$e(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/gov/parameters/voting", params).then(function (_a) {
            var d = _a.result;
            return {
              voting_period: Number.parseInt(d.voting_period)
            };
          })];
        });
      });
    };
    /** Gets teh Gov module's tally parameters */


    GovAPI.prototype.tallyParameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        return __generator$e(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/gov/parameters/tallying", params).then(function (_a) {
            var d = _a.result;
            return {
              quorum: new core_1$7.Dec(d.quorum),
              veto_threshold: new core_1$7.Dec(d.veto_threshold),
              threshold: new core_1$7.Dec(d.threshold)
            };
          })];
        });
      });
    };
    /** Gets the Gov module's current parameters  */


    GovAPI.prototype.parameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$h(this, void 0, void 0, function () {
        var _a, deposit_params, voting_params, tally_params;

        return __generator$e(this, function (_b) {
          switch (_b.label) {
            case 0:
              return [4
              /*yield*/
              , Promise.all([this.depositParameters(params), this.votingParameters(params), this.tallyParameters(params)])];

            case 1:
              _a = _b.sent(), deposit_params = _a[0], voting_params = _a[1], tally_params = _a[2];
              return [2
              /*return*/
              , {
                deposit_params: deposit_params,
                voting_params: voting_params,
                tally_params: tally_params
              }];
          }
        });
      });
    };

    return GovAPI;
  }(BaseAPI_1$a.BaseAPI);

  GovAPI$1.GovAPI = GovAPI;

  var MarketAPI$1 = {};

  var __extends$d = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __assign$6 = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign$6 = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return __assign$6.apply(this, arguments);
  };

  var __awaiter$g = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$d = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(MarketAPI$1, "__esModule", {
    value: true
  });
  MarketAPI$1.MarketAPI = void 0;
  var core_1$6 = core;
  var BaseAPI_1$9 = BaseAPI$1;

  var MarketAPI =
  /** @class */
  function (_super) {
    __extends$d(MarketAPI, _super);

    function MarketAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets the Market's swap rate for a given coin to a requested denomination.
     * @param offerCoin coin to convert
     * @param askDenom denomination to swap into
     */


    MarketAPI.prototype.swapRate = function (offerCoin, askDenom, _params) {
      if (_params === void 0) {
        _params = {};
      }

      return __awaiter$g(this, void 0, void 0, function () {
        var params;
        return __generator$d(this, function (_a) {
          params = __assign$6(__assign$6({}, _params), {
            offer_coin: offerCoin.toString(),
            ask_denom: askDenom
          });
          return [2
          /*return*/
          , this.c.get("/market/swap", params).then(function (d) {
            return core_1$6.Coin.fromData(d.result);
          })];
        });
      });
    };
    /**
     * Gets current value of the pool delta, which is used to determine Terra<>Luna swap rates.
     */


    MarketAPI.prototype.poolDelta = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$g(this, void 0, void 0, function () {
        return __generator$d(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/market/terra_pool_delta", params).then(function (d) {
            return new core_1$6.Dec(d.result);
          })];
        });
      });
    };
    /**
     * Gets the current Market module's parameters.
     */


    MarketAPI.prototype.parameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$g(this, void 0, void 0, function () {
        return __generator$d(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/market/parameters", params).then(function (_a) {
            var d = _a.result;
            return {
              pool_recovery_period: Number.parseInt(d.pool_recovery_period),
              base_pool: new core_1$6.Dec(d.base_pool),
              min_stability_spread: new core_1$6.Dec(d.min_stability_spread)
            };
          })];
        });
      });
    };

    return MarketAPI;
  }(BaseAPI_1$9.BaseAPI);

  MarketAPI$1.MarketAPI = MarketAPI;

  var MsgAuthAPI$1 = {};

  var __extends$c = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$f = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$c = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(MsgAuthAPI$1, "__esModule", {
    value: true
  });
  MsgAuthAPI$1.MsgAuthAPI = void 0;
  var BaseAPI_1$8 = BaseAPI$1;
  var Authorization_1 = Authorization;

  var MsgAuthAPI =
  /** @class */
  function (_super) {
    __extends$c(MsgAuthAPI, _super);

    function MsgAuthAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get the message authorization grants for a specific granter and grantee
     */


    MsgAuthAPI.prototype.grants = function (granter, grantee, msgType, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$f(this, void 0, void 0, function () {
        return __generator$c(this, function (_a) {
          if (msgType === undefined) {
            return [2
            /*return*/
            , this.c.get("/msgauth/granters/" + granter + "/grantees/" + grantee + "/grants", params).then(function (d) {
              return d.result.map(Authorization_1.AuthorizationGrant.fromData);
            })];
          } else {
            return [2
            /*return*/
            , this.c.get("/msgauth/granters/" + granter + "/grantees/" + grantee + "/grants/" + msgType, params).then(function (d) {
              if (d.result === null) {
                return [];
              }

              return [Authorization_1.AuthorizationGrant.fromData(d.result)];
            })];
          }
        });
      });
    };

    return MsgAuthAPI;
  }(BaseAPI_1$8.BaseAPI);

  MsgAuthAPI$1.MsgAuthAPI = MsgAuthAPI;

  var OracleAPI$1 = {};

  var __extends$b = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$e = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$b = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(OracleAPI$1, "__esModule", {
    value: true
  });
  OracleAPI$1.OracleAPI = void 0;
  var BaseAPI_1$7 = BaseAPI$1;
  var core_1$5 = core;

  var OracleAPI =
  /** @class */
  function (_super) {
    __extends$b(OracleAPI, _super);

    function OracleAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets the Oracle module's currently registered exchange rate for LUNA in all available denominations.
     */


    OracleAPI.prototype.exchangeRates = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$e(this, void 0, void 0, function () {
        return __generator$b(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/oracle/denoms/exchange_rates", params).then(function (d) {
            if (d === null || d === void 0 ? void 0 : d.result) {
              return core_1$5.Coins.fromData(d.result);
            } else {
              return new core_1$5.Coins({});
            }
          })];
        });
      });
    };
    /**
     * Gets the Oracle module's currently registered exchange rate for the specific denomination.
     * @param denom denomination in which to get the exchange rate of LUNA
     */


    OracleAPI.prototype.exchangeRate = function (denom) {
      return __awaiter$e(this, void 0, void 0, function () {
        var rates;
        return __generator$b(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.exchangeRates()];

            case 1:
              rates = _a.sent();
              return [2
              /*return*/
              , rates.get(denom)];
          }
        });
      });
    };
    /**
     * Gets the current list of active denominations.
     */


    OracleAPI.prototype.activeDenoms = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$e(this, void 0, void 0, function () {
        return __generator$b(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/oracle/denoms/actives", params).then(function (d) {
            return d.result;
          })];
        });
      });
    };
    /**
     * Gets the registered feeder address associated with the validator. The feeder address is the
     * Terra account that is permitted to sign Oracle vote messages in the validator's name.
     * @param validator validator's operator address
     */


    OracleAPI.prototype.feederAddress = function (validator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$e(this, void 0, void 0, function () {
        return __generator$b(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/oracle/voters/" + validator + "/feeder", params).then(function (d) {
            return d.result;
          })];
        });
      });
    };
    /**
     * Gets the number of missed oracle votes for the validator over the current slash window.
     * @param validator validator's operator address
     */


    OracleAPI.prototype.misses = function (validator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$e(this, void 0, void 0, function () {
        return __generator$b(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/oracle/voters/" + validator + "/miss", params).then(function (d) {
            return Number.parseInt(d.result);
          })];
        });
      });
    };
    /**
     * Gets the validator's current submitted aggregate prevote
     * @param validator validator's operator address
     */


    OracleAPI.prototype.aggregatePrevote = function (validator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$e(this, void 0, void 0, function () {
        return __generator$b(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/oracle/voters/" + validator + "/aggregate_prevote", params).then(function (d) {
            return core_1$5.AggregateExchangeRatePrevote.fromData(d.result);
          })];
        });
      });
    };
    /**
     * Gets the validator's current submitted aggregate vote
     * @param validator validator's operator address
     */


    OracleAPI.prototype.aggregateVote = function (validator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$e(this, void 0, void 0, function () {
        return __generator$b(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/oracle/voters/" + validator + "/aggregate_vote", params).then(function (d) {
            return core_1$5.AggregateExchangeRateVote.fromData(d.result);
          })];
        });
      });
    };
    /**
     * Gets the current Oracle module's parameters.
     */


    OracleAPI.prototype.parameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$e(this, void 0, void 0, function () {
        return __generator$b(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/oracle/parameters", params).then(function (_a) {
            var d = _a.result;
            return {
              vote_period: Number.parseInt(d.vote_period),
              vote_threshold: new core_1$5.Dec(d.vote_threshold),
              reward_band: new core_1$5.Dec(d.reward_band),
              reward_distribution_window: Number.parseInt(d.reward_distribution_window),
              whitelist: d.whitelist.map(function (x) {
                return {
                  name: x.name,
                  tobin_tax: new core_1$5.Dec(x.tobin_tax)
                };
              }),
              slash_fraction: new core_1$5.Dec(d.slash_fraction),
              slash_window: Number.parseInt(d.slash_window),
              min_valid_per_window: new core_1$5.Dec(d.min_valid_per_window)
            };
          })];
        });
      });
    };

    return OracleAPI;
  }(BaseAPI_1$7.BaseAPI);

  OracleAPI$1.OracleAPI = OracleAPI;

  var SlashingAPI$1 = {};

  var __extends$a = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$d = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$a = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(SlashingAPI$1, "__esModule", {
    value: true
  });
  SlashingAPI$1.SlashingAPI = void 0;
  var BaseAPI_1$6 = BaseAPI$1;
  var core_1$4 = core;

  var SlashingAPI =
  /** @class */
  function (_super) {
    __extends$a(SlashingAPI, _super);

    function SlashingAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets all signing info, or just the signing info of a particular validator.
     *
     * @param valConsPubKey validator's consensus public key
     */


    SlashingAPI.prototype.signingInfos = function (valConsPubKey, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$d(this, void 0, void 0, function () {
        var url;
        return __generator$a(this, function (_a) {
          if (valConsPubKey !== undefined) {
            url = "/slashing/validators/" + valConsPubKey + "/signing_info";
          } else {
            url = "/slashing/signing_infos";
          }

          return [2
          /*return*/
          , this.c.get(url, params).then(function (d) {
            return d.result.map(function (x) {
              return {
                address: x.address,
                start_height: Number.parseInt(x.start_height),
                index_offset: Number.parseInt(x.index_offset),
                jailed_until: new Date(x.jailed_until),
                tombstoned: x.tombstoned,
                missed_blocks_counter: Number.parseInt(x.missed_blocks_counter)
              };
            });
          })];
        });
      });
    };
    /**
     * Gets the current Slashing module's parameters.
     */


    SlashingAPI.prototype.parameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$d(this, void 0, void 0, function () {
        return __generator$a(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/slashing/parameters", params).then(function (_a) {
            var d = _a.result;
            return {
              signed_blocks_window: Number.parseInt(d.signed_blocks_window),
              min_signed_per_window: new core_1$4.Dec(d.min_signed_per_window),
              downtime_jail_duration: Number.parseInt(d.downtime_jail_duration),
              slash_fraction_double_sign: new core_1$4.Dec(d.slash_fraction_double_sign),
              slash_fraction_downtime: new core_1$4.Dec(d.slash_fraction_downtime)
            };
          })];
        });
      });
    };

    return SlashingAPI;
  }(BaseAPI_1$6.BaseAPI);

  SlashingAPI$1.SlashingAPI = SlashingAPI;

  var StakingAPI$1 = {};

  var __extends$9 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __assign$5 = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign$5 = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return __assign$5.apply(this, arguments);
  };

  var __awaiter$c = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$9 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(StakingAPI$1, "__esModule", {
    value: true
  });
  StakingAPI$1.StakingAPI = void 0;
  var core_1$3 = core;
  var BaseAPI_1$5 = BaseAPI$1;
  var Delegation_1 = Delegation$1;
  var Validator_1 = Validator;
  var Redelegation_1 = Redelegation;

  var StakingAPI =
  /** @class */
  function (_super) {
    __extends$9(StakingAPI, _super);

    function StakingAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Queries all delegations, filtering by delegator, validator, or both.
     *
     * At least one of the parameters must be defined.
     * @param delegator delegator's account address
     * @param validator validator's operator address
     */


    StakingAPI.prototype.delegations = function (delegator, validator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$c(this, void 0, void 0, function () {
        return __generator$9(this, function (_a) {
          if (delegator !== undefined && validator !== undefined) {
            return [2
            /*return*/
            , this.c.get("/staking/delegators/" + delegator + "/delegations/" + validator, params).then(function (data) {
              return [Delegation_1.Delegation.fromData(data.result)];
            })];
          } else if (delegator !== undefined) {
            return [2
            /*return*/
            , this.c.get("/staking/delegators/" + delegator + "/delegations", params).then(function (data) {
              return data.result.map(Delegation_1.Delegation.fromData);
            })];
          } else if (validator !== undefined) {
            return [2
            /*return*/
            , this.c.get("/staking/validators/" + validator + "/delegations", params).then(function (data) {
              return data.result.map(Delegation_1.Delegation.fromData);
            })];
          } else {
            throw new TypeError('arguments delegator and validator cannot both be empty');
          }
        });
      });
    };
    /**
     * Gets the delegation between a delegator and validator, if it exists.
     * @param delegator delegator's account address
     * @param validator validator's operator address
     */


    StakingAPI.prototype.delegation = function (delegator, validator) {
      return __awaiter$c(this, void 0, void 0, function () {
        return __generator$9(this, function (_a) {
          return [2
          /*return*/
          , this.delegations(delegator, validator).then(function (delgs) {
            return delgs[0];
          })];
        });
      });
    };
    /**
     * Queries all unbonding delegations, filtering by delegator, validator, or both.
     *
     * At least one of the parameters must be defined.
     * @param delegator delegator's account address
     * @param validator validator's operator address
     */


    StakingAPI.prototype.unbondingDelegations = function (delegator, validator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$c(this, void 0, void 0, function () {
        return __generator$9(this, function (_a) {
          if (delegator !== undefined && validator !== undefined) {
            return [2
            /*return*/
            , this.c.get("/staking/delegators/" + delegator + "/unbonding_delegations/" + validator, params).then(function (data) {
              return [core_1$3.UnbondingDelegation.fromData(data.result)];
            })];
          } else if (delegator !== undefined) {
            return [2
            /*return*/
            , this.c.get("/staking/delegators/" + delegator + "/unbonding_delegations", params).then(function (data) {
              return data.result.map(core_1$3.UnbondingDelegation.fromData);
            })];
          } else if (validator !== undefined) {
            return [2
            /*return*/
            , this.c.get("/staking/validators/" + validator + "/unbonding_delegations", params).then(function (data) {
              return data.result.map(core_1$3.UnbondingDelegation.fromData);
            })];
          } else {
            throw new TypeError('arguments delegator and validator cannot both be empty');
          }
        });
      });
    };
    /**
     * Gets the unbonding delegation between a delegator and validator, if it exists.
     * @param delegator delegator's account address
     * @param validator validator's operator address
     */


    StakingAPI.prototype.unbondingDelegation = function (delegator, validator) {
      return __awaiter$c(this, void 0, void 0, function () {
        return __generator$9(this, function (_a) {
          return [2
          /*return*/
          , this.unbondingDelegations(delegator, validator).then(function (udelgs) {
            return udelgs[0];
          })];
        });
      });
    };
    /**
     * Queries all redelegations, filterable by delegator, source validator, and target validator.
     * @param delegator delegator's account address
     * @param validatorSrc source validator's operator address (from).
     * @param validatorDst destination validator's operator address (to).
     */


    StakingAPI.prototype.redelegations = function (delegator, validatorSrc, validatorDst, _params) {
      if (_params === void 0) {
        _params = {};
      }

      return __awaiter$c(this, void 0, void 0, function () {
        var params;
        return __generator$9(this, function (_a) {
          params = __assign$5(__assign$5({}, _params), {
            delegator: delegator,
            validator_from: validatorSrc,
            validator_to: validatorDst
          });
          return [2
          /*return*/
          , this.c.get("/staking/redelegations", params).then(function (d) {
            return d.result.map(Redelegation_1.Redelegation.fromData);
          })];
        });
      });
    };
    /**
     * Gets all bonded validators for a delegator given its address.
     * @param delegator delegator's account address
     */


    StakingAPI.prototype.bondedValidators = function (delegator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$c(this, void 0, void 0, function () {
        return __generator$9(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/staking/delegators/" + delegator + "/validators", params).then(function (d) {
            return d.result.map(Validator_1.Validator.fromData);
          })];
        });
      });
    };
    /**
     * Get all current registered validators, including validators that are not currently in the validating set.
     */


    StakingAPI.prototype.validators = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$c(this, void 0, void 0, function () {
        return __generator$9(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/staking/validators", params).then(function (d) {
            return d.result.map(Validator_1.Validator.fromData);
          })];
        });
      });
    };
    /**
     * Gets the validator information for a specific validator.
     * @param validator validator's operator address
     */


    StakingAPI.prototype.validator = function (validator, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$c(this, void 0, void 0, function () {
        return __generator$9(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/staking/validators/" + validator, params).then(function (d) {
            return Validator_1.Validator.fromData(d.result);
          })];
        });
      });
    };
    /**
     * Gets the current staking pool.
     */


    StakingAPI.prototype.pool = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$c(this, void 0, void 0, function () {
        return __generator$9(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/staking/pool", params).then(function (_a) {
            var d = _a.result;
            return {
              bonded_tokens: new core_1$3.Coin('uluna', d.bonded_tokens),
              not_bonded_tokens: new core_1$3.Coin('uluna', d.not_bonded_tokens)
            };
          })];
        });
      });
    };
    /**
     * Gets the current Staking module's parameters.
     */


    StakingAPI.prototype.parameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$c(this, void 0, void 0, function () {
        return __generator$9(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/staking/parameters", params).then(function (_a) {
            var d = _a.result;
            return {
              unbonding_time: Number.parseInt(d.unbonding_time),
              max_validators: d.max_validators,
              max_entries: d.max_entries,
              historical_entries: d.historical_entries,
              bond_denom: d.bond_denom,
              power_reduction: d.power_reduction
            };
          })];
        });
      });
    };

    return StakingAPI;
  }(BaseAPI_1$5.BaseAPI);

  StakingAPI$1.StakingAPI = StakingAPI;

  var SupplyAPI$1 = {};

  var __extends$8 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$b = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$8 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(SupplyAPI$1, "__esModule", {
    value: true
  });
  SupplyAPI$1.SupplyAPI = void 0;
  /**
   * Total supply API has been moved bank module
   * This file will be deprecated. DO NOT USE
   */

  var core_1$2 = core;
  var BaseAPI_1$4 = BaseAPI$1;

  var SupplyAPI =
  /** @class */
  function (_super) {
    __extends$8(SupplyAPI, _super);

    function SupplyAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get the total supply of tokens in circulation for all denominations.
     */


    SupplyAPI.prototype.total = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$b(this, void 0, void 0, function () {
        return __generator$8(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/bank/total", params).then(function (d) {
            return core_1$2.Coins.fromData(d.result.supply);
          })];
        });
      });
    };

    return SupplyAPI;
  }(BaseAPI_1$4.BaseAPI);

  SupplyAPI$1.SupplyAPI = SupplyAPI;

  var TendermintAPI$1 = {};

  var __extends$7 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$a = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$7 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(TendermintAPI$1, "__esModule", {
    value: true
  });
  TendermintAPI$1.TendermintAPI = void 0;
  var BaseAPI_1$3 = BaseAPI$1;

  var TendermintAPI =
  /** @class */
  function (_super) {
    __extends$7(TendermintAPI, _super);

    function TendermintAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets the node's information.
     */


    TendermintAPI.prototype.nodeInfo = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$a(this, void 0, void 0, function () {
        return __generator$7(this, function (_a) {
          return [2
          /*return*/
          , this.c.getRaw("/node_info", params)];
        });
      });
    };
    /**
     * Gets whether the node is currently in syncing mode to catch up with blocks.
     */


    TendermintAPI.prototype.syncing = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$a(this, void 0, void 0, function () {
        return __generator$7(this, function (_a) {
          return [2
          /*return*/
          , this.c.getRaw("/syncing", params).then(function (d) {
            return d.syncing;
          })];
        });
      });
    };
    /**
     * Gets the validator (delegates) set at the specific height. If no height is given, the current set is returned.
     * @param height block height
     */


    TendermintAPI.prototype.validatorSet = function (height, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$a(this, void 0, void 0, function () {
        var url;
        return __generator$7(this, function (_a) {
          url = height !== undefined ? "/validatorsets/" + height : "/validatorsets/latest";
          return [2
          /*return*/
          , this.c.get(url, params).then(function (d) {
            return d.result;
          })];
        });
      });
    };
    /**
     * Gets the block information at the specified height. If no height is given, the latest block is returned.
     * @param height block height.
     */


    TendermintAPI.prototype.blockInfo = function (height, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$a(this, void 0, void 0, function () {
        var url;
        return __generator$7(this, function (_a) {
          url = height !== undefined ? "/blocks/" + height : "/blocks/latest";
          return [2
          /*return*/
          , this.c.getRaw(url, params)];
        });
      });
    };

    return TendermintAPI;
  }(BaseAPI_1$3.BaseAPI);

  TendermintAPI$1.TendermintAPI = TendermintAPI;

  var TreasuryAPI$1 = {};

  var __extends$6 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __assign$4 = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign$4 = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return __assign$4.apply(this, arguments);
  };

  var __awaiter$9 = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$6 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(TreasuryAPI$1, "__esModule", {
    value: true
  });
  TreasuryAPI$1.TreasuryAPI = void 0;
  var BaseAPI_1$2 = BaseAPI$1;
  var core_1$1 = core;

  var TreasuryAPI =
  /** @class */
  function (_super) {
    __extends$6(TreasuryAPI, _super);

    function TreasuryAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets the current registered Tax Cap for a specified denomation.
     * @param denom denomination desired for Tax Cap query.
     */


    TreasuryAPI.prototype.taxCap = function (denom, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$9(this, void 0, void 0, function () {
        return __generator$6(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/treasury/tax_cap/" + denom, params).then(function (d) {
            return new core_1$1.Coin(denom, d.result);
          })];
        });
      });
    };
    /**
     * Gets the current registered Tax Rate.
     */


    TreasuryAPI.prototype.taxRate = function (height, _params) {
      if (_params === void 0) {
        _params = {};
      }

      return __awaiter$9(this, void 0, void 0, function () {
        var params;
        return __generator$6(this, function (_a) {
          params = __assign$4({}, _params);

          if (height) {
            params.height = height;
          }

          return [2
          /*return*/
          , this.c.get("/treasury/tax_rate", params).then(function (d) {
            return new core_1$1.Dec(d.result);
          })];
        });
      });
    };
    /**
     * Gets the current registered Reward Weight monetary policy lever.
     */


    TreasuryAPI.prototype.rewardWeight = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$9(this, void 0, void 0, function () {
        return __generator$6(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/treasury/reward_weight", params).then(function (d) {
            return new core_1$1.Dec(d.result);
          })];
        });
      });
    };
    /**
     * Gets the tax proceeds for the epoch.
     */


    TreasuryAPI.prototype.taxProceeds = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$9(this, void 0, void 0, function () {
        return __generator$6(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/treasury/tax_proceeds", params).then(function (d) {
            return core_1$1.Coins.fromData(d.result);
          })];
        });
      });
    };
    /**
     * Gets the seigniorage proceeds for the epoch.
     */


    TreasuryAPI.prototype.seigniorageProceeds = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$9(this, void 0, void 0, function () {
        return __generator$6(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/treasury/seigniorage_proceeds", params).then(function (d) {
            return new core_1$1.Coin('uluna', d.result);
          })];
        });
      });
    };
    /**
     * Gets the current Treasury module's parameters.
     */


    TreasuryAPI.prototype.parameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$9(this, void 0, void 0, function () {
        return __generator$6(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/treasury/parameters", params).then(function (_a) {
            var d = _a.result;
            return {
              tax_policy: core_1$1.PolicyConstraints.fromData(d.tax_policy),
              reward_policy: core_1$1.PolicyConstraints.fromData(d.reward_policy),
              mining_increment: new core_1$1.Dec(d.mining_increment),
              seigniorage_burden_target: new core_1$1.Dec(d.seigniorage_burden_target),
              window_long: Number.parseInt(d.window_long),
              window_short: Number.parseInt(d.window_short),
              window_probation: Number.parseInt(d.window_probation)
            };
          })];
        });
      });
    };

    return TreasuryAPI;
  }(BaseAPI_1$2.BaseAPI);

  TreasuryAPI$1.TreasuryAPI = TreasuryAPI;

  var TxAPI = {};

  var hash = {};

  var Base64 = {exports: {}};

  (function (module, exports) {
    !function (r, n) {
      module.exports = n();
    }(commonjsGlobal, function () {
      return function () {

        var r = {
          d: function d(n, t) {
            for (var e in t) {
              r.o(t, e) && !r.o(n, e) && Object.defineProperty(n, e, {
                enumerable: !0,
                get: t[e]
              });
            }
          }
        };
        r.g = function () {
          if ("object" == typeof globalThis) return globalThis;

          try {
            return this || new Function("return this")();
          } catch (r) {
            if ("object" == typeof window) return window;
          }
        }(), r.o = function (r, n) {
          return Object.prototype.hasOwnProperty.call(r, n);
        }, r.r = function (r) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(r, Symbol.toStringTag, {
            value: "Module"
          }), Object.defineProperty(r, "t", {
            value: !0
          });
        };
        var n = {};
        r.r(n), r.d(n, {
          Base64: function Base64() {
            return h;
          }
        });

        var t,
            e = function e(r) {
          for (var n = r.nSigBytes, t = r.words, e = [], i = 0; i < n; i++) {
            var o = t[i >>> 2] >>> 24 - i % 4 * 8 & 255;
            e.push((o >>> 4).toString(16)), e.push((15 & o).toString(16));
          }

          return e.join("");
        },
            i = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
            o = (t = parseInt((/msie (\d+)/.exec(i) || [])[1], 10), isNaN(t) ? (t = parseInt((/trident\/.*; rv:(\d+)/.exec(i) || [])[1], 10), !isNaN(t) && t) : t);

        for (var a = function () {
          if ("undefined" != typeof window) {
            var n = window.crypto || window.msCrypto;

            if (!n) {
              if (function (r, n) {
                return !1 !== o && (!n || ("<" === r ? o < n : "<=" === r ? o <= n : ">" === r ? o > n : ">=" === r ? o >= n : o === n));
              }("<", 11)) return console.warn("IE <= 10 uses insecure random generator. Please consider to use IE11 or another modern browser"), function () {
                return Math.floor(512 * Math.random()) % 256;
              };
              throw new Error("Crypto module not found");
            }

            return function () {
              return n.getRandomValues(new Uint32Array(1))[0];
            };
          }

          return void 0 !== r.g && r.g.crypto ? function () {
            return r.g.crypto.randomBytes(4).readInt32LE();
          } : function () {
            return require$$0__default["default"].randomBytes(4).readInt32LE();
          };
        }(), f = function () {
          function r(n, t) {
            if (Array.isArray(n) || !n) return this.i = Array.isArray(n) ? n : [], void (this.u = "number" == typeof t ? t : 4 * this.i.length);
            if (n instanceof r) return this.i = n.words.slice(), void (this.u = n.nSigBytes);
            var e;

            try {
              n instanceof ArrayBuffer ? e = new Uint8Array(n) : (n instanceof Uint8Array || n instanceof Int8Array || n instanceof Uint8ClampedArray || n instanceof Int16Array || n instanceof Uint16Array || n instanceof Int32Array || n instanceof Uint32Array || n instanceof Float32Array || n instanceof Float64Array) && (e = new Uint8Array(n.buffer, n.byteOffset, n.byteLength));
            } catch (r) {
              throw new Error("Invalid argument");
            }

            if (!e) throw new Error("Invalid argument");

            for (var i = e.byteLength, o = [], a = 0; a < i; a++) {
              o[a >>> 2] |= e[a] << 24 - a % 4 * 8;
            }

            this.i = o, this.u = i;
          }

          return Object.defineProperty(r.prototype, "nSigBytes", {
            get: function get() {
              return this.u;
            },
            set: function set(r) {
              this.u = r;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(r.prototype, "words", {
            get: function get() {
              return this.i;
            },
            enumerable: !1,
            configurable: !0
          }), r.prototype.toString = function (r) {
            return r ? r.stringify(this) : e(this);
          }, r.prototype.toUint8Array = function () {
            for (var r = this.i, n = this.u, t = new Uint8Array(n), e = 0; e < n; e++) {
              t[e] = r[e >>> 2] >>> 24 - e % 4 * 8 & 255;
            }

            return t;
          }, r.prototype.concat = function (r) {
            var n = r.words.slice(),
                t = r.nSigBytes;
            if (this.clamp(), this.u % 4) for (var e = 0; e < t; e++) {
              var i = n[e >>> 2] >>> 24 - e % 4 * 8 & 255;
              this.i[this.u + e >>> 2] |= i << 24 - (this.u + e) % 4 * 8;
            } else for (e = 0; e < t; e += 4) {
              this.i[this.u + e >>> 2] = n[e >>> 2];
            }
            return this.u += t, this;
          }, r.prototype.clamp = function () {
            var r = this.u;
            this.i[r >>> 2] &= 4294967295 << 32 - r % 4 * 8, this.i.length = Math.ceil(r / 4);
          }, r.prototype.clone = function () {
            return new r(this.i.slice(), this.u);
          }, r.random = function (n) {
            for (var t = [], e = 0; e < n; e += 4) {
              t.push(a());
            }

            return new r(t, n);
          }, r;
        }(), u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", s = [], c = 0; c < u.length; c++) {
          s[u.charCodeAt(c)] = c;
        }

        var h = {
          stringify: function stringify(r) {
            var n = r.words,
                t = r.nSigBytes;
            r.clamp();

            for (var e = [], i = 0; i < t; i += 3) {
              for (var o = (n[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 16 | (n[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255) << 8 | n[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, a = 0; a < 4 && i + .75 * a < t; a++) {
                e.push(u.charAt(o >>> 6 * (3 - a) & 63));
              }
            }

            var f = u.charAt(64);
            if (f) for (; e.length % 4;) {
              e.push(f);
            }
            return e.join("");
          },
          parse: function parse(r) {
            var n = r.length,
                t = u.charAt(64);

            if (t) {
              var e = r.indexOf(t);
              -1 !== e && (n = e);
            }

            for (var i = [], o = 0, a = 0; a < n; a++) {
              if (a % 4) {
                var c = s[r.charCodeAt(a - 1)] << a % 4 * 2 | s[r.charCodeAt(a)] >>> 6 - a % 4 * 2;
                i[o >>> 2] |= c << 24 - o % 4 * 8, o++;
              }
            }

            return new f(i, o);
          }
        };
        return n;
      }();
    });
  })(Base64);

  Object.defineProperty(hash, "__esModule", {
    value: true
  });
  hash.hashTxBytes = void 0;
  var SHA256_1 = SHA256$2.exports;
  var Base64_1 = Base64.exports;
  /*
  DEPRECATED (was used by crypto-js)
  function byteArrayToWordArray(ba: Uint8Array): CryptoJS.LibWordArray {
    const wa: number[] = [];
    for (let i = 0; i < ba.length; i += 1) {
      wa[(i / 4) | 0] |= ba[i] << (24 - 8 * i);
    }
    return crypto.lib.WordArray.create(wa);
  }*/

  /**
   * Calculates the transaction hash from Proto-encoded string.
   * @param txData Proto-encoded string (base64)
   */

  function hashTxBytes(txData) {
    return SHA256_1.SHA256.hash(Base64_1.Base64.parse(txData)).toString().toUpperCase();
  }

  hash.hashTxBytes = hashTxBytes;

  (function (exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };

    var __generator = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
      var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) {
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];

            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;

              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };

              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;

              case 7:
                op = _.ops.pop();

                _.trys.pop();

                continue;

              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }

                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }

                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }

                if (t && _.label < t[2]) {
                  _.label = t[2];

                  _.ops.push(op);

                  break;
                }

                if (t[2]) _.ops.pop();

                _.trys.pop();

                continue;
            }

            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TxAPI = exports.isTxError = exports.Broadcast = void 0;
    var BaseAPI_1 = BaseAPI$1;
    var core_1 = core;
    var hash_1 = hash;
    var core_2 = core;
    /** Transaction broadcasting modes  */

    var Broadcast;

    (function (Broadcast) {
      /** Wait until the transaction has been included in the block */
      Broadcast["BLOCK"] = "block";
      /** Return after DeliverTx() */

      Broadcast["SYNC"] = "sync";
      /** Return after CheckTx() */

      Broadcast["ASYNC"] = "async";
    })(Broadcast = exports.Broadcast || (exports.Broadcast = {}));

    function isTxError(x) {
      return x.code !== undefined;
    }

    exports.isTxError = isTxError;

    var TxAPI =
    /** @class */
    function (_super) {
      __extends(TxAPI, _super);

      function TxAPI(lcd) {
        var _this = _super.call(this, lcd.apiRequester) || this;

        _this.lcd = lcd;
        return _this;
      }
      /**
       * Looks up a transaction on the blockchain, addressed by its hash
       * @param txHash transaction's hash
       */


      TxAPI.prototype.txInfo = function (txHash, params) {
        if (params === void 0) {
          params = {};
        }

        return __awaiter(this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            return [2
            /*return*/
            , this.c.getRaw("/txs/" + txHash, params).then(core_1.TxInfo.fromData)];
          });
        });
      };
      /**
       * Builds a [[StdSignMsg]] that is ready to be signed by a [[Key]]. The appropriate
       * account number and sequence will be fetched live from the blockchain and added to
       * the resultant [[StdSignMsg]]. If no fee is provided, fee will be automatically
       * estimated using the parameters, simulated using a "dummy fee" with sourceAddress's
       * nonzero denominations in its balance.
       *
       * @param sourceAddress account address of signer
       * @param options TX generation options
       */


      TxAPI.prototype.create = function (sourceAddress, options) {
        return __awaiter(this, void 0, void 0, function () {
          var fee, memo, msgs, account;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                fee = options.fee, memo = options.memo;
                msgs = options.msgs;
                memo = memo || '';
                if (!(!options.account_number || !options.sequence)) return [3
                /*break*/
                , 2];
                return [4
                /*yield*/
                , this.lcd.auth.accountInfo(sourceAddress)];

              case 1:
                account = _a.sent();

                if (!options.account_number) {
                  options.account_number = account.account_number;
                }

                if (!options.sequence) {
                  options.sequence = account.sequence;
                }

                _a.label = 2;

              case 2:
                if (!(fee === undefined)) return [3
                /*break*/
                , 4];
                return [4
                /*yield*/
                , this.lcd.tx.estimateFee(sourceAddress, msgs, options)];

              case 3:
                fee = _a.sent();
                _a.label = 4;

              case 4:
                return [2
                /*return*/
                , new core_1.StdSignMsg(this.lcd.config.chainID, options.account_number, options.sequence, fee, msgs, memo, options.timeout_height)];
            }
          });
        });
      };
      /**
       * Looks up transactions on the blockchain for the block height. If height is undefined,
       * gets the transactions for the latest block.
       * @param height block height
       */


      TxAPI.prototype.txInfosByHeight = function (height) {
        return __awaiter(this, void 0, void 0, function () {
          var blockInfo, txs, txhashes;

          var _this = this;

          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4
                /*yield*/
                , this.lcd.tendermint.blockInfo(height)];

              case 1:
                blockInfo = _a.sent();
                txs = blockInfo.block.data.txs;

                if (!txs) {
                  return [2
                  /*return*/
                  , []];
                } else {
                  txhashes = txs.map(function (txdata) {
                    return (0, hash_1.hashTxBytes)(txdata);
                  });
                  return [2
                  /*return*/
                  , Promise.all(txhashes.map(function (txhash) {
                    return _this.txInfo(txhash);
                  }))];
                }
            }
          });
        });
      };
      /**
       * Estimates the transaction's fee by simulating it within the node
       * @param sourceAddress address that will pay the bill
       * @param msgs standard messages
       * @param options options for fee estimation
       */


      TxAPI.prototype.estimateFee = function (sourceAddress, msgs, options) {
        return __awaiter(this, void 0, void 0, function () {
          var memo, gas, gasPrices, gasAdjustment, feeDenoms, gasPricesCoins, gasPricesCoinsFiltered, data;
          return __generator(this, function (_a) {
            memo = options === null || options === void 0 ? void 0 : options.memo;
            gas = options === null || options === void 0 ? void 0 : options.gas;
            gasPrices = (options === null || options === void 0 ? void 0 : options.gasPrices) || this.lcd.config.gasPrices;
            gasAdjustment = (options === null || options === void 0 ? void 0 : options.gasAdjustment) || this.lcd.config.gasAdjustment;
            feeDenoms = (options === null || options === void 0 ? void 0 : options.feeDenoms) || ['uluna'];

            if (gasPrices) {
              gasPricesCoins = new core_1.Coins(gasPrices);

              if (feeDenoms) {
                gasPricesCoinsFiltered = gasPricesCoins.filter(function (c) {
                  return feeDenoms.includes(c.denom);
                });

                if (gasPricesCoinsFiltered.toArray().length > 0) {
                  gasPricesCoins = gasPricesCoinsFiltered;
                }
              }
            }

            data = {
              base_req: {
                chain_id: this.lcd.config.chainID,
                memo: memo,
                from: sourceAddress,
                gas: gas || 'auto',
                gas_prices: gasPricesCoins && gasPricesCoins.toData(),
                gas_adjustment: gasAdjustment && gasAdjustment.toString()
              },
              msgs: msgs.map(function (m) {
                return m.toData();
              })
            };
            return [2
            /*return*/
            , this.c.post("/txs/estimate_fee", data).then(function (_a) {
              var fee = _a.result.fee;
              return core_1.StdFee.fromData(fee);
            })];
          });
        });
      };
      /**
       * Encode a transaction to Amino-encoding
       * @param tx transaction to encode
       */


      TxAPI.prototype.encode = function (tx, options) {
        var _a;

        return __awaiter(this, void 0, void 0, function () {
          return __generator(this, function (_b) {
            return [2
            /*return*/
            , this.c.postRaw("/txs/encode", {
              tx: tx.toData().value,
              sequences: (_a = options === null || options === void 0 ? void 0 : options.sequences) === null || _a === void 0 ? void 0 : _a.map(function (s) {
                return s.toFixed();
              }),
              fee_granter: options === null || options === void 0 ? void 0 : options.feeGranter
            }).then(function (d) {
              return d.tx;
            })];
          });
        });
      };
      /**
       * Get the transaction's hash
       * @param tx transaction to hash
       */


      TxAPI.prototype.hash = function (tx) {
        return __awaiter(this, void 0, void 0, function () {
          var amino;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4
                /*yield*/
                , this.encode(tx)];

              case 1:
                amino = _a.sent();
                return [2
                /*return*/
                , (0, hash_1.hashTxBytes)(amino)];
            }
          });
        });
      };

      TxAPI.prototype._broadcast = function (tx, mode, options) {
        var _a;

        return __awaiter(this, void 0, void 0, function () {
          return __generator(this, function (_b) {
            return [2
            /*return*/
            , this.c.postRaw("/txs", {
              tx: tx.toData().value,
              mode: mode,
              sequences: (_a = options === null || options === void 0 ? void 0 : options.sequences) === null || _a === void 0 ? void 0 : _a.map(function (s) {
                return s.toFixed();
              }),
              fee_granter: options === null || options === void 0 ? void 0 : options.feeGranter
            })];
          });
        });
      };
      /**
       * Broadcast the transaction using the "block" mode, waiting for its inclusion in the blockchain.
       * @param tx tranasaction to broadcast
       */


      TxAPI.prototype.broadcast = function (tx, options) {
        return __awaiter(this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            return [2
            /*return*/
            , this._broadcast(tx, Broadcast.BLOCK, options).then(function (d) {
              var blockResult = {
                txhash: d.txhash,
                raw_log: d.raw_log,
                gas_wanted: Number.parseInt(d.gas_wanted),
                gas_used: Number.parseInt(d.gas_used)
              };

              if (d.height) {
                blockResult.height = +d.height;
              }

              if (d.logs) {
                blockResult.logs = d.logs.map(function (l) {
                  return core_2.TxLog.fromData(l);
                });
              }

              if (d.code) {
                blockResult.code = d.code;
              }

              if (d.codespace) {
                blockResult.codespace = d.codespace;
              }

              return blockResult;
            })];
          });
        });
      };
      /**
       * NOTE: This is not a synchronous function and is unconventionally named. This function
       * can be await as it returns a `Promise`.
       *
       * Broadcast the transaction using the "sync" mode, returning after DeliverTx() is performed.
       * @param tx transaction to broadcast
       */


      TxAPI.prototype.broadcastSync = function (tx, options) {
        return __awaiter(this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            return [2
            /*return*/
            , this._broadcast(tx, Broadcast.SYNC, options).then(function (d) {
              var blockResult = {
                height: +d.height,
                txhash: d.txhash,
                raw_log: d.raw_log
              };

              if (d.code) {
                blockResult.code = d.code;
              }

              if (d.codespace) {
                blockResult.codespace = d.codespace;
              }

              return blockResult;
            })];
          });
        });
      };
      /**
       * Broadcast the transaction using the "async" mode, returning after CheckTx() is performed.
       * @param tx transaction to broadcast
       */


      TxAPI.prototype.broadcastAsync = function (tx, options) {
        return __awaiter(this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            return [2
            /*return*/
            , this._broadcast(tx, Broadcast.ASYNC, options).then(function (d) {
              return {
                height: +d.height,
                txhash: d.txhash
              };
            })];
          });
        });
      };
      /**
       * Search for transactions based on event attributes.
       * @param options
       */


      TxAPI.prototype.search = function (options) {
        return __awaiter(this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            return [2
            /*return*/
            , this.c.getRaw("/txs", options).then(function (d) {
              return {
                total_count: Number.parseInt(d.total_count),
                count: Number.parseInt(d.count),
                page_number: Number.parseInt(d.page_number),
                page_total: Number.parseInt(d.page_total),
                limit: Number.parseInt(d.limit),
                txs: d.txs ? d.txs.map(function (txdata) {
                  return core_1.TxInfo.fromData(txdata);
                }) : []
              };
            })];
          });
        });
      };

      return TxAPI;
    }(BaseAPI_1.BaseAPI);

    exports.TxAPI = TxAPI;
  })(TxAPI);

  var WasmAPI$1 = {};

  var __extends$5 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __assign$3 = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign$3 = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return __assign$3.apply(this, arguments);
  };

  var __awaiter$8 = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$5 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(WasmAPI$1, "__esModule", {
    value: true
  });
  WasmAPI$1.WasmAPI = void 0;
  var BaseAPI_1$1 = BaseAPI$1;

  var WasmAPI =
  /** @class */
  function (_super) {
    __extends$5(WasmAPI, _super);

    function WasmAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    WasmAPI.prototype.codeInfo = function (codeID, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$8(this, void 0, void 0, function () {
        return __generator$5(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/wasm/codes/" + codeID, params).then(function (d) {
            return d.result;
          })];
        });
      });
    };

    WasmAPI.prototype.contractInfo = function (contractAddress, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$8(this, void 0, void 0, function () {
        return __generator$5(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/wasm/contracts/" + contractAddress, params).then(function (_a) {
            var d = _a.result;
            return {
              code_id: Number.parseInt(d.code_id),
              address: d.address,
              creator: d.creator,
              admin: d.admin,
              init_msg: d.init_msg
            };
          })];
        });
      });
    };

    WasmAPI.prototype.contractQuery = function (contractAddress, query, params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$8(this, void 0, void 0, function () {
        return __generator$5(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/wasm/contracts/" + contractAddress + "/store", __assign$3(__assign$3({}, params), {
            query_msg: JSON.stringify(query)
          })).then(function (d) {
            return d.result;
          })];
        });
      });
    };

    WasmAPI.prototype.parameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$8(this, void 0, void 0, function () {
        return __generator$5(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/wasm/parameters", params).then(function (_a) {
            var d = _a.result;
            return {
              max_contract_size: Number.parseInt(d.max_contract_size),
              max_contract_gas: Number.parseInt(d.max_contract_gas),
              max_contract_msg_size: Number.parseInt(d.max_contract_msg_size)
            };
          })];
        });
      });
    };

    return WasmAPI;
  }(BaseAPI_1$1.BaseAPI);

  WasmAPI$1.WasmAPI = WasmAPI;

  var MintAPI$1 = {};

  var __extends$4 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter$7 = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$4 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(MintAPI$1, "__esModule", {
    value: true
  });
  MintAPI$1.MintAPI = void 0;
  var core_1 = core;
  var BaseAPI_1 = BaseAPI$1;

  var MintAPI =
  /** @class */
  function (_super) {
    __extends$4(MintAPI, _super);

    function MintAPI() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets the current minting inflation value
     */


    MintAPI.prototype.inflation = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$7(this, void 0, void 0, function () {
        return __generator$4(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/minting/inflation", params).then(function (d) {
            return new core_1.Dec(d.result);
          })];
        });
      });
    };
    /**
     * Gets the current minting annaul provisions value
     */


    MintAPI.prototype.annualProvisions = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$7(this, void 0, void 0, function () {
        return __generator$4(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("minting/annual-provisions", params).then(function (d) {
            return new core_1.Dec(d.result);
          })];
        });
      });
    };
    /**
     * Gets the current minting module's parameters.
     */


    MintAPI.prototype.parameters = function (params) {
      if (params === void 0) {
        params = {};
      }

      return __awaiter$7(this, void 0, void 0, function () {
        return __generator$4(this, function (_a) {
          return [2
          /*return*/
          , this.c.get("/minting/parameters", params).then(function (_a) {
            var d = _a.result;
            return {
              mint_denom: d.mint_denom,
              inflation_rate_change: new core_1.Dec(d.inflation_rate_change),
              inflation_max: new core_1.Dec(d.inflation_max),
              inflation_min: new core_1.Dec(d.inflation_min),
              goal_bonded: new core_1.Dec(d.goal_bonded),
              blocks_per_year: Number.parseInt(d.blocks_per_year)
            };
          })];
        });
      });
    };

    return MintAPI;
  }(BaseAPI_1.BaseAPI);

  MintAPI$1.MintAPI = MintAPI;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(AuthAPI$1, exports);

    __exportStar(BankAPI$1, exports);

    __exportStar(DistributionAPI$1, exports);

    __exportStar(GovAPI$1, exports);

    __exportStar(MarketAPI$1, exports);

    __exportStar(MsgAuthAPI$1, exports);

    __exportStar(OracleAPI$1, exports);

    __exportStar(SlashingAPI$1, exports);

    __exportStar(StakingAPI$1, exports);

    __exportStar(SupplyAPI$1, exports);

    __exportStar(TendermintAPI$1, exports);

    __exportStar(TreasuryAPI$1, exports);

    __exportStar(TxAPI, exports);

    __exportStar(WasmAPI$1, exports);

    __exportStar(MintAPI$1, exports);
  })(api);

  var LCDUtils$1 = {};

  var __awaiter$6 = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$3 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(LCDUtils$1, "__esModule", {
    value: true
  });
  LCDUtils$1.LCDUtils = void 0;
  var Coin_1 = Coin;
  var numeric_1 = numeric;

  var LCDUtils =
  /** @class */
  function () {
    function LCDUtils(lcd) {
      this.lcd = lcd;
    }
    /**
     * Calculates the tax that would be applied for the Coin if sent.
     * Tax = min(taxCap, taxRate * amount)
     * @param coin
     */


    LCDUtils.prototype.calculateTax = function (coin) {
      return __awaiter$6(this, void 0, void 0, function () {
        var rate, cap;
        return __generator$3(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.lcd.treasury.taxRate()];

            case 1:
              rate = _a.sent();
              return [4
              /*yield*/
              , this.lcd.treasury.taxCap(coin.denom)];

            case 2:
              cap = _a.sent();
              return [2
              /*return*/
              , new Coin_1.Coin(coin.denom, numeric_1.Int.ceil(numeric_1.Dec.min(coin.amount.mul(rate), cap.amount)))];
          }
        });
      });
    };
    /**
     * Gets current validators and merges their voting power from the validator set query.
     */


    LCDUtils.prototype.validatorsWithVotingPower = function () {
      return __awaiter$6(this, void 0, void 0, function () {
        var validatorSetResponse, validators, validatorSet, res, _i, validators_1, v, delegateInfo;

        return __generator$3(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.lcd.tendermint.validatorSet()];

            case 1:
              validatorSetResponse = _a.sent();
              return [4
              /*yield*/
              , this.lcd.staking.validators()];

            case 2:
              validators = _a.sent();
              validatorSet = validatorSetResponse.validators.reduce(function (m, o) {
                m[o.pub_key.value] = o;
                return m;
              }, {});
              res = {};

              for (_i = 0, validators_1 = validators; _i < validators_1.length; _i++) {
                v = validators_1[_i];
                delegateInfo = validatorSet[v.consensus_pubkey.value];
                if (delegateInfo === undefined) continue;
                res[v.operator_address] = {
                  validatorInfo: v,
                  votingPower: Number.parseInt(delegateInfo.voting_power),
                  proposerPriority: Number.parseInt(delegateInfo.proposer_priority)
                };
              }

              return [2
              /*return*/
              , res];
          }
        });
      });
    };

    return LCDUtils;
  }();

  LCDUtils$1.LCDUtils = LCDUtils;

  var Wallet$1 = {};

  var __awaiter$5 = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$2 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(Wallet$1, "__esModule", {
    value: true
  });
  Wallet$1.Wallet = void 0;

  var Wallet =
  /** @class */
  function () {
    function Wallet(lcd, key) {
      this.lcd = lcd;
      this.key = key;
    }

    Wallet.prototype.accountNumberAndSequence = function () {
      return this.lcd.auth.accountInfo(this.key.accAddress).then(function (d) {
        return {
          account_number: d.account_number,
          sequence: d.sequence
        };
      });
    };

    Wallet.prototype.accountNumber = function () {
      return this.lcd.auth.accountInfo(this.key.accAddress).then(function (d) {
        return d.account_number;
      });
    };

    Wallet.prototype.sequence = function () {
      return this.lcd.auth.accountInfo(this.key.accAddress).then(function (d) {
        return d.sequence;
      });
    };

    Wallet.prototype.createTx = function (options) {
      return this.lcd.tx.create(this.key.accAddress, options);
    };

    Wallet.prototype.createAndSignTx = function (options) {
      return __awaiter$5(this, void 0, void 0, function () {
        var stdSignMsg;
        return __generator$2(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.createTx(options)];

            case 1:
              stdSignMsg = _a.sent();
              return [2
              /*return*/
              , this.key.signTx(stdSignMsg)];
          }
        });
      });
    };

    return Wallet;
  }();

  Wallet$1.Wallet = Wallet;

  var __assign$2 = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign$2 = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return __assign$2.apply(this, arguments);
  };

  Object.defineProperty(LCDClient$1, "__esModule", {
    value: true
  });
  LCDClient$1.LCDClient = void 0;
  var APIRequester_1 = APIRequester$1;
  var api_1 = api;
  var LCDUtils_1 = LCDUtils$1;
  var Wallet_1 = Wallet$1;
  var DEFAULT_LCD_OPTIONS = {
    gasAdjustment: 1.75
  };
  var DEFAULT_GAS_PRICES_BY_CHAIN_ID = {
    default: {
      uluna: 0.15
    },
    'columbus-5': {
      uluna: 0.015
    },
    'bombay-12': {
      uluna: 0.15
    }
  };
  /**
   * An object repesenting a connection to a terrad node running the Lite Client Daemon (LCD)
   * server, a REST server providing access to a node.
   *
   * ### Example
   *
   * ```ts
   * import { LCDClient, Coin } from 'terra.js';
   *
   * const terra = new LCDClient({
   *    URL: "https://lcd.terra.dev",
   *    chainID: "columbus-3"
   * });
   *
   * terra.market.swapRate(new Coin('uluna', 10000), 'ukrw').then(c => console.log(c.toString()));
   * ```
   */

  var LCDClient =
  /** @class */
  function () {
    /**
     * Creates a new LCD client with the specified configuration.
     *
     * @param config LCD configuration
     */
    function LCDClient(config) {
      this.config = __assign$2(__assign$2(__assign$2({}, DEFAULT_LCD_OPTIONS), {
        gasPrices: DEFAULT_GAS_PRICES_BY_CHAIN_ID[config.chainID] || DEFAULT_GAS_PRICES_BY_CHAIN_ID['default']
      }), config);
      this.apiRequester = new APIRequester_1.APIRequester(this.config.URL); // instantiate APIs

      this.auth = new api_1.AuthAPI(this.apiRequester);
      this.bank = new api_1.BankAPI(this.apiRequester);
      this.distribution = new api_1.DistributionAPI(this.apiRequester);
      this.gov = new api_1.GovAPI(this.apiRequester);
      this.market = new api_1.MarketAPI(this.apiRequester);
      this.mint = new api_1.MintAPI(this.apiRequester);
      this.msgauth = new api_1.MsgAuthAPI(this.apiRequester);
      this.oracle = new api_1.OracleAPI(this.apiRequester);
      this.slashing = new api_1.SlashingAPI(this.apiRequester);
      this.staking = new api_1.StakingAPI(this.apiRequester);
      this.supply = new api_1.SupplyAPI(this.apiRequester);
      this.tendermint = new api_1.TendermintAPI(this.apiRequester);
      this.treasury = new api_1.TreasuryAPI(this.apiRequester);
      this.wasm = new api_1.WasmAPI(this.apiRequester);
      this.tx = new api_1.TxAPI(this);
      this.utils = new LCDUtils_1.LCDUtils(this);
    }
    /** Creates a new wallet with the Key. */


    LCDClient.prototype.wallet = function (key) {
      return new Wallet_1.Wallet(this, key);
    };

    return LCDClient;
  }();

  LCDClient$1.LCDClient = LCDClient;

  var LocalTerra$1 = {};

  var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(LocalTerra$1, "__esModule", {
    value: true
  });
  LocalTerra$1.LocalTerra = void 0;
  var LCDClient_1 = LCDClient$1;
  var MnemonicKey_1 = MnemonicKey;
  var LOCALTERRA_MNEMONICS = {
    validator: 'satisfy adjust timber high purchase tuition stool faith fine install that you unaware feed domain license impose boss human eager hat rent enjoy dawn',
    test1: 'notice oak worry limit wrap speak medal online prefer cluster roof addict wrist behave treat actual wasp year salad speed social layer crew genius',
    test2: 'quality vacuum heart guard buzz spike sight swarm shove special gym robust assume sudden deposit grid alcohol choice devote leader tilt noodle tide penalty',
    test3: 'symbol force gallery make bulk round subway violin worry mixture penalty kingdom boring survey tool fringe patrol sausage hard admit remember broken alien absorb',
    test4: 'bounce success option birth apple portion aunt rural episode solution hockey pencil lend session cause hedgehog slender journey system canvas decorate razor catch empty',
    test5: 'second render cat sing soup reward cluster island bench diet lumber grocery repeat balcony perfect diesel stumble piano distance caught occur example ozone loyal',
    test6: 'spatial forest elevator battle also spoon fun skirt flight initial nasty transfer glory palm drama gossip remove fan joke shove label dune debate quick',
    test7: 'noble width taxi input there patrol clown public spell aunt wish punch moment will misery eight excess arena pen turtle minimum grain vague inmate',
    test8: 'cream sport mango believe inhale text fish rely elegant below earth april wall rug ritual blossom cherry detail length blind digital proof identify ride',
    test9: 'index light average senior silent limit usual local involve delay update rack cause inmate wall render magnet common feature laundry exact casual resource hundred',
    test10: 'prefer forget visit mistake mixture feel eyebrow autumn shop pair address airport diesel street pass vague innocent poem method awful require hurry unhappy shoulder'
  };

  var LocalTerra =
  /** @class */
  function (_super) {
    __extends$3(LocalTerra, _super);

    function LocalTerra() {
      var _this = _super.call(this, {
        URL: 'http://localhost:1317',
        chainID: 'localterra'
      }) || this;

      _this.wallets = {
        validator: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.validator
        })),
        test1: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test1
        })),
        test2: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test2
        })),
        test3: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test3
        })),
        test4: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test4
        })),
        test5: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test5
        })),
        test6: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test6
        })),
        test7: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test7
        })),
        test8: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test8
        })),
        test9: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test9
        })),
        test10: _this.wallet(new MnemonicKey_1.MnemonicKey({
          mnemonic: LOCALTERRA_MNEMONICS.test10
        }))
      };
      return _this;
    }

    return LocalTerra;
  }(LCDClient_1.LCDClient);

  LocalTerra$1.LocalTerra = LocalTerra;

  var WebSocketClient$1 = {};

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$1(o, p);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$1(subClass, superClass);
  }

  var bufferUtil$3 = {exports: {}};

  var constants$3 = {
    BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
    GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
    kStatusCode: Symbol('status-code'),
    kWebSocket: Symbol('websocket'),
    EMPTY_BUFFER: Buffer.alloc(0),
    NOOP: function NOOP() {}
  };

  var bufferutil = {exports: {}};

  var fs = require$$0__default$4["default"];
  var path = require$$1__default["default"];
  var os = require$$2__default["default"]; // Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'

  var runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : commonjsRequire; // eslint-disable-line

  var vars = process.config && process.config.variables || {};
  var abi = process.versions.modules; // TODO: support old node where this is undef

  var runtime = isElectron() ? 'electron' : 'node';
  var arch = os.arch();
  var platform = os.platform();
  var libc = (isAlpine(platform) ? 'musl' : 'glibc');
  var armv = (arch === 'arm64' ? '8' : vars.arm_version) || '';
  var uv = (process.versions.uv || '').split('.')[0];
  var nodeGypBuild = load;

  function load(dir) {
    return runtimeRequire(load.path(dir));
  }

  load.path = function (dir) {
    dir = path.resolve(dir || '.');

    try {
      var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
      if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
    } catch (err) {}

    {
      var release = getFirst(path.join(dir, 'build/Release'), matchBuild);
      if (release) return release;
      var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
      if (debug) return debug;
    }

    var prebuild = resolve(dir);
    if (prebuild) return prebuild;
    var nearby = resolve(path.dirname(process.execPath));
    if (nearby) return nearby;
    var target = ['platform=' + platform, 'arch=' + arch, 'runtime=' + runtime, 'abi=' + abi, 'uv=' + uv, armv ? 'armv=' + armv : '', 'libc=' + libc, 'node=' + process.versions.node, process.versions.electron ? 'electron=' + process.versions.electron : '', typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line
    ].filter(Boolean).join(' ');
    throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n');

    function resolve(dir) {
      // Find matching "prebuilds/<platform>-<arch>" directory
      var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple);
      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple) return; // Find most specific flavor first

      var prebuilds = path.join(dir, 'prebuilds', tuple.name);
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner) return path.join(prebuilds, winner.file);
    }
  };

  function readdirSync(dir) {
    try {
      return fs.readdirSync(dir);
    } catch (err) {
      return [];
    }
  }

  function getFirst(dir, filter) {
    var files = readdirSync(dir).filter(filter);
    return files[0] && path.join(dir, files[0]);
  }

  function matchBuild(name) {
    return /\.node$/.test(name);
  }

  function parseTuple(name) {
    // Example: darwin-x64+arm64
    var arr = name.split('-');
    if (arr.length !== 2) return;
    var platform = arr[0];
    var architectures = arr[1].split('+');
    if (!platform) return;
    if (!architectures.length) return;
    if (!architectures.every(Boolean)) return;
    return {
      name: name,
      platform: platform,
      architectures: architectures
    };
  }

  function matchTuple(platform, arch) {
    return function (tuple) {
      if (tuple == null) return false;
      if (tuple.platform !== platform) return false;
      return tuple.architectures.includes(arch);
    };
  }

  function compareTuples(a, b) {
    // Prefer single-arch prebuilds over multi-arch
    return a.architectures.length - b.architectures.length;
  }

  function parseTags(file) {
    var arr = file.split('.');
    var extension = arr.pop();
    var tags = {
      file: file,
      specificity: 0
    };
    if (extension !== 'node') return;

    for (var i = 0; i < arr.length; i++) {
      var tag = arr[i];

      if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
        tags.runtime = tag;
      } else if (tag === 'napi') {
        tags.napi = true;
      } else if (tag.slice(0, 3) === 'abi') {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === 'uv') {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === 'armv') {
        tags.armv = tag.slice(4);
      } else if (tag === 'glibc' || tag === 'musl') {
        tags.libc = tag;
      } else {
        continue;
      }

      tags.specificity++;
    }

    return tags;
  }

  function matchTags(runtime, abi) {
    return function (tags) {
      if (tags == null) return false;
      if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false;
      if (tags.abi !== abi && !tags.napi) return false;
      if (tags.uv && tags.uv !== uv) return false;
      if (tags.armv && tags.armv !== armv) return false;
      if (tags.libc && tags.libc !== libc) return false;
      return true;
    };
  }

  function runtimeAgnostic(tags) {
    return tags.runtime === 'node' && tags.napi;
  }

  function compareTags(runtime) {
    // Precedence: non-agnostic runtime, abi over napi, then by specificity.
    return function (a, b) {
      if (a.runtime !== b.runtime) {
        return a.runtime === runtime ? -1 : 1;
      } else if (a.abi !== b.abi) {
        return a.abi ? -1 : 1;
      } else if (a.specificity !== b.specificity) {
        return a.specificity > b.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  }

  function isElectron() {
    if (process.versions && process.versions.electron) return true;
    return true;
  }

  function isAlpine(platform) {
    return platform === 'linux' && fs.existsSync('/etc/alpine-release');
  } // Exposed for unit tests
  // TODO: move to lib


  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;

  /**
   * Masks a buffer using the given mask.
   *
   * @param {Buffer} source The buffer to mask
   * @param {Buffer} mask The mask to use
   * @param {Buffer} output The buffer where to store the result
   * @param {Number} offset The offset at which to start writing
   * @param {Number} length The number of bytes to mask.
   * @public
   */


  var mask$2 = function mask(source, _mask, output, offset, length) {
    for (var i = 0; i < length; i++) {
      output[offset + i] = source[i] ^ _mask[i & 3];
    }
  };
  /**
   * Unmasks a buffer using the given mask.
   *
   * @param {Buffer} buffer The buffer to unmask
   * @param {Buffer} mask The mask to use
   * @public
   */


  var unmask$2 = function unmask(buffer, mask) {
    // Required until https://github.com/nodejs/node/issues/9006 is resolved.
    var length = buffer.length;

    for (var i = 0; i < length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  };

  var fallback$1 = {
    mask: mask$2,
    unmask: unmask$2
  };

  try {
    bufferutil.exports = nodeGypBuild(__dirname);
  } catch (e) {
    bufferutil.exports = fallback$1;
  }

  var EMPTY_BUFFER$7 = constants$3.EMPTY_BUFFER;
  /**
   * Merges an array of buffers into a new buffer.
   *
   * @param {Buffer[]} list The array of buffers to concat
   * @param {Number} totalLength The total length of buffers in the list
   * @return {Buffer} The resulting buffer
   * @public
   */

  function concat$3(list, totalLength) {
    if (list.length === 0) return EMPTY_BUFFER$7;
    if (list.length === 1) return list[0];
    var target = Buffer.allocUnsafe(totalLength);
    var offset = 0;

    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }

    if (offset < totalLength) return target.slice(0, offset);
    return target;
  }
  /**
   * Masks a buffer using the given mask.
   *
   * @param {Buffer} source The buffer to mask
   * @param {Buffer} mask The mask to use
   * @param {Buffer} output The buffer where to store the result
   * @param {Number} offset The offset at which to start writing
   * @param {Number} length The number of bytes to mask.
   * @public
   */


  function _mask$1(source, mask, output, offset, length) {
    for (var i = 0; i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  /**
   * Unmasks a buffer using the given mask.
   *
   * @param {Buffer} buffer The buffer to unmask
   * @param {Buffer} mask The mask to use
   * @public
   */


  function _unmask$1(buffer, mask) {
    // Required until https://github.com/nodejs/node/issues/9006 is resolved.
    var length = buffer.length;

    for (var i = 0; i < length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  /**
   * Converts a buffer to an `ArrayBuffer`.
   *
   * @param {Buffer} buf The buffer to convert
   * @return {ArrayBuffer} Converted buffer
   * @public
   */


  function toArrayBuffer$3(buf) {
    if (buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    }

    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
  /**
   * Converts `data` to a `Buffer`.
   *
   * @param {*} data The data to convert
   * @return {Buffer} The buffer
   * @throws {TypeError}
   * @public
   */


  function toBuffer$5(data) {
    toBuffer$5.readOnly = true;
    if (Buffer.isBuffer(data)) return data;
    var buf;

    if (data instanceof ArrayBuffer) {
      buf = Buffer.from(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer$5.readOnly = false;
    }

    return buf;
  }

  try {
    var _bufferUtil$1 = bufferutil.exports;
    var bu$1 = _bufferUtil$1.BufferUtil || _bufferUtil$1;
    bufferUtil$3.exports = {
      concat: concat$3,
      mask: function mask(source, _mask2, output, offset, length) {
        if (length < 48) _mask$1(source, _mask2, output, offset, length);else bu$1.mask(source, _mask2, output, offset, length);
      },
      toArrayBuffer: toArrayBuffer$3,
      toBuffer: toBuffer$5,
      unmask: function unmask(buffer, mask) {
        if (buffer.length < 32) _unmask$1(buffer, mask);else bu$1.unmask(buffer, mask);
      }
    };
  } catch (e)
  /* istanbul ignore next */
  {
    bufferUtil$3.exports = {
      concat: concat$3,
      mask: _mask$1,
      toArrayBuffer: toArrayBuffer$3,
      toBuffer: toBuffer$5,
      unmask: _unmask$1
    };
  }

  var kDone$1 = Symbol('kDone');
  var kRun$1 = Symbol('kRun');
  /**
   * A very simple job queue with adjustable concurrency. Adapted from
   * https://github.com/STRML/async-limiter
   */

  var Limiter$3 = /*#__PURE__*/function () {
    /**
     * Creates a new `Limiter`.
     *
     * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
     *     to run concurrently
     */
    function Limiter(concurrency) {
      var _this = this;

      this[kDone$1] = function () {
        _this.pending--;

        _this[kRun$1]();
      };

      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    /**
     * Adds a job to the queue.
     *
     * @param {Function} job The job to run
     * @public
     */


    var _proto = Limiter.prototype;

    _proto.add = function add(job) {
      this.jobs.push(job);
      this[kRun$1]();
    }
    /**
     * Removes a job from the queue and runs it if possible.
     *
     * @private
     */
    ;

    _proto[kRun$1] = function () {
      if (this.pending === this.concurrency) return;

      if (this.jobs.length) {
        var job = this.jobs.shift();
        this.pending++;
        job(this[kDone$1]);
      }
    };

    return Limiter;
  }();

  var limiter$1 = Limiter$3;

  var zlib$1 = require$$0__default$5["default"];
  var bufferUtil$2 = bufferUtil$3.exports;
  var Limiter$2 = limiter$1;
  var kStatusCode$5 = constants$3.kStatusCode,
      NOOP$3 = constants$3.NOOP;
  var TRAILER$1 = Buffer.from([0x00, 0x00, 0xff, 0xff]);
  var kPerMessageDeflate$1 = Symbol('permessage-deflate');
  var kTotalLength$1 = Symbol('total-length');
  var kCallback$1 = Symbol('callback');
  var kBuffers$1 = Symbol('buffers');
  var kError$1 = Symbol('error'); //
  // We limit zlib concurrency, which prevents severe memory fragmentation
  // as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
  // and https://github.com/websockets/ws/issues/1202
  //
  // Intentionally global; it's the global thread pool that's an issue.
  //

  var zlibLimiter$1;
  /**
   * permessage-deflate implementation.
   */

  var PerMessageDeflate$9 = /*#__PURE__*/function () {
    /**
     * Creates a PerMessageDeflate instance.
     *
     * @param {Object} [options] Configuration options
     * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
     *     disabling of server context takeover
     * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
     *     acknowledge disabling of client context takeover
     * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
     *     use of a custom server window size
     * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
     *     for, or request, a custom client window size
     * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
     *     deflate
     * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
     *     inflate
     * @param {Number} [options.threshold=1024] Size (in bytes) below which
     *     messages should not be compressed
     * @param {Number} [options.concurrencyLimit=10] The number of concurrent
     *     calls to zlib
     * @param {Boolean} [isServer=false] Create the instance in either server or
     *     client mode
     * @param {Number} [maxPayload=0] The maximum allowed message length
     */
    function PerMessageDeflate(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;

      if (!zlibLimiter$1) {
        var concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter$1 = new Limiter$2(concurrency);
      }
    }
    /**
     * @type {String}
     */


    var _proto = PerMessageDeflate.prototype;

    /**
     * Create an extension negotiation offer.
     *
     * @return {Object} Extension parameters
     * @public
     */
    _proto.offer = function offer() {
      var params = {};

      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }

      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }

      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }

      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }

      return params;
    }
    /**
     * Accept an extension negotiation offer/response.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Object} Accepted configuration
     * @public
     */
    ;

    _proto.accept = function accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    /**
     * Releases all resources used by the extension.
     *
     * @public
     */
    ;

    _proto.cleanup = function cleanup() {
      if (this._inflate) {
        this._inflate.close();

        this._inflate = null;
      }

      if (this._deflate) {
        var callback = this._deflate[kCallback$1];

        this._deflate.close();

        this._deflate = null;

        if (callback) {
          callback(new Error('The deflate stream was closed while data was being processed'));
        }
      }
    }
    /**
     *  Accept an extension negotiation offer.
     *
     * @param {Array} offers The extension negotiation offers
     * @return {Object} Accepted configuration
     * @private
     */
    ;

    _proto.acceptAsServer = function acceptAsServer(offers) {
      var opts = this._options;
      var accepted = offers.find(function (params) {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {
          return false;
        }

        return true;
      });

      if (!accepted) {
        throw new Error('None of the extension offers can be accepted');
      }

      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }

      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }

      if (typeof opts.serverMaxWindowBits === 'number') {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }

      if (typeof opts.clientMaxWindowBits === 'number') {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }

      return accepted;
    }
    /**
     * Accept the extension negotiation response.
     *
     * @param {Array} response The extension negotiation response
     * @return {Object} Accepted configuration
     * @private
     */
    ;

    _proto.acceptAsClient = function acceptAsClient(response) {
      var params = response[0];

      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }

      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === 'number') {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }

      return params;
    }
    /**
     * Normalize parameters.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Array} The offers/response with normalized parameters
     * @private
     */
    ;

    _proto.normalizeParams = function normalizeParams(configurations) {
      var _this = this;

      configurations.forEach(function (params) {
        Object.keys(params).forEach(function (key) {
          var value = params[key];

          if (value.length > 1) {
            throw new Error("Parameter \"" + key + "\" must have only a single value");
          }

          value = value[0];

          if (key === 'client_max_window_bits') {
            if (value !== true) {
              var num = +value;

              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError("Invalid value for parameter \"" + key + "\": " + value);
              }

              value = num;
            } else if (!_this._isServer) {
              throw new TypeError("Invalid value for parameter \"" + key + "\": " + value);
            }
          } else if (key === 'server_max_window_bits') {
            var _num = +value;

            if (!Number.isInteger(_num) || _num < 8 || _num > 15) {
              throw new TypeError("Invalid value for parameter \"" + key + "\": " + value);
            }

            value = _num;
          } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {
            if (value !== true) {
              throw new TypeError("Invalid value for parameter \"" + key + "\": " + value);
            }
          } else {
            throw new Error("Unknown parameter \"" + key + "\"");
          }

          params[key] = value;
        });
      });
      return configurations;
    }
    /**
     * Decompress data. Concurrency limited.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */
    ;

    _proto.decompress = function decompress(data, fin, callback) {
      var _this2 = this;

      zlibLimiter$1.add(function (done) {
        _this2._decompress(data, fin, function (err, result) {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Compress data. Concurrency limited.
     *
     * @param {Buffer} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */
    ;

    _proto.compress = function compress(data, fin, callback) {
      var _this3 = this;

      zlibLimiter$1.add(function (done) {
        _this3._compress(data, fin, function (err, result) {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Decompress data.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */
    ;

    _proto._decompress = function _decompress(data, fin, callback) {
      var _this4 = this;

      var endpoint = this._isServer ? 'client' : 'server';

      if (!this._inflate) {
        var key = endpoint + "_max_window_bits";
        var windowBits = typeof this.params[key] !== 'number' ? zlib$1.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib$1.createInflateRaw(_extends$1({}, this._options.zlibInflateOptions, {
          windowBits: windowBits
        }));
        this._inflate[kPerMessageDeflate$1] = this;
        this._inflate[kTotalLength$1] = 0;
        this._inflate[kBuffers$1] = [];

        this._inflate.on('error', inflateOnError$1);

        this._inflate.on('data', inflateOnData$1);
      }

      this._inflate[kCallback$1] = callback;

      this._inflate.write(data);

      if (fin) this._inflate.write(TRAILER$1);

      this._inflate.flush(function () {
        var err = _this4._inflate[kError$1];

        if (err) {
          _this4._inflate.close();

          _this4._inflate = null;
          callback(err);
          return;
        }

        var data = bufferUtil$2.concat(_this4._inflate[kBuffers$1], _this4._inflate[kTotalLength$1]);

        if (_this4._inflate._readableState.endEmitted) {
          _this4._inflate.close();

          _this4._inflate = null;
        } else {
          _this4._inflate[kTotalLength$1] = 0;
          _this4._inflate[kBuffers$1] = [];

          if (fin && _this4.params[endpoint + "_no_context_takeover"]) {
            _this4._inflate.reset();
          }
        }

        callback(null, data);
      });
    }
    /**
     * Compress data.
     *
     * @param {Buffer} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */
    ;

    _proto._compress = function _compress(data, fin, callback) {
      var _this5 = this;

      var endpoint = this._isServer ? 'server' : 'client';

      if (!this._deflate) {
        var key = endpoint + "_max_window_bits";
        var windowBits = typeof this.params[key] !== 'number' ? zlib$1.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib$1.createDeflateRaw(_extends$1({}, this._options.zlibDeflateOptions, {
          windowBits: windowBits
        }));
        this._deflate[kTotalLength$1] = 0;
        this._deflate[kBuffers$1] = []; //
        // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
        // `zlib.DeflateRaw` instance is closed while data is being processed.
        // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
        // time due to an abnormal WebSocket closure.
        //

        this._deflate.on('error', NOOP$3);

        this._deflate.on('data', deflateOnData$1);
      }

      this._deflate[kCallback$1] = callback;

      this._deflate.write(data);

      this._deflate.flush(zlib$1.Z_SYNC_FLUSH, function () {
        if (!_this5._deflate) {
          //
          // The deflate stream was closed while data was being processed.
          //
          return;
        }

        var data = bufferUtil$2.concat(_this5._deflate[kBuffers$1], _this5._deflate[kTotalLength$1]);
        if (fin) data = data.slice(0, data.length - 4); //
        // Ensure that the callback will not be called again in
        // `PerMessageDeflate#cleanup()`.
        //

        _this5._deflate[kCallback$1] = null;
        _this5._deflate[kTotalLength$1] = 0;
        _this5._deflate[kBuffers$1] = [];

        if (fin && _this5.params[endpoint + "_no_context_takeover"]) {
          _this5._deflate.reset();
        }

        callback(null, data);
      });
    };

    _createClass$2(PerMessageDeflate, null, [{
      key: "extensionName",
      get: function get() {
        return 'permessage-deflate';
      }
    }]);

    return PerMessageDeflate;
  }();

  var permessageDeflate$1 = PerMessageDeflate$9;
  /**
   * The listener of the `zlib.DeflateRaw` stream `'data'` event.
   *
   * @param {Buffer} chunk A chunk of data
   * @private
   */

  function deflateOnData$1(chunk) {
    this[kBuffers$1].push(chunk);
    this[kTotalLength$1] += chunk.length;
  }
  /**
   * The listener of the `zlib.InflateRaw` stream `'data'` event.
   *
   * @param {Buffer} chunk A chunk of data
   * @private
   */


  function inflateOnData$1(chunk) {
    this[kTotalLength$1] += chunk.length;

    if (this[kPerMessageDeflate$1]._maxPayload < 1 || this[kTotalLength$1] <= this[kPerMessageDeflate$1]._maxPayload) {
      this[kBuffers$1].push(chunk);
      return;
    }

    this[kError$1] = new RangeError('Max payload size exceeded');
    this[kError$1].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
    this[kError$1][kStatusCode$5] = 1009;
    this.removeListener('data', inflateOnData$1);
    this.reset();
  }
  /**
   * The listener of the `zlib.InflateRaw` stream `'error'` event.
   *
   * @param {Error} err The emitted error
   * @private
   */


  function inflateOnError$1(err) {
    //
    // There is no need to call `Zlib#close()` as the handle is automatically
    // closed when an error is emitted.
    //
    this[kPerMessageDeflate$1]._inflate = null;
    err[kStatusCode$5] = 1007;
    this[kCallback$1](err);
  }

  var validation$1 = {exports: {}};

  var utf8Validate = {exports: {}};

  /**
   * Checks if a given buffer contains only correct UTF-8.
   * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
   * Markus Kuhn.
   *
   * @param {Buffer} buf The buffer to check
   * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
   * @public
   */


  function isValidUTF8$2(buf) {
    var len = buf.length;
    var i = 0;

    while (i < len) {
      if ((buf[i] & 0x80) === 0x00) {
        // 0xxxxxxx
        i++;
      } else if ((buf[i] & 0xe0) === 0xc0) {
        // 110xxxxx 10xxxxxx
        if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // overlong
        ) {
          return false;
        }

        i += 2;
      } else if ((buf[i] & 0xf0) === 0xe0) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // overlong
        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // surrogate (U+D800 - U+DFFF)
        ) {
          return false;
        }

        i += 3;
      } else if ((buf[i] & 0xf8) === 0xf0) {
        // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // overlong
        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF
        ) {
          return false;
        }

        i += 4;
      } else {
        return false;
      }
    }

    return true;
  }

  var fallback = isValidUTF8$2;

  try {
    utf8Validate.exports = nodeGypBuild(__dirname);
  } catch (e) {
    utf8Validate.exports = fallback;
  }

  /**
   * Checks if a status code is allowed in a close frame.
   *
   * @param {Number} code The status code
   * @return {Boolean} `true` if the status code is valid, else `false`
   * @public
   */


  function isValidStatusCode$5(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  /**
   * Checks if a given buffer contains only correct UTF-8.
   * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
   * Markus Kuhn.
   *
   * @param {Buffer} buf The buffer to check
   * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
   * @public
   */


  function _isValidUTF8$1(buf) {
    var len = buf.length;
    var i = 0;

    while (i < len) {
      if ((buf[i] & 0x80) === 0) {
        // 0xxxxxxx
        i++;
      } else if ((buf[i] & 0xe0) === 0xc0) {
        // 110xxxxx 10xxxxxx
        if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong
        ) {
          return false;
        }

        i += 2;
      } else if ((buf[i] & 0xf0) === 0xe0) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong
        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)
        ) {
          return false;
        }

        i += 3;
      } else if ((buf[i] & 0xf8) === 0xf0) {
        // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong
        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF
        ) {
          return false;
        }

        i += 4;
      } else {
        return false;
      }
    }

    return true;
  }

  try {
    var _isValidUTF$1 = utf8Validate.exports;
    /* istanbul ignore if */

    if (typeof _isValidUTF$1 === 'object') {
      _isValidUTF$1 = _isValidUTF$1.Validation.isValidUTF8; // utf-8-validate@<3.0.0
    }

    validation$1.exports = {
      isValidStatusCode: isValidStatusCode$5,
      isValidUTF8: function isValidUTF8(buf) {
        return buf.length < 150 ? _isValidUTF8$1(buf) : _isValidUTF$1(buf);
      }
    };
  } catch (e)
  /* istanbul ignore next */
  {
    validation$1.exports = {
      isValidStatusCode: isValidStatusCode$5,
      isValidUTF8: _isValidUTF8$1
    };
  }

  var Writable$1 = require$$0__default$6["default"].Writable;
  var PerMessageDeflate$8 = permessageDeflate$1;
  var BINARY_TYPES$3 = constants$3.BINARY_TYPES,
      EMPTY_BUFFER$6 = constants$3.EMPTY_BUFFER,
      kStatusCode$4 = constants$3.kStatusCode,
      kWebSocket$5 = constants$3.kWebSocket;
  var concat$2 = bufferUtil$3.exports.concat,
      toArrayBuffer$2 = bufferUtil$3.exports.toArrayBuffer,
      unmask$1 = bufferUtil$3.exports.unmask;
  var isValidStatusCode$4 = validation$1.exports.isValidStatusCode,
      isValidUTF8$1 = validation$1.exports.isValidUTF8;
  var GET_INFO$1 = 0;
  var GET_PAYLOAD_LENGTH_16$1 = 1;
  var GET_PAYLOAD_LENGTH_64$1 = 2;
  var GET_MASK$1 = 3;
  var GET_DATA$1 = 4;
  var INFLATING$1 = 5;
  /**
   * HyBi Receiver implementation.
   *
   * @extends Writable
   */

  var Receiver$3 = /*#__PURE__*/function (_Writable) {
    _inheritsLoose(Receiver, _Writable);

    /**
     * Creates a Receiver instance.
     *
     * @param {String} [binaryType=nodebuffer] The type for binary data
     * @param {Object} [extensions] An object containing the negotiated extensions
     * @param {Boolean} [isServer=false] Specifies whether to operate in client or
     *     server mode
     * @param {Number} [maxPayload=0] The maximum allowed message length
     */
    function Receiver(binaryType, extensions, isServer, maxPayload) {
      var _this;

      _this = _Writable.call(this) || this;
      _this._binaryType = binaryType || BINARY_TYPES$3[0];
      _this[kWebSocket$5] = undefined;
      _this._extensions = extensions || {};
      _this._isServer = !!isServer;
      _this._maxPayload = maxPayload | 0;
      _this._bufferedBytes = 0;
      _this._buffers = [];
      _this._compressed = false;
      _this._payloadLength = 0;
      _this._mask = undefined;
      _this._fragmented = 0;
      _this._masked = false;
      _this._fin = false;
      _this._opcode = 0;
      _this._totalPayloadLength = 0;
      _this._messageLength = 0;
      _this._fragments = [];
      _this._state = GET_INFO$1;
      _this._loop = false;
      return _this;
    }
    /**
     * Implements `Writable.prototype._write()`.
     *
     * @param {Buffer} chunk The chunk of data to write
     * @param {String} encoding The character encoding of `chunk`
     * @param {Function} cb Callback
     * @private
     */


    var _proto = Receiver.prototype;

    _proto._write = function _write(chunk, encoding, cb) {
      if (this._opcode === 0x08 && this._state == GET_INFO$1) return cb();
      this._bufferedBytes += chunk.length;

      this._buffers.push(chunk);

      this.startLoop(cb);
    }
    /**
     * Consumes `n` bytes from the buffered data.
     *
     * @param {Number} n The number of bytes to consume
     * @return {Buffer} The consumed bytes
     * @private
     */
    ;

    _proto.consume = function consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length) return this._buffers.shift();

      if (n < this._buffers[0].length) {
        var buf = this._buffers[0];
        this._buffers[0] = buf.slice(n);
        return buf.slice(0, n);
      }

      var dst = Buffer.allocUnsafe(n);

      do {
        var _buf = this._buffers[0];
        var offset = dst.length - n;

        if (n >= _buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(_buf.buffer, _buf.byteOffset, n), offset);
          this._buffers[0] = _buf.slice(n);
        }

        n -= _buf.length;
      } while (n > 0);

      return dst;
    }
    /**
     * Starts the parsing loop.
     *
     * @param {Function} cb Callback
     * @private
     */
    ;

    _proto.startLoop = function startLoop(cb) {
      var err;
      this._loop = true;

      do {
        switch (this._state) {
          case GET_INFO$1:
            err = this.getInfo();
            break;

          case GET_PAYLOAD_LENGTH_16$1:
            err = this.getPayloadLength16();
            break;

          case GET_PAYLOAD_LENGTH_64$1:
            err = this.getPayloadLength64();
            break;

          case GET_MASK$1:
            this.getMask();
            break;

          case GET_DATA$1:
            err = this.getData(cb);
            break;

          default:
            // `INFLATING`
            this._loop = false;
            return;
        }
      } while (this._loop);

      cb(err);
    }
    /**
     * Reads the first two bytes of a frame.
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.getInfo = function getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      var buf = this.consume(2);

      if ((buf[0] & 0x30) !== 0x00) {
        this._loop = false;
        return error$2(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
      }

      var compressed = (buf[0] & 0x40) === 0x40;

      if (compressed && !this._extensions[PerMessageDeflate$8.extensionName]) {
        this._loop = false;
        return error$2(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
      }

      this._fin = (buf[0] & 0x80) === 0x80;
      this._opcode = buf[0] & 0x0f;
      this._payloadLength = buf[1] & 0x7f;

      if (this._opcode === 0x00) {
        if (compressed) {
          this._loop = false;
          return error$2(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
        }

        if (!this._fragmented) {
          this._loop = false;
          return error$2(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');
        }

        this._opcode = this._fragmented;
      } else if (this._opcode === 0x01 || this._opcode === 0x02) {
        if (this._fragmented) {
          this._loop = false;
          return error$2(RangeError, "invalid opcode " + this._opcode, true, 1002, 'WS_ERR_INVALID_OPCODE');
        }

        this._compressed = compressed;
      } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
        if (!this._fin) {
          this._loop = false;
          return error$2(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');
        }

        if (compressed) {
          this._loop = false;
          return error$2(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
        }

        if (this._payloadLength > 0x7d) {
          this._loop = false;
          return error$2(RangeError, "invalid payload length " + this._payloadLength, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
        }
      } else {
        this._loop = false;
        return error$2(RangeError, "invalid opcode " + this._opcode, true, 1002, 'WS_ERR_INVALID_OPCODE');
      }

      if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
      this._masked = (buf[1] & 0x80) === 0x80;

      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error$2(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');
        }
      } else if (this._masked) {
        this._loop = false;
        return error$2(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');
      }

      if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16$1;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64$1;else return this.haveLength();
    }
    /**
     * Gets extended payload length (7+16).
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.getPayloadLength16 = function getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    /**
     * Gets extended payload length (7+64).
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.getPayloadLength64 = function getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }

      var buf = this.consume(8);
      var num = buf.readUInt32BE(0); //
      // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
      // if payload length is greater than this number.
      //

      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error$2(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
      }

      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    /**
     * Payload length has been read.
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.haveLength = function haveLength() {
      if (this._payloadLength && this._opcode < 0x08) {
        this._totalPayloadLength += this._payloadLength;

        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error$2(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
        }
      }

      if (this._masked) this._state = GET_MASK$1;else this._state = GET_DATA$1;
    }
    /**
     * Reads mask bytes.
     *
     * @private
     */
    ;

    _proto.getMask = function getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }

      this._mask = this.consume(4);
      this._state = GET_DATA$1;
    }
    /**
     * Reads data bytes.
     *
     * @param {Function} cb Callback
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.getData = function getData(cb) {
      var data = EMPTY_BUFFER$6;

      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }

        data = this.consume(this._payloadLength);
        if (this._masked) unmask$1(data, this._mask);
      }

      if (this._opcode > 0x07) return this.controlMessage(data);

      if (this._compressed) {
        this._state = INFLATING$1;
        this.decompress(data, cb);
        return;
      }

      if (data.length) {
        //
        // This message is not compressed so its lenght is the sum of the payload
        // length of all fragments.
        //
        this._messageLength = this._totalPayloadLength;

        this._fragments.push(data);
      }

      return this.dataMessage();
    }
    /**
     * Decompresses data.
     *
     * @param {Buffer} data Compressed data
     * @param {Function} cb Callback
     * @private
     */
    ;

    _proto.decompress = function decompress(data, cb) {
      var _this2 = this;

      var perMessageDeflate = this._extensions[PerMessageDeflate$8.extensionName];
      perMessageDeflate.decompress(data, this._fin, function (err, buf) {
        if (err) return cb(err);

        if (buf.length) {
          _this2._messageLength += buf.length;

          if (_this2._messageLength > _this2._maxPayload && _this2._maxPayload > 0) {
            return cb(error$2(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'));
          }

          _this2._fragments.push(buf);
        }

        var er = _this2.dataMessage();

        if (er) return cb(er);

        _this2.startLoop(cb);
      });
    }
    /**
     * Handles a data message.
     *
     * @return {(Error|undefined)} A possible error
     * @private
     */
    ;

    _proto.dataMessage = function dataMessage() {
      if (this._fin) {
        var messageLength = this._messageLength;
        var fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];

        if (this._opcode === 2) {
          var data;

          if (this._binaryType === 'nodebuffer') {
            data = concat$2(fragments, messageLength);
          } else if (this._binaryType === 'arraybuffer') {
            data = toArrayBuffer$2(concat$2(fragments, messageLength));
          } else {
            data = fragments;
          }

          this.emit('message', data);
        } else {
          var buf = concat$2(fragments, messageLength);

          if (!isValidUTF8$1(buf)) {
            this._loop = false;
            return error$2(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
          }

          this.emit('message', buf.toString());
        }
      }

      this._state = GET_INFO$1;
    }
    /**
     * Handles a control message.
     *
     * @param {Buffer} data Data to handle
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.controlMessage = function controlMessage(data) {
      if (this._opcode === 0x08) {
        this._loop = false;

        if (data.length === 0) {
          this.emit('conclude', 1005, '');
          this.end();
        } else if (data.length === 1) {
          return error$2(RangeError, 'invalid payload length 1', true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
        } else {
          var code = data.readUInt16BE(0);

          if (!isValidStatusCode$4(code)) {
            return error$2(RangeError, "invalid status code " + code, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
          }

          var buf = data.slice(2);

          if (!isValidUTF8$1(buf)) {
            return error$2(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
          }

          this.emit('conclude', code, buf.toString());
          this.end();
        }
      } else if (this._opcode === 0x09) {
        this.emit('ping', data);
      } else {
        this.emit('pong', data);
      }

      this._state = GET_INFO$1;
    };

    return Receiver;
  }(Writable$1);

  var receiver$1 = Receiver$3;
  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */

  function error$2(ErrorCtor, message, prefix, statusCode, errorCode) {
    var err = new ErrorCtor(prefix ? "Invalid WebSocket frame: " + message : message);
    Error.captureStackTrace(err, error$2);
    err.code = errorCode;
    err[kStatusCode$4] = statusCode;
    return err;
  }

  /* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls$" }] */
  var randomFillSync$1 = require$$0__default["default"].randomFillSync;
  var PerMessageDeflate$7 = permessageDeflate$1;
  var EMPTY_BUFFER$5 = constants$3.EMPTY_BUFFER;
  var isValidStatusCode$3 = validation$1.exports.isValidStatusCode;
  var applyMask$1 = bufferUtil$3.exports.mask,
      toBuffer$4 = bufferUtil$3.exports.toBuffer;
  var mask$1 = Buffer.alloc(4);
  /**
   * HyBi Sender implementation.
   */

  var Sender$3 = /*#__PURE__*/function () {
    /**
     * Creates a Sender instance.
     *
     * @param {(net.Socket|tls.Socket)} socket The connection socket
     * @param {Object} [extensions] An object containing the negotiated extensions
     */
    function Sender(socket, extensions) {
      this._extensions = extensions || {};
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    /**
     * Frames a piece of data according to the HyBi WebSocket protocol.
     *
     * @param {Buffer} data The data to frame
     * @param {Object} options Options object
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @return {Buffer[]} The framed data as a list of `Buffer` instances
     * @public
     */


    Sender.frame = function frame(data, options) {
      var merge = options.mask && options.readOnly;
      var offset = options.mask ? 6 : 2;
      var payloadLength = data.length;

      if (data.length >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (data.length > 125) {
        offset += 2;
        payloadLength = 126;
      }

      var target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
      target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
      if (options.rsv1) target[0] |= 0x40;
      target[1] = payloadLength;

      if (payloadLength === 126) {
        target.writeUInt16BE(data.length, 2);
      } else if (payloadLength === 127) {
        target.writeUInt32BE(0, 2);
        target.writeUInt32BE(data.length, 6);
      }

      if (!options.mask) return [target, data];
      randomFillSync$1(mask$1, 0, 4);
      target[1] |= 0x80;
      target[offset - 4] = mask$1[0];
      target[offset - 3] = mask$1[1];
      target[offset - 2] = mask$1[2];
      target[offset - 1] = mask$1[3];

      if (merge) {
        applyMask$1(data, mask$1, target, offset, data.length);
        return [target];
      }

      applyMask$1(data, mask$1, data, 0, data.length);
      return [target, data];
    }
    /**
     * Sends a close message to the other peer.
     *
     * @param {Number} [code] The status code component of the body
     * @param {String} [data] The message component of the body
     * @param {Boolean} [mask=false] Specifies whether or not to mask the message
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    var _proto = Sender.prototype;

    _proto.close = function close(code, data, mask, cb) {
      var buf;

      if (code === undefined) {
        buf = EMPTY_BUFFER$5;
      } else if (typeof code !== 'number' || !isValidStatusCode$3(code)) {
        throw new TypeError('First argument must be a valid error code number');
      } else if (data === undefined || data === '') {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        var length = Buffer.byteLength(data);

        if (length > 123) {
          throw new RangeError('The message must not be greater than 123 bytes');
        }

        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        buf.write(data, 2);
      }

      if (this._deflating) {
        this.enqueue([this.doClose, buf, mask, cb]);
      } else {
        this.doClose(buf, mask, cb);
      }
    }
    /**
     * Frames and sends a close message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.doClose = function doClose(data, mask, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask: mask,
        readOnly: false
      }), cb);
    }
    /**
     * Sends a ping message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    _proto.ping = function ping(data, mask, cb) {
      var buf = toBuffer$4(data);

      if (buf.length > 125) {
        throw new RangeError('The data size must not be greater than 125 bytes');
      }

      if (this._deflating) {
        this.enqueue([this.doPing, buf, mask, toBuffer$4.readOnly, cb]);
      } else {
        this.doPing(buf, mask, toBuffer$4.readOnly, cb);
      }
    }
    /**
     * Frames and sends a ping message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.doPing = function doPing(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask: mask,
        readOnly: readOnly
      }), cb);
    }
    /**
     * Sends a pong message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    _proto.pong = function pong(data, mask, cb) {
      var buf = toBuffer$4(data);

      if (buf.length > 125) {
        throw new RangeError('The data size must not be greater than 125 bytes');
      }

      if (this._deflating) {
        this.enqueue([this.doPong, buf, mask, toBuffer$4.readOnly, cb]);
      } else {
        this.doPong(buf, mask, toBuffer$4.readOnly, cb);
      }
    }
    /**
     * Frames and sends a pong message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.doPong = function doPong(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask: mask,
        readOnly: readOnly
      }), cb);
    }
    /**
     * Sends a data message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Object} options Options object
     * @param {Boolean} [options.compress=false] Specifies whether or not to
     *     compress `data`
     * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
     *     or text
     * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    _proto.send = function send(data, options, cb) {
      var buf = toBuffer$4(data);
      var perMessageDeflate = this._extensions[PerMessageDeflate$7.extensionName];
      var opcode = options.binary ? 2 : 1;
      var rsv1 = options.compress;

      if (this._firstFragment) {
        this._firstFragment = false;

        if (rsv1 && perMessageDeflate) {
          rsv1 = buf.length >= perMessageDeflate._threshold;
        }

        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }

      if (options.fin) this._firstFragment = true;

      if (perMessageDeflate) {
        var opts = {
          fin: options.fin,
          rsv1: rsv1,
          opcode: opcode,
          mask: options.mask,
          readOnly: toBuffer$4.readOnly
        };

        if (this._deflating) {
          this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
        } else {
          this.dispatch(buf, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode: opcode,
          mask: options.mask,
          readOnly: toBuffer$4.readOnly
        }), cb);
      }
    }
    /**
     * Dispatches a data message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [compress=false] Specifies whether or not to compress
     *     `data`
     * @param {Object} options Options object
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.dispatch = function dispatch(data, compress, options, cb) {
      var _this = this;

      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }

      var perMessageDeflate = this._extensions[PerMessageDeflate$7.extensionName];
      this._bufferedBytes += data.length;
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, function (_, buf) {
        if (_this._socket.destroyed) {
          var err = new Error('The socket was closed while data was being compressed');
          if (typeof cb === 'function') cb(err);

          for (var i = 0; i < _this._queue.length; i++) {
            var callback = _this._queue[i][4];
            if (typeof callback === 'function') callback(err);
          }

          return;
        }

        _this._bufferedBytes -= data.length;
        _this._deflating = false;
        options.readOnly = false;

        _this.sendFrame(Sender.frame(buf, options), cb);

        _this.dequeue();
      });
    }
    /**
     * Executes queued send operations.
     *
     * @private
     */
    ;

    _proto.dequeue = function dequeue() {
      while (!this._deflating && this._queue.length) {
        var params = this._queue.shift();

        this._bufferedBytes -= params[1].length;
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    /**
     * Enqueues a send operation.
     *
     * @param {Array} params Send operation parameters.
     * @private
     */
    ;

    _proto.enqueue = function enqueue(params) {
      this._bufferedBytes += params[1].length;

      this._queue.push(params);
    }
    /**
     * Sends a frame.
     *
     * @param {Buffer[]} list The frame to send
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.sendFrame = function sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();

        this._socket.write(list[0]);

        this._socket.write(list[1], cb);

        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    };

    return Sender;
  }();

  var sender$1 = Sender$3;

  /**
   * Class representing an event.
   *
   * @private
   */


  var Event$1 =
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was
   *     dispatched
   */
  function Event(type, target) {
    this.target = target;
    this.type = type;
  };
  /**
   * Class representing a message event.
   *
   * @extends Event
   * @private
   */


  var MessageEvent$1 = /*#__PURE__*/function (_Event) {
    _inheritsLoose(MessageEvent, _Event);

    /**
     * Create a new `MessageEvent`.
     *
     * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
     * @param {WebSocket} target A reference to the target to which the event was
     *     dispatched
     */
    function MessageEvent(data, target) {
      var _this;

      _this = _Event.call(this, 'message', target) || this;
      _this.data = data;
      return _this;
    }

    return MessageEvent;
  }(Event$1);
  /**
   * Class representing a close event.
   *
   * @extends Event
   * @private
   */


  var CloseEvent$1 = /*#__PURE__*/function (_Event2) {
    _inheritsLoose(CloseEvent, _Event2);

    /**
     * Create a new `CloseEvent`.
     *
     * @param {Number} code The status code explaining why the connection is being
     *     closed
     * @param {String} reason A human-readable string explaining why the
     *     connection is closing
     * @param {WebSocket} target A reference to the target to which the event was
     *     dispatched
     */
    function CloseEvent(code, reason, target) {
      var _this2;

      _this2 = _Event2.call(this, 'close', target) || this;
      _this2.wasClean = target._closeFrameReceived && target._closeFrameSent;
      _this2.reason = reason;
      _this2.code = code;
      return _this2;
    }

    return CloseEvent;
  }(Event$1);
  /**
   * Class representing an open event.
   *
   * @extends Event
   * @private
   */


  var OpenEvent$1 = /*#__PURE__*/function (_Event3) {
    _inheritsLoose(OpenEvent, _Event3);

    /**
     * Create a new `OpenEvent`.
     *
     * @param {WebSocket} target A reference to the target to which the event was
     *     dispatched
     */
    function OpenEvent(target) {
      return _Event3.call(this, 'open', target) || this;
    }

    return OpenEvent;
  }(Event$1);
  /**
   * Class representing an error event.
   *
   * @extends Event
   * @private
   */


  var ErrorEvent$1 = /*#__PURE__*/function (_Event4) {
    _inheritsLoose(ErrorEvent, _Event4);

    /**
     * Create a new `ErrorEvent`.
     *
     * @param {Object} error The error that generated this event
     * @param {WebSocket} target A reference to the target to which the event was
     *     dispatched
     */
    function ErrorEvent(error, target) {
      var _this3;

      _this3 = _Event4.call(this, 'error', target) || this;
      _this3.message = error.message;
      _this3.error = error;
      return _this3;
    }

    return ErrorEvent;
  }(Event$1);
  /**
   * This provides methods for emulating the `EventTarget` interface. It's not
   * meant to be used directly.
   *
   * @mixin
   */


  var EventTarget$1 = {
    /**
     * Register an event listener.
     *
     * @param {String} type A string representing the event type to listen for
     * @param {Function} listener The listener to add
     * @param {Object} [options] An options object specifies characteristics about
     *     the event listener
     * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
     *     listener should be invoked at most once after being added. If `true`,
     *     the listener would be automatically removed when invoked.
     * @public
     */
    addEventListener: function addEventListener(type, listener, options) {
      if (typeof listener !== 'function') return;

      function onMessage(data) {
        listener.call(this, new MessageEvent$1(data, this));
      }

      function onClose(code, message) {
        listener.call(this, new CloseEvent$1(code, message, this));
      }

      function onError(error) {
        listener.call(this, new ErrorEvent$1(error, this));
      }

      function onOpen() {
        listener.call(this, new OpenEvent$1(this));
      }

      var method = options && options.once ? 'once' : 'on';

      if (type === 'message') {
        onMessage._listener = listener;
        this[method](type, onMessage);
      } else if (type === 'close') {
        onClose._listener = listener;
        this[method](type, onClose);
      } else if (type === 'error') {
        onError._listener = listener;
        this[method](type, onError);
      } else if (type === 'open') {
        onOpen._listener = listener;
        this[method](type, onOpen);
      } else {
        this[method](type, listener);
      }
    },

    /**
     * Remove an event listener.
     *
     * @param {String} type A string representing the event type to remove
     * @param {Function} listener The listener to remove
     * @public
     */
    removeEventListener: function removeEventListener(type, listener) {
      var listeners = this.listeners(type);

      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i] === listener || listeners[i]._listener === listener) {
          this.removeListener(type, listeners[i]);
        }
      }
    }
  };
  var eventTarget$1 = EventTarget$1;

  // Allowed token characters:
  //
  // '!', '#', '$', '%', '&', ''', '*', '+', '-',
  // '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
  //
  // tokenChars[32] === 0 // ' '
  // tokenChars[33] === 1 // '!'
  // tokenChars[34] === 0 // '"'
  // ...
  //
  // prettier-ignore


  var tokenChars$1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
  ];
  /**
   * Adds an offer to the map of extension offers or a parameter to the map of
   * parameters.
   *
   * @param {Object} dest The map of extension offers or parameters
   * @param {String} name The extension or parameter name
   * @param {(Object|Boolean|String)} elem The extension parameters or the
   *     parameter value
   * @private
   */

  function push$1(dest, name, elem) {
    if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);
  }
  /**
   * Parses the `Sec-WebSocket-Extensions` header into an object.
   *
   * @param {String} header The field value of the header
   * @return {Object} The parsed object
   * @public
   */


  function parse$5(header) {
    var offers = Object.create(null);
    if (header === undefined || header === '') return offers;
    var params = Object.create(null);
    var mustUnescape = false;
    var isEscaping = false;
    var inQuotes = false;
    var extensionName;
    var paramName;
    var start = -1;
    var end = -1;
    var i = 0;

    for (; i < header.length; i++) {
      var code = header.charCodeAt(i);

      if (extensionName === undefined) {
        if (end === -1 && tokenChars$1[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x20
        /* ' ' */
        || code === 0x09
        /* '\t' */
        ) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 0x3b
        /* ';' */
        || code === 0x2c
        /* ',' */
        ) {
          if (start === -1) {
            throw new SyntaxError("Unexpected character at index " + i);
          }

          if (end === -1) end = i;
          var name = header.slice(start, end);

          if (code === 0x2c) {
            push$1(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }

          start = end = -1;
        } else {
          throw new SyntaxError("Unexpected character at index " + i);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars$1[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x20 || code === 0x09) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 0x3b || code === 0x2c) {
          if (start === -1) {
            throw new SyntaxError("Unexpected character at index " + i);
          }

          if (end === -1) end = i;
          push$1(params, header.slice(start, end), true);

          if (code === 0x2c) {
            push$1(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }

          start = end = -1;
        } else if (code === 0x3d
        /* '=' */
        && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError("Unexpected character at index " + i);
        }
      } else {
        //
        // The value of a quoted-string after unescaping must conform to the
        // token ABNF, so only token characters are valid.
        // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
        //
        if (isEscaping) {
          if (tokenChars$1[code] !== 1) {
            throw new SyntaxError("Unexpected character at index " + i);
          }

          if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars$1[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 0x22
          /* '"' */
          && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 0x5c
          /* '\' */
          ) {
            isEscaping = true;
          } else {
            throw new SyntaxError("Unexpected character at index " + i);
          }
        } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
          inQuotes = true;
        } else if (end === -1 && tokenChars$1[code] === 1) {
          if (start === -1) start = i;
        } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
          if (end === -1) end = i;
        } else if (code === 0x3b || code === 0x2c) {
          if (start === -1) {
            throw new SyntaxError("Unexpected character at index " + i);
          }

          if (end === -1) end = i;
          var value = header.slice(start, end);

          if (mustUnescape) {
            value = value.replace(/\\/g, '');
            mustUnescape = false;
          }

          push$1(params, paramName, value);

          if (code === 0x2c) {
            push$1(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }

          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError("Unexpected character at index " + i);
        }
      }
    }

    if (start === -1 || inQuotes) {
      throw new SyntaxError('Unexpected end of input');
    }

    if (end === -1) end = i;
    var token = header.slice(start, end);

    if (extensionName === undefined) {
      push$1(offers, token, params);
    } else {
      if (paramName === undefined) {
        push$1(params, token, true);
      } else if (mustUnescape) {
        push$1(params, paramName, token.replace(/\\/g, ''));
      } else {
        push$1(params, paramName, token);
      }

      push$1(offers, extensionName, params);
    }

    return offers;
  }
  /**
   * Builds the `Sec-WebSocket-Extensions` header field value.
   *
   * @param {Object} extensions The map of extensions and parameters to format
   * @return {String} A string representing the given object
   * @public
   */


  function format$5(extensions) {
    return Object.keys(extensions).map(function (extension) {
      var configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations.map(function (params) {
        return [extension].concat(Object.keys(params).map(function (k) {
          var values = params[k];
          if (!Array.isArray(values)) values = [values];
          return values.map(function (v) {
            return v === true ? k : k + "=" + v;
          }).join('; ');
        })).join('; ');
      }).join(', ');
    }).join(', ');
  }

  var extension$2 = {
    format: format$5,
    parse: parse$5
  };

  var EventEmitter$3 = require$$0__default$3["default"];
  var https$1 = require$$1__default$1["default"];
  var http$3 = require$$2__default$1["default"];
  var net$1 = require$$3__default["default"];
  var tls$1 = require$$4__default["default"];
  var randomBytes$2 = require$$0__default["default"].randomBytes,
      createHash$3 = require$$0__default["default"].createHash;
  require$$0__default$6["default"].Readable;
  var URL$1 = require$$7__default["default"].URL;
  var PerMessageDeflate$6 = permessageDeflate$1;
  var Receiver$2 = receiver$1;
  var Sender$2 = sender$1;
  var BINARY_TYPES$2 = constants$3.BINARY_TYPES,
      EMPTY_BUFFER$4 = constants$3.EMPTY_BUFFER,
      GUID$3 = constants$3.GUID,
      kStatusCode$3 = constants$3.kStatusCode,
      kWebSocket$4 = constants$3.kWebSocket,
      NOOP$2 = constants$3.NOOP;
  var addEventListener$1 = eventTarget$1.addEventListener,
      removeEventListener$1 = eventTarget$1.removeEventListener;
  var format$4 = extension$2.format,
      parse$4 = extension$2.parse;
  var toBuffer$3 = bufferUtil$3.exports.toBuffer;
  var readyStates$1 = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
  var protocolVersions$1 = [8, 13];
  var closeTimeout$1 = 30 * 1000;
  /**
   * Class representing a WebSocket.
   *
   * @extends EventEmitter
   */

  var WebSocket$5 = /*#__PURE__*/function (_EventEmitter) {
    _inheritsLoose(WebSocket, _EventEmitter);

    /**
     * Create a new `WebSocket`.
     *
     * @param {(String|URL)} address The URL to which to connect
     * @param {(String|String[])} [protocols] The subprotocols
     * @param {Object} [options] Connection options
     */
    function WebSocket(address, protocols, options) {
      var _this;

      _this = _EventEmitter.call(this) || this;
      _this._binaryType = BINARY_TYPES$2[0];
      _this._closeCode = 1006;
      _this._closeFrameReceived = false;
      _this._closeFrameSent = false;
      _this._closeMessage = '';
      _this._closeTimer = null;
      _this._extensions = {};
      _this._protocol = '';
      _this._readyState = WebSocket.CONNECTING;
      _this._receiver = null;
      _this._sender = null;
      _this._socket = null;

      if (address !== null) {
        _this._bufferedAmount = 0;
        _this._isServer = false;
        _this._redirects = 0;

        if (Array.isArray(protocols)) {
          protocols = protocols.join(', ');
        } else if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = undefined;
        }

        initAsClient$1(_assertThisInitialized$1(_this), address, protocols, options);
      } else {
        _this._isServer = true;
      }

      return _this;
    }
    /**
     * This deviates from the WHATWG interface since ws doesn't support the
     * required default "blob" type (instead we define a custom "nodebuffer"
     * type).
     *
     * @type {String}
     */


    var _proto = WebSocket.prototype;

    /**
     * Set up the socket and the internal resources.
     *
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Number} [maxPayload=0] The maximum allowed message size
     * @private
     */
    _proto.setSocket = function setSocket(socket, head, maxPayload) {
      var receiver = new Receiver$2(this.binaryType, this._extensions, this._isServer, maxPayload);
      this._sender = new Sender$2(socket, this._extensions);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket$4] = this;
      socket[kWebSocket$4] = this;
      receiver.on('conclude', receiverOnConclude$1);
      receiver.on('drain', receiverOnDrain$1);
      receiver.on('error', receiverOnError$1);
      receiver.on('message', receiverOnMessage$1);
      receiver.on('ping', receiverOnPing$1);
      receiver.on('pong', receiverOnPong$1);
      socket.setTimeout(0);
      socket.setNoDelay();
      if (head.length > 0) socket.unshift(head);
      socket.on('close', socketOnClose$1);
      socket.on('data', socketOnData$1);
      socket.on('end', socketOnEnd$1);
      socket.on('error', socketOnError$3);
      this._readyState = WebSocket.OPEN;
      this.emit('open');
    }
    /**
     * Emit the `'close'` event.
     *
     * @private
     */
    ;

    _proto.emitClose = function emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit('close', this._closeCode, this._closeMessage);
        return;
      }

      if (this._extensions[PerMessageDeflate$6.extensionName]) {
        this._extensions[PerMessageDeflate$6.extensionName].cleanup();
      }

      this._receiver.removeAllListeners();

      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
    }
    /**
     * Start a closing handshake.
     *
     *          +----------+   +-----------+   +----------+
     *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
     *    |     +----------+   +-----------+   +----------+     |
     *          +----------+   +-----------+         |
     * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
     *          +----------+   +-----------+   |
     *    |           |                        |   +---+        |
     *                +------------------------+-->|fin| - - - -
     *    |         +---+                      |   +---+
     *     - - - - -|fin|<---------------------+
     *              +---+
     *
     * @param {Number} [code] Status code explaining why the connection is closing
     * @param {String} [data] A string explaining why the connection is closing
     * @public
     */
    ;

    _proto.close = function close(code, data) {
      var _this2 = this;

      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        var msg = 'WebSocket was closed before the connection was established';
        return abortHandshake$3(this, this._req, msg);
      }

      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }

        return;
      }

      this._readyState = WebSocket.CLOSING;

      this._sender.close(code, data, !this._isServer, function (err) {
        //
        // This error is handled by the `'error'` listener on the socket. We only
        // want to know if the close frame has been sent here.
        //
        if (err) return;
        _this2._closeFrameSent = true;

        if (_this2._closeFrameReceived || _this2._receiver._writableState.errorEmitted) {
          _this2._socket.end();
        }
      }); //
      // Specify a timeout for the closing handshake to complete.
      //


      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout$1);
    }
    /**
     * Send a ping.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the ping is sent
     * @public
     */
    ;

    _proto.ping = function ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose$1(this, data, cb);
        return;
      }

      if (mask === undefined) mask = !this._isServer;

      this._sender.ping(data || EMPTY_BUFFER$4, mask, cb);
    }
    /**
     * Send a pong.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the pong is sent
     * @public
     */
    ;

    _proto.pong = function pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose$1(this, data, cb);
        return;
      }

      if (mask === undefined) mask = !this._isServer;

      this._sender.pong(data || EMPTY_BUFFER$4, mask, cb);
    }
    /**
     * Send a data message.
     *
     * @param {*} data The message to send
     * @param {Object} [options] Options object
     * @param {Boolean} [options.compress] Specifies whether or not to compress
     *     `data`
     * @param {Boolean} [options.binary] Specifies whether `data` is binary or
     *     text
     * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when data is written out
     * @public
     */
    ;

    _proto.send = function send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose$1(this, data, cb);
        return;
      }

      var opts = _extends$1({
        binary: typeof data !== 'string',
        mask: !this._isServer,
        compress: true,
        fin: true
      }, options);

      if (!this._extensions[PerMessageDeflate$6.extensionName]) {
        opts.compress = false;
      }

      this._sender.send(data || EMPTY_BUFFER$4, opts, cb);
    }
    /**
     * Forcibly close the connection.
     *
     * @public
     */
    ;

    _proto.terminate = function terminate() {
      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        var msg = 'WebSocket was closed before the connection was established';
        return abortHandshake$3(this, this._req, msg);
      }

      if (this._socket) {
        this._readyState = WebSocket.CLOSING;

        this._socket.destroy();
      }
    };

    _createClass$2(WebSocket, [{
      key: "binaryType",
      get: function get() {
        return this._binaryType;
      },
      set: function set(type) {
        if (!BINARY_TYPES$2.includes(type)) return;
        this._binaryType = type; //
        // Allow to change `binaryType` on the fly.
        //

        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */

    }, {
      key: "bufferedAmount",
      get: function get() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */

    }, {
      key: "extensions",
      get: function get() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Function}
       */

      /* istanbul ignore next */

    }, {
      key: "onclose",
      get: function get() {
        return undefined;
      }
      /* istanbul ignore next */
      ,
      set: function set(listener) {}
      /**
       * @type {Function}
       */

      /* istanbul ignore next */

    }, {
      key: "onerror",
      get: function get() {
        return undefined;
      }
      /* istanbul ignore next */
      ,
      set: function set(listener) {}
      /**
       * @type {Function}
       */

      /* istanbul ignore next */

    }, {
      key: "onopen",
      get: function get() {
        return undefined;
      }
      /* istanbul ignore next */
      ,
      set: function set(listener) {}
      /**
       * @type {Function}
       */

      /* istanbul ignore next */

    }, {
      key: "onmessage",
      get: function get() {
        return undefined;
      }
      /* istanbul ignore next */
      ,
      set: function set(listener) {}
      /**
       * @type {String}
       */

    }, {
      key: "protocol",
      get: function get() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */

    }, {
      key: "readyState",
      get: function get() {
        return this._readyState;
      }
      /**
       * @type {String}
       */

    }, {
      key: "url",
      get: function get() {
        return this._url;
      }
    }]);

    return WebSocket;
  }(EventEmitter$3);
  /**
   * @constant {Number} CONNECTING
   * @memberof WebSocket
   */


  Object.defineProperty(WebSocket$5, 'CONNECTING', {
    enumerable: true,
    value: readyStates$1.indexOf('CONNECTING')
  });
  /**
   * @constant {Number} CONNECTING
   * @memberof WebSocket.prototype
   */

  Object.defineProperty(WebSocket$5.prototype, 'CONNECTING', {
    enumerable: true,
    value: readyStates$1.indexOf('CONNECTING')
  });
  /**
   * @constant {Number} OPEN
   * @memberof WebSocket
   */

  Object.defineProperty(WebSocket$5, 'OPEN', {
    enumerable: true,
    value: readyStates$1.indexOf('OPEN')
  });
  /**
   * @constant {Number} OPEN
   * @memberof WebSocket.prototype
   */

  Object.defineProperty(WebSocket$5.prototype, 'OPEN', {
    enumerable: true,
    value: readyStates$1.indexOf('OPEN')
  });
  /**
   * @constant {Number} CLOSING
   * @memberof WebSocket
   */

  Object.defineProperty(WebSocket$5, 'CLOSING', {
    enumerable: true,
    value: readyStates$1.indexOf('CLOSING')
  });
  /**
   * @constant {Number} CLOSING
   * @memberof WebSocket.prototype
   */

  Object.defineProperty(WebSocket$5.prototype, 'CLOSING', {
    enumerable: true,
    value: readyStates$1.indexOf('CLOSING')
  });
  /**
   * @constant {Number} CLOSED
   * @memberof WebSocket
   */

  Object.defineProperty(WebSocket$5, 'CLOSED', {
    enumerable: true,
    value: readyStates$1.indexOf('CLOSED')
  });
  /**
   * @constant {Number} CLOSED
   * @memberof WebSocket.prototype
   */

  Object.defineProperty(WebSocket$5.prototype, 'CLOSED', {
    enumerable: true,
    value: readyStates$1.indexOf('CLOSED')
  });
  ['binaryType', 'bufferedAmount', 'extensions', 'protocol', 'readyState', 'url'].forEach(function (property) {
    Object.defineProperty(WebSocket$5.prototype, property, {
      enumerable: true
    });
  }); //
  // Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
  // See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
  //

  ['open', 'error', 'close', 'message'].forEach(function (method) {
    Object.defineProperty(WebSocket$5.prototype, "on" + method, {
      enumerable: true,
      get: function get() {
        var listeners = this.listeners(method);

        for (var i = 0; i < listeners.length; i++) {
          if (listeners[i]._listener) return listeners[i]._listener;
        }

        return undefined;
      },
      set: function set(listener) {
        var listeners = this.listeners(method);

        for (var i = 0; i < listeners.length; i++) {
          //
          // Remove only the listeners added via `addEventListener`.
          //
          if (listeners[i]._listener) this.removeListener(method, listeners[i]);
        }

        this.addEventListener(method, listener);
      }
    });
  });
  WebSocket$5.prototype.addEventListener = addEventListener$1;
  WebSocket$5.prototype.removeEventListener = removeEventListener$1;
  var websocket$1 = WebSocket$5;
  /**
   * Initialize a WebSocket client.
   *
   * @param {WebSocket} websocket The client to initialize
   * @param {(String|URL)} address The URL to which to connect
   * @param {String} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
   *     handshake request
   * @param {Number} [options.protocolVersion=13] Value of the
   *     `Sec-WebSocket-Version` header
   * @param {String} [options.origin] Value of the `Origin` or
   *     `Sec-WebSocket-Origin` header
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.followRedirects=false] Whether or not to follow
   *     redirects
   * @param {Number} [options.maxRedirects=10] The maximum number of redirects
   *     allowed
   * @private
   */

  function initAsClient$1(websocket, address, protocols, options) {
    var opts = _extends$1({
      protocolVersion: protocolVersions$1[1],
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10
    }, options, {
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: undefined,
      host: undefined,
      path: undefined,
      port: undefined
    });

    if (!protocolVersions$1.includes(opts.protocolVersion)) {
      throw new RangeError("Unsupported protocol version: " + opts.protocolVersion + " " + ("(supported versions: " + protocolVersions$1.join(', ') + ")"));
    }

    var parsedUrl;

    if (address instanceof URL$1) {
      parsedUrl = address;
      websocket._url = address.href;
    } else {
      parsedUrl = new URL$1(address);
      websocket._url = address;
    }

    var isUnixSocket = parsedUrl.protocol === 'ws+unix:';

    if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
      throw new Error("Invalid URL: " + websocket.url);
    }

    var isSecure = parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
    var defaultPort = isSecure ? 443 : 80;
    var key = randomBytes$2(16).toString('base64');
    var get = isSecure ? https$1.get : http$3.get;
    var perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect$1 : netConnect$1;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = _extends$1({
      'Sec-WebSocket-Version': opts.protocolVersion,
      'Sec-WebSocket-Key': key,
      Connection: 'Upgrade',
      Upgrade: 'websocket'
    }, opts.headers);
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;

    if (opts.perMessageDeflate) {
      var _format;

      perMessageDeflate = new PerMessageDeflate$6(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers['Sec-WebSocket-Extensions'] = format$4((_format = {}, _format[PerMessageDeflate$6.extensionName] = perMessageDeflate.offer(), _format));
    }

    if (protocols) {
      opts.headers['Sec-WebSocket-Protocol'] = protocols;
    }

    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers['Sec-WebSocket-Origin'] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }

    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = parsedUrl.username + ":" + parsedUrl.password;
    }

    if (isUnixSocket) {
      var parts = opts.path.split(':');
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }

    var req = websocket._req = get(opts);

    if (opts.timeout) {
      req.on('timeout', function () {
        abortHandshake$3(websocket, req, 'Opening handshake has timed out');
      });
    }

    req.on('error', function (err) {
      if (req === null || req.aborted) return;
      req = websocket._req = null;
      websocket._readyState = WebSocket$5.CLOSING;
      websocket.emit('error', err);
      websocket.emitClose();
    });
    req.on('response', function (res) {
      var location = res.headers.location;
      var statusCode = res.statusCode;

      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake$3(websocket, req, 'Maximum redirects exceeded');
          return;
        }

        req.abort();
        var addr = new URL$1(location, address);
        initAsClient$1(websocket, addr, protocols, options);
      } else if (!websocket.emit('unexpected-response', req, res)) {
        abortHandshake$3(websocket, req, "Unexpected server response: " + res.statusCode);
      }
    });
    req.on('upgrade', function (res, socket, head) {
      websocket.emit('upgrade', res); //
      // The user may have closed the connection from a listener of the `upgrade`
      // event.
      //

      if (websocket.readyState !== WebSocket$5.CONNECTING) return;
      req = websocket._req = null;
      var digest = createHash$3('sha1').update(key + GUID$3).digest('base64');

      if (res.headers['sec-websocket-accept'] !== digest) {
        abortHandshake$3(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
        return;
      }

      var serverProt = res.headers['sec-websocket-protocol'];
      var protList = (protocols || '').split(/, */);
      var protError;

      if (!protocols && serverProt) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (protocols && !serverProt) {
        protError = 'Server sent no subprotocol';
      } else if (serverProt && !protList.includes(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }

      if (protError) {
        abortHandshake$3(websocket, socket, protError);
        return;
      }

      if (serverProt) websocket._protocol = serverProt;
      var secWebSocketExtensions = res.headers['sec-websocket-extensions'];

      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          var message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';
          abortHandshake$3(websocket, socket, message);
          return;
        }

        var extensions;

        try {
          extensions = parse$4(secWebSocketExtensions);
        } catch (err) {
          var _message = 'Invalid Sec-WebSocket-Extensions header';
          abortHandshake$3(websocket, socket, _message);
          return;
        }

        var extensionNames = Object.keys(extensions);

        if (extensionNames.length) {
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$6.extensionName) {
            var _message2 = 'Server indicated an extension that was not requested';
            abortHandshake$3(websocket, socket, _message2);
            return;
          }

          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate$6.extensionName]);
          } catch (err) {
            var _message3 = 'Invalid Sec-WebSocket-Extensions header';
            abortHandshake$3(websocket, socket, _message3);
            return;
          }

          websocket._extensions[PerMessageDeflate$6.extensionName] = perMessageDeflate;
        }
      }

      websocket.setSocket(socket, head, opts.maxPayload);
    });
  }
  /**
   * Create a `net.Socket` and initiate a connection.
   *
   * @param {Object} options Connection options
   * @return {net.Socket} The newly created socket used to start the connection
   * @private
   */


  function netConnect$1(options) {
    options.path = options.socketPath;
    return net$1.connect(options);
  }
  /**
   * Create a `tls.TLSSocket` and initiate a connection.
   *
   * @param {Object} options Connection options
   * @return {tls.TLSSocket} The newly created socket used to start the connection
   * @private
   */


  function tlsConnect$1(options) {
    options.path = undefined;

    if (!options.servername && options.servername !== '') {
      options.servername = net$1.isIP(options.host) ? '' : options.host;
    }

    return tls$1.connect(options);
  }
  /**
   * Abort the handshake and emit an error.
   *
   * @param {WebSocket} websocket The WebSocket instance
   * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
   *     abort or the socket to destroy
   * @param {String} message The error message
   * @private
   */


  function abortHandshake$3(websocket, stream, message) {
    websocket._readyState = WebSocket$5.CLOSING;
    var err = new Error(message);
    Error.captureStackTrace(err, abortHandshake$3);

    if (stream.setHeader) {
      stream.abort();

      if (stream.socket && !stream.socket.destroyed) {
        //
        // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
        // called after the request completed. See
        // https://github.com/websockets/ws/issues/1869.
        //
        stream.socket.destroy();
      }

      stream.once('abort', websocket.emitClose.bind(websocket));
      websocket.emit('error', err);
    } else {
      stream.destroy(err);
      stream.once('error', websocket.emit.bind(websocket, 'error'));
      stream.once('close', websocket.emitClose.bind(websocket));
    }
  }
  /**
   * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
   * when the `readyState` attribute is `CLOSING` or `CLOSED`.
   *
   * @param {WebSocket} websocket The WebSocket instance
   * @param {*} [data] The data to send
   * @param {Function} [cb] Callback
   * @private
   */


  function sendAfterClose$1(websocket, data, cb) {
    if (data) {
      var length = toBuffer$3(data).length; //
      // The `_bufferedAmount` property is used only when the peer is a client and
      // the opening handshake fails. Under these circumstances, in fact, the
      // `setSocket()` method is not called, so the `_socket` and `_sender`
      // properties are set to `null`.
      //

      if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;
    }

    if (cb) {
      var err = new Error("WebSocket is not open: readyState " + websocket.readyState + " " + ("(" + readyStates$1[websocket.readyState] + ")"));
      cb(err);
    }
  }
  /**
   * The listener of the `Receiver` `'conclude'` event.
   *
   * @param {Number} code The status code
   * @param {String} reason The reason for closing
   * @private
   */


  function receiverOnConclude$1(code, reason) {
    var websocket = this[kWebSocket$4];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket$4] === undefined) return;

    websocket._socket.removeListener('data', socketOnData$1);

    process.nextTick(resume, websocket._socket);
    if (code === 1005) websocket.close();else websocket.close(code, reason);
  }
  /**
   * The listener of the `Receiver` `'drain'` event.
   *
   * @private
   */


  function receiverOnDrain$1() {
    this[kWebSocket$4]._socket.resume();
  }
  /**
   * The listener of the `Receiver` `'error'` event.
   *
   * @param {(RangeError|Error)} err The emitted error
   * @private
   */


  function receiverOnError$1(err) {
    var websocket = this[kWebSocket$4];

    if (websocket._socket[kWebSocket$4] !== undefined) {
      websocket._socket.removeListener('data', socketOnData$1); //
      // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
      // https://github.com/websockets/ws/issues/1940.
      //


      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode$3]);
    }

    websocket.emit('error', err);
  }
  /**
   * The listener of the `Receiver` `'finish'` event.
   *
   * @private
   */


  function receiverOnFinish$1() {
    this[kWebSocket$4].emitClose();
  }
  /**
   * The listener of the `Receiver` `'message'` event.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
   * @private
   */


  function receiverOnMessage$1(data) {
    this[kWebSocket$4].emit('message', data);
  }
  /**
   * The listener of the `Receiver` `'ping'` event.
   *
   * @param {Buffer} data The data included in the ping frame
   * @private
   */


  function receiverOnPing$1(data) {
    var websocket = this[kWebSocket$4];
    websocket.pong(data, !websocket._isServer, NOOP$2);
    websocket.emit('ping', data);
  }
  /**
   * The listener of the `Receiver` `'pong'` event.
   *
   * @param {Buffer} data The data included in the pong frame
   * @private
   */


  function receiverOnPong$1(data) {
    this[kWebSocket$4].emit('pong', data);
  }
  /**
   * Resume a readable stream
   *
   * @param {Readable} stream The readable stream
   * @private
   */


  function resume(stream) {
    stream.resume();
  }
  /**
   * The listener of the `net.Socket` `'close'` event.
   *
   * @private
   */


  function socketOnClose$1() {
    var websocket = this[kWebSocket$4];
    this.removeListener('close', socketOnClose$1);
    this.removeListener('data', socketOnData$1);
    this.removeListener('end', socketOnEnd$1);
    websocket._readyState = WebSocket$5.CLOSING;
    var chunk; //
    // The close frame might not have been received or the `'end'` event emitted,
    // for example, if the socket was destroyed due to an error. Ensure that the
    // `receiver` stream is closed after writing any remaining buffered data to
    // it. If the readable side of the socket is in flowing mode then there is no
    // buffered data as everything has been already written and `readable.read()`
    // will return `null`. If instead, the socket is paused, any possible buffered
    // data will be read as a single chunk.
    //

    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }

    websocket._receiver.end();

    this[kWebSocket$4] = undefined;
    clearTimeout(websocket._closeTimer);

    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on('error', receiverOnFinish$1);

      websocket._receiver.on('finish', receiverOnFinish$1);
    }
  }
  /**
   * The listener of the `net.Socket` `'data'` event.
   *
   * @param {Buffer} chunk A chunk of data
   * @private
   */


  function socketOnData$1(chunk) {
    if (!this[kWebSocket$4]._receiver.write(chunk)) {
      this.pause();
    }
  }
  /**
   * The listener of the `net.Socket` `'end'` event.
   *
   * @private
   */


  function socketOnEnd$1() {
    var websocket = this[kWebSocket$4];
    websocket._readyState = WebSocket$5.CLOSING;

    websocket._receiver.end();

    this.end();
  }
  /**
   * The listener of the `net.Socket` `'error'` event.
   *
   * @private
   */


  function socketOnError$3() {
    var websocket = this[kWebSocket$4];
    this.removeListener('error', socketOnError$3);
    this.on('error', NOOP$2);

    if (websocket) {
      websocket._readyState = WebSocket$5.CLOSING;
      this.destroy();
    }
  }

  var Duplex$1 = require$$0__default$6["default"].Duplex;
  /**
   * Emits the `'close'` event on a stream.
   *
   * @param {Duplex} stream The stream.
   * @private
   */

  function emitClose$3(stream) {
    stream.emit('close');
  }
  /**
   * The listener of the `'end'` event.
   *
   * @private
   */


  function duplexOnEnd$1() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  /**
   * The listener of the `'error'` event.
   *
   * @param {Error} err The error
   * @private
   */


  function duplexOnError$1(err) {
    this.removeListener('error', duplexOnError$1);
    this.destroy();

    if (this.listenerCount('error') === 0) {
      // Do not suppress the throwing behavior.
      this.emit('error', err);
    }
  }
  /**
   * Wraps a `WebSocket` in a duplex stream.
   *
   * @param {WebSocket} ws The `WebSocket` to wrap
   * @param {Object} [options] The options for the `Duplex` constructor
   * @return {Duplex} The duplex stream
   * @public
   */


  function createWebSocketStream$1(ws, options) {
    var resumeOnReceiverDrain = true;
    var terminateOnDestroy = true;

    function receiverOnDrain() {
      if (resumeOnReceiverDrain) ws._socket.resume();
    }

    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        ws._receiver.removeAllListeners('drain');

        ws._receiver.on('drain', receiverOnDrain);
      });
    } else {
      ws._receiver.removeAllListeners('drain');

      ws._receiver.on('drain', receiverOnDrain);
    }

    var duplex = new Duplex$1(_extends$1({}, options, {
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    }));
    ws.on('message', function message(msg) {
      if (!duplex.push(msg)) {
        resumeOnReceiverDrain = false;

        ws._socket.pause();
      }
    });
    ws.once('error', function error(err) {
      if (duplex.destroyed) return; // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
      //
      // - If the `'error'` event is emitted before the `'open'` event, then
      //   `ws.terminate()` is a noop as no socket is assigned.
      // - Otherwise, the error is re-emitted by the listener of the `'error'`
      //   event of the `Receiver` object. The listener already closes the
      //   connection by calling `ws.close()`. This allows a close frame to be
      //   sent to the other peer. If `ws.terminate()` is called right after this,
      //   then the close frame might not be sent.

      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once('close', function close() {
      if (duplex.destroyed) return;
      duplex.push(null);
    });

    duplex._destroy = function (err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose$3, duplex);
        return;
      }

      var called = false;
      ws.once('error', function error(err) {
        called = true;
        callback(err);
      });
      ws.once('close', function close() {
        if (!called) callback(err);
        process.nextTick(emitClose$3, duplex);
      });
      if (terminateOnDestroy) ws.terminate();
    };

    duplex._final = function (callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once('open', function open() {
          duplex._final(callback);
        });
        return;
      } // If the value of the `_socket` property is `null` it means that `ws` is a
      // client websocket and the handshake failed. In fact, when this happens, a
      // socket is never assigned to the websocket. Wait for the `'error'` event
      // that will be emitted by the websocket.


      if (ws._socket === null) return;

      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted) duplex.destroy();
      } else {
        ws._socket.once('finish', function finish() {
          // `duplex` is not destroyed here because the `'end'` event will be
          // emitted on `duplex` after this `'finish'` event. The EOF signaling
          // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
          callback();
        });

        ws.close();
      }
    };

    duplex._read = function () {
      if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
        resumeOnReceiverDrain = true;
        if (!ws._receiver._writableState.needDrain) ws._socket.resume();
      }
    };

    duplex._write = function (chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once('open', function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }

      ws.send(chunk, callback);
    };

    duplex.on('end', duplexOnEnd$1);
    duplex.on('error', duplexOnError$1);
    return duplex;
  }

  var stream$1 = createWebSocketStream$1;

  function _createForOfIteratorHelperLoose$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

  function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var EventEmitter$2 = require$$0__default$3["default"];
  var http$2 = require$$2__default$1["default"];
  var createHash$2 = require$$0__default["default"].createHash;
  var PerMessageDeflate$5 = permessageDeflate$1;
  var WebSocket$4 = websocket$1;
  var format$3 = extension$2.format,
      parse$3 = extension$2.parse;
  var GUID$2 = constants$3.GUID,
      kWebSocket$3 = constants$3.kWebSocket;
  var keyRegex$1 = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING$1 = 0;
  var CLOSING$1 = 1;
  var CLOSED$1 = 2;
  /**
   * Class representing a WebSocket server.
   *
   * @extends EventEmitter
   */

  var WebSocketServer$1 = /*#__PURE__*/function (_EventEmitter) {
    _inheritsLoose(WebSocketServer, _EventEmitter);

    /**
     * Create a `WebSocketServer` instance.
     *
     * @param {Object} options Configuration options
     * @param {Number} [options.backlog=511] The maximum length of the queue of
     *     pending connections
     * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
     *     track clients
     * @param {Function} [options.handleProtocols] A hook to handle protocols
     * @param {String} [options.host] The hostname where to bind the server
     * @param {Number} [options.maxPayload=104857600] The maximum allowed message
     *     size
     * @param {Boolean} [options.noServer=false] Enable no server mode
     * @param {String} [options.path] Accept only connections matching this path
     * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
     *     permessage-deflate
     * @param {Number} [options.port] The port where to bind the server
     * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
     *     server to use
     * @param {Function} [options.verifyClient] A hook to reject connections
     * @param {Function} [callback] A listener for the `listening` event
     */
    function WebSocketServer(options, callback) {
      var _this;

      _this = _EventEmitter.call(this) || this;
      options = _extends$1({
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        // use default (511 as implemented in net.js)
        server: null,
        host: null,
        path: null,
        port: null
      }, options);

      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + 'must be specified');
      }

      if (options.port != null) {
        _this._server = http$2.createServer(function (req, res) {
          var body = http$2.STATUS_CODES[426];
          res.writeHead(426, {
            'Content-Length': body.length,
            'Content-Type': 'text/plain'
          });
          res.end(body);
        });

        _this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        _this._server = options.server;
      }

      if (_this._server) {
        var emitConnection = _this.emit.bind(_assertThisInitialized$1(_this), 'connection');

        _this._removeListeners = addListeners$1(_this._server, {
          listening: _this.emit.bind(_assertThisInitialized$1(_this), 'listening'),
          error: _this.emit.bind(_assertThisInitialized$1(_this), 'error'),
          upgrade: function upgrade(req, socket, head) {
            _this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }

      if (options.perMessageDeflate === true) options.perMessageDeflate = {};
      if (options.clientTracking) _this.clients = new Set();
      _this.options = options;
      _this._state = RUNNING$1;
      return _this;
    }
    /**
     * Returns the bound address, the address family name, and port of the server
     * as reported by the operating system if listening on an IP socket.
     * If the server is listening on a pipe or UNIX domain socket, the name is
     * returned as a string.
     *
     * @return {(Object|String|null)} The address of the server
     * @public
     */


    var _proto = WebSocketServer.prototype;

    _proto.address = function address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }

      if (!this._server) return null;
      return this._server.address();
    }
    /**
     * Close the server.
     *
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    _proto.close = function close(cb) {
      if (cb) this.once('close', cb);

      if (this._state === CLOSED$1) {
        process.nextTick(emitClose$2, this);
        return;
      }

      if (this._state === CLOSING$1) return;
      this._state = CLOSING$1; //
      // Terminate all associated clients.
      //

      if (this.clients) {
        for (var _iterator = _createForOfIteratorHelperLoose$2(this.clients), _step; !(_step = _iterator()).done;) {
          var client = _step.value;
          client.terminate();
        }
      }

      var server = this._server;

      if (server) {
        this._removeListeners();

        this._removeListeners = this._server = null; //
        // Close the http server if it was internally created.
        //

        if (this.options.port != null) {
          server.close(emitClose$2.bind(undefined, this));
          return;
        }
      }

      process.nextTick(emitClose$2, this);
    }
    /**
     * See if a given request should be handled by this server instance.
     *
     * @param {http.IncomingMessage} req Request object to inspect
     * @return {Boolean} `true` if the request is valid, else `false`
     * @public
     */
    ;

    _proto.shouldHandle = function shouldHandle(req) {
      if (this.options.path) {
        var index = req.url.indexOf('?');
        var pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path) return false;
      }

      return true;
    }
    /**
     * Handle a HTTP Upgrade request.
     *
     * @param {http.IncomingMessage} req The request object
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @public
     */
    ;

    _proto.handleUpgrade = function handleUpgrade(req, socket, head, cb) {
      var _this2 = this;

      socket.on('error', socketOnError$2);
      var key = req.headers['sec-websocket-key'] !== undefined ? req.headers['sec-websocket-key'].trim() : false;
      var version = +req.headers['sec-websocket-version'];
      var extensions = {};

      if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !key || !keyRegex$1.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
        return abortHandshake$2(socket, 400);
      }

      if (this.options.perMessageDeflate) {
        var perMessageDeflate = new PerMessageDeflate$5(this.options.perMessageDeflate, true, this.options.maxPayload);

        try {
          var offers = parse$3(req.headers['sec-websocket-extensions']);

          if (offers[PerMessageDeflate$5.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate$5.extensionName]);
            extensions[PerMessageDeflate$5.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          return abortHandshake$2(socket, 400);
        }
      } //
      // Optionally call external client verification handler.
      //


      if (this.options.verifyClient) {
        var info = {
          origin: req.headers["" + (version === 8 ? 'sec-websocket-origin' : 'origin')],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req: req
        };

        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, function (verified, code, message, headers) {
            if (!verified) {
              return abortHandshake$2(socket, code || 401, message, headers);
            }

            _this2.completeUpgrade(key, extensions, req, socket, head, cb);
          });
          return;
        }

        if (!this.options.verifyClient(info)) return abortHandshake$2(socket, 401);
      }

      this.completeUpgrade(key, extensions, req, socket, head, cb);
    }
    /**
     * Upgrade the connection to WebSocket.
     *
     * @param {String} key The value of the `Sec-WebSocket-Key` header
     * @param {Object} extensions The accepted extensions
     * @param {http.IncomingMessage} req The request object
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @throws {Error} If called more than once with the same socket
     * @private
     */
    ;

    _proto.completeUpgrade = function completeUpgrade(key, extensions, req, socket, head, cb) {
      var _this3 = this;

      //
      // Destroy the socket if the client has already sent a FIN packet.
      //
      if (!socket.readable || !socket.writable) return socket.destroy();

      if (socket[kWebSocket$3]) {
        throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');
      }

      if (this._state > RUNNING$1) return abortHandshake$2(socket, 503);
      var digest = createHash$2('sha1').update(key + GUID$2).digest('base64');
      var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', "Sec-WebSocket-Accept: " + digest];
      var ws = new WebSocket$4(null);
      var protocol = req.headers['sec-websocket-protocol'];

      if (protocol) {
        protocol = protocol.split(',').map(trim$1); //
        // Optionally call external protocol selection handler.
        //

        if (this.options.handleProtocols) {
          protocol = this.options.handleProtocols(protocol, req);
        } else {
          protocol = protocol[0];
        }

        if (protocol) {
          headers.push("Sec-WebSocket-Protocol: " + protocol);
          ws._protocol = protocol;
        }
      }

      if (extensions[PerMessageDeflate$5.extensionName]) {
        var _format;

        var params = extensions[PerMessageDeflate$5.extensionName].params;
        var value = format$3((_format = {}, _format[PerMessageDeflate$5.extensionName] = [params], _format));
        headers.push("Sec-WebSocket-Extensions: " + value);
        ws._extensions = extensions;
      } //
      // Allow external modification/inspection of handshake headers.
      //


      this.emit('headers', headers, req);
      socket.write(headers.concat('\r\n').join('\r\n'));
      socket.removeListener('error', socketOnError$2);
      ws.setSocket(socket, head, this.options.maxPayload);

      if (this.clients) {
        this.clients.add(ws);
        ws.on('close', function () {
          return _this3.clients.delete(ws);
        });
      }

      cb(ws, req);
    };

    return WebSocketServer;
  }(EventEmitter$2);

  var websocketServer$1 = WebSocketServer$1;
  /**
   * Add event listeners on an `EventEmitter` using a map of <event, listener>
   * pairs.
   *
   * @param {EventEmitter} server The event emitter
   * @param {Object.<String, Function>} map The listeners to add
   * @return {Function} A function that will remove the added listeners when
   *     called
   * @private
   */

  function addListeners$1(server, map) {
    for (var _i = 0, _Object$keys = Object.keys(map); _i < _Object$keys.length; _i++) {
      var event = _Object$keys[_i];
      server.on(event, map[event]);
    }

    return function removeListeners() {
      for (var _i2 = 0, _Object$keys2 = Object.keys(map); _i2 < _Object$keys2.length; _i2++) {
        var _event = _Object$keys2[_i2];
        server.removeListener(_event, map[_event]);
      }
    };
  }
  /**
   * Emit a `'close'` event on an `EventEmitter`.
   *
   * @param {EventEmitter} server The event emitter
   * @private
   */


  function emitClose$2(server) {
    server._state = CLOSED$1;
    server.emit('close');
  }
  /**
   * Handle premature socket errors.
   *
   * @private
   */


  function socketOnError$2() {
    this.destroy();
  }
  /**
   * Close the connection when preconditions are not fulfilled.
   *
   * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
   * @param {Number} code The HTTP response status code
   * @param {String} [message] The HTTP response body
   * @param {Object} [headers] Additional HTTP response headers
   * @private
   */


  function abortHandshake$2(socket, code, message, headers) {
    if (socket.writable) {
      message = message || http$2.STATUS_CODES[code];
      headers = _extends$1({
        Connection: 'close',
        'Content-Type': 'text/html',
        'Content-Length': Buffer.byteLength(message)
      }, headers);
      socket.write("HTTP/1.1 " + code + " " + http$2.STATUS_CODES[code] + "\r\n" + Object.keys(headers).map(function (h) {
        return h + ": " + headers[h];
      }).join('\r\n') + '\r\n\r\n' + message);
    }

    socket.removeListener('error', socketOnError$2);
    socket.destroy();
  }
  /**
   * Remove whitespace characters from both ends of a string.
   *
   * @param {String} str The string
   * @return {String} A new string representing `str` stripped of whitespace
   *     characters from both its beginning and end
   * @private
   */


  function trim$1(str) {
    return str.trim();
  }

  var WebSocket$3 = websocket$1;
  WebSocket$3.createWebSocketStream = stream$1;
  WebSocket$3.Server = websocketServer$1;
  WebSocket$3.Receiver = receiver$1;
  WebSocket$3.Sender = sender$1;
  var ws$1 = WebSocket$3;

  var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __assign$1 = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign$1 = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return __assign$1.apply(this, arguments);
  };

  var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(WebSocketClient$1, "__esModule", {
    value: true
  });
  WebSocketClient$1.WebSocketClient = void 0;
  var events_1$1 = require$$0__default$3["default"];

  var ws_1 = __importDefault$5(ws$1);

  var hash_1 = hash;

  var escapeSingleQuotes = function escapeSingleQuotes(str) {
    return str.replace(/'/g, "\\'");
  };

  function makeQueryParams(query) {
    var queryBuilder = [];

    for (var _i = 0, _a = Object.keys(query); _i < _a.length; _i++) {
      var key = _a[_i];
      var queryItem = void 0;
      var value = query[key]; // if value is scalar

      if (!Array.isArray(value)) {
        switch (typeof value) {
          case 'number':
            queryItem = key + "=" + value;
            break;

          case 'string':
            queryItem = key + "='" + escapeSingleQuotes(value) + "'";
            break;

          default:
            // Date
            queryItem = key + "=" + value.toISOString();
        }
      } else {
        switch (value[0]) {
          case '>':
          case '<':
          case '<=':
          case '>=':
            if (typeof value[1] !== 'number') {
              queryItem = "" + key + value[0] + value[1].toISOString();
            } else {
              queryItem = "" + key + value[0] + value[1];
            }

            break;

          case 'CONTAINS':
            queryItem = key + " CONTAINS '" + escapeSingleQuotes(value[1]) + "'";
            break;

          case 'EXISTS':
            queryItem = key + " EXISTS";
            break;
        }
      }

      queryBuilder.push(queryItem);
    }

    return queryBuilder.join(' AND ');
  }
  /**
   * An object repesenting a connection to a Terra node's WebSocket RPC endpoint.
   * This allows for subscribing to Tendermint events through WebSocket.
   *
   * ### Events
   * **error** emitted when error raises
   * **connect** emitted after connection establishment
   * **reconnect** emitted upon every attempt of reconnection
   * **destroyed** emitted when socket has been destroyed
   *
   * ### Example
   *
   * ```ts
   * import { WebSocketClient } from '@terra-money/terra.js';
   *
   * const wsclient = new WebSocketClient("ws://localhost:26657/websocket");
   *
   * wsclient.subscribe('NewBlock', {}, (data) => {
   *    console.log(data.value);
   *
   *    // close after receiving one block.
   *    wsclient.destroy();
   * })
   *
   * wsclient.subscribe(
   * 'Tx',
   *  {
   *    'message.action': 'send',
   *    'message.sender': ['CONTAINS', 'terra1...'],
   *  },
   *  (data) => {
   *    console.log(data.value);
   *
   *   // close after receiving one send Tx
   *   wsclient.destroy();
   * });
   *
   * ```
   */


  var WebSocketClient =
  /** @class */
  function (_super) {
    __extends$2(WebSocketClient, _super);
    /**
     * WebSocketClient constructor
     * @param URL The WebSocket endpoint URL on the Tendermint RPC server.
     *            Ex: ws://localhost:26657/websocket
     * @param reconnectCount 0 for not to attempt reconnect, -1 for infinite, > 0 for number of times to attempt
     * @param reconnectInterval retry interval in milliseconds
     */


    function WebSocketClient(URL, reconnectCount, reconnectInterval) {
      if (reconnectCount === void 0) {
        reconnectCount = 0;
      }

      if (reconnectInterval === void 0) {
        reconnectInterval = 1000;
      }

      var _this = _super.call(this) || this;

      _this.URL = URL;
      _this.reconnectCount = reconnectCount;
      _this.reconnectInterval = reconnectInterval;
      _this._reconnectCount = _this.reconnectCount;
      _this.isConnected = false;
      _this.shouldAttemptReconnect = !!_this.reconnectInterval;
      return _this;
    }
    /**
     * Destroys class as well as socket
     */


    WebSocketClient.prototype.destroy = function () {
      this.shouldAttemptReconnect = false;
      this.reconnectTimeoutId && clearTimeout(this.reconnectTimeoutId);
      this.socket && this.socket.close();
    };

    WebSocketClient.prototype.start = function () {
      this.socket = new ws_1.default(this.URL);
      this.socket.onopen = this.onOpen.bind(this);
      this.socket.onmessage = this.onMessage.bind(this);
      this.socket.onclose = this.onClose.bind(this);

      this.socket.onerror = function () {
        return undefined;
      };
    };

    WebSocketClient.prototype.onOpen = function () {
      this.isConnected = true;
      this.emit('connect'); // reset reconnectCount after connection establishment

      this._reconnectCount = this.reconnectCount;
      this.socket.send(JSON.stringify({
        jsonrpc: '2.0',
        method: 'subscribe',
        params: [this.queryParams],
        id: 1
      }));
    };

    WebSocketClient.prototype.onMessage = function (message) {
      try {
        var parsedData = JSON.parse(message.data.toString());

        if (this.callback && parsedData.result && parsedData.result.query === this.queryParams) {
          // this.emit('message', parsedData.result.data);
          this.callback(parsedData.result.data);
        }
      } catch (err) {
        this.emit('error', err);
      }
    };

    WebSocketClient.prototype.onClose = function () {
      var _this = this;

      this.isConnected = false;

      if (this.shouldAttemptReconnect && (this._reconnectCount > 0 || this._reconnectCount === -1)) {
        if (this._reconnectCount !== -1) {
          this._reconnectCount--;
        }

        this.reconnectTimeoutId && clearTimeout(this.reconnectTimeoutId);
        this.reconnectTimeoutId = setTimeout(function () {
          _this.emit('reconnect');

          _this.start();
        }, this.reconnectInterval);
      } else {
        this.emit('destroyed');
      }
    };

    WebSocketClient.prototype.subscribe = function (event, query, callback) {
      this.queryParams = makeQueryParams(__assign$1({
        'tm.event': event
      }, query));
      this.callback = callback;
    };

    WebSocketClient.prototype.subscribeTx = function (query, callback) {
      var newCallback = function newCallback(d) {
        d.value.TxResult.txhash = (0, hash_1.hashTxBytes)(d.value.TxResult.tx);
        return callback(d);
      };

      this.subscribe('Tx', query, newCallback);
    };

    return WebSocketClient;
  }(events_1$1.EventEmitter);

  WebSocketClient$1.WebSocketClient = WebSocketClient;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    }); // LCDClient

    __exportStar(LCDClient$1, exports);

    __exportStar(Wallet$1, exports);

    __exportStar(api, exports); // LocalTerra (LCDClient)


    __exportStar(LocalTerra$1, exports); // WebSocketClient


    __exportStar(WebSocketClient$1, exports);
  })(client);

  var extension$1 = {};

  var PostMessageStream$1 = {};

  var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(PostMessageStream$1, "__esModule", {
    value: true
  });
  var readable_stream_1 = readableBrowser.exports;

  var noop$1 = function noop() {
    return undefined;
  };

  var PostMessageStream =
  /** @class */
  function (_super) {
    __extends$1(PostMessageStream, _super);

    function PostMessageStream(_a) {
      var name = _a.name,
          target = _a.target,
          targetWindow = _a.targetWindow;

      var _this = _super.call(this, {
        objectMode: true
      }) || this;

      _this._name = name;
      _this._target = target;
      _this._targetWindow = targetWindow || window;
      _this._origin = targetWindow ? '*' : location.origin; // initialization flags

      _this._init = false;
      _this._haveSyn = false;
      _this._onMessage = _this._onMessage.bind(_this);
      window.addEventListener('message', _this._onMessage, false); // send syncorization message

      _this._write('SYN', null, noop$1);

      _this.cork();

      return _this;
    }

    PostMessageStream.prototype._destroy = function () {
      // console.log('PostMessageStream: destroy');
      window.removeEventListener('message', this._onMessage, false);
    };

    PostMessageStream.prototype._onMessage = function (event) {
      var msg = event.data; // validate message

      if (this._origin !== '*' && event.origin !== this._origin) return;
      if (event.source !== this._targetWindow) return;
      if (typeof msg !== 'object') return;
      if (msg.target !== this._name) return;
      if (!msg.data) return;

      if (!this._init) {
        if (msg.data === 'SYN') {
          this._haveSyn = true;

          this._write('ACK', null, noop$1);
        } else if (msg.data === 'ACK') {
          this._init = true;

          if (!this._haveSyn) {
            this._write('ACK', null, noop$1);
          }

          this.uncork();
        }
      } else {
        // forward message
        try {
          this.push(msg.data);
        } catch (err) {
          this.emit('error', err);
        }
      }
    };

    PostMessageStream.prototype._read = function () {
      return undefined;
    };

    PostMessageStream.prototype._write = function (data, _encoding, cb) {
      var message = {
        target: this._target,
        data: data
      };

      this._targetWindow.postMessage(message, this._origin);

      cb(null);
    };

    return PostMessageStream;
  }(readable_stream_1.Duplex);

  PostMessageStream$1.default = PostMessageStream;

  var __assign = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return __assign.apply(this, arguments);
  };

  var __awaiter$4 = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator$1 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(extension$1, "__esModule", {
    value: true
  });
  extension$1.Extension = void 0;

  var PostMessageStream_1 = __importDefault$4(PostMessageStream$1);
  /**
   * Extension class is for communicating between page and extension
   */


  var Extension =
  /** @class */
  function () {
    /**
     * Using singleton pattern, hence every instanciation will return same value
     */
    function Extension() {
      if (Extension.instance) {
        return Extension.instance;
      }

      Extension.instance = this;
      this.inpageStream = new PostMessageStream_1.default({
        name: 'station:inpage',
        target: 'station:content'
      });
    }

    Extension.prototype.destroy = function () {
      this.inpageStream && this.inpageStream.destroy();
    };

    Extension.prototype.generateId = function () {
      return Date.now();
    };

    Object.defineProperty(Extension.prototype, "isAvailable", {
      /**
       * Indicates the Station Extension is installed and availble (requires extension v1.1 or later)
       */
      get: function get() {
        return !!window.isTerraExtensionAvailable;
      },
      enumerable: false,
      configurable: true
    });
    /**
     * low level function for sending message to extension.
     * Do not use this function unless you know what you are doing.
     */

    Extension.prototype.send = function (type, data) {
      var id = this.generateId();
      this.inpageStream.write(__assign(__assign({}, data), {
        id: id,
        type: type
      }));
      return id;
    };

    Extension.prototype.on = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      this.inpageStream.on('data', function (data) {
        if (typeof args[0] === 'string') {
          data.name === args[0] && args[1](data.payload, data.name);
        } else {
          args[0](data.payload, data.name);
        }
      });
    };

    Extension.prototype.once = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      this.inpageStream.once('data', function (data) {
        if (typeof args[0] === 'string') {
          data.name === args[0] && args[1](data.payload, data.name);
        } else {
          args[0](data.payload, data.name);
        }
      });
    };
    /**
     * Send a request
     *
     * @param {SendDataType} type
     * @param {SendData} data
     */


    Extension.prototype.request = function (type, data) {
      return __awaiter$4(this, void 0, void 0, function () {
        var _this = this;

        return __generator$1(this, function (_a) {
          this.send(type, data);
          return [2
          /*return*/
          , new Promise(function (resolve) {
            _this.inpageStream.once('data', resolve);
          })];
        });
      });
    };
    /**
     * Request to Station Extension for connecting a wallet
     *
     * @return {string}     name      'onConnect'
     * @return {AccAddress} payload   Terra account address
     */


    Extension.prototype.connect = function () {
      return this.send('connect');
    };
    /**
     * Request for Station Extension information
     *
     * @return {object}  payload.network
     * @return {string}  payload.network.name    Name of the network
     * @return {string}  payload.network.chainId Chain ID
     * @return {string}  payload.network.lcd     LCD address
     * @return {string}  payload.network.fcd     FCD address
     * @return {string}  payload.network.ws      Websocket address
     */


    Extension.prototype.info = function () {
      return this.send('info');
    };
    /**
     * Request for signing tx
     *
     * @return {string}  name               'onSign'
     * @return {object}  payload
     * @return {number}  payload.id         identifier
     * @return {string}  payload.origin     origin address
     * @return {Msg[]}   payload.msgs       requested msgs
     * @return {boolean} payload.success
     * @return {string}  payload.result.public_key Base64 encoded public key
     * @return {string}  payload.result.signature  Base64 encoded signature
     * @return {number}  payload.result.recid      Recovery id
     * @return {StdSignMsg.Data} payload.result.stdSignMsgData
     *
     * @example of broadcasting
     *
     * const { signature, public_key, recid, stdSignMsg } = payload.result;
     *
     * const sig = StdSignature.fromData({
     *   signature,
     *   pub_key: {
     *    type: 'tendermint/PubKeySecp256k1',
     *    value: public_key,
     *  },
     * });
     *
     * const stdSignMsg = StdSignMsg.fromData(payload.result.stdSignMsgData);
     * terra.tx.broadcast(new StdTx(stdSignMsg.msgs, stdSignMsg.fee, [sig], stdSignMsg.memo));
     */


    Extension.prototype.sign = function (options) {
      var _a, _b, _c;

      return this.send('sign', __assign(__assign({}, options), {
        msgs: options.msgs.map(function (msg) {
          return msg.toJSON();
        }),
        fee: (_a = options.fee) === null || _a === void 0 ? void 0 : _a.toJSON(),
        memo: options.memo,
        gasPrices: (_b = options.gasPrices) === null || _b === void 0 ? void 0 : _b.toString(),
        gasAdjustment: (_c = options.gasAdjustment) === null || _c === void 0 ? void 0 : _c.toString(),
        account_number: options.account_number,
        sequence: options.sequence,
        waitForConfirmation: options.waitForConfirmation,
        purgeQueue: options.purgeQueue
      }));
    };
    /**
     * Request for sign and post to LCD server
     *
     * @return {string}  name                   'onPost'
     * @return {object}  payload
     * @return {number}  payload.id             identifier
     * @return {string}  payload.origin         origin address
     * @return {Msg[]}   payload.msgs           requested msgs
     * @return {boolean} payload.success
     * @return {number|undefined} payload.result.code
     *                                          error code. undefined with successful tx
     * @return {string}  payload.result.raw_log raw log
     * @return {string}  payload.result.txhash  transaction hash
     */


    Extension.prototype.post = function (options) {
      var _a, _b, _c;

      return this.send('post', {
        msgs: options.msgs.map(function (msg) {
          return msg.toJSON();
        }),
        fee: (_a = options.fee) === null || _a === void 0 ? void 0 : _a.toJSON(),
        memo: options.memo,
        gasPrices: (_b = options.gasPrices) === null || _b === void 0 ? void 0 : _b.toString(),
        gasAdjustment: (_c = options.gasAdjustment) === null || _c === void 0 ? void 0 : _c.toString(),
        account_number: options.account_number,
        sequence: options.sequence,
        waitForConfirmation: options.waitForConfirmation,
        purgeQueue: options.purgeQueue
      });
    };

    return Extension;
  }();

  extension$1.Extension = Extension;

  var util$2 = {};

  var contract = {};

  Object.defineProperty(contract, "__esModule", {
    value: true
  });
  contract.getContractEvents = contract.getContractAddress = contract.getCodeId = void 0;
  var TxAPI_1 = TxAPI;

  function getCodeId(txResult, msgIndex) {
    if (msgIndex === void 0) {
      msgIndex = 0;
    }

    if ((0, TxAPI_1.isTxError)(txResult) || txResult.logs === undefined || txResult.logs.length === 0) {
      throw new Error('could not parse code id -- tx logs are empty.');
    }

    var codeId = txResult.logs[msgIndex].eventsByType['store_code']['code_id'][0];
    return codeId;
  }

  contract.getCodeId = getCodeId;

  function getContractAddress(txResult, msgIndex) {
    if (msgIndex === void 0) {
      msgIndex = 0;
    }

    if ((0, TxAPI_1.isTxError)(txResult) || txResult.logs === undefined || txResult.logs.length === 0) {
      throw new Error('could not parse contract address -- tx logs are empty.');
    }

    var contractAddress = txResult.logs[msgIndex].eventsByType['instantiate_contract']['contract_address'][0];
    return contractAddress;
  }

  contract.getContractAddress = getContractAddress;

  function getContractEvents(txResult, msgIndex) {
    if (msgIndex === void 0) {
      msgIndex = 0;
    }

    if ((0, TxAPI_1.isTxError)(txResult) || txResult.logs === undefined || txResult.logs.length === 0) {
      throw new Error('could not parse contract events -- tx logs are empty.');
    }

    var contractEvents = [];

    for (var _i = 0, _a = txResult.logs[msgIndex].events; _i < _a.length; _i++) {
      var event_1 = _a[_i];

      if (event_1.type === 'from_contract') {
        var eventData = {
          contract_address: ''
        }; // will be overwritten

        var currentContractAddress = event_1.attributes[0].value;

        for (var _b = 0, _c = event_1.attributes; _b < _c.length; _b++) {
          var att = _c[_b];

          if (att.key == 'contract_address' && currentContractAddress !== att.value) {
            contractEvents.push(eventData);
            eventData = {
              contract_address: ''
            };
            currentContractAddress = att.value;
          }

          eventData[att.key] = att.value;
        }

        contractEvents.push(eventData);
        return contractEvents;
      }
    }

    throw new Error("could not find event type 'from_contract' in logs");
  }

  contract.getContractEvents = getContractEvents;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(hash, exports);

    __exportStar(contract, exports);
  })(util$2);

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(core, exports);

    __exportStar(key$2, exports);

    __exportStar(client, exports);

    __exportStar(extension$1, exports);

    __exportStar(util$2, exports);
  })(dist$1);

  var mobileDetect = {exports: {}};

  (function (module) {
    // THIS FILE IS GENERATED - DO NOT EDIT!

    /*!mobile-detect v1.4.5 2021-03-13*/

    /*global module:false, define:false*/

    /*jshint latedef:false*/

    /*!@license Copyright 2013, Heinrich Goebl, License: MIT, see https://github.com/hgoebl/mobile-detect.js*/
    (function (define, undefined$1) {
      define(function () {

        var impl = {};
        impl.mobileDetectRules = {
          "phones": {
            "iPhone": "\\biPhone\\b|\\biPod\\b",
            "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+|\\b(BBA100|BBB100|BBD100|BBE100|BBF100|STH100)\\b-[0-9]+",
            "Pixel": "; \\bPixel\\b",
            "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
            "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 5X|Nexus 6",
            "Dell": "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
            "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052",
            "Samsung": "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F|SM-G610F|SM-G981B|SM-G892A|SM-A530F",
            "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)|LM-G710",
            "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533|SOV34|601SO|F8332",
            "Asus": "Asus.*Galaxy|PadFone.*Mobile",
            "Xiaomi": "^(?!.*\\bx11\\b).*xiaomi.*$|POCOPHONE F1|MI 8|Redmi Note 9S|Redmi Note 5A Prime|N2G47H|M2001J2G|M2001J2I|M1805E10A|M2004J11G|M1902F1G|M2002J9G|M2004J19G|M2003J6A1G",
            "NokiaLumia": "Lumia [0-9]{3,4}",
            "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
            "Palm": "PalmSource|Palm",
            "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
            "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
            "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
            "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
            "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
            "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
            "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
            "Alcatel": "Alcatel",
            "Nintendo": "Nintendo (3DS|Switch)",
            "Amoi": "Amoi",
            "INQ": "INQ",
            "OnePlus": "ONEPLUS",
            "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
          },
          "tablets": {
            "iPad": "iPad|iPad.*Mobile",
            "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
            "GoogleTablet": "Android.*Pixel C",
            "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835|SM-T830|SM-T837V|SM-T720|SM-T510|SM-T387V|SM-P610|SM-T290|SM-T515|SM-T590|SM-T595|SM-T725|SM-T817P|SM-P585N0|SM-T395|SM-T295|SM-T865|SM-P610N|SM-P615|SM-T970|SM-T380|SM-T5950|SM-T905|SM-T231|SM-T500|SM-T860",
            "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk\/[0-9.]+ like Chrome\/[0-9.]+ (?!Mobile)",
            "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
            "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
            "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b",
            "BlackBerryTablet": "PlayBook|RIM Tablet",
            "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
            "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
            "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
            "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30|A3-A40",
            "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
            "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
            "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
            "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
            "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304X|TB-X304F|TB-X304L|TB-X505F|TB-X505L|TB-X505X|TB-X605F|TB-X605L|TB-8703F|TB-8703X|TB-8703N|TB-8704N|TB-8704F|TB-8704X|TB-8704V|TB-7304F|TB-7304I|TB-7304X|Tab2A7-10F|Tab2A7-20F|TB2-X30L|YT3-X50L|YT3-X50F|YT3-X50M|YT-X705F|YT-X703F|YT-X703L|YT-X705L|YT-X705X|TB2-X30F|TB2-X30L|TB2-X30M|A2107A-F|A2107A-H|TB3-730F|TB3-730M|TB3-730X|TB-7504F|TB-7504X|TB-X704F|TB-X104F|TB3-X70F|TB-X705F|TB-8504F|TB3-X70L|TB3-710F|TB-X704L",
            "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
            "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
            "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
            "ArnovaTablet": "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
            "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
            "IRUTablet": "M702pro",
            "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
            "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
            "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
            "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
            "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
            "NokiaLumiaTablet": "Lumia 2520",
            "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712",
            "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
            "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
            "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
            "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
            "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
            "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
            "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
            "FlyTablet": "IQ310|Fly Vision",
            "bqTablet": "Android.*(bq)?.*\\b(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))\\b|Maxwell.*Lite|Maxwell.*Plus",
            "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09|AGS-L09|CMR-AL19",
            "NecTablet": "\\bN-06D|\\bN-08D",
            "PantechTablet": "Pantech.*P4100",
            "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
            "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
            "ZyncTablet": "z1000|Z99 2G|z930|z990|z909|Z919|z900",
            "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
            "NabiTablet": "Android.*\\bNabi",
            "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
            "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
            "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
            "PlaystationTablet": "Playstation.*(Portable|Vita)",
            "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
            "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
            "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
            "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
            "GalapadTablet": "Android [0-9.]+; [a-z-]+; \\bG1\\b",
            "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
            "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
            "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
            "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
            "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
            "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
            "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
            "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
            "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
            "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
            "DPSTablet": "DPS Dream 9|DPS Dual 7",
            "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
            "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
            "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
            "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
            "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
            "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
            "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
            "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
            "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
            "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497|VFD 1400",
            "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
            "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
            "iMobileTablet": "i-mobile i-note",
            "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
            "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
            "AMPETablet": "Android.* A78 ",
            "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
            "TecnoTablet": "TECNO P9|TECNO DP8D",
            "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
            "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
            "FX2Tablet": "FX2 PAD7|FX2 PAD10",
            "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
            "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
            "VerizonTablet": "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
            "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
            "CaptivaTablet": "CAPTIVA PAD",
            "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
            "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
            "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b",
            "JaytechTablet": "TPC-PA762",
            "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
            "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
            "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
            "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
            "AocTablet": "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
            "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
            "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
            "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
            "MediacomTablet": "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA",
            "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
            "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
            "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
            "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
            "UbislateTablet": "UbiSlate[\\s]?7C",
            "PocketBookTablet": "Pocketbook",
            "KocasoTablet": "\\b(TB-1207)\\b",
            "HisenseTablet": "\\b(F5281|E2371)\\b",
            "Hudl": "Hudl HT7S3|Hudl 2",
            "TelstraTablet": "T-Hub2",
            "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107"
          },
          "oss": {
            "AndroidOS": "Android",
            "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
            "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
            "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
            "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Windows Mobile|Windows Phone [0-9.]+|WCE;",
            "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
            "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
            "iPadOS": "CPU OS 13",
            "SailfishOS": "Sailfish",
            "MeeGoOS": "MeeGo",
            "MaemoOS": "Maemo",
            "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
            "webOS": "webOS|hpwOS",
            "badaOS": "\\bBada\\b",
            "BREWOS": "BREW"
          },
          "uas": {
            "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
            "Dolfin": "\\bDolfin\\b",
            "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+$|Coast\/[0-9.]+",
            "Skyfire": "Skyfire",
            "Edge": "\\bEdgiOS\\b|Mobile Safari\/[.0-9]* Edge",
            "IE": "IEMobile|MSIEMobile",
            "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
            "Bolt": "bolt",
            "TeaShark": "teashark",
            "Blazer": "Blazer",
            "Safari": "Version((?!\\bEdgiOS\\b).)*Mobile.*Safari|Safari.*Mobile|MobileSafari",
            "WeChat": "\\bMicroMessenger\\b",
            "UCBrowser": "UC.*Browser|UCWEB",
            "baiduboxapp": "baiduboxapp",
            "baidubrowser": "baidubrowser",
            "DiigoBrowser": "DiigoBrowser",
            "Mercury": "\\bMercury\\b",
            "ObigoBrowser": "Obigo",
            "NetFront": "NF-Browser",
            "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
            "PaleMoon": "Android.*PaleMoon|Mobile.*PaleMoon"
          },
          "props": {
            "Mobile": "Mobile\/[VER]",
            "Build": "Build\/[VER]",
            "Version": "Version\/[VER]",
            "VendorID": "VendorID\/[VER]",
            "iPad": "iPad.*CPU[a-z ]+[VER]",
            "iPhone": "iPhone.*CPU[a-z ]+[VER]",
            "iPod": "iPod.*CPU[a-z ]+[VER]",
            "Kindle": "Kindle\/[VER]",
            "Chrome": ["Chrome\/[VER]", "CriOS\/[VER]", "CrMo\/[VER]"],
            "Coast": ["Coast\/[VER]"],
            "Dolfin": "Dolfin\/[VER]",
            "Firefox": ["Firefox\/[VER]", "FxiOS\/[VER]"],
            "Fennec": "Fennec\/[VER]",
            "Edge": "Edge\/[VER]",
            "IE": ["IEMobile\/[VER];", "IEMobile [VER]", "MSIE [VER];", "Trident\/[0-9.]+;.*rv:[VER]"],
            "NetFront": "NetFront\/[VER]",
            "NokiaBrowser": "NokiaBrowser\/[VER]",
            "Opera": [" OPR\/[VER]", "Opera Mini\/[VER]", "Version\/[VER]"],
            "Opera Mini": "Opera Mini\/[VER]",
            "Opera Mobi": "Version\/[VER]",
            "UCBrowser": ["UCWEB[VER]", "UC.*Browser\/[VER]"],
            "MQQBrowser": "MQQBrowser\/[VER]",
            "MicroMessenger": "MicroMessenger\/[VER]",
            "baiduboxapp": "baiduboxapp\/[VER]",
            "baidubrowser": "baidubrowser\/[VER]",
            "SamsungBrowser": "SamsungBrowser\/[VER]",
            "Iron": "Iron\/[VER]",
            "Safari": ["Version\/[VER]", "Safari\/[VER]"],
            "Skyfire": "Skyfire\/[VER]",
            "Tizen": "Tizen\/[VER]",
            "Webkit": "webkit[ \/][VER]",
            "PaleMoon": "PaleMoon\/[VER]",
            "SailfishBrowser": "SailfishBrowser\/[VER]",
            "Gecko": "Gecko\/[VER]",
            "Trident": "Trident\/[VER]",
            "Presto": "Presto\/[VER]",
            "Goanna": "Goanna\/[VER]",
            "iOS": " \\bi?OS\\b [VER][ ;]{1}",
            "Android": "Android [VER]",
            "Sailfish": "Sailfish [VER]",
            "BlackBerry": ["BlackBerry[\\w]+\/[VER]", "BlackBerry.*Version\/[VER]", "Version\/[VER]"],
            "BREW": "BREW [VER]",
            "Java": "Java\/[VER]",
            "Windows Phone OS": ["Windows Phone OS [VER]", "Windows Phone [VER]"],
            "Windows Phone": "Windows Phone [VER]",
            "Windows CE": "Windows CE\/[VER]",
            "Windows NT": "Windows NT [VER]",
            "Symbian": ["SymbianOS\/[VER]", "Symbian\/[VER]"],
            "webOS": ["webOS\/[VER]", "hpwOS\/[VER];"]
          },
          "utils": {
            "Bot": "Googlebot|facebookexternalhit|Google-AMPHTML|s~amp-validator|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom|contentkingapp|AspiegelBot",
            "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
            "DesktopMode": "WPDesktop",
            "TV": "SonyDTV|HbbTV",
            "WebKit": "(webkit)[ \/]([\\w.]+)",
            "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b",
            "Watch": "SM-V700"
          }
        }; // following patterns come from http://detectmobilebrowsers.com/

        impl.detectMobileBrowsers = {
          fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
          shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
          tabletPattern: /android|ipad|playbook|silk/i
        };
        var hasOwnProp = Object.prototype.hasOwnProperty,
            isArray;
        impl.FALLBACK_PHONE = 'UnknownPhone';
        impl.FALLBACK_TABLET = 'UnknownTablet';
        impl.FALLBACK_MOBILE = 'UnknownMobile';
        isArray = 'isArray' in Array ? Array.isArray : function (value) {
          return Object.prototype.toString.call(value) === '[object Array]';
        };

        function equalIC(a, b) {
          return a != null && b != null && a.toLowerCase() === b.toLowerCase();
        }

        function containsIC(array, value) {
          var valueLC,
              i,
              len = array.length;

          if (!len || !value) {
            return false;
          }

          valueLC = value.toLowerCase();

          for (i = 0; i < len; ++i) {
            if (valueLC === array[i].toLowerCase()) {
              return true;
            }
          }

          return false;
        }

        function convertPropsToRegExp(object) {
          for (var key in object) {
            if (hasOwnProp.call(object, key)) {
              object[key] = new RegExp(object[key], 'i');
            }
          }
        }

        function prepareUserAgent(userAgent) {
          return (userAgent || '').substr(0, 500); // mitigate vulnerable to ReDoS
        }

        (function init() {
          var key,
              values,
              value,
              i,
              len,
              verPos,
              mobileDetectRules = impl.mobileDetectRules;

          for (key in mobileDetectRules.props) {
            if (hasOwnProp.call(mobileDetectRules.props, key)) {
              values = mobileDetectRules.props[key];

              if (!isArray(values)) {
                values = [values];
              }

              len = values.length;

              for (i = 0; i < len; ++i) {
                value = values[i];
                verPos = value.indexOf('[VER]');

                if (verPos >= 0) {
                  value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
                }

                values[i] = new RegExp(value, 'i');
              }

              mobileDetectRules.props[key] = values;
            }
          }

          convertPropsToRegExp(mobileDetectRules.oss);
          convertPropsToRegExp(mobileDetectRules.phones);
          convertPropsToRegExp(mobileDetectRules.tablets);
          convertPropsToRegExp(mobileDetectRules.uas);
          convertPropsToRegExp(mobileDetectRules.utils); // copy some patterns to oss0 which are tested first (see issue#15)

          mobileDetectRules.oss0 = {
            WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
            WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
          };
        })();
        /**
         * Test userAgent string against a set of rules and find the first matched key.
         * @param {Object} rules (key is String, value is RegExp)
         * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
         * @returns {String|null} the matched key if found, otherwise <tt>null</tt>
         * @private
         */


        impl.findMatch = function (rules, userAgent) {
          for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
              if (rules[key].test(userAgent)) {
                return key;
              }
            }
          }

          return null;
        };
        /**
         * Test userAgent string against a set of rules and return an array of matched keys.
         * @param {Object} rules (key is String, value is RegExp)
         * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
         * @returns {Array} an array of matched keys, may be empty when there is no match, but not <tt>null</tt>
         * @private
         */


        impl.findMatches = function (rules, userAgent) {
          var result = [];

          for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
              if (rules[key].test(userAgent)) {
                result.push(key);
              }
            }
          }

          return result;
        };
        /**
         * Check the version of the given property in the User-Agent.
         *
         * @param {String} propertyName
         * @param {String} userAgent
         * @return {String} version or <tt>null</tt> if version not found
         * @private
         */


        impl.getVersionStr = function (propertyName, userAgent) {
          var props = impl.mobileDetectRules.props,
              patterns,
              i,
              len,
              match;

          if (hasOwnProp.call(props, propertyName)) {
            patterns = props[propertyName];
            len = patterns.length;

            for (i = 0; i < len; ++i) {
              match = patterns[i].exec(userAgent);

              if (match !== null) {
                return match[1];
              }
            }
          }

          return null;
        };
        /**
         * Check the version of the given property in the User-Agent.
         * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
         *
         * @param {String} propertyName
         * @param {String} userAgent
         * @return {Number} version or <tt>NaN</tt> if version not found
         * @private
         */


        impl.getVersion = function (propertyName, userAgent) {
          var version = impl.getVersionStr(propertyName, userAgent);
          return version ? impl.prepareVersionNo(version) : NaN;
        };
        /**
         * Prepare the version number.
         *
         * @param {String} version
         * @return {Number} the version number as a floating number
         * @private
         */


        impl.prepareVersionNo = function (version) {
          var numbers;
          numbers = version.split(/[a-z._ \/\-]/i);

          if (numbers.length === 1) {
            version = numbers[0];
          }

          if (numbers.length > 1) {
            version = numbers[0] + '.';
            numbers.shift();
            version += numbers.join('');
          }

          return Number(version);
        };

        impl.isMobileFallback = function (userAgent) {
          return impl.detectMobileBrowsers.fullPattern.test(userAgent) || impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0, 4));
        };

        impl.isTabletFallback = function (userAgent) {
          return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
        };

        impl.prepareDetectionCache = function (cache, userAgent, maxPhoneWidth) {
          if (cache.mobile !== undefined$1) {
            return;
          }

          var phone, tablet, phoneSized; // first check for stronger tablet rules, then phone (see issue#5)

          tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);

          if (tablet) {
            cache.mobile = cache.tablet = tablet;
            cache.phone = null;
            return; // unambiguously identified as tablet
          }

          phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);

          if (phone) {
            cache.mobile = cache.phone = phone;
            cache.tablet = null;
            return; // unambiguously identified as phone
          } // our rules haven't found a match -> try more general fallback rules


          if (impl.isMobileFallback(userAgent)) {
            phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);

            if (phoneSized === undefined$1) {
              cache.mobile = impl.FALLBACK_MOBILE;
              cache.tablet = cache.phone = null;
            } else if (phoneSized) {
              cache.mobile = cache.phone = impl.FALLBACK_PHONE;
              cache.tablet = null;
            } else {
              cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
              cache.phone = null;
            }
          } else if (impl.isTabletFallback(userAgent)) {
            cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
            cache.phone = null;
          } else {
            // not mobile at all!
            cache.mobile = cache.tablet = cache.phone = null;
          }
        }; // t is a reference to a MobileDetect instance


        impl.mobileGrade = function (t) {
          // impl note:
          // To keep in sync w/ Mobile_Detect.php easily, the following code is tightly aligned to the PHP version.
          // When changes are made in Mobile_Detect.php, copy this method and replace:
          //     $this-> / t.
          //     self::MOBILE_GRADE_(.) / '$1'
          //     , self::VERSION_TYPE_FLOAT / (nothing)
          //     isIOS() / os('iOS')
          //     [reg] / (nothing)   <-- jsdelivr complaining about unescaped unicode character U+00AE
          var $isMobile = t.mobile() !== null;

          if ( // Apple iOS 3.2-5.1 - Tested on the original iPad (4.3 / 5.0), iPad 2 (4.3), iPad 3 (5.1), original iPhone (3.1), iPhone 3 (3.2), 3GS (4.3), 4 (4.3 / 5.0), and 4S (5.1)
          t.os('iOS') && t.version('iPad') >= 4.3 || t.os('iOS') && t.version('iPhone') >= 3.1 || t.os('iOS') && t.version('iPod') >= 3.1 || // Android 2.1-2.3 - Tested on the HTC Incredible (2.2), original Droid (2.2), HTC Aria (2.1), Google Nexus S (2.3). Functional on 1.5 & 1.6 but performance may be sluggish, tested on Google G1 (1.5)
          // Android 3.1 (Honeycomb)  - Tested on the Samsung Galaxy Tab 10.1 and Motorola XOOM
          // Android 4.0 (ICS)  - Tested on a Galaxy Nexus. Note: transition performance can be poor on upgraded devices
          // Android 4.1 (Jelly Bean)  - Tested on a Galaxy Nexus and Galaxy 7
          t.version('Android') > 2.1 && t.is('Webkit') || // Windows Phone 7-7.5 - Tested on the HTC Surround (7.0) HTC Trophy (7.5), LG-E900 (7.5), Nokia Lumia 800
          t.version('Windows Phone OS') >= 7.0 || // Blackberry 7 - Tested on BlackBerry Torch 9810
          // Blackberry 6.0 - Tested on the Torch 9800 and Style 9670
          t.is('BlackBerry') && t.version('BlackBerry') >= 6.0 || // Blackberry Playbook (1.0-2.0) - Tested on PlayBook
          t.match('Playbook.*Tablet') || // Palm WebOS (1.4-2.0) - Tested on the Palm Pixi (1.4), Pre (1.4), Pre 2 (2.0)
          t.version('webOS') >= 1.4 && t.match('Palm|Pre|Pixi') || // Palm WebOS 3.0  - Tested on HP TouchPad
          t.match('hp.*TouchPad') || // Firefox Mobile (12 Beta) - Tested on Android 2.3 device
          t.is('Firefox') && t.version('Firefox') >= 12 || // Chrome for Android - Tested on Android 4.0, 4.1 device
          t.is('Chrome') && t.is('AndroidOS') && t.version('Android') >= 4.0 || // Skyfire 4.1 - Tested on Android 2.3 device
          t.is('Skyfire') && t.version('Skyfire') >= 4.1 && t.is('AndroidOS') && t.version('Android') >= 2.3 || // Opera Mobile 11.5-12: Tested on Android 2.3
          t.is('Opera') && t.version('Opera Mobi') > 11 && t.is('AndroidOS') || // Meego 1.2 - Tested on Nokia 950 and N9
          t.is('MeeGoOS') || // Tizen (pre-release) - Tested on early hardware
          t.is('Tizen') || // Samsung Bada 2.0 - Tested on a Samsung Wave 3, Dolphin browser
          // @todo: more tests here!
          t.is('Dolfin') && t.version('Bada') >= 2.0 || // UC Browser - Tested on Android 2.3 device
          (t.is('UC Browser') || t.is('Dolfin')) && t.version('Android') >= 2.3 || // Kindle 3 and Fire  - Tested on the built-in WebKit browser for each
          t.match('Kindle Fire') || t.is('Kindle') && t.version('Kindle') >= 3.0 || // Nook Color 1.4.1 - Tested on original Nook Color, not Nook Tablet
          t.is('AndroidOS') && t.is('NookTablet') || // Chrome Desktop 11-21 - Tested on OS X 10.7 and Windows 7
          t.version('Chrome') >= 11 && !$isMobile || // Safari Desktop 4-5 - Tested on OS X 10.7 and Windows 7
          t.version('Safari') >= 5.0 && !$isMobile || // Firefox Desktop 4-13 - Tested on OS X 10.7 and Windows 7
          t.version('Firefox') >= 4.0 && !$isMobile || // Internet Explorer 7-9 - Tested on Windows XP, Vista and 7
          t.version('MSIE') >= 7.0 && !$isMobile || // Opera Desktop 10-12 - Tested on OS X 10.7 and Windows 7
          // @reference: http://my.opera.com/community/openweb/idopera/
          t.version('Opera') >= 10 && !$isMobile) {
            return 'A';
          }

          if (t.os('iOS') && t.version('iPad') < 4.3 || t.os('iOS') && t.version('iPhone') < 3.1 || t.os('iOS') && t.version('iPod') < 3.1 || // Blackberry 5.0: Tested on the Storm 2 9550, Bold 9770
          t.is('Blackberry') && t.version('BlackBerry') >= 5 && t.version('BlackBerry') < 6 || //Opera Mini (5.0-6.5) - Tested on iOS 3.2/4.3 and Android 2.3
          t.version('Opera Mini') >= 5.0 && t.version('Opera Mini') <= 6.5 && (t.version('Android') >= 2.3 || t.is('iOS')) || // Nokia Symbian^3 - Tested on Nokia N8 (Symbian^3), C7 (Symbian^3), also works on N97 (Symbian^1)
          t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') || // @todo: report this (tested on Nokia N71)
          t.version('Opera Mobi') >= 11 && t.is('SymbianOS')) {
            return 'B';
          }

          if ( // Blackberry 4.x - Tested on the Curve 8330
          t.version('BlackBerry') < 5.0 || // Windows Mobile - Tested on the HTC Leo (WinMo 5.2)
          t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile') <= 5.2) {
            return 'C';
          } //All older smartphone platforms and featurephones - Any device that doesn't support media queries
          //will receive the basic, C grade experience.


          return 'C';
        };

        impl.detectOS = function (ua) {
          return impl.findMatch(impl.mobileDetectRules.oss0, ua) || impl.findMatch(impl.mobileDetectRules.oss, ua);
        };

        impl.getDeviceSmallerSide = function () {
          return window.screen.width < window.screen.height ? window.screen.width : window.screen.height;
        };
        /**
         * Constructor for MobileDetect object.
         * <br>
         * Such an object will keep a reference to the given user-agent string and cache most of the detect queries.<br>
         * <div style="background-color: #d9edf7; border: 1px solid #bce8f1; color: #3a87ad; padding: 14px; border-radius: 2px; margin-top: 20px">
         *     <strong>Find information how to download and install:</strong>
         *     <a href="https://github.com/hgoebl/mobile-detect.js/">github.com/hgoebl/mobile-detect.js/</a>
         * </div>
         *
         * @example <pre>
         *     var md = new MobileDetect(window.navigator.userAgent);
         *     if (md.mobile()) {
         *         location.href = (md.mobileGrade() === 'A') ? '/mobile/' : '/lynx/';
         *     }
         * </pre>
         *
         * @param {string} userAgent typically taken from window.navigator.userAgent or http_header['User-Agent']
         * @param {number} [maxPhoneWidth=600] <strong>only for browsers</strong> specify a value for the maximum
         *        width of smallest device side (in logical "CSS" pixels) until a device detected as mobile will be handled
         *        as phone.
         *        This is only used in cases where the device cannot be classified as phone or tablet.<br>
         *        See <a href="http://developer.android.com/guide/practices/screens_support.html">Declaring Tablet Layouts
         *        for Android</a>.<br>
         *        If you provide a value < 0, then this "fuzzy" check is disabled.
         * @constructor
         * @global
         */


        function MobileDetect(userAgent, maxPhoneWidth) {
          this.ua = prepareUserAgent(userAgent);
          this._cache = {}; //600dp is typical 7" tablet minimum width

          this.maxPhoneWidth = maxPhoneWidth || 600;
        }

        MobileDetect.prototype = {
          constructor: MobileDetect,

          /**
           * Returns the detected phone or tablet type or <tt>null</tt> if it is not a mobile device.
           * <br>
           * For a list of possible return values see {@link MobileDetect#phone} and {@link MobileDetect#tablet}.<br>
           * <br>
           * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
           * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
           * is positive, a value of <code>UnknownPhone</code>, <code>UnknownTablet</code> or
           * <code>UnknownMobile</code> is returned.<br>
           * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
           * <br>
           * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
           * and <code>UnknownMobile</code>, so you will get <code>UnknownMobile</code> here.<br>
           * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
           * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
           * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
           * <br>
           * In most cases you will use the return value just as a boolean.
           *
           * @returns {String} the key for the phone family or tablet family, e.g. "Nexus".
           * @function MobileDetect#mobile
           */
          mobile: function mobile() {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.mobile;
          },

          /**
           * Returns the detected phone type/family string or <tt>null</tt>.
           * <br>
           * The returned tablet (family or producer) is one of following keys:<br>
           * <br><tt>iPhone, BlackBerry, Pixel, HTC, Nexus, Dell, Motorola, Samsung, LG, Sony, Asus,
           * Xiaomi, NokiaLumia, Micromax, Palm, Vertu, Pantech, Fly, Wiko, iMobile,
           * SimValley, Wolfgang, Alcatel, Nintendo, Amoi, INQ, OnePlus, GenericPhone</tt><br>
           * <br>
           * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
           * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
           * is positive, a value of <code>UnknownPhone</code> or <code>UnknownMobile</code> is returned.<br>
           * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
           * <br>
           * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
           * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
           * will return <code>UnknownMobile</code>.<br>
           * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
           * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
           * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
           * <br>
           * In most cases you will use the return value just as a boolean.
           *
           * @returns {String} the key of the phone family or producer, e.g. "iPhone"
           * @function MobileDetect#phone
           */
          phone: function phone() {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.phone;
          },

          /**
           * Returns the detected tablet type/family string or <tt>null</tt>.
           * <br>
           * The returned tablet (family or producer) is one of following keys:<br>
           * <br><tt>iPad, NexusTablet, GoogleTablet, SamsungTablet, Kindle, SurfaceTablet,
           * HPTablet, AsusTablet, BlackBerryTablet, HTCtablet, MotorolaTablet, NookTablet,
           * AcerTablet, ToshibaTablet, LGTablet, FujitsuTablet, PrestigioTablet,
           * LenovoTablet, DellTablet, YarvikTablet, MedionTablet, ArnovaTablet,
           * IntensoTablet, IRUTablet, MegafonTablet, EbodaTablet, AllViewTablet,
           * ArchosTablet, AinolTablet, NokiaLumiaTablet, SonyTablet, PhilipsTablet,
           * CubeTablet, CobyTablet, MIDTablet, MSITablet, SMiTTablet, RockChipTablet,
           * FlyTablet, bqTablet, HuaweiTablet, NecTablet, PantechTablet, BronchoTablet,
           * VersusTablet, ZyncTablet, PositivoTablet, NabiTablet, KoboTablet, DanewTablet,
           * TexetTablet, PlaystationTablet, TrekstorTablet, PyleAudioTablet, AdvanTablet,
           * DanyTechTablet, GalapadTablet, MicromaxTablet, KarbonnTablet, AllFineTablet,
           * PROSCANTablet, YONESTablet, ChangJiaTablet, GUTablet, PointOfViewTablet,
           * OvermaxTablet, HCLTablet, DPSTablet, VistureTablet, CrestaTablet,
           * MediatekTablet, ConcordeTablet, GoCleverTablet, ModecomTablet, VoninoTablet,
           * ECSTablet, StorexTablet, VodafoneTablet, EssentielBTablet, RossMoorTablet,
           * iMobileTablet, TolinoTablet, AudioSonicTablet, AMPETablet, SkkTablet,
           * TecnoTablet, JXDTablet, iJoyTablet, FX2Tablet, XoroTablet, ViewsonicTablet,
           * VerizonTablet, OdysTablet, CaptivaTablet, IconbitTablet, TeclastTablet,
           * OndaTablet, JaytechTablet, BlaupunktTablet, DigmaTablet, EvolioTablet,
           * LavaTablet, AocTablet, MpmanTablet, CelkonTablet, WolderTablet, MediacomTablet,
           * MiTablet, NibiruTablet, NexoTablet, LeaderTablet, UbislateTablet,
           * PocketBookTablet, KocasoTablet, HisenseTablet, Hudl, TelstraTablet,
           * GenericTablet</tt><br>
           * <br>
           * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
           * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
           * is positive, a value of <code>UnknownTablet</code> or <code>UnknownMobile</code> is returned.<br>
           * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
           * <br>
           * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
           * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
           * will return <code>UnknownMobile</code>.<br>
           * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
           * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
           * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
           * <br>
           * In most cases you will use the return value just as a boolean.
           *
           * @returns {String} the key of the tablet family or producer, e.g. "SamsungTablet"
           * @function MobileDetect#tablet
           */
          tablet: function tablet() {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.tablet;
          },

          /**
           * Returns the (first) detected user-agent string or <tt>null</tt>.
           * <br>
           * The returned user-agent is one of following keys:<br>
           * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
           * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
           * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
           * <br>
           * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
           * cases where a mobile device pretends to be more than one particular browser. You can get the
           * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
           * providing one of the defined keys as first argument to {@link MobileDetect#is}.
           *
           * @returns {String} the key for the detected user-agent or <tt>null</tt>
           * @function MobileDetect#userAgent
           */
          userAgent: function userAgent() {
            if (this._cache.userAgent === undefined$1) {
              this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
            }

            return this._cache.userAgent;
          },

          /**
           * Returns all detected user-agent strings.
           * <br>
           * The array is empty or contains one or more of following keys:<br>
           * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
           * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
           * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
           * <br>
           * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
           * cases where a mobile device pretends to be more than one particular browser. You can get the
           * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
           * providing one of the defined keys as first argument to {@link MobileDetect#is}.
           *
           * @returns {Array} the array of detected user-agent keys or <tt>[]</tt>
           * @function MobileDetect#userAgents
           */
          userAgents: function userAgents() {
            if (this._cache.userAgents === undefined$1) {
              this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
            }

            return this._cache.userAgents;
          },

          /**
           * Returns the detected operating system string or <tt>null</tt>.
           * <br>
           * The operating system is one of following keys:<br>
           * <br><tt>AndroidOS, BlackBerryOS, PalmOS, SymbianOS, WindowsMobileOS, WindowsPhoneOS,
           * iOS, iPadOS, SailfishOS, MeeGoOS, MaemoOS, JavaOS, webOS, badaOS, BREWOS</tt><br>
           *
           * @returns {String} the key for the detected operating system.
           * @function MobileDetect#os
           */
          os: function os() {
            if (this._cache.os === undefined$1) {
              this._cache.os = impl.detectOS(this.ua);
            }

            return this._cache.os;
          },

          /**
           * Get the version (as Number) of the given property in the User-Agent.
           * <br>
           * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
           *
           * @param {String} key a key defining a thing which has a version.<br>
           *        You can use one of following keys:<br>
           * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
           * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
           * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
           * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon,
           * SailfishBrowser, Gecko, Trident, Presto, Goanna, iOS, Android, Sailfish,
           * BlackBerry, BREW, Java, Windows Phone OS, Windows Phone, Windows CE, Windows
           * NT, Symbian, webOS</tt><br>
           *
           * @returns {Number} the version as float or <tt>NaN</tt> if User-Agent doesn't contain this version.
           *          Be careful when comparing this value with '==' operator!
           * @function MobileDetect#version
           */
          version: function version(key) {
            return impl.getVersion(key, this.ua);
          },

          /**
           * Get the version (as String) of the given property in the User-Agent.
           * <br>
           *
           * @param {String} key a key defining a thing which has a version.<br>
           *        You can use one of following keys:<br>
           * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
           * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
           * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
           * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon,
           * SailfishBrowser, Gecko, Trident, Presto, Goanna, iOS, Android, Sailfish,
           * BlackBerry, BREW, Java, Windows Phone OS, Windows Phone, Windows CE, Windows
           * NT, Symbian, webOS</tt><br>
           *
           * @returns {String} the "raw" version as String or <tt>null</tt> if User-Agent doesn't contain this version.
           *
           * @function MobileDetect#versionStr
           */
          versionStr: function versionStr(key) {
            return impl.getVersionStr(key, this.ua);
          },

          /**
           * Global test key against userAgent, os, phone, tablet and some other properties of userAgent string.
           *
           * @param {String} key the key (case-insensitive) of a userAgent, an operating system, phone or
           *        tablet family.<br>
           *        For a complete list of possible values, see {@link MobileDetect#userAgent},
           *        {@link MobileDetect#os}, {@link MobileDetect#phone}, {@link MobileDetect#tablet}.<br>
           *        Additionally you have following keys:<br>
           * <br><tt>Bot, MobileBot, DesktopMode, TV, WebKit, Console, Watch</tt><br>
           *
           * @returns {boolean} <tt>true</tt> when the given key is one of the defined keys of userAgent, os, phone,
           *                    tablet or one of the listed additional keys, otherwise <tt>false</tt>
           * @function MobileDetect#is
           */
          is: function is(key) {
            return containsIC(this.userAgents(), key) || equalIC(key, this.os()) || equalIC(key, this.phone()) || equalIC(key, this.tablet()) || containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
          },

          /**
           * Do a quick test against navigator::userAgent.
           *
           * @param {String|RegExp} pattern the pattern, either as String or RegExp
           *                        (a string will be converted to a case-insensitive RegExp).
           * @returns {boolean} <tt>true</tt> when the pattern matches, otherwise <tt>false</tt>
           * @function MobileDetect#match
           */
          match: function match(pattern) {
            if (!(pattern instanceof RegExp)) {
              pattern = new RegExp(pattern, 'i');
            }

            return pattern.test(this.ua);
          },

          /**
           * Checks whether the mobile device can be considered as phone regarding <code>screen.width</code>.
           * <br>
           * Obviously this method makes sense in browser environments only (not for Node.js)!
           * @param {number} [maxPhoneWidth] the maximum logical pixels (aka. CSS-pixels) to be considered as phone.<br>
           *        The argument is optional and if not present or falsy, the value of the constructor is taken.
           * @returns {boolean|undefined} <code>undefined</code> if screen size wasn't detectable, else <code>true</code>
           *          when screen.width is less or equal to maxPhoneWidth, otherwise <code>false</code>.<br>
           *          Will always return <code>undefined</code> server-side.
           */
          isPhoneSized: function isPhoneSized(maxPhoneWidth) {
            return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
          },

          /**
           * Returns the mobile grade ('A', 'B', 'C').
           *
           * @returns {String} one of the mobile grades ('A', 'B', 'C').
           * @function MobileDetect#mobileGrade
           */
          mobileGrade: function mobileGrade() {
            if (this._cache.grade === undefined$1) {
              this._cache.grade = impl.mobileGrade(this);
            }

            return this._cache.grade;
          }
        }; // environment-dependent

        if (typeof window !== 'undefined' && window.screen) {
          MobileDetect.isPhoneSized = function (maxPhoneWidth) {
            return maxPhoneWidth < 0 ? undefined$1 : impl.getDeviceSmallerSide() <= maxPhoneWidth;
          };
        } else {
          MobileDetect.isPhoneSized = function () {};
        } // should not be replaced by a completely new object - just overwrite existing methods


        MobileDetect._impl = impl;
        MobileDetect.version = '1.4.5 2021-03-13';
        return MobileDetect;
      }); // end of call of define()
    })(function (undefined$1) {
      if (module.exports) {
        return function (factory) {
          module.exports = factory();
        };
      } else if (typeof undefined$1 === 'function' && undefined$1.amd) {
        return undefined$1;
      } else if (typeof window !== 'undefined') {
        return function (factory) {
          window.MobileDetect = factory();
        };
      } else {
        // please file a bug if you get this error!
        throw new Error('unknown environment');
      }
    }());
  })(mobileDetect);

  var MobileDetect = mobileDetect.exports;

  var isMobile = function isMobile() {
    var mobileDetect = new MobileDetect(navigator.userAgent);
    return !!mobileDetect.os();
  };

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  var reactIs$3 = {exports: {}};

  /** @license React v17.0.2
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  if ("function" === typeof Symbol && Symbol.for) {
    var x$1 = Symbol.for;
    x$1("react.element");
    x$1("react.portal");
    x$1("react.fragment");
    x$1("react.strict_mode");
    x$1("react.profiler");
    x$1("react.provider");
    x$1("react.context");
    x$1("react.forward_ref");
    x$1("react.suspense");
    x$1("react.suspense_list");
    x$1("react.memo");
    x$1("react.lazy");
    x$1("react.block");
    x$1("react.server.block");
    x$1("react.fundamental");
    x$1("react.debug_trace_mode");
    x$1("react.legacy_hidden");
  }

  var reactIs_development$2 = {};

  /** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    (function () {
      // When adding new symbols to this file,
      // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
      // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
      // nor polyfill, then a plain number is used for performance.

      var REACT_ELEMENT_TYPE = 0xeac7;
      var REACT_PORTAL_TYPE = 0xeaca;
      var REACT_FRAGMENT_TYPE = 0xeacb;
      var REACT_STRICT_MODE_TYPE = 0xeacc;
      var REACT_PROFILER_TYPE = 0xead2;
      var REACT_PROVIDER_TYPE = 0xeacd;
      var REACT_CONTEXT_TYPE = 0xeace;
      var REACT_FORWARD_REF_TYPE = 0xead0;
      var REACT_SUSPENSE_TYPE = 0xead1;
      var REACT_SUSPENSE_LIST_TYPE = 0xead8;
      var REACT_MEMO_TYPE = 0xead3;
      var REACT_LAZY_TYPE = 0xead4;
      var REACT_BLOCK_TYPE = 0xead9;
      var REACT_SERVER_BLOCK_TYPE = 0xeada;
      var REACT_FUNDAMENTAL_TYPE = 0xead5;
      var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
      var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

      if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        symbolFor('react.scope');
        symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
      } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.


      var enableScopeAPI = false; // Experimental Create Event Handle API.

      function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') {
          return true;
        } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
          return true;
        }

        if (typeof type === 'object' && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
            return true;
          }
        }

        return false;
      }

      function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
          var $$typeof = object.$$typeof;

          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;

              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;

                default:
                  var $$typeofType = type && type.$$typeof;

                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;

                    default:
                      return $$typeof;
                  }

              }

            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }

        return undefined;
      }

      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }

      function isConcurrentMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
            hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }

      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }

      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }

      function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }

      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }

      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }

      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }

      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }

      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }

      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }

      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }

      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }

      reactIs_development$2.ContextConsumer = ContextConsumer;
      reactIs_development$2.ContextProvider = ContextProvider;
      reactIs_development$2.Element = Element;
      reactIs_development$2.ForwardRef = ForwardRef;
      reactIs_development$2.Fragment = Fragment;
      reactIs_development$2.Lazy = Lazy;
      reactIs_development$2.Memo = Memo;
      reactIs_development$2.Portal = Portal;
      reactIs_development$2.Profiler = Profiler;
      reactIs_development$2.StrictMode = StrictMode;
      reactIs_development$2.Suspense = Suspense;
      reactIs_development$2.isAsyncMode = isAsyncMode;
      reactIs_development$2.isConcurrentMode = isConcurrentMode;
      reactIs_development$2.isContextConsumer = isContextConsumer;
      reactIs_development$2.isContextProvider = isContextProvider;
      reactIs_development$2.isElement = isElement;
      reactIs_development$2.isForwardRef = isForwardRef;
      reactIs_development$2.isFragment = isFragment;
      reactIs_development$2.isLazy = isLazy;
      reactIs_development$2.isMemo = isMemo;
      reactIs_development$2.isPortal = isPortal;
      reactIs_development$2.isProfiler = isProfiler;
      reactIs_development$2.isStrictMode = isStrictMode;
      reactIs_development$2.isSuspense = isSuspense;
      reactIs_development$2.isValidElementType = isValidElementType;
      reactIs_development$2.typeOf = typeOf;
    })();
  }

  {
    reactIs$3.exports = reactIs_development$2;
  }

  function stylis_min(W) {
    function M(d, c, e, h, a) {
      for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
        g = e.charCodeAt(l);
        l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

        if (0 === b + n + v + m) {
          if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
            switch (g) {
              case 32:
              case 9:
              case 59:
              case 13:
              case 10:
                break;

              default:
                f += e.charAt(l);
            }

            g = 59;
          }

          switch (g) {
            case 123:
              f = f.trim();
              q = f.charCodeAt(0);
              k = 1;

              for (t = ++l; l < B;) {
                switch (g = e.charCodeAt(l)) {
                  case 123:
                    k++;
                    break;

                  case 125:
                    k--;
                    break;

                  case 47:
                    switch (g = e.charCodeAt(l + 1)) {
                      case 42:
                      case 47:
                        a: {
                          for (u = l + 1; u < J; ++u) {
                            switch (e.charCodeAt(u)) {
                              case 47:
                                if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                  l = u + 1;
                                  break a;
                                }

                                break;

                              case 10:
                                if (47 === g) {
                                  l = u + 1;
                                  break a;
                                }

                            }
                          }

                          l = u;
                        }

                    }

                    break;

                  case 91:
                    g++;

                  case 40:
                    g++;

                  case 34:
                  case 39:
                    for (; l++ < J && e.charCodeAt(l) !== g;) {}

                }

                if (0 === k) break;
                l++;
              }

              k = e.substring(t, l);
              0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

              switch (q) {
                case 64:
                  0 < r && (f = f.replace(N, ''));
                  g = f.charCodeAt(1);

                  switch (g) {
                    case 100:
                    case 109:
                    case 115:
                    case 45:
                      r = c;
                      break;

                    default:
                      r = O;
                  }

                  k = M(c, r, k, g, a + 1);
                  t = k.length;
                  0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                  if (0 < t) switch (g) {
                    case 115:
                      f = f.replace(da, ea);

                    case 100:
                    case 109:
                    case 45:
                      k = f + '{' + k + '}';
                      break;

                    case 107:
                      f = f.replace(fa, '$1 $2');
                      k = f + '{' + k + '}';
                      k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                      break;

                    default:
                      k = f + k, 112 === h && (k = (p += k, ''));
                  } else k = '';
                  break;

                default:
                  k = M(c, X(c, f, I), k, h, a + 1);
              }

              F += k;
              k = I = r = u = q = 0;
              f = '';
              g = e.charCodeAt(++l);
              break;

            case 125:
            case 59:
              f = (0 < r ? f.replace(N, '') : f).trim();
              if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
                case 0:
                  break;

                case 64:
                  if (105 === g || 99 === g) {
                    G += f + e.charAt(l);
                    break;
                  }

                default:
                  58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
              }
              I = r = u = q = 0;
              f = '';
              g = e.charCodeAt(++l);
          }
        }

        switch (g) {
          case 13:
          case 10:
            47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
            0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
            z = 1;
            D++;
            break;

          case 59:
          case 125:
            if (0 === b + n + v + m) {
              z++;
              break;
            }

          default:
            z++;
            y = e.charAt(l);

            switch (g) {
              case 9:
              case 32:
                if (0 === n + m + b) switch (x) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y = '';
                    break;

                  default:
                    32 !== g && (y = ' ');
                }
                break;

              case 0:
                y = '\\0';
                break;

              case 12:
                y = '\\f';
                break;

              case 11:
                y = '\\v';
                break;

              case 38:
                0 === n + b + m && (r = I = 1, y = '\f' + y);
                break;

              case 108:
                if (0 === n + b + m + E && 0 < u) switch (l - u) {
                  case 2:
                    112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                  case 8:
                    111 === K && (E = K);
                }
                break;

              case 58:
                0 === n + b + m && (u = l);
                break;

              case 44:
                0 === b + v + n + m && (r = 1, y += '\r');
                break;

              case 34:
              case 39:
                0 === b && (n = n === g ? 0 : 0 === n ? g : n);
                break;

              case 91:
                0 === n + b + v && m++;
                break;

              case 93:
                0 === n + b + v && m--;
                break;

              case 41:
                0 === n + b + m && v--;
                break;

              case 40:
                if (0 === n + b + m) {
                  if (0 === q) switch (2 * x + 3 * K) {
                    case 533:
                      break;

                    default:
                      q = 1;
                  }
                  v++;
                }

                break;

              case 64:
                0 === b + v + n + m + u + k && (k = 1);
                break;

              case 42:
              case 47:
                if (!(0 < n + m + v)) switch (b) {
                  case 0:
                    switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                      case 235:
                        b = 47;
                        break;

                      case 220:
                        t = l, b = 42;
                    }

                    break;

                  case 42:
                    47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
                }
            }

            0 === b && (f += y);
        }

        K = x;
        x = g;
        l++;
      }

      t = p.length;

      if (0 < t) {
        r = c;
        if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
        p = r.join(',') + '{' + p + '}';

        if (0 !== w * E) {
          2 !== w || L(p, 2) || (E = 0);

          switch (E) {
            case 111:
              p = p.replace(ha, ':-moz-$1') + p;
              break;

            case 112:
              p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
          }

          E = 0;
        }
      }

      return G + p + F;
    }

    function X(d, c, e) {
      var h = c.trim().split(ia);
      c = h;
      var a = h.length,
          m = d.length;

      switch (m) {
        case 0:
        case 1:
          var b = 0;

          for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
            c[b] = Z(d, c[b], e).trim();
          }

          break;

        default:
          var v = b = 0;

          for (c = []; b < a; ++b) {
            for (var n = 0; n < m; ++n) {
              c[v++] = Z(d[n] + ' ', h[b], e).trim();
            }
          }

      }

      return c;
    }

    function Z(d, c, e) {
      var h = c.charCodeAt(0);
      33 > h && (h = (c = c.trim()).charCodeAt(0));

      switch (h) {
        case 38:
          return c.replace(F, '$1' + d.trim());

        case 58:
          return d.trim() + c.replace(F, '$1' + d.trim());

        default:
          if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
      }

      return d + c;
    }

    function P(d, c, e, h) {
      var a = d + ';',
          m = 2 * c + 3 * e + 4 * h;

      if (944 === m) {
        d = a.indexOf(':', 9) + 1;
        var b = a.substring(d, a.length - 1).trim();
        b = a.substring(0, d).trim() + b + ';';
        return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
      }

      if (0 === w || 2 === w && !L(a, 1)) return a;

      switch (m) {
        case 1015:
          return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

        case 951:
          return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

        case 963:
          return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

        case 1009:
          if (100 !== a.charCodeAt(4)) break;

        case 969:
        case 942:
          return '-webkit-' + a + a;

        case 978:
          return '-webkit-' + a + '-moz-' + a + a;

        case 1019:
        case 983:
          return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

        case 883:
          if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
          if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
          break;

        case 932:
          if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
            case 103:
              return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

            case 115:
              return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

            case 98:
              return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
          }
          return '-webkit-' + a + '-ms-' + a + a;

        case 964:
          return '-webkit-' + a + '-ms-flex-' + a + a;

        case 1023:
          if (99 !== a.charCodeAt(8)) break;
          b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
          return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

        case 1005:
          return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

        case 1e3:
          b = a.substring(13).trim();
          c = b.indexOf('-') + 1;

          switch (b.charCodeAt(0) + b.charCodeAt(c)) {
            case 226:
              b = a.replace(G, 'tb');
              break;

            case 232:
              b = a.replace(G, 'tb-rl');
              break;

            case 220:
              b = a.replace(G, 'lr');
              break;

            default:
              return a;
          }

          return '-webkit-' + a + '-ms-' + b + a;

        case 1017:
          if (-1 === a.indexOf('sticky', 9)) break;

        case 975:
          c = (a = d).length - 10;
          b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

          switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
            case 203:
              if (111 > b.charCodeAt(8)) break;

            case 115:
              a = a.replace(b, '-webkit-' + b) + ';' + a;
              break;

            case 207:
            case 102:
              a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
          }

          return a + ';';

        case 938:
          if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
            case 105:
              return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

            case 115:
              return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

            default:
              return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
          }
          break;

        case 973:
        case 989:
          if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

        case 931:
        case 953:
          if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
          break;

        case 962:
          if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
      }

      return a;
    }

    function L(d, c) {
      var e = d.indexOf(1 === c ? ':' : '{'),
          h = d.substring(0, 3 !== c ? e : 10);
      e = d.substring(e + 1, d.length - 1);
      return R(2 !== c ? h : h.replace(na, '$1'), e, c);
    }

    function ea(d, c) {
      var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
      return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
    }

    function H(d, c, e, h, a, m, b, v, n, q) {
      for (var g = 0, x = c, w; g < A; ++g) {
        switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
          case void 0:
          case !1:
          case !0:
          case null:
            break;

          default:
            x = w;
        }
      }

      if (x !== c) return x;
    }

    function T(d) {
      switch (d) {
        case void 0:
        case null:
          A = S.length = 0;
          break;

        default:
          if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {
            T(d[c]);
          } else Y = !!d | 0;
      }

      return T;
    }

    function U(d) {
      d = d.prefix;
      void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
      return U;
    }

    function B(d, c) {
      var e = d;
      33 > e.charCodeAt(0) && (e = e.trim());
      V = e;
      e = [V];

      if (0 < A) {
        var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
        void 0 !== h && 'string' === typeof h && (c = h);
      }

      var a = M(O, e, c, 0, 0);
      0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
      V = '';
      E = 0;
      z = D = 1;
      return a;
    }

    var ca = /^\0+/g,
        N = /[\0\r\f]/g,
        aa = /: */g,
        ka = /zoo|gra/,
        ma = /([,: ])(transform)/g,
        ia = /,\r+?/g,
        F = /([\t\r\n ])*\f?&/g,
        fa = /@(k\w+)\s*(\S*)\s*/,
        Q = /::(place)/g,
        ha = /:(read-only)/g,
        G = /[svh]\w+-[tblr]{2}/,
        da = /\(\s*(.*)\s*\)/g,
        oa = /([\s\S]*?);/g,
        ba = /-self|flex-/g,
        na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
        la = /stretch|:\s*\w+\-(?:conte|avail)/,
        ja = /([^-])(image-set\()/,
        z = 1,
        D = 1,
        E = 0,
        w = 1,
        O = [],
        S = [],
        A = 0,
        R = null,
        Y = 0,
        V = '';
    B.use = T;
    B.set = U;
    void 0 !== W && U(W);
    return B;
  }

  var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };

  function memoize(fn) {
    var cache = {};
    return function (arg) {
      if (cache[arg] === undefined) cache[arg] = fn(arg);
      return cache[arg];
    };
  }

  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

  var index = memoize(function (prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
    /* o */
    && prop.charCodeAt(1) === 110
    /* n */
    && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
  );

  var reactIs$2 = {exports: {}};

  var reactIs_development$1 = {};

  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    (function () {
      // nor polyfill, then a plain number is used for performance.

      var hasSymbol = typeof Symbol === 'function' && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
      // (unstable) APIs that have been removed. Can we remove the symbols?

      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

      function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }

      function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
          var $$typeof = object.$$typeof;

          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;

              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;

                default:
                  var $$typeofType = type && type.$$typeof;

                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;

                    default:
                      return $$typeof;
                  }

              }

            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }

        return undefined;
      } // AsyncMode is deprecated along with isAsyncMode


      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }

      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }

      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }

      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }

      function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }

      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }

      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }

      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }

      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }

      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }

      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }

      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }

      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }

      reactIs_development$1.AsyncMode = AsyncMode;
      reactIs_development$1.ConcurrentMode = ConcurrentMode;
      reactIs_development$1.ContextConsumer = ContextConsumer;
      reactIs_development$1.ContextProvider = ContextProvider;
      reactIs_development$1.Element = Element;
      reactIs_development$1.ForwardRef = ForwardRef;
      reactIs_development$1.Fragment = Fragment;
      reactIs_development$1.Lazy = Lazy;
      reactIs_development$1.Memo = Memo;
      reactIs_development$1.Portal = Portal;
      reactIs_development$1.Profiler = Profiler;
      reactIs_development$1.StrictMode = StrictMode;
      reactIs_development$1.Suspense = Suspense;
      reactIs_development$1.isAsyncMode = isAsyncMode;
      reactIs_development$1.isConcurrentMode = isConcurrentMode;
      reactIs_development$1.isContextConsumer = isContextConsumer;
      reactIs_development$1.isContextProvider = isContextProvider;
      reactIs_development$1.isElement = isElement;
      reactIs_development$1.isForwardRef = isForwardRef;
      reactIs_development$1.isFragment = isFragment;
      reactIs_development$1.isLazy = isLazy;
      reactIs_development$1.isMemo = isMemo;
      reactIs_development$1.isPortal = isPortal;
      reactIs_development$1.isProfiler = isProfiler;
      reactIs_development$1.isStrictMode = isStrictMode;
      reactIs_development$1.isSuspense = isSuspense;
      reactIs_development$1.isValidElementType = isValidElementType;
      reactIs_development$1.typeOf = typeOf;
    })();
  }

  {
    reactIs$2.exports = reactIs_development$1;
  }

  var reactIs$1 = reactIs$2.exports;
  /**
   * Copyright 2015, Yahoo! Inc.
   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
   */

  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;

  function getStatics(component) {
    // React v16.11 and below
    if (reactIs$1.isMemo(component)) {
      return MEMO_STATICS;
    } // React v16.12 and above


    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
  }

  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;

  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
      // don't hoist over string (html) components
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);

        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }

      var keys = getOwnPropertyNames(sourceComponent);

      if (getOwnPropertySymbols$1) {
        keys = keys.concat(getOwnPropertySymbols$1(sourceComponent));
      }

      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);

      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];

        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

          try {
            // Avoid failures from read-only properties
            defineProperty(targetComponent, key, descriptor);
          } catch (e) {}
        }
      }
    }

    return targetComponent;
  }

  var hoistNonReactStatics_cjs = hoistNonReactStatics;

  function v() {
    return (v = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];

        for (var r in n) {
          Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
        }
      }

      return e;
    }).apply(this, arguments);
  }

  var g = function g(e, t) {
    for (var n = [e[0]], r = 0, o = t.length; r < o; r += 1) {
      n.push(t[r], e[r + 1]);
    }

    return n;
  },
      S = function S(t) {
    return null !== t && "object" == typeof t && "[object Object]" === (t.toString ? t.toString() : Object.prototype.toString.call(t)) && !reactIs$3.exports.typeOf(t);
  },
      w = Object.freeze([]),
      E = Object.freeze({});

  function b(e) {
    return "function" == typeof e;
  }

  function _(e) {
    return "string" == typeof e && e || e.displayName || e.name || "Component";
  }

  function N(e) {
    return e && "string" == typeof e.styledComponentId;
  }

  var A = "undefined" != typeof process && (undefined) || "data-styled",
      I = "undefined" != typeof window && "HTMLElement" in window,
      P = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== undefined && "" !== undefined ? undefined : "undefined" != typeof process && void 0 !== undefined && "" !== undefined ? undefined : "production" !== "development"),
      R = {
    1: "Cannot create styled-component for component: %s.\n\n",
    2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n",
    3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n",
    4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n",
    5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n",
    6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n",
    7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n',
    8: 'ThemeProvider: Please make your "theme" prop an object.\n\n',
    9: "Missing document `<head>`\n\n",
    10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n",
    11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n",
    12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n",
    13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n",
    14: 'ThemeProvider: "theme" prop is required.\n\n',
    15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n",
    16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n",
    17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n"
  } ;

  function D() {
    for (var e = arguments.length <= 0 ? void 0 : arguments[0], t = [], n = 1, r = arguments.length; n < r; n += 1) {
      t.push(n < 0 || arguments.length <= n ? void 0 : arguments[n]);
    }

    return t.forEach(function (t) {
      e = e.replace(/%[a-z]/, t);
    }), e;
  }

  function j(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) {
      n[r - 1] = arguments[r];
    }

    throw new Error(D.apply(void 0, [R[e]].concat(n)).trim());
  }

  var T = function () {
    function e(e) {
      this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e;
    }

    var t = e.prototype;
    return t.indexOfGroup = function (e) {
      for (var t = 0, n = 0; n < e; n++) {
        t += this.groupSizes[n];
      }

      return t;
    }, t.insertRules = function (e, t) {
      if (e >= this.groupSizes.length) {
        for (var n = this.groupSizes, r = n.length, o = r; e >= o;) {
          (o <<= 1) < 0 && j(16, "" + e);
        }

        this.groupSizes = new Uint32Array(o), this.groupSizes.set(n), this.length = o;

        for (var s = r; s < o; s++) {
          this.groupSizes[s] = 0;
        }
      }

      for (var i = this.indexOfGroup(e + 1), a = 0, c = t.length; a < c; a++) {
        this.tag.insertRule(i, t[a]) && (this.groupSizes[e]++, i++);
      }
    }, t.clearGroup = function (e) {
      if (e < this.length) {
        var t = this.groupSizes[e],
            n = this.indexOfGroup(e),
            r = n + t;
        this.groupSizes[e] = 0;

        for (var o = n; o < r; o++) {
          this.tag.deleteRule(n);
        }
      }
    }, t.getGroup = function (e) {
      var t = "";
      if (e >= this.length || 0 === this.groupSizes[e]) return t;

      for (var n = this.groupSizes[e], r = this.indexOfGroup(e), o = r + n, s = r; s < o; s++) {
        t += this.tag.getRule(s) + "/*!sc*/\n";
      }

      return t;
    }, e;
  }(),
      x = new Map(),
      k = new Map(),
      V = 1,
      B = function B(e) {
    if (x.has(e)) return x.get(e);

    for (; k.has(V);) {
      V++;
    }

    var t = V++;
    return ((0 | t) < 0 || t > 1 << 30) && j(16, "" + t), x.set(e, t), k.set(t, e), t;
  },
      z = function z(e) {
    return k.get(e);
  },
      M = function M(e, t) {
    t >= V && (V = t + 1), x.set(e, t), k.set(t, e);
  },
      G = "style[" + A + '][data-styled-version="5.3.3"]',
      L = new RegExp("^" + A + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),
      F = function F(e, t, n) {
    for (var r, o = n.split(","), s = 0, i = o.length; s < i; s++) {
      (r = o[s]) && e.registerName(t, r);
    }
  },
      Y = function Y(e, t) {
    for (var n = (t.textContent || "").split("/*!sc*/\n"), r = [], o = 0, s = n.length; o < s; o++) {
      var i = n[o].trim();

      if (i) {
        var a = i.match(L);

        if (a) {
          var c = 0 | parseInt(a[1], 10),
              u = a[2];
          0 !== c && (M(u, c), F(e, u, a[3]), e.getTag().insertRules(c, r)), r.length = 0;
        } else r.push(i);
      }
    }
  },
      q = function q() {
    return "undefined" != typeof window && void 0 !== window.__webpack_nonce__ ? window.__webpack_nonce__ : null;
  },
      H = function H(e) {
    var t = document.head,
        n = e || t,
        r = document.createElement("style"),
        o = function (e) {
      for (var t = e.childNodes, n = t.length; n >= 0; n--) {
        var r = t[n];
        if (r && 1 === r.nodeType && r.hasAttribute(A)) return r;
      }
    }(n),
        s = void 0 !== o ? o.nextSibling : null;

    r.setAttribute(A, "active"), r.setAttribute("data-styled-version", "5.3.3");
    var i = q();
    return i && r.setAttribute("nonce", i), n.insertBefore(r, s), r;
  },
      $ = function () {
    function e(e) {
      var t = this.element = H(e);
      t.appendChild(document.createTextNode("")), this.sheet = function (e) {
        if (e.sheet) return e.sheet;

        for (var t = document.styleSheets, n = 0, r = t.length; n < r; n++) {
          var o = t[n];
          if (o.ownerNode === e) return o;
        }

        j(17);
      }(t), this.length = 0;
    }

    var t = e.prototype;
    return t.insertRule = function (e, t) {
      try {
        return this.sheet.insertRule(t, e), this.length++, !0;
      } catch (e) {
        return !1;
      }
    }, t.deleteRule = function (e) {
      this.sheet.deleteRule(e), this.length--;
    }, t.getRule = function (e) {
      var t = this.sheet.cssRules[e];
      return void 0 !== t && "string" == typeof t.cssText ? t.cssText : "";
    }, e;
  }(),
      W = function () {
    function e(e) {
      var t = this.element = H(e);
      this.nodes = t.childNodes, this.length = 0;
    }

    var t = e.prototype;
    return t.insertRule = function (e, t) {
      if (e <= this.length && e >= 0) {
        var n = document.createTextNode(t),
            r = this.nodes[e];
        return this.element.insertBefore(n, r || null), this.length++, !0;
      }

      return !1;
    }, t.deleteRule = function (e) {
      this.element.removeChild(this.nodes[e]), this.length--;
    }, t.getRule = function (e) {
      return e < this.length ? this.nodes[e].textContent : "";
    }, e;
  }(),
      U = function () {
    function e(e) {
      this.rules = [], this.length = 0;
    }

    var t = e.prototype;
    return t.insertRule = function (e, t) {
      return e <= this.length && (this.rules.splice(e, 0, t), this.length++, !0);
    }, t.deleteRule = function (e) {
      this.rules.splice(e, 1), this.length--;
    }, t.getRule = function (e) {
      return e < this.length ? this.rules[e] : "";
    }, e;
  }(),
      J = I,
      X = {
    isServer: !I,
    useCSSOMInjection: !P
  },
      Z = function () {
    function e(e, t, n) {
      void 0 === e && (e = E), void 0 === t && (t = {}), this.options = v({}, X, {}, e), this.gs = t, this.names = new Map(n), this.server = !!e.isServer, !this.server && I && J && (J = !1, function (e) {
        for (var t = document.querySelectorAll(G), n = 0, r = t.length; n < r; n++) {
          var o = t[n];
          o && "active" !== o.getAttribute(A) && (Y(e, o), o.parentNode && o.parentNode.removeChild(o));
        }
      }(this));
    }

    e.registerId = function (e) {
      return B(e);
    };

    var t = e.prototype;
    return t.reconstructWithOptions = function (t, n) {
      return void 0 === n && (n = !0), new e(v({}, this.options, {}, t), this.gs, n && this.names || void 0);
    }, t.allocateGSInstance = function (e) {
      return this.gs[e] = (this.gs[e] || 0) + 1;
    }, t.getTag = function () {
      return this.tag || (this.tag = (n = (t = this.options).isServer, r = t.useCSSOMInjection, o = t.target, e = n ? new U(o) : r ? new $(o) : new W(o), new T(e)));
      var e, t, n, r, o;
    }, t.hasNameForId = function (e, t) {
      return this.names.has(e) && this.names.get(e).has(t);
    }, t.registerName = function (e, t) {
      if (B(e), this.names.has(e)) this.names.get(e).add(t);else {
        var n = new Set();
        n.add(t), this.names.set(e, n);
      }
    }, t.insertRules = function (e, t, n) {
      this.registerName(e, t), this.getTag().insertRules(B(e), n);
    }, t.clearNames = function (e) {
      this.names.has(e) && this.names.get(e).clear();
    }, t.clearRules = function (e) {
      this.getTag().clearGroup(B(e)), this.clearNames(e);
    }, t.clearTag = function () {
      this.tag = void 0;
    }, t.toString = function () {
      return function (e) {
        for (var t = e.getTag(), n = t.length, r = "", o = 0; o < n; o++) {
          var s = z(o);

          if (void 0 !== s) {
            var i = e.names.get(s),
                a = t.getGroup(o);

            if (i && a && i.size) {
              var c = A + ".g" + o + '[id="' + s + '"]',
                  u = "";
              void 0 !== i && i.forEach(function (e) {
                e.length > 0 && (u += e + ",");
              }), r += "" + a + c + '{content:"' + u + '"}/*!sc*/\n';
            }
          }
        }

        return r;
      }(this);
    }, e;
  }(),
      K = /(a)(d)/gi,
      Q = function Q(e) {
    return String.fromCharCode(e + (e > 25 ? 39 : 97));
  };

  function ee(e) {
    var t,
        n = "";

    for (t = Math.abs(e); t > 52; t = t / 52 | 0) {
      n = Q(t % 52) + n;
    }

    return (Q(t % 52) + n).replace(K, "$1-$2");
  }

  var te = function te(e, t) {
    for (var n = t.length; n;) {
      e = 33 * e ^ t.charCodeAt(--n);
    }

    return e;
  },
      ne = function ne(e) {
    return te(5381, e);
  };

  var oe = ne("5.3.3"),
      se = function () {
    function e(e, t, n) {
      this.rules = e, this.staticRulesId = "", this.isStatic = "production" === "development"  , this.componentId = t, this.baseHash = te(oe, t), this.baseStyle = n, Z.registerId(t);
    }

    return e.prototype.generateAndInjectStyles = function (e, t, n) {
      var r = this.componentId,
          o = [];
      if (this.baseStyle && o.push(this.baseStyle.generateAndInjectStyles(e, t, n)), this.isStatic && !n.hash) {
        if (this.staticRulesId && t.hasNameForId(r, this.staticRulesId)) o.push(this.staticRulesId);else {
          var s = Ne(this.rules, e, t, n).join(""),
              i = ee(te(this.baseHash, s) >>> 0);

          if (!t.hasNameForId(r, i)) {
            var a = n(s, "." + i, void 0, r);
            t.insertRules(r, i, a);
          }

          o.push(i), this.staticRulesId = i;
        }
      } else {
        for (var c = this.rules.length, u = te(this.baseHash, n.hash), l = "", d = 0; d < c; d++) {
          var h = this.rules[d];
          if ("string" == typeof h) l += h, (u = te(u, h + d));else if (h) {
            var p = Ne(h, e, t, n),
                f = Array.isArray(p) ? p.join("") : p;
            u = te(u, f + d), l += f;
          }
        }

        if (l) {
          var m = ee(u >>> 0);

          if (!t.hasNameForId(r, m)) {
            var y = n(l, "." + m, void 0, r);
            t.insertRules(r, m, y);
          }

          o.push(m);
        }
      }
      return o.join(" ");
    }, e;
  }(),
      ie = /^\s*\/\/.*$/gm,
      ae = [":", "[", ".", "#"];

  function ce(e) {
    var t,
        n,
        r,
        o,
        s = void 0 === e ? E : e,
        i = s.options,
        a = void 0 === i ? E : i,
        c = s.plugins,
        u = void 0 === c ? w : c,
        l = new stylis_min(a),
        d = [],
        h = function (e) {
      function t(t) {
        if (t) try {
          e(t + "}");
        } catch (e) {}
      }

      return function (n, r, o, s, i, a, c, u, l, d) {
        switch (n) {
          case 1:
            if (0 === l && 64 === r.charCodeAt(0)) return e(r + ";"), "";
            break;

          case 2:
            if (0 === u) return r + "/*|*/";
            break;

          case 3:
            switch (u) {
              case 102:
              case 112:
                return e(o[0] + r), "";

              default:
                return r + (0 === d ? "/*|*/" : "");
            }

          case -2:
            r.split("/*|*/}").forEach(t);
        }
      };
    }(function (e) {
      d.push(e);
    }),
        f = function f(e, r, s) {
      return 0 === r && -1 !== ae.indexOf(s[n.length]) || s.match(o) ? e : "." + t;
    };

    function m(e, s, i, a) {
      void 0 === a && (a = "&");
      var c = e.replace(ie, ""),
          u = s && i ? i + " " + s + " { " + c + " }" : c;
      return t = a, n = s, r = new RegExp("\\" + n + "\\b", "g"), o = new RegExp("(\\" + n + "\\b){2,}"), l(i || !s ? "" : s, u);
    }

    return l.use([].concat(u, [function (e, t, o) {
      2 === e && o.length && o[0].lastIndexOf(n) > 0 && (o[0] = o[0].replace(r, f));
    }, h, function (e) {
      if (-2 === e) {
        var t = d;
        return d = [], t;
      }
    }])), m.hash = u.length ? u.reduce(function (e, t) {
      return t.name || j(15), te(e, t.name);
    }, 5381).toString() : "", m;
  }

  var ue = /*#__PURE__*/React__default["default"].createContext();
      ue.Consumer;
      var de = /*#__PURE__*/React__default["default"].createContext(),
      he = (de.Consumer, new Z()),
      pe = ce();

  function fe() {
    return React$1.useContext(ue) || he;
  }

  function me() {
    return React$1.useContext(de) || pe;
  }

  var ve = function () {
    function e(e, t) {
      var n = this;
      this.inject = function (e, t) {
        void 0 === t && (t = pe);
        var r = n.name + t.hash;
        e.hasNameForId(n.id, r) || e.insertRules(n.id, r, t(n.rules, r, "@keyframes"));
      }, this.toString = function () {
        return j(12, String(n.name));
      }, this.name = e, this.id = "sc-keyframes-" + e, this.rules = t;
    }

    return e.prototype.getName = function (e) {
      return void 0 === e && (e = pe), this.name + e.hash;
    }, e;
  }(),
      ge = /([A-Z])/,
      Se = /([A-Z])/g,
      we = /^ms-/,
      Ee = function Ee(e) {
    return "-" + e.toLowerCase();
  };

  function be(e) {
    return ge.test(e) ? e.replace(Se, Ee).replace(we, "-ms-") : e;
  }

  var _e = function _e(e) {
    return null == e || !1 === e || "" === e;
  };

  function Ne(e, n, r, o) {
    if (Array.isArray(e)) {
      for (var s, i = [], a = 0, c = e.length; a < c; a += 1) {
        "" !== (s = Ne(e[a], n, r, o)) && (Array.isArray(s) ? i.push.apply(i, s) : i.push(s));
      }

      return i;
    }

    if (_e(e)) return "";
    if (N(e)) return "." + e.styledComponentId;

    if (b(e)) {
      if ("function" != typeof (l = e) || l.prototype && l.prototype.isReactComponent || !n) return e;
      var u = e(n);
      return reactIs$3.exports.isElement(u) && console.warn(_(e) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), Ne(u, n, r, o);
    }

    var l;
    return e instanceof ve ? r ? (e.inject(r, o), e.getName(o)) : e : S(e) ? function e(t, n) {
      var r,
          o,
          s = [];

      for (var i in t) {
        t.hasOwnProperty(i) && !_e(t[i]) && (Array.isArray(t[i]) && t[i].isCss || b(t[i]) ? s.push(be(i) + ":", t[i], ";") : S(t[i]) ? s.push.apply(s, e(t[i], i)) : s.push(be(i) + ": " + (r = i, null == (o = t[i]) || "boolean" == typeof o || "" === o ? "" : "number" != typeof o || 0 === o || r in unitlessKeys ? String(o).trim() : o + "px") + ";"));
      }

      return n ? [n + " {"].concat(s, ["}"]) : s;
    }(e) : e.toString();
  }

  var Ae = function Ae(e) {
    return Array.isArray(e) && (e.isCss = !0), e;
  };

  function Ce(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) {
      n[r - 1] = arguments[r];
    }

    return b(e) || S(e) ? Ae(Ne(g(w, [e].concat(n)))) : 0 === n.length && 1 === e.length && "string" == typeof e[0] ? e : Ae(Ne(g(e, n)));
  }

  var Ie = /invalid hook call/i,
      Pe = new Set(),
      Oe = function Oe(e, t) {
    {
      var n = "The component " + e + (t ? ' with the id of "' + t + '"' : "") + " has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.",
          r = console.error;

      try {
        var o = !0;
        console.error = function (e) {
          if (Ie.test(e)) o = !1, Pe.delete(n);else {
            for (var t = arguments.length, s = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) {
              s[i - 1] = arguments[i];
            }

            r.apply(void 0, [e].concat(s));
          }
        }, React$1.useRef(), o && !Pe.has(n) && (console.warn(n), Pe.add(n));
      } catch (e) {
        Ie.test(e.message) && Pe.delete(n);
      } finally {
        console.error = r;
      }
    }
  },
      Re = function Re(e, t, n) {
    return void 0 === n && (n = E), e.theme !== n.theme && e.theme || t || n.theme;
  },
      De = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
      je = /(^-|-$)/g;

  function Te(e) {
    return e.replace(De, "-").replace(je, "");
  }

  var xe = function xe(e) {
    return ee(ne(e) >>> 0);
  };

  function ke(e) {
    return "string" == typeof e && (e.charAt(0) === e.charAt(0).toLowerCase());
  }

  var Ve = function Ve(e) {
    return "function" == typeof e || "object" == typeof e && null !== e && !Array.isArray(e);
  },
      Be = function Be(e) {
    return "__proto__" !== e && "constructor" !== e && "prototype" !== e;
  };

  function ze(e, t, n) {
    var r = e[n];
    Ve(t) && Ve(r) ? Me(r, t) : e[n] = t;
  }

  function Me(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) {
      n[r - 1] = arguments[r];
    }

    for (var o = 0, s = n; o < s.length; o++) {
      var i = s[o];
      if (Ve(i)) for (var a in i) {
        Be(a) && ze(e, i[a], a);
      }
    }

    return e;
  }

  var Ge = /*#__PURE__*/React__default["default"].createContext();
      Ge.Consumer;

  var Ye = {};

  function qe(e, t, n) {
    var o = N(e),
        i = !ke(e),
        a = t.attrs,
        c = void 0 === a ? w : a,
        d = t.componentId,
        h = void 0 === d ? function (e, t) {
      var n = "string" != typeof e ? "sc" : Te(e);
      Ye[n] = (Ye[n] || 0) + 1;
      var r = n + "-" + xe("5.3.3" + n + Ye[n]);
      return t ? t + "-" + r : r;
    }(t.displayName, t.parentComponentId) : d,
        p = t.displayName,
        f = void 0 === p ? function (e) {
      return ke(e) ? "styled." + e : "Styled(" + _(e) + ")";
    }(e) : p,
        g = t.displayName && t.componentId ? Te(t.displayName) + "-" + t.componentId : t.componentId || h,
        S = o && e.attrs ? Array.prototype.concat(e.attrs, c).filter(Boolean) : c,
        A = t.shouldForwardProp;
    o && e.shouldForwardProp && (A = t.shouldForwardProp ? function (n, r, o) {
      return e.shouldForwardProp(n, r, o) && t.shouldForwardProp(n, r, o);
    } : e.shouldForwardProp);

    var C,
        I = new se(n, g, o ? e.componentStyle : void 0),
        P = I.isStatic && 0 === c.length,
        O = function O(e, t) {
      return function (e, t, n, r) {
        var o = e.attrs,
            i = e.componentStyle,
            a = e.defaultProps,
            c = e.foldedComponentIds,
            d = e.shouldForwardProp,
            h = e.styledComponentId,
            p = e.target;
        React$1.useDebugValue(h);

        var f = function (e, t, n) {
          void 0 === e && (e = E);
          var r = v({}, t, {
            theme: e
          }),
              o = {};
          return n.forEach(function (e) {
            var t,
                n,
                s,
                i = e;

            for (t in b(i) && (i = i(r)), i) {
              r[t] = o[t] = "className" === t ? (n = o[t], s = i[t], n && s ? n + " " + s : n || s) : i[t];
            }
          }), [r, o];
        }(Re(t, React$1.useContext(Ge), a) || E, t, o),
            y = f[0],
            g = f[1],
            S = function (e, t, n, r) {
          var o = fe(),
              s = me(),
              i = t ? e.generateAndInjectStyles(E, o, s) : e.generateAndInjectStyles(n, o, s);
          return React$1.useDebugValue(i), !t && r && r(i), i;
        }(i, r, y, e.warnTooManyClasses ),
            w = n,
            _ = g.$as || t.$as || g.as || t.as || p,
            N = ke(_),
            A = g !== t ? v({}, t, {}, g) : t,
            C = {};

        for (var I in A) {
          "$" !== I[0] && "as" !== I && ("forwardedAs" === I ? C.as = A[I] : (d ? d(I, index, _) : !N || index(I)) && (C[I] = A[I]));
        }

        return t.style && g.style !== t.style && (C.style = v({}, t.style, {}, g.style)), C.className = Array.prototype.concat(c, h, S !== h ? S : null, t.className, g.className).filter(Boolean).join(" "), C.ref = w, /*#__PURE__*/React$1.createElement(_, C);
      }(C, e, t, P);
    };

    return O.displayName = f, (C = /*#__PURE__*/React__default["default"].forwardRef(O)).attrs = S, C.componentStyle = I, C.displayName = f, C.shouldForwardProp = A, C.foldedComponentIds = o ? Array.prototype.concat(e.foldedComponentIds, e.styledComponentId) : w, C.styledComponentId = g, C.target = o ? e.target : e, C.withComponent = function (e) {
      var r = t.componentId,
          o = function (e, t) {
        if (null == e) return {};
        var n,
            r,
            o = {},
            s = Object.keys(e);

        for (r = 0; r < s.length; r++) {
          n = s[r], t.indexOf(n) >= 0 || (o[n] = e[n]);
        }

        return o;
      }(t, ["componentId"]),
          s = r && r + "-" + (ke(e) ? e : Te(_(e)));

      return qe(e, v({}, o, {
        attrs: S,
        componentId: s
      }), n);
    }, Object.defineProperty(C, "defaultProps", {
      get: function get() {
        return this._foldedDefaultProps;
      },
      set: function set(t) {
        this._foldedDefaultProps = o ? Me({}, e.defaultProps, t) : t;
      }
    }), (Oe(f, g), C.warnTooManyClasses = function (e, t) {
      var n = {},
          r = !1;
      return function (o) {
        if (!r && (n[o] = !0, Object.keys(n).length >= 200)) {
          var s = t ? ' with the id of "' + t + '"' : "";
          console.warn("Over 200 classes were generated for component " + e + s + ".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), r = !0, n = {};
        }
      };
    }(f, g)), C.toString = function () {
      return "." + C.styledComponentId;
    }, i && hoistNonReactStatics_cjs(C, e, {
      attrs: !0,
      componentStyle: !0,
      displayName: !0,
      foldedComponentIds: !0,
      shouldForwardProp: !0,
      styledComponentId: !0,
      target: !0,
      withComponent: !0
    }), C;
  }

  var He = function He(e) {
    return function e(t, r, o) {
      if (void 0 === o && (o = E), !reactIs$3.exports.isValidElementType(r)) return j(1, String(r));

      var s = function s() {
        return t(r, o, Ce.apply(void 0, arguments));
      };

      return s.withConfig = function (n) {
        return e(t, r, v({}, o, {}, n));
      }, s.attrs = function (n) {
        return e(t, r, v({}, o, {
          attrs: Array.prototype.concat(o.attrs, n).filter(Boolean)
        }));
      }, s;
    }(qe, e);
  };

  ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function (e) {
    He[e] = He(e);
  });

  function Ue(e) {
    "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");

    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) {
      n[r - 1] = arguments[r];
    }

    var o = Ce.apply(void 0, [e].concat(n)).join(""),
        s = xe(o);
    return new ve(s, o);
  }

  "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), "undefined" != typeof window && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 1 === window["__styled-components-init__"] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window["__styled-components-init__"] += 1);
  var styled = He;

  var _templateObject$1, _templateObject2$1, _templateObject3$1;

  function ReadonlyWalletModalBase(_ref2) {
    var networks = _ref2.networks,
        className = _ref2.className,
        onComplete = _ref2.onComplete;

    var _useState = React$1.useState(function () {
      return networks[0].chainID;
    }),
        chainID = _useState[0],
        setChainID = _useState[1];

    var _useState2 = React$1.useState(''),
        address = _useState2[0],
        setAddress = _useState2[1];

    var validAddress = React$1.useMemo(function () {
      return dist$1.AccAddress.validate(address);
    }, [address]);
    var submit = React$1.useCallback(function () {
      var network = networks.find(function (itemNetwork) {
        return itemNetwork.chainID === chainID;
      });
      if (!network) return;
      onComplete({
        terraAddress: address,
        network: network
      });
    }, [address, chainID, networks, onComplete]);
    return jsxRuntime.jsxs("div", Object.assign({
      className: className
    }, {
      children: [jsxRuntime.jsx("div", {
        onClick: function onClick() {
          return onComplete(null);
        }
      }, void 0), jsxRuntime.jsxs("section", {
        children: [jsxRuntime.jsx("h1", {
          children: "View an Address"
        }, void 0), jsxRuntime.jsxs("label", {
          children: [jsxRuntime.jsx("select", Object.assign({
            value: chainID,
            onChange: function onChange(_ref3) {
              var target = _ref3.target;
              return setChainID(target.value);
            }
          }, {
            children: networks.map(function (itemNetwork) {
              return jsxRuntime.jsxs("option", {
                children: [itemNetwork.name[0].toUpperCase() + itemNetwork.name.slice(1), ' ', "- ", itemNetwork.chainID]
              }, itemNetwork.chainID);
            })
          }), void 0), jsxRuntime.jsx("svg", Object.assign({
            viewBox: "0 0 10 6"
          }, {
            children: jsxRuntime.jsx("polyline", {
              points: "1 1 5 5 9 1"
            }, void 0)
          }), void 0)]
        }, void 0), jsxRuntime.jsx("input", {
          type: "text",
          value: address,
          onChange: function onChange(_ref4) {
            var target = _ref4.target;
            return setAddress(target.value);
          }
        }, void 0), jsxRuntime.jsx("button", Object.assign({
          disabled: !validAddress,
          onClick: submit
        }, {
          children: "View an Address"
        }), void 0)]
      }, void 0)]
    }), void 0);
  }

  var modalEnter$1 = Ue(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose(["\n  0% {\n    opacity: 0;\n  }\n  \n  100% {\n    opacity: 1;\n  }\n"])));
  var sectionEnter$1 = Ue(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteralLoose(["\n  0% {\n    opacity: 0;\n    transform: scale(0.4);\n  }\n  \n  100% {\n    opacity: 1;\n    transform: scale(1);\n  }\n"])));
  styled(ReadonlyWalletModalBase)(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteralLoose(["\n  position: fixed;\n  z-index: 100000;\n\n  color: #000000;\n\n  left: 0;\n  top: 0;\n  width: 100vw;\n  height: 100vh;\n\n  display: grid;\n  place-content: center;\n\n  > div {\n    position: fixed;\n    z-index: -1;\n\n    left: 0;\n    top: 0;\n    width: 100vw;\n    height: 100vh;\n    background-color: rgba(0, 0, 0, 0.3);\n\n    animation: ", " 0.2s ease-in-out;\n  }\n\n  > section {\n    max-width: 80vw;\n    width: 450px;\n\n    border-radius: 25px;\n\n    background-color: #ffffff;\n    box-shadow: 0 4px 18px 3px rgba(0, 0, 0, 0.43);\n\n    animation: ", " 0.2s ease-in-out;\n\n    padding: 50px 60px;\n\n    h1 {\n      font-size: 27px;\n      font-weight: 500;\n\n      text-align: center;\n\n      margin-bottom: 24px;\n    }\n\n    label {\n      position: relative;\n\n      select {\n        -webkit-appearance: none;\n        outline: none;\n        padding: 10px 40px 10px 12px;\n        width: 100%;\n        border: 1px solid #2c2c2c;\n        border-radius: 10px;\n        cursor: pointer;\n        font-family: inherit;\n        font-size: 13px;\n      }\n\n      svg {\n        position: absolute;\n        right: 12px;\n        top: calc(50%);\n        width: 10px;\n        height: 6px;\n        stroke-width: 2px;\n        stroke: #2c2c2c;\n        fill: none;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        pointer-events: none;\n      }\n    }\n\n    input {\n      box-sizing: border-box;\n      margin-top: 10px;\n\n      font-size: 13px;\n      outline: none;\n      border-radius: 10px;\n      padding: 0 12px;\n      width: 100%;\n      height: 37px;\n      border: 1px solid #2c2c2c;\n    }\n\n    button {\n      margin-top: 20px;\n\n      cursor: pointer;\n\n      display: block;\n      outline: none;\n      width: 100%;\n      height: 40px;\n      font-size: 13px;\n      letter-spacing: -0.2px;\n      border-radius: 18px;\n      border: 0;\n\n      color: #ffffff;\n      background-color: #2c2c2c;\n\n      &:disabled {\n        opacity: 0.4;\n      }\n    }\n  }\n"])), modalEnter$1, sectionEnter$1);

  var WalletStatus;

  (function (WalletStatus) {
    WalletStatus["INITIALIZING"] = "INITIALIZING";
    WalletStatus["WALLET_NOT_CONNECTED"] = "WALLET_NOT_CONNECTED";
    WalletStatus["WALLET_CONNECTED"] = "WALLET_CONNECTED";
  })(WalletStatus || (WalletStatus = {}));

  var ConnectType;

  (function (ConnectType) {
    /** Terra Station Chrome Extension */
    ConnectType["CHROME_EXTENSION"] = "CHROME_EXTENSION";
    /** [Hidden mode]: Next version of the Terra Station Browser Extensions */

    ConnectType["WEB_CONNECT"] = "WEB_CONNECT";
    /** Terra Station Mobile */

    ConnectType["WALLETCONNECT"] = "WALLETCONNECT";
    /** Read only mode - View an address */

    ConnectType["READONLY"] = "READONLY";
  })(ConnectType || (ConnectType = {}));

  var WalletContext = /*#__PURE__*/React$1.createContext();
  function useWallet() {
    return React$1.useContext(WalletContext);
  }
  /**
   * can use insteadof useWallet() on the class component
   */

  WalletContext.Consumer;

  function useConnectedWallet() {
    var _useWallet = useWallet(),
        status = _useWallet.status,
        network = _useWallet.network,
        wallets = _useWallet.wallets,
        _post = _useWallet.post,
        _sign = _useWallet.sign;

    var value = React$1.useMemo(function () {
      try {
        if (status === WalletStatus.WALLET_CONNECTED && wallets.length > 0 && dist$1.AccAddress.validate(wallets[0].terraAddress)) {
          var _wallets$ = wallets[0],
              terraAddress = _wallets$.terraAddress,
              connectType = _wallets$.connectType,
              design = _wallets$.design;
          return {
            network: network,
            terraAddress: terraAddress,
            walletAddress: terraAddress,
            design: design,
            post: function post(tx) {
              return _post(tx, {
                terraAddress: terraAddress
              });
            },
            sign: function sign(tx) {
              return _sign(tx, {
                terraAddress: terraAddress
              });
            },
            availablePost: connectType === ConnectType.WEB_CONNECT || connectType === ConnectType.CHROME_EXTENSION || connectType === ConnectType.WALLETCONNECT,
            availableSign: connectType === ConnectType.CHROME_EXTENSION,
            connectType: connectType
          };
        } else {
          return undefined;
        }
      } catch (_a) {
        return undefined;
      }
    }, [network, _post, _sign, status, wallets]);
    return value;
  }

  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$1(o);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf$1(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf$1(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf$1(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  /** User denied the request */
  var UserDenied = /*#__PURE__*/function (_Error) {
    _inheritsLoose(UserDenied, _Error);

    function UserDenied() {
      var _this;

      _this = _Error.call(this, 'User Denied') || this;

      _this.toString = function () {
        return "[" + _this.name + "]";
      };

      _this.name = 'UserDenied';
      return _this;
    }

    return UserDenied;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /** Failed to create tx (did not make a txhash) */

  var CreateTxFailed = /*#__PURE__*/function (_Error2) {
    _inheritsLoose(CreateTxFailed, _Error2);

    function CreateTxFailed(tx, message) {
      var _this2;

      _this2 = _Error2.call(this, message) || this;
      _this2.tx = tx;

      _this2.toString = function () {
        return "[" + _this2.name + " message=\"" + _this2.message + "\"]\n" + JSON.stringify(_this2.tx, null, 2);
      };

      _this2.name = 'CreateTxFailed';
      return _this2;
    }

    return CreateTxFailed;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /** Failed process the tx (maked a txhash) */

  var TxFailed = /*#__PURE__*/function (_Error3) {
    _inheritsLoose(TxFailed, _Error3);

    function TxFailed(tx, txhash, message, raw_message) {
      var _this3;

      _this3 = _Error3.call(this, message) || this;
      _this3.tx = tx;
      _this3.txhash = txhash;
      _this3.raw_message = raw_message;

      _this3.toString = function () {
        return "[" + _this3.name + " txhash=\"" + _this3.txhash + "\" message=\"" + _this3.message + "\"]\n" + JSON.stringify(_this3.tx, null, 2) + "\n" + JSON.stringify(_this3.raw_message, null, 2);
      };

      _this3.name = 'TxFailed';
      return _this3;
    }

    return TxFailed;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /** the user did not complete the action during a specific time */

  var Timeout = /*#__PURE__*/function (_Error4) {
    _inheritsLoose(Timeout, _Error4);

    function Timeout(message) {
      var _this4;

      _this4 = _Error4.call(this, message) || this;

      _this4.toString = function () {
        return "[" + _this4.name + " message=\"" + _this4.message + "\"]";
      };

      _this4.name = 'Timeout';
      return _this4;
    }

    return Timeout;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /** Unknown error */

  var TxUnspecifiedError = /*#__PURE__*/function (_Error5) {
    _inheritsLoose(TxUnspecifiedError, _Error5);

    function TxUnspecifiedError(tx, message) {
      var _this5;

      _this5 = _Error5.call(this, message) || this;
      _this5.tx = tx;

      _this5.toString = function () {
        return "[" + _this5.name + " message=\"" + _this5.message + "\"]\n" + JSON.stringify(_this5.tx, null, 2);
      };

      _this5.name = 'TxUnspecifiedError';
      return _this5;
    }

    return TxUnspecifiedError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  var WebConnectorStatusType;

  (function (WebConnectorStatusType) {
    WebConnectorStatusType["INITIALIZING"] = "initializing";
    WebConnectorStatusType["NO_AVAILABLE"] = "no_available";
    WebConnectorStatusType["READY"] = "ready";
  })(WebConnectorStatusType || (WebConnectorStatusType = {}));

  var WebConnectorTxStatus;

  (function (WebConnectorTxStatus) {
    WebConnectorTxStatus["PROGRESS"] = "PROGRESS";
    WebConnectorTxStatus["SUCCEED"] = "SUCCEED";
    WebConnectorTxStatus["FAIL"] = "FAIL";
    WebConnectorTxStatus["DENIED"] = "DENIED";
  })(WebConnectorTxStatus || (WebConnectorTxStatus = {}));

  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  var ChromeExtensionStatus;

  (function (ChromeExtensionStatus) {
    ChromeExtensionStatus["INITIALIZING"] = "INITIALIZING"; // can't using extension api

    ChromeExtensionStatus["UNAVAILABLE"] = "UNAVAILABLE"; // can using extension api, but not connected

    ChromeExtensionStatus["WALLET_NOT_CONNECTED"] = "WALLET_NOT_CONNECTED"; // session connected

    ChromeExtensionStatus["WALLET_CONNECTED"] = "WALLET_CONNECTED";
  })(ChromeExtensionStatus || (ChromeExtensionStatus = {}));

  var propTypes = {exports: {}};

  var reactIs = {exports: {}};

  var reactIs_development = {};

  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    (function () {
      // nor polyfill, then a plain number is used for performance.

      var hasSymbol = typeof Symbol === 'function' && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
      // (unstable) APIs that have been removed. Can we remove the symbols?

      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

      function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }

      function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
          var $$typeof = object.$$typeof;

          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;

              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;

                default:
                  var $$typeofType = type && type.$$typeof;

                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;

                    default:
                      return $$typeof;
                  }

              }

            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }

        return undefined;
      } // AsyncMode is deprecated along with isAsyncMode


      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }

      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }

      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }

      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }

      function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }

      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }

      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }

      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }

      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }

      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }

      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }

      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }

      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }

      reactIs_development.AsyncMode = AsyncMode;
      reactIs_development.ConcurrentMode = ConcurrentMode;
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }

  {
    reactIs.exports = reactIs_development;
  }

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */


  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      } // Detect buggy property enumeration order in older V8 versions.
      // https://bugs.chromium.org/p/v8/issues/detail?id=4118


      var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

      test1[5] = 'de';

      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


      var test2 = {};

      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }

      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
        return test2[n];
      });

      if (order2.join('') !== '0123456789') {
        return false;
      } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
        test3[letter] = letter;
      });

      if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }

      return true;
    } catch (err) {
      // We don't expect any of the above to throw, but better to be safe.
      return false;
    }
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;

    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);

      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }

      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);

        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }

    return to;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret$2 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$2;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var printWarning$1 = function printWarning() {};

  {
    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
    var loggedTypeFailures = {};
    var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);

    printWarning$1 = function printWarning(text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }
  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?Function} getStack Returns the component stack.
   * @private
   */


  function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
    {
      for (var typeSpecName in typeSpecs) {
        if (has$1(typeSpecs, typeSpecName)) {
          var error; // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.

          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');
              err.name = 'Invariant Violation';
              throw err;
            }

            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
          } catch (ex) {
            error = ex;
          }

          if (error && !(error instanceof Error)) {
            printWarning$1((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
          }

          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : '';
            printWarning$1('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
          }
        }
      }
    }
  }
  /**
   * Resets warning cache when testing.
   *
   * @private
   */


  checkPropTypes$1.resetWarningCache = function () {
    {
      loggedTypeFailures = {};
    }
  };

  var checkPropTypes_1 = checkPropTypes$1;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactIs$1 = reactIs.exports;
  var assign = objectAssign;
  var ReactPropTypesSecret = ReactPropTypesSecret_1;
  var checkPropTypes = checkPropTypes_1;
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  var printWarning = function printWarning() {};

  {
    printWarning = function printWarning(text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }

  function emptyFunctionThatReturnsNull() {
    return null;
  }

  var factoryWithTypeCheckers = function factoryWithTypeCheckers(isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */

    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }
    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */


    var ANONYMOUS = '<<anonymous>>'; // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };
    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */

    /*eslint-disable no-self-compare*/

    function is(x, y) {
      // SameValue algorithm
      if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
      }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */


    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    } // Make `instanceof Error` still work for returned errors.


    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }

      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            // New behavior only for users of `prop-types` package
            var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
            err.name = 'Invariant Violation';
            throw err;
          } else if (typeof console !== 'undefined') {
            // Old behavior for people using React.PropTypes
            var cacheKey = componentName + ':' + propName;

            if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3) {
              printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }

        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }

            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }

          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== expectedType) {
          // `propValue` being instance of, say, date/regexp, pass the 'object'
          // check, but we can offer a more precise error message here rather than
          // 'of type `object`'.
          var preciseType = getPreciseType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }

        var propValue = props[propName];

        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }

        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);

          if (error instanceof Error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!ReactIs$1.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        {
          if (arguments.length > 1) {
            printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
          } else {
            printWarning('Invalid argument supplied to oneOf, expected an array.');
          }
        }

        return emptyFunctionThatReturnsNull;
      }

      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type = getPreciseType(value);

          if (type === 'symbol') {
            return String(value);
          }

          return value;
        });
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }

        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }

        for (var key in propValue) {
          if (has(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

            if (error instanceof Error) {
              return error;
            }
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') ;
        return emptyFunctionThatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];

        if (typeof checker !== 'function') {
          printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
          return emptyFunctionThatReturnsNull;
        }
      }

      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];

          if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
            return null;
          }
        }

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }

        for (var key in shapeTypes) {
          var checker = shapeTypes[key];

          if (!checker) {
            continue;
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        } // We need to check all keys in case some are required but missing from
        // props.


        var allKeys = assign({}, props[propName], shapeTypes);

        for (var key in allKeys) {
          var checker = shapeTypes[key];

          if (!checker) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;

        case 'boolean':
          return !propValue;

        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }

          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);

          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;

            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              // Iterator will provide entry [k,v] tuples rather than values.
              while (!(step = iterator.next()).done) {
                var entry = step.value;

                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;

        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      // Native Symbol.
      if (propType === 'symbol') {
        return true;
      } // falsy value can't be a Symbol


      if (!propValue) {
        return false;
      } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'


      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      } // Fallback for non-spec compliant Symbols which are polyfilled.


      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    } // Equivalent of `typeof` but with special handling for array and regexp.


    function getPropType(propValue) {
      var propType = typeof propValue;

      if (Array.isArray(propValue)) {
        return 'array';
      }

      if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
      }

      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }

      return propType;
    } // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.


    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }

      var propType = getPropType(propValue);

      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }

      return propType;
    } // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"


    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);

      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;

        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;

        default:
          return type;
      }
    } // Returns class name of the object, if any.


    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }

      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    var ReactIs = reactIs.exports; // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod

    var throwOnDirectAccess = true;
    propTypes.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
  }

  var mode$1 = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3
  };

  var mode = mode$1;

  function QR8bitByte(data) {
    this.mode = mode.MODE_8BIT_BYTE;
    this.data = data;
  }

  QR8bitByte.prototype = {
    getLength: function getLength(buffer) {
      return this.data.length;
    },
    write: function write(buffer) {
      for (var i = 0; i < this.data.length; i++) {
        // not JIS ...
        buffer.put(this.data.charCodeAt(i), 8);
      }
    }
  };
  var _8BitByte = QR8bitByte;

  var ErrorCorrectLevel$1 = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
  };

  var ECL = ErrorCorrectLevel$1;

  function QRRSBlock(totalCount, dataCount) {
    this.totalCount = totalCount;
    this.dataCount = dataCount;
  }

  QRRSBlock.RS_BLOCK_TABLE = [// L
  // M
  // Q
  // H
  // 1
  [1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], // 2
  [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], // 3
  [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], // 4		
  [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], // 5
  [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], // 6
  [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], // 7		
  [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], // 8
  [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], // 9
  [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], // 10		
  [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], // 11
  [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], // 12
  [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], // 13
  [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], // 14
  [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], // 15
  [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], // 16
  [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], // 17
  [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], // 18
  [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], // 19
  [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], // 20
  [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], // 21
  [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], // 22
  [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], // 23
  [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], // 24
  [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], // 25
  [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], // 26
  [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], // 27
  [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], // 28
  [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], // 29
  [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], // 30
  [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], // 31
  [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], // 32
  [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], // 33
  [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], // 34
  [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], // 35
  [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], // 36
  [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], // 37
  [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], // 38
  [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], // 39
  [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], // 40
  [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];

  QRRSBlock.getRSBlocks = function (typeNumber, errorCorrectLevel) {
    var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);

    if (rsBlock == undefined) {
      throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
    }

    var length = rsBlock.length / 3;
    var list = new Array();

    for (var i = 0; i < length; i++) {
      var count = rsBlock[i * 3 + 0];
      var totalCount = rsBlock[i * 3 + 1];
      var dataCount = rsBlock[i * 3 + 2];

      for (var j = 0; j < count; j++) {
        list.push(new QRRSBlock(totalCount, dataCount));
      }
    }

    return list;
  };

  QRRSBlock.getRsBlockTable = function (typeNumber, errorCorrectLevel) {
    switch (errorCorrectLevel) {
      case ECL.L:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];

      case ECL.M:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];

      case ECL.Q:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];

      case ECL.H:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];

      default:
        return undefined;
    }
  };

  var RSBlock$1 = QRRSBlock;

  function QRBitBuffer() {
    this.buffer = new Array();
    this.length = 0;
  }

  QRBitBuffer.prototype = {
    get: function get(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    },
    put: function put(num, length) {
      for (var i = 0; i < length; i++) {
        this.putBit((num >>> length - i - 1 & 1) == 1);
      }
    },
    getLengthInBits: function getLengthInBits() {
      return this.length;
    },
    putBit: function putBit(bit) {
      var bufIndex = Math.floor(this.length / 8);

      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }

      if (bit) {
        this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
      }

      this.length++;
    }
  };
  var BitBuffer$1 = QRBitBuffer;

  var QRMath = {
    glog: function glog(n) {
      if (n < 1) {
        throw new Error("glog(" + n + ")");
      }

      return QRMath.LOG_TABLE[n];
    },
    gexp: function gexp(n) {
      while (n < 0) {
        n += 255;
      }

      while (n >= 256) {
        n -= 255;
      }

      return QRMath.EXP_TABLE[n];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256)
  };

  for (var i = 0; i < 8; i++) {
    QRMath.EXP_TABLE[i] = 1 << i;
  }

  for (var i = 8; i < 256; i++) {
    QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
  }

  for (var i = 0; i < 255; i++) {
    QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
  }

  var math$2 = QRMath;

  var math$1 = math$2;

  function QRPolynomial(num, shift) {
    if (num.length == undefined) {
      throw new Error(num.length + "/" + shift);
    }

    var offset = 0;

    while (offset < num.length && num[offset] == 0) {
      offset++;
    }

    this.num = new Array(num.length - offset + shift);

    for (var i = 0; i < num.length - offset; i++) {
      this.num[i] = num[i + offset];
    }
  }

  QRPolynomial.prototype = {
    get: function get(index) {
      return this.num[index];
    },
    getLength: function getLength() {
      return this.num.length;
    },
    multiply: function multiply(e) {
      var num = new Array(this.getLength() + e.getLength() - 1);

      for (var i = 0; i < this.getLength(); i++) {
        for (var j = 0; j < e.getLength(); j++) {
          num[i + j] ^= math$1.gexp(math$1.glog(this.get(i)) + math$1.glog(e.get(j)));
        }
      }

      return new QRPolynomial(num, 0);
    },
    mod: function mod(e) {
      if (this.getLength() - e.getLength() < 0) {
        return this;
      }

      var ratio = math$1.glog(this.get(0)) - math$1.glog(e.get(0));
      var num = new Array(this.getLength());

      for (var i = 0; i < this.getLength(); i++) {
        num[i] = this.get(i);
      }

      for (var i = 0; i < e.getLength(); i++) {
        num[i] ^= math$1.gexp(math$1.glog(e.get(i)) + ratio);
      } // recursive call


      return new QRPolynomial(num, 0).mod(e);
    }
  };
  var Polynomial$2 = QRPolynomial;

  var Mode = mode$1;
  var Polynomial$1 = Polynomial$2;
  var math = math$2;
  var QRMaskPattern = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  var QRUtil = {
    PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
    G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
    G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
    G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
    getBCHTypeInfo: function getBCHTypeInfo(data) {
      var d = data << 10;

      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d ^= QRUtil.G15 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15);
      }

      return (data << 10 | d) ^ QRUtil.G15_MASK;
    },
    getBCHTypeNumber: function getBCHTypeNumber(data) {
      var d = data << 12;

      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d ^= QRUtil.G18 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18);
      }

      return data << 12 | d;
    },
    getBCHDigit: function getBCHDigit(data) {
      var digit = 0;

      while (data != 0) {
        digit++;
        data >>>= 1;
      }

      return digit;
    },
    getPatternPosition: function getPatternPosition(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },
    getMask: function getMask(maskPattern, i, j) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i + j) % 2 == 0;

        case QRMaskPattern.PATTERN001:
          return i % 2 == 0;

        case QRMaskPattern.PATTERN010:
          return j % 3 == 0;

        case QRMaskPattern.PATTERN011:
          return (i + j) % 3 == 0;

        case QRMaskPattern.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;

        case QRMaskPattern.PATTERN101:
          return i * j % 2 + i * j % 3 == 0;

        case QRMaskPattern.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 == 0;

        case QRMaskPattern.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 == 0;

        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    },
    getErrorCorrectPolynomial: function getErrorCorrectPolynomial(errorCorrectLength) {
      var a = new Polynomial$1([1], 0);

      for (var i = 0; i < errorCorrectLength; i++) {
        a = a.multiply(new Polynomial$1([1, math.gexp(i)], 0));
      }

      return a;
    },
    getLengthInBits: function getLengthInBits(mode, type) {
      if (1 <= type && type < 10) {
        // 1 - 9
        switch (mode) {
          case Mode.MODE_NUMBER:
            return 10;

          case Mode.MODE_ALPHA_NUM:
            return 9;

          case Mode.MODE_8BIT_BYTE:
            return 8;

          case Mode.MODE_KANJI:
            return 8;

          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 27) {
        // 10 - 26
        switch (mode) {
          case Mode.MODE_NUMBER:
            return 12;

          case Mode.MODE_ALPHA_NUM:
            return 11;

          case Mode.MODE_8BIT_BYTE:
            return 16;

          case Mode.MODE_KANJI:
            return 10;

          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 41) {
        // 27 - 40
        switch (mode) {
          case Mode.MODE_NUMBER:
            return 14;

          case Mode.MODE_ALPHA_NUM:
            return 13;

          case Mode.MODE_8BIT_BYTE:
            return 16;

          case Mode.MODE_KANJI:
            return 12;

          default:
            throw new Error("mode:" + mode);
        }
      } else {
        throw new Error("type:" + type);
      }
    },
    getLostPoint: function getLostPoint(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0; // LEVEL1

      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);

          for (var r = -1; r <= 1; r++) {
            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }

            for (var c = -1; c <= 1; c++) {
              if (col + c < 0 || moduleCount <= col + c) {
                continue;
              }

              if (r == 0 && c == 0) {
                continue;
              }

              if (dark == qrCode.isDark(row + r, col + c)) {
                sameCount++;
              }
            }
          }

          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      } // LEVEL2


      for (var row = 0; row < moduleCount - 1; row++) {
        for (var col = 0; col < moduleCount - 1; col++) {
          var count = 0;
          if (qrCode.isDark(row, col)) count++;
          if (qrCode.isDark(row + 1, col)) count++;
          if (qrCode.isDark(row, col + 1)) count++;
          if (qrCode.isDark(row + 1, col + 1)) count++;

          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      } // LEVEL3


      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }

      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      } // LEVEL4


      var darkCount = 0;

      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }

      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    }
  };
  var util$1 = QRUtil;

  var BitByte = _8BitByte;
  var RSBlock = RSBlock$1;
  var BitBuffer = BitBuffer$1;
  var util = util$1;
  var Polynomial = Polynomial$2;

  function QRCode$1(typeNumber, errorCorrectLevel) {
    this.typeNumber = typeNumber;
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null;
    this.moduleCount = 0;
    this.dataCache = null;
    this.dataList = [];
  } // for client side minification


  var proto = QRCode$1.prototype;

  proto.addData = function (data) {
    var newData = new BitByte(data);
    this.dataList.push(newData);
    this.dataCache = null;
  };

  proto.isDark = function (row, col) {
    if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
      throw new Error(row + "," + col);
    }

    return this.modules[row][col];
  };

  proto.getModuleCount = function () {
    return this.moduleCount;
  };

  proto.make = function () {
    // Calculate automatically typeNumber if provided is < 1
    if (this.typeNumber < 1) {
      var typeNumber = 1;

      for (typeNumber = 1; typeNumber < 40; typeNumber++) {
        var rsBlocks = RSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
        var buffer = new BitBuffer();
        var totalDataCount = 0;

        for (var i = 0; i < rsBlocks.length; i++) {
          totalDataCount += rsBlocks[i].dataCount;
        }

        for (var i = 0; i < this.dataList.length; i++) {
          var data = this.dataList[i];
          buffer.put(data.mode, 4);
          buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
          data.write(buffer);
        }

        if (buffer.getLengthInBits() <= totalDataCount * 8) break;
      }

      this.typeNumber = typeNumber;
    }

    this.makeImpl(false, this.getBestMaskPattern());
  };

  proto.makeImpl = function (test, maskPattern) {
    this.moduleCount = this.typeNumber * 4 + 17;
    this.modules = new Array(this.moduleCount);

    for (var row = 0; row < this.moduleCount; row++) {
      this.modules[row] = new Array(this.moduleCount);

      for (var col = 0; col < this.moduleCount; col++) {
        this.modules[row][col] = null; //(col + row) % 3;
      }
    }

    this.setupPositionProbePattern(0, 0);
    this.setupPositionProbePattern(this.moduleCount - 7, 0);
    this.setupPositionProbePattern(0, this.moduleCount - 7);
    this.setupPositionAdjustPattern();
    this.setupTimingPattern();
    this.setupTypeInfo(test, maskPattern);

    if (this.typeNumber >= 7) {
      this.setupTypeNumber(test);
    }

    if (this.dataCache == null) {
      this.dataCache = QRCode$1.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
    }

    this.mapData(this.dataCache, maskPattern);
  };

  proto.setupPositionProbePattern = function (row, col) {
    for (var r = -1; r <= 7; r++) {
      if (row + r <= -1 || this.moduleCount <= row + r) continue;

      for (var c = -1; c <= 7; c++) {
        if (col + c <= -1 || this.moduleCount <= col + c) continue;

        if (0 <= r && r <= 6 && (c == 0 || c == 6) || 0 <= c && c <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {
          this.modules[row + r][col + c] = true;
        } else {
          this.modules[row + r][col + c] = false;
        }
      }
    }
  };

  proto.getBestMaskPattern = function () {
    var minLostPoint = 0;
    var pattern = 0;

    for (var i = 0; i < 8; i++) {
      this.makeImpl(true, i);
      var lostPoint = util.getLostPoint(this);

      if (i == 0 || minLostPoint > lostPoint) {
        minLostPoint = lostPoint;
        pattern = i;
      }
    }

    return pattern;
  };

  proto.createMovieClip = function (target_mc, instance_name, depth) {
    var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
    var cs = 1;
    this.make();

    for (var row = 0; row < this.modules.length; row++) {
      var y = row * cs;

      for (var col = 0; col < this.modules[row].length; col++) {
        var x = col * cs;
        var dark = this.modules[row][col];

        if (dark) {
          qr_mc.beginFill(0, 100);
          qr_mc.moveTo(x, y);
          qr_mc.lineTo(x + cs, y);
          qr_mc.lineTo(x + cs, y + cs);
          qr_mc.lineTo(x, y + cs);
          qr_mc.endFill();
        }
      }
    }

    return qr_mc;
  };

  proto.setupTimingPattern = function () {
    for (var r = 8; r < this.moduleCount - 8; r++) {
      if (this.modules[r][6] != null) {
        continue;
      }

      this.modules[r][6] = r % 2 == 0;
    }

    for (var c = 8; c < this.moduleCount - 8; c++) {
      if (this.modules[6][c] != null) {
        continue;
      }

      this.modules[6][c] = c % 2 == 0;
    }
  };

  proto.setupPositionAdjustPattern = function () {
    var pos = util.getPatternPosition(this.typeNumber);

    for (var i = 0; i < pos.length; i++) {
      for (var j = 0; j < pos.length; j++) {
        var row = pos[i];
        var col = pos[j];

        if (this.modules[row][col] != null) {
          continue;
        }

        for (var r = -2; r <= 2; r++) {
          for (var c = -2; c <= 2; c++) {
            if (r == -2 || r == 2 || c == -2 || c == 2 || r == 0 && c == 0) {
              this.modules[row + r][col + c] = true;
            } else {
              this.modules[row + r][col + c] = false;
            }
          }
        }
      }
    }
  };

  proto.setupTypeNumber = function (test) {
    var bits = util.getBCHTypeNumber(this.typeNumber);

    for (var i = 0; i < 18; i++) {
      var mod = !test && (bits >> i & 1) == 1;
      this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
    }

    for (var i = 0; i < 18; i++) {
      var mod = !test && (bits >> i & 1) == 1;
      this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
    }
  };

  proto.setupTypeInfo = function (test, maskPattern) {
    var data = this.errorCorrectLevel << 3 | maskPattern;
    var bits = util.getBCHTypeInfo(data); // vertical		

    for (var i = 0; i < 15; i++) {
      var mod = !test && (bits >> i & 1) == 1;

      if (i < 6) {
        this.modules[i][8] = mod;
      } else if (i < 8) {
        this.modules[i + 1][8] = mod;
      } else {
        this.modules[this.moduleCount - 15 + i][8] = mod;
      }
    } // horizontal


    for (var i = 0; i < 15; i++) {
      var mod = !test && (bits >> i & 1) == 1;

      if (i < 8) {
        this.modules[8][this.moduleCount - i - 1] = mod;
      } else if (i < 9) {
        this.modules[8][15 - i - 1 + 1] = mod;
      } else {
        this.modules[8][15 - i - 1] = mod;
      }
    } // fixed module


    this.modules[this.moduleCount - 8][8] = !test;
  };

  proto.mapData = function (data, maskPattern) {
    var inc = -1;
    var row = this.moduleCount - 1;
    var bitIndex = 7;
    var byteIndex = 0;

    for (var col = this.moduleCount - 1; col > 0; col -= 2) {
      if (col == 6) col--;

      while (true) {
        for (var c = 0; c < 2; c++) {
          if (this.modules[row][col - c] == null) {
            var dark = false;

            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) == 1;
            }

            var mask = util.getMask(maskPattern, row, col - c);

            if (mask) {
              dark = !dark;
            }

            this.modules[row][col - c] = dark;
            bitIndex--;

            if (bitIndex == -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }

        row += inc;

        if (row < 0 || this.moduleCount <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  };

  QRCode$1.PAD0 = 0xEC;
  QRCode$1.PAD1 = 0x11;

  QRCode$1.createData = function (typeNumber, errorCorrectLevel, dataList) {
    var rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
    var buffer = new BitBuffer();

    for (var i = 0; i < dataList.length; i++) {
      var data = dataList[i];
      buffer.put(data.mode, 4);
      buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
      data.write(buffer);
    } // calc num max data.


    var totalDataCount = 0;

    for (var i = 0; i < rsBlocks.length; i++) {
      totalDataCount += rsBlocks[i].dataCount;
    }

    if (buffer.getLengthInBits() > totalDataCount * 8) {
      throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
    } // end code


    if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
      buffer.put(0, 4);
    } // padding


    while (buffer.getLengthInBits() % 8 != 0) {
      buffer.putBit(false);
    } // padding


    while (true) {
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }

      buffer.put(QRCode$1.PAD0, 8);

      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }

      buffer.put(QRCode$1.PAD1, 8);
    }

    return QRCode$1.createBytes(buffer, rsBlocks);
  };

  QRCode$1.createBytes = function (buffer, rsBlocks) {
    var offset = 0;
    var maxDcCount = 0;
    var maxEcCount = 0;
    var dcdata = new Array(rsBlocks.length);
    var ecdata = new Array(rsBlocks.length);

    for (var r = 0; r < rsBlocks.length; r++) {
      var dcCount = rsBlocks[r].dataCount;
      var ecCount = rsBlocks[r].totalCount - dcCount;
      maxDcCount = Math.max(maxDcCount, dcCount);
      maxEcCount = Math.max(maxEcCount, ecCount);
      dcdata[r] = new Array(dcCount);

      for (var i = 0; i < dcdata[r].length; i++) {
        dcdata[r][i] = 0xff & buffer.buffer[i + offset];
      }

      offset += dcCount;
      var rsPoly = util.getErrorCorrectPolynomial(ecCount);
      var rawPoly = new Polynomial(dcdata[r], rsPoly.getLength() - 1);
      var modPoly = rawPoly.mod(rsPoly);
      ecdata[r] = new Array(rsPoly.getLength() - 1);

      for (var i = 0; i < ecdata[r].length; i++) {
        var modIndex = i + modPoly.getLength() - ecdata[r].length;
        ecdata[r][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
      }
    }

    var totalCodeCount = 0;

    for (var i = 0; i < rsBlocks.length; i++) {
      totalCodeCount += rsBlocks[i].totalCount;
    }

    var data = new Array(totalCodeCount);
    var index = 0;

    for (var i = 0; i < maxDcCount; i++) {
      for (var r = 0; r < rsBlocks.length; r++) {
        if (i < dcdata[r].length) {
          data[index++] = dcdata[r][i];
        }
      }
    }

    for (var i = 0; i < maxEcCount; i++) {
      for (var r = 0; r < rsBlocks.length; r++) {
        if (i < ecdata[r].length) {
          data[index++] = ecdata[r][i];
        }
      }
    }

    return data;
  };

  var QRCode_1 = QRCode$1;

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(source, true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var React = React__default["default"];
  var PropTypes = propTypes.exports ; // qr.js doesn't handle error level of zero (M) so we need to do it right,
  // thus the deep require.

  var QRCodeImpl = QRCode_1;
  var ErrorCorrectLevel = ErrorCorrectLevel$1; // TODO: pull this off of the QRCode class type so it matches.
  // Convert from UTF-16, forcing the use of byte-mode encoding in our QR Code.
  // This allows us to encode Hanji, Kanji, emoji, etc. Ideally we'd do more
  // detection and not resort to byte-mode if possible, but we're trading off
  // a smaller library for a smaller amount of data we can potentially encode.
  // Based on http://jonisalonen.com/2012/from-utf-16-to-utf-8-in-javascript/

  function convertStr(str) {
    var out = '';

    for (var i = 0; i < str.length; i++) {
      var charcode = str.charCodeAt(i);

      if (charcode < 0x0080) {
        out += String.fromCharCode(charcode);
      } else if (charcode < 0x0800) {
        out += String.fromCharCode(0xc0 | charcode >> 6);
        out += String.fromCharCode(0x80 | charcode & 0x3f);
      } else if (charcode < 0xd800 || charcode >= 0xe000) {
        out += String.fromCharCode(0xe0 | charcode >> 12);
        out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
        out += String.fromCharCode(0x80 | charcode & 0x3f);
      } else {
        // This is a surrogate pair, so we'll reconsitute the pieces and work
        // from that
        i++;
        charcode = 0x10000 + ((charcode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);
        out += String.fromCharCode(0xf0 | charcode >> 18);
        out += String.fromCharCode(0x80 | charcode >> 12 & 0x3f);
        out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
        out += String.fromCharCode(0x80 | charcode & 0x3f);
      }
    }

    return out;
  }

  var DEFAULT_PROPS = {
    size: 128,
    level: 'L',
    bgColor: '#FFFFFF',
    fgColor: '#000000',
    includeMargin: false
  };
  var PROP_TYPES = {
    value: PropTypes.string.isRequired,
    size: PropTypes.number,
    level: PropTypes.oneOf(['L', 'M', 'Q', 'H']),
    bgColor: PropTypes.string,
    fgColor: PropTypes.string,
    includeMargin: PropTypes.bool,
    imageSettings: PropTypes.shape({
      src: PropTypes.string.isRequired,
      height: PropTypes.number.isRequired,
      width: PropTypes.number.isRequired,
      excavate: PropTypes.bool,
      x: PropTypes.number,
      y: PropTypes.number
    })
  }  ;
  var MARGIN_SIZE = 4; // This is *very* rough estimate of max amount of QRCode allowed to be covered.
  // It is "wrong" in a lot of ways (area is a terrible way to estimate, it
  // really should be number of modules covered), but if for some reason we don't
  // get an explicit height or width, I'd rather default to something than throw.

  var DEFAULT_IMG_SCALE = 0.1;

  function generatePath(modules) {
    var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var ops = [];
    modules.forEach(function (row, y) {
      var start = null;
      row.forEach(function (cell, x) {
        if (!cell && start !== null) {
          // M0 0h7v1H0z injects the space with the move and drops the comma,
          // saving a char per operation
          ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
          start = null;
          return;
        } // end of row, clean up or skip


        if (x === row.length - 1) {
          if (!cell) {
            // We would have closed the op above already so this can only mean
            // 2+ light modules in a row.
            return;
          }

          if (start === null) {
            // Just a single dark module.
            ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
          } else {
            // Otherwise finish the current line.
            ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
          }

          return;
        }

        if (cell && start === null) {
          start = x;
        }
      });
    });
    return ops.join('');
  } // We could just do this in generatePath, except that we want to support
  // non-Path2D canvas, so we need to keep it an explicit step.


  function excavateModules(modules, excavation) {
    return modules.slice().map(function (row, y) {
      if (y < excavation.y || y >= excavation.y + excavation.h) {
        return row;
      }

      return row.map(function (cell, x) {
        if (x < excavation.x || x >= excavation.x + excavation.w) {
          return cell;
        }

        return false;
      });
    });
  }

  function getImageSettings(props, cells) {
    var imageSettings = props.imageSettings,
        size = props.size,
        includeMargin = props.includeMargin;

    if (imageSettings == null) {
      return null;
    }

    var margin = includeMargin ? MARGIN_SIZE : 0;
    var numCells = cells.length + margin * 2;
    var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
    var scale = numCells / size;
    var w = (imageSettings.width || defaultSize) * scale;
    var h = (imageSettings.height || defaultSize) * scale;
    var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
    var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
    var excavation = null;

    if (imageSettings.excavate) {
      var floorX = Math.floor(x);
      var floorY = Math.floor(y);
      var ceilW = Math.ceil(w + x - floorX);
      var ceilH = Math.ceil(h + y - floorY);
      excavation = {
        x: floorX,
        y: floorY,
        w: ceilW,
        h: ceilH
      };
    }

    return {
      x: x,
      y: y,
      h: h,
      w: w,
      excavation: excavation
    };
  } // For canvas we're going to switch our drawing mode based on whether or not
  // the environment supports Path2D. We only need the constructor to be
  // supported, but Edge doesn't actually support the path (string) type
  // argument. Luckily it also doesn't support the addPath() method. We can
  // treat that as the same thing.


  var SUPPORTS_PATH2D = function () {
    try {
      new Path2D().addPath(new Path2D());
    } catch (e) {
      return false;
    }

    return true;
  }();

  var QRCodeCanvas = /*#__PURE__*/function (_React$PureComponent) {
    _inherits(QRCodeCanvas, _React$PureComponent);

    function QRCodeCanvas() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, QRCodeCanvas);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(QRCodeCanvas)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_this), "_canvas", void 0);

      _defineProperty(_assertThisInitialized(_this), "_image", void 0);

      _defineProperty(_assertThisInitialized(_this), "state", {
        imgLoaded: false
      });

      _defineProperty(_assertThisInitialized(_this), "handleImageLoad", function () {
        _this.setState({
          imgLoaded: true
        });
      });

      return _this;
    }

    _createClass(QRCodeCanvas, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this._image && this._image.complete) {
          this.handleImageLoad();
        }

        this.update();
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        var _this$props$imageSett, _nextProps$imageSetti;

        var currentSrc = (_this$props$imageSett = this.props.imageSettings) === null || _this$props$imageSett === void 0 ? void 0 : _this$props$imageSett.src;
        var nextSrc = (_nextProps$imageSetti = nextProps.imageSettings) === null || _nextProps$imageSetti === void 0 ? void 0 : _nextProps$imageSetti.src;

        if (currentSrc !== nextSrc) {
          this.setState({
            imgLoaded: false
          });
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.update();
      }
    }, {
      key: "update",
      value: function update() {
        var _this$props = this.props,
            value = _this$props.value,
            size = _this$props.size,
            level = _this$props.level,
            bgColor = _this$props.bgColor,
            fgColor = _this$props.fgColor,
            includeMargin = _this$props.includeMargin,
            imageSettings = _this$props.imageSettings; // We'll use type===-1 to force QRCode to automatically pick the best type

        var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
        qrcode.addData(convertStr(value));
        qrcode.make();

        if (this._canvas != null) {
          var canvas = this._canvas;
          var ctx = canvas.getContext('2d');

          if (!ctx) {
            return;
          }

          var cells = qrcode.modules;

          if (cells === null) {
            return;
          }

          var margin = includeMargin ? MARGIN_SIZE : 0;
          var numCells = cells.length + margin * 2;
          var calculatedImageSettings = getImageSettings(this.props, cells);

          if (imageSettings != null && calculatedImageSettings != null) {
            if (calculatedImageSettings.excavation != null) {
              cells = excavateModules(cells, calculatedImageSettings.excavation);
            }
          } // We're going to scale this so that the number of drawable units
          // matches the number of cells. This avoids rounding issues, but does
          // result in some potentially unwanted single pixel issues between
          // blocks, only in environments that don't support Path2D.


          var pixelRatio = window.devicePixelRatio || 1;
          canvas.height = canvas.width = size * pixelRatio;
          var scale = size / numCells * pixelRatio;
          ctx.scale(scale, scale); // Draw solid background, only paint dark modules.

          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, numCells, numCells);
          ctx.fillStyle = fgColor;

          if (SUPPORTS_PATH2D) {
            // $FlowFixMe: Path2D c'tor doesn't support args yet.
            ctx.fill(new Path2D(generatePath(cells, margin)));
          } else {
            cells.forEach(function (row, rdx) {
              row.forEach(function (cell, cdx) {
                if (cell) {
                  ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
                }
              });
            });
          }

          if (this.state.imgLoaded && this._image && calculatedImageSettings != null) {
            ctx.drawImage(this._image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props2 = this.props;
            _this$props2.value;
            var size = _this$props2.size;
            _this$props2.level;
            _this$props2.bgColor;
            _this$props2.fgColor;
            var style = _this$props2.style;
            _this$props2.includeMargin;
            var imageSettings = _this$props2.imageSettings,
            otherProps = _objectWithoutProperties(_this$props2, ["value", "size", "level", "bgColor", "fgColor", "style", "includeMargin", "imageSettings"]);

        var canvasStyle = _objectSpread({
          height: size,
          width: size
        }, style);

        var img = null;
        var imgSrc = imageSettings && imageSettings.src;

        if (imageSettings != null && imgSrc != null) {
          img = React.createElement("img", {
            src: imgSrc,
            style: {
              display: 'none'
            },
            onLoad: this.handleImageLoad,
            ref: function ref(_ref) {
              return _this2._image = _ref;
            }
          });
        }

        return React.createElement(React.Fragment, null, React.createElement("canvas", _extends({
          style: canvasStyle,
          height: size,
          width: size,
          ref: function ref(_ref2) {
            return _this2._canvas = _ref2;
          }
        }, otherProps)), img);
      }
    }]);

    return QRCodeCanvas;
  }(React.PureComponent);

  _defineProperty(QRCodeCanvas, "defaultProps", DEFAULT_PROPS);

  {
    QRCodeCanvas.propTypes = PROP_TYPES ;
  }

  var QRCodeSVG = /*#__PURE__*/function (_React$PureComponent2) {
    _inherits(QRCodeSVG, _React$PureComponent2);

    function QRCodeSVG() {
      _classCallCheck(this, QRCodeSVG);

      return _possibleConstructorReturn(this, _getPrototypeOf(QRCodeSVG).apply(this, arguments));
    }

    _createClass(QRCodeSVG, [{
      key: "render",
      value: function render() {
        var _this$props3 = this.props,
            value = _this$props3.value,
            size = _this$props3.size,
            level = _this$props3.level,
            bgColor = _this$props3.bgColor,
            fgColor = _this$props3.fgColor,
            includeMargin = _this$props3.includeMargin,
            imageSettings = _this$props3.imageSettings,
            otherProps = _objectWithoutProperties(_this$props3, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]); // We'll use type===-1 to force QRCode to automatically pick the best type


        var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
        qrcode.addData(convertStr(value));
        qrcode.make();
        var cells = qrcode.modules;

        if (cells === null) {
          return null;
        }

        var margin = includeMargin ? MARGIN_SIZE : 0;
        var numCells = cells.length + margin * 2;
        var calculatedImageSettings = getImageSettings(this.props, cells);
        var image = null;

        if (imageSettings != null && calculatedImageSettings != null) {
          if (calculatedImageSettings.excavation != null) {
            cells = excavateModules(cells, calculatedImageSettings.excavation);
          }

          image = React.createElement("image", {
            xlinkHref: imageSettings.src,
            height: calculatedImageSettings.h,
            width: calculatedImageSettings.w,
            x: calculatedImageSettings.x + margin,
            y: calculatedImageSettings.y + margin,
            preserveAspectRatio: "none"
          });
        } // Drawing strategy: instead of a rect per module, we're going to create a
        // single path for the dark modules and layer that on top of a light rect,
        // for a total of 2 DOM nodes. We pay a bit more in string concat but that's
        // way faster than DOM ops.
        // For level 1, 441 nodes -> 2
        // For level 40, 31329 -> 2


        var fgPath = generatePath(cells, margin);
        return React.createElement("svg", _extends({
          shapeRendering: "crispEdges",
          height: size,
          width: size,
          viewBox: "0 0 ".concat(numCells, " ").concat(numCells)
        }, otherProps), React.createElement("path", {
          fill: bgColor,
          d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z")
        }), React.createElement("path", {
          fill: fgColor,
          d: fgPath
        }), image);
      }
    }]);

    return QRCodeSVG;
  }(React.PureComponent);

  _defineProperty(QRCodeSVG, "defaultProps", DEFAULT_PROPS);

  {
    QRCodeSVG.propTypes = PROP_TYPES ;
  }

  var QRCode = function QRCode(props) {
    var renderAs = props.renderAs,
        otherProps = _objectWithoutProperties(props, ["renderAs"]);

    var Component = renderAs === 'svg' ? QRCodeSVG : QRCodeCanvas;
    return React.createElement(Component, otherProps);
  };

  QRCode.defaultProps = _objectSpread({
    renderAs: 'canvas'
  }, DEFAULT_PROPS);
  var lib = QRCode;

  var _templateObject, _templateObject2, _templateObject3;

  function TerraQRCodeModalBase(_ref) {
    var schemeUri = _ref.schemeUri,
        className = _ref.className,
        onClose = _ref.onClose;
    var isMobile$1 = React$1.useMemo(function () {
      return isMobile();
    }, []);
    var openTerraStationMobile = React$1.useCallback(function () {
      window.location.href = schemeUri;
    }, [schemeUri]);
    return jsxRuntime.jsxs("div", Object.assign({
      className: className
    }, {
      children: [jsxRuntime.jsx("div", {
        onClick: onClose
      }, void 0), isMobile$1 ? jsxRuntime.jsxs("section", Object.assign({
        className: "mobile"
      }, {
        children: [jsxRuntime.jsx("h1", {
          children: "Wallet Connect"
        }, void 0), jsxRuntime.jsx("button", Object.assign({
          onClick: openTerraStationMobile,
          className: "flat-button"
        }, {
          children: "Open Terra Station Mobile"
        }), void 0)]
      }), void 0) : jsxRuntime.jsxs("section", Object.assign({
        className: "desktop"
      }, {
        children: [jsxRuntime.jsx("h1", {
          children: "Wallet Connect"
        }, void 0), jsxRuntime.jsx(lib, {
          value: schemeUri,
          size: 240
        }, void 0)]
      }), void 0)]
    }), void 0);
  }

  var modalEnter = Ue(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["\n  0% {\n    opacity: 0;\n  }\n  \n  100% {\n    opacity: 1;\n  }\n"])));
  var sectionEnter = Ue(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose(["\n  0% {\n    opacity: 0;\n    transform: scale(0.4);\n  }\n  \n  100% {\n    opacity: 1;\n    transform: scale(1);\n  }\n"])));
  styled(TerraQRCodeModalBase)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteralLoose(["\n  position: fixed;\n  z-index: 100000;\n\n  color: #000000;\n\n  left: 0;\n  top: 0;\n  width: 100vw;\n  height: 100vh;\n\n  display: grid;\n  place-content: center;\n\n  > div {\n    position: fixed;\n    z-index: -1;\n\n    left: 0;\n    top: 0;\n    width: 100vw;\n    height: 100vh;\n    background-color: rgba(0, 0, 0, 0.3);\n\n    animation: ", " 0.2s ease-in-out;\n  }\n\n  > section {\n    border-radius: 25px;\n\n    background-color: #ffffff;\n    box-shadow: 0 4px 18px 3px rgba(0, 0, 0, 0.43);\n\n    animation: ", " 0.2s ease-in-out;\n\n    button {\n      cursor: pointer;\n\n      display: block;\n      outline: none;\n      background-color: transparent;\n      width: 100%;\n      height: 32px;\n      font-size: 13px;\n      letter-spacing: -0.2px;\n      border-radius: 18px;\n      border: solid 1px #2c2c2c;\n\n      &.flat-button {\n        border: 0;\n        color: #ffffff;\n        background-color: #2c2c2c;\n      }\n    }\n\n    .separator {\n      height: 12px;\n\n      position: relative;\n\n      hr {\n        position: absolute;\n        top: 5px;\n        left: 0;\n        right: 0;\n\n        border: 0;\n        border-bottom: 1px dashed #cccccc;\n      }\n\n      span {\n        display: block;\n\n        position: absolute;\n        top: -4px;\n        left: 50%;\n        transform: translateX(-50%);\n\n        font-size: 12px;\n        color: #c2c2c2;\n        background-color: #ffffff;\n        padding: 0 2px;\n      }\n    }\n\n    &.desktop {\n      padding: 50px 60px;\n\n      h1 {\n        font-size: 27px;\n        font-weight: 500;\n\n        text-align: center;\n\n        margin-bottom: 24px;\n      }\n\n      button {\n        margin-top: 20px;\n      }\n    }\n\n    &.mobile {\n      padding: 40px 30px;\n      min-width: 320px;\n\n      h1 {\n        font-size: 22px;\n        font-weight: 500;\n\n        text-align: center;\n\n        margin-bottom: 30px;\n      }\n\n      .separator {\n        margin: 10px 0;\n      }\n\n      canvas {\n        display: block;\n        margin: 16px auto 0 auto;\n      }\n    }\n  }\n"])), modalEnter, sectionEnter);

  var cjs$8 = {};

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }

    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter$3(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  }
  var __createBinding = Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  };
  function __exportStar(m, o) {
    for (var p in m) {
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function next() {
        if (o && i >= o.length) o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;

    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
        ar.push(r.value);
      }
    } catch (error) {
      e = {
        error: error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }

    return ar;
  }
  /** @deprecated */

  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) {
      ar = ar.concat(__read(arguments[i]));
    }

    return ar;
  }
  /** @deprecated */

  function __spreadArrays$1() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
      s += arguments[i].length;
    }

    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
        r[k] = a[j];
      }
    }

    return r;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []),
        i,
        q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i;

    function verb(n) {
      if (g[n]) i[n] = function (v) {
        return new Promise(function (a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }

    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }

    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }

    function fulfill(value) {
      resume("next", value);
    }

    function reject(value) {
      resume("throw", value);
    }

    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function () {
      return this;
    }, i;

    function verb(n, f) {
      i[n] = o[n] ? function (v) {
        return (p = !p) ? {
          value: __await(o[n](v)),
          done: n === "return"
        } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
        i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i);

    function verb(n) {
      i[n] = o[n] && function (v) {
        return new Promise(function (resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }

    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({
          value: v,
          done: d
        });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", {
        value: raw
      });
    } else {
      cooked.raw = raw;
    }

    return cooked;
  }

  var __setModuleDefault = Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  };

  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }

    __setModuleDefault(result, mod);

    return result;
  }
  function __importDefault$3(mod) {
    return mod && mod.__esModule ? mod : {
      default: mod
    };
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  }

  var tslib_es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    __extends: __extends,
    get __assign () { return _assign; },
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __metadata: __metadata,
    __awaiter: __awaiter$3,
    __generator: __generator,
    __createBinding: __createBinding,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays$1,
    __spreadArray: __spreadArray,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault$3,
    __classPrivateFieldGet: __classPrivateFieldGet,
    __classPrivateFieldSet: __classPrivateFieldSet
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(tslib_es6);

  var cjs$7 = {};

  var cjs$6 = {};

  var browser = {};

  var cjs$5 = {};

  var cjs$4 = {};

  Object.defineProperty(cjs$4, "__esModule", {
    value: true
  });
  cjs$4.getLocalStorage = cjs$4.getLocalStorageOrThrow = cjs$4.getCrypto = cjs$4.getCryptoOrThrow = cjs$4.getLocation = cjs$4.getLocationOrThrow = cjs$4.getNavigator = cjs$4.getNavigatorOrThrow = cjs$4.getDocument = cjs$4.getDocumentOrThrow = cjs$4.getFromWindowOrThrow = cjs$4.getFromWindow = void 0;

  function getFromWindow(name) {
    var res = undefined;

    if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
      res = window[name];
    }

    return res;
  }

  cjs$4.getFromWindow = getFromWindow;

  function getFromWindowOrThrow(name) {
    var res = getFromWindow(name);

    if (!res) {
      throw new Error(name + " is not defined in Window");
    }

    return res;
  }

  cjs$4.getFromWindowOrThrow = getFromWindowOrThrow;

  function getDocumentOrThrow() {
    return getFromWindowOrThrow("document");
  }

  cjs$4.getDocumentOrThrow = getDocumentOrThrow;

  function getDocument() {
    return getFromWindow("document");
  }

  cjs$4.getDocument = getDocument;

  function getNavigatorOrThrow() {
    return getFromWindowOrThrow("navigator");
  }

  cjs$4.getNavigatorOrThrow = getNavigatorOrThrow;

  function getNavigator() {
    return getFromWindow("navigator");
  }

  cjs$4.getNavigator = getNavigator;

  function getLocationOrThrow() {
    return getFromWindowOrThrow("location");
  }

  cjs$4.getLocationOrThrow = getLocationOrThrow;

  function getLocation() {
    return getFromWindow("location");
  }

  cjs$4.getLocation = getLocation;

  function getCryptoOrThrow() {
    return getFromWindowOrThrow("crypto");
  }

  cjs$4.getCryptoOrThrow = getCryptoOrThrow;

  function getCrypto() {
    return getFromWindow("crypto");
  }

  cjs$4.getCrypto = getCrypto;

  function getLocalStorageOrThrow() {
    return getFromWindowOrThrow("localStorage");
  }

  cjs$4.getLocalStorageOrThrow = getLocalStorageOrThrow;

  function getLocalStorage() {
    return getFromWindow("localStorage");
  }

  cjs$4.getLocalStorage = getLocalStorage;

  Object.defineProperty(cjs$5, "__esModule", {
    value: true
  });
  cjs$5.getWindowMetadata = void 0;
  var window_getters_1 = cjs$4;

  function getWindowMetadata() {
    var doc;
    var loc;

    try {
      doc = window_getters_1.getDocumentOrThrow();
      loc = window_getters_1.getLocationOrThrow();
    } catch (e) {
      return null;
    }

    function getIcons() {
      var links = doc.getElementsByTagName("link");
      var icons = [];

      for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var rel = link.getAttribute("rel");

        if (rel) {
          if (rel.toLowerCase().indexOf("icon") > -1) {
            var href = link.getAttribute("href");

            if (href) {
              if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                var absoluteHref = loc.protocol + "//" + loc.host;

                if (href.indexOf("/") === 0) {
                  absoluteHref += href;
                } else {
                  var path = loc.pathname.split("/");
                  path.pop();
                  var finalPath = path.join("/");
                  absoluteHref += finalPath + "/" + href;
                }

                icons.push(absoluteHref);
              } else if (href.indexOf("//") === 0) {
                var absoluteUrl = loc.protocol + href;
                icons.push(absoluteUrl);
              } else {
                icons.push(href);
              }
            }
          }
        }
      }

      return icons;
    }

    function getWindowMetadataOfAny() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var metaTags = doc.getElementsByTagName("meta");

      var _loop = function _loop(i) {
        var tag = metaTags[i];
        var attributes = ["itemprop", "property", "name"].map(function (target) {
          return tag.getAttribute(target);
        }).filter(function (attr) {
          if (attr) {
            return args.includes(attr);
          }

          return false;
        });

        if (attributes.length && attributes) {
          var content = tag.getAttribute("content");

          if (content) {
            return {
              v: content
            };
          }
        }
      };

      for (var i = 0; i < metaTags.length; i++) {
        var _ret = _loop(i);

        if (typeof _ret === "object") return _ret.v;
      }

      return "";
    }

    function getName() {
      var name = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");

      if (!name) {
        name = doc.title;
      }

      return name;
    }

    function getDescription() {
      var description = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
      return description;
    }

    var name = getName();
    var description = getDescription();
    var url = loc.origin;
    var icons = getIcons();
    var meta = {
      description: description,
      url: url,
      icons: icons,
      name: name
    };
    return meta;
  }

  cjs$5.getWindowMetadata = getWindowMetadata;

  var __spreadArrays = undefined && undefined.__spreadArrays || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
      s += arguments[i].length;
    }

    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
        r[k] = a[j];
      }
    }

    return r;
  };

  var BrowserInfo =
  /** @class */
  function () {
    function BrowserInfo(name, version, os) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.type = 'browser';
    }

    return BrowserInfo;
  }();

  var NodeInfo =
  /** @class */
  function () {
    function NodeInfo(version) {
      this.version = version;
      this.type = 'node';
      this.name = 'node';
      this.os = process.platform;
    }

    return NodeInfo;
  }();

  var SearchBotDeviceInfo =
  /** @class */
  function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.bot = bot;
      this.type = 'bot-device';
    }

    return SearchBotDeviceInfo;
  }();

  var BotInfo =
  /** @class */
  function () {
    function BotInfo() {
      this.type = 'bot';
      this.bot = true; // NOTE: deprecated test name instead

      this.name = 'bot';
      this.version = null;
      this.os = null;
    }

    return BotInfo;
  }();

  var ReactNativeInfo =
  /** @class */
  function () {
    function ReactNativeInfo() {
      this.type = 'react-native';
      this.name = 'react-native';
      this.version = null;
      this.os = null;
    }

    return ReactNativeInfo;
  }();

  var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
  var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
  var REQUIRED_VERSION_PARTS = 3;
  var userAgentRules = [['aol', /AOLShield\/([0-9\._]+)/], ['edge', /Edge\/([0-9\._]+)/], ['edge-ios', /EdgiOS\/([0-9\._]+)/], ['yandexbrowser', /YaBrowser\/([0-9\._]+)/], ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/], ['samsung', /SamsungBrowser\/([0-9\.]+)/], ['silk', /\bSilk\/([0-9._-]+)\b/], ['miui', /MiuiBrowser\/([0-9\.]+)$/], ['beaker', /BeakerBrowser\/([0-9\.]+)/], ['edge-chromium', /EdgA?\/([0-9\.]+)/], ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/], ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/], ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/], ['fxios', /FxiOS\/([0-9\.]+)/], ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/], ['opera', /Opera\/([0-9\.]+)(?:\s|$)/], ['opera', /OPR\/([0-9\.]+)(:?\s|$)/], ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ['ie', /MSIE\s(7\.0)/], ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/], ['android', /Android\s([0-9\.]+)/], ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/], ['safari', /Version\/([0-9\._]+).*Safari/], ['facebook', /FBAV\/([0-9\.]+)/], ['instagram', /Instagram\s([0-9\.]+)/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ['searchbot', SEARCHBOX_UA_REGEX]];
  var operatingSystemRules = [['iOS', /iP(hone|od|ad)/], ['Android OS', /Android/], ['BlackBerry OS', /BlackBerry|BB10/], ['Windows Mobile', /IEMobile/], ['Amazon OS', /Kindle/], ['Windows 3.11', /Win16/], ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/], ['Windows 98', /(Windows 98)|(Win98)/], ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/], ['Windows XP', /(Windows NT 5.1)|(Windows XP)/], ['Windows Server 2003', /(Windows NT 5.2)/], ['Windows Vista', /(Windows NT 6.0)/], ['Windows 7', /(Windows NT 6.1)/], ['Windows 8', /(Windows NT 6.2)/], ['Windows 8.1', /(Windows NT 6.3)/], ['Windows 10', /(Windows NT 10.0)/], ['Windows ME', /Windows ME/], ['Open BSD', /OpenBSD/], ['Sun OS', /SunOS/], ['Chrome OS', /CrOS/], ['Linux', /(Linux)|(X11)/], ['Mac OS', /(Mac_PowerPC)|(Macintosh)/], ['QNX', /QNX/], ['BeOS', /BeOS/], ['OS/2', /OS\/2/]];
  function detect(userAgent) {
    if (!!userAgent) {
      return parseUserAgent(userAgent);
    }

    if (typeof document === 'undefined' && typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
      return new ReactNativeInfo();
    }

    if (typeof navigator !== 'undefined') {
      return parseUserAgent(navigator.userAgent);
    }

    return getNodeVersion();
  }

  function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return ua !== '' && userAgentRules.reduce(function (matched, _a) {
      var browser = _a[0],
          regex = _a[1];

      if (matched) {
        return matched;
      }

      var uaMatch = regex.exec(ua);
      return !!uaMatch && [browser, uaMatch];
    }, false);
  }

  function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
  }
  function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);

    if (!matchedRule) {
      return null;
    }

    var name = matchedRule[0],
        match = matchedRule[1];

    if (name === 'searchbot') {
      return new BotInfo();
    }

    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);

    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS) {
        versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
      }
    } else {
      versionParts = [];
    }

    var version = versionParts.join('.');
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);

    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }

    return new BrowserInfo(name, version, os);
  }
  function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
      var _a = operatingSystemRules[ii],
          os = _a[0],
          regex = _a[1];
      var match = regex.exec(ua);

      if (match) {
        return os;
      }
    }

    return null;
  }
  function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
  }

  function createVersionParts(count) {
    var output = [];

    for (var ii = 0; ii < count; ii++) {
      output.push('0');
    }

    return output;
  }

  var es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BrowserInfo: BrowserInfo,
    NodeInfo: NodeInfo,
    SearchBotDeviceInfo: SearchBotDeviceInfo,
    BotInfo: BotInfo,
    ReactNativeInfo: ReactNativeInfo,
    detect: detect,
    browserName: browserName,
    parseUserAgent: parseUserAgent,
    detectOS: detectOS,
    getNodeVersion: getNodeVersion
  });

  var require$$3 = /*@__PURE__*/getAugmentedNamespace(es);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getClientMeta = exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = exports.isBrowser = exports.isNode = exports.isMobile = exports.isIOS = exports.isAndroid = exports.detectOS = exports.detectEnv = void 0;
    var tslib_1 = require$$0;
    var windowMetadata = (0, tslib_1.__importStar)(cjs$5);
    var windowGetters = (0, tslib_1.__importStar)(cjs$4);
    var detect_browser_1 = require$$3;

    function detectEnv(userAgent) {
      return (0, detect_browser_1.detect)(userAgent);
    }

    exports.detectEnv = detectEnv;

    function detectOS() {
      var env = detectEnv();
      return env && env.os ? env.os : undefined;
    }

    exports.detectOS = detectOS;

    function isAndroid() {
      var os = detectOS();
      return os ? os.toLowerCase().includes("android") : false;
    }

    exports.isAndroid = isAndroid;

    function isIOS() {
      var os = detectOS();
      return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
    }

    exports.isIOS = isIOS;

    function isMobile() {
      var os = detectOS();
      return os ? isAndroid() || isIOS() : false;
    }

    exports.isMobile = isMobile;

    function isNode() {
      var env = detectEnv();
      var result = env && env.name ? env.name.toLowerCase() === "node" : false;
      return result;
    }

    exports.isNode = isNode;

    function isBrowser() {
      var result = !isNode() && !!(0, exports.getNavigator)();
      return result;
    }

    exports.isBrowser = isBrowser;
    exports.getFromWindow = windowGetters.getFromWindow;
    exports.getFromWindowOrThrow = windowGetters.getFromWindowOrThrow;
    exports.getDocumentOrThrow = windowGetters.getDocumentOrThrow;
    exports.getDocument = windowGetters.getDocument;
    exports.getNavigatorOrThrow = windowGetters.getNavigatorOrThrow;
    exports.getNavigator = windowGetters.getNavigator;
    exports.getLocationOrThrow = windowGetters.getLocationOrThrow;
    exports.getLocation = windowGetters.getLocation;
    exports.getCryptoOrThrow = windowGetters.getCryptoOrThrow;
    exports.getCrypto = windowGetters.getCrypto;
    exports.getLocalStorageOrThrow = windowGetters.getLocalStorageOrThrow;
    exports.getLocalStorage = windowGetters.getLocalStorage;

    function getClientMeta() {
      return windowMetadata.getWindowMetadata();
    }

    exports.getClientMeta = getClientMeta;
  })(browser);

  var json = {};

  function safeJsonParse(value) {
    if (typeof value !== "string") {
      throw new Error("Cannot safe json parse value of type " + typeof value);
    }

    try {
      return JSON.parse(value);
    } catch (_a) {
      return value;
    }
  }
  function safeJsonStringify(value) {
    return typeof value === "string" ? value : JSON.stringify(value);
  }

  var esm$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    safeJsonParse: safeJsonParse,
    safeJsonStringify: safeJsonStringify
  });

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(esm$1);

  Object.defineProperty(json, "__esModule", {
    value: true
  });
  json.safeJsonStringify = json.safeJsonParse = void 0;
  var tslib_1$8 = require$$0;
  var safeJson = (0, tslib_1$8.__importStar)(require$$1);
  json.safeJsonParse = safeJson.safeJsonParse;
  json.safeJsonStringify = safeJson.safeJsonStringify;

  var local = {};

  Object.defineProperty(local, "__esModule", {
    value: true
  });
  local.removeLocal = local.getLocal = local.setLocal = void 0;
  var json_1 = json;
  var browser_1 = browser;

  function setLocal(key, data) {
    var raw = (0, json_1.safeJsonStringify)(data);
    var local = (0, browser_1.getLocalStorage)();

    if (local) {
      local.setItem(key, raw);
    }
  }

  local.setLocal = setLocal;

  function getLocal(key) {
    var data = null;
    var raw = null;
    var local = (0, browser_1.getLocalStorage)();

    if (local) {
      raw = local.getItem(key);
    }

    data = raw ? (0, json_1.safeJsonParse)(raw) : raw;
    return data;
  }

  local.getLocal = getLocal;

  function removeLocal(key) {
    var local = (0, browser_1.getLocalStorage)();

    if (local) {
      local.removeItem(key);
    }
  }

  local.removeLocal = removeLocal;

  var mobile = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getMobileLinkRegistry = exports.getMobileRegistryEntry = exports.saveMobileLinkInfo = exports.formatIOSMobile = exports.mobileLinkChoiceKey = void 0;
    var local_1 = local;
    exports.mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";

    function formatIOSMobile(uri, entry) {
      var encodedUri = encodeURIComponent(uri);
      return entry.universalLink ? entry.universalLink + "/wc?uri=" + encodedUri : entry.deepLink ? "" + entry.deepLink + (entry.deepLink.endsWith(":") ? "//" : "/") + "wc?uri=" + encodedUri : "";
    }

    exports.formatIOSMobile = formatIOSMobile;

    function saveMobileLinkInfo(data) {
      var focusUri = data.href.split("?")[0];
      (0, local_1.setLocal)(exports.mobileLinkChoiceKey, Object.assign(Object.assign({}, data), {
        href: focusUri
      }));
    }

    exports.saveMobileLinkInfo = saveMobileLinkInfo;

    function getMobileRegistryEntry(registry, name) {
      return registry.filter(function (entry) {
        return entry.name.toLowerCase().includes(name.toLowerCase());
      })[0];
    }

    exports.getMobileRegistryEntry = getMobileRegistryEntry;

    function getMobileLinkRegistry(registry, whitelist) {
      var links = registry;

      if (whitelist) {
        links = whitelist.map(function (name) {
          return getMobileRegistryEntry(registry, name);
        }).filter(Boolean);
      }

      return links;
    }

    exports.getMobileLinkRegistry = getMobileLinkRegistry;
  })(mobile);

  var registry = {};

  Object.defineProperty(registry, "__esModule", {
    value: true
  });
  registry.formatMobileRegistry = registry.formatMobileRegistryEntry = registry.getAppLogoUrl = registry.getDappRegistryUrl = registry.getWalletRegistryUrl = void 0;
  var API_URL = "https://registry.walletconnect.org";

  function getWalletRegistryUrl() {
    return API_URL + "/data/wallets.json";
  }

  registry.getWalletRegistryUrl = getWalletRegistryUrl;

  function getDappRegistryUrl() {
    return API_URL + "/data/dapps.json";
  }

  registry.getDappRegistryUrl = getDappRegistryUrl;

  function getAppLogoUrl(id) {
    return API_URL + "/logo/sm/" + id + ".jpeg";
  }

  registry.getAppLogoUrl = getAppLogoUrl;

  function formatMobileRegistryEntry(entry, platform) {
    if (platform === void 0) {
      platform = "mobile";
    }

    return {
      name: entry.name || "",
      shortName: entry.metadata.shortName || "",
      color: entry.metadata.colors.primary || "",
      logo: entry.id ? getAppLogoUrl(entry.id) : "",
      universalLink: entry[platform].universal || "",
      deepLink: entry[platform].native || ""
    };
  }

  registry.formatMobileRegistryEntry = formatMobileRegistryEntry;

  function formatMobileRegistry(registry, platform) {
    if (platform === void 0) {
      platform = "mobile";
    }

    return Object.values(registry).filter(function (entry) {
      return !!entry[platform].universal || !!entry[platform].native;
    }).map(function (entry) {
      return formatMobileRegistryEntry(entry, platform);
    });
  }

  registry.formatMobileRegistry = formatMobileRegistry;

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var tslib_1 = require$$0;
    (0, tslib_1.__exportStar)(browser, exports);
    (0, tslib_1.__exportStar)(json, exports);
    (0, tslib_1.__exportStar)(local, exports);
    (0, tslib_1.__exportStar)(mobile, exports);
    (0, tslib_1.__exportStar)(registry, exports);
  })(cjs$6);

  var constants$2 = {};

  Object.defineProperty(constants$2, "__esModule", {
    value: true
  });
  constants$2.infuraNetworks = constants$2.stateMethods = constants$2.signingMethods = constants$2.reservedEvents = void 0;
  constants$2.reservedEvents = ["session_request", "session_update", "exchange_key", "connect", "disconnect", "display_uri", "modal_closed", "transport_open", "transport_close", "transport_error"];
  constants$2.signingMethods = ["eth_sendTransaction", "eth_signTransaction", "eth_sign", "eth_signTypedData", "eth_signTypedData_v1", "eth_signTypedData_v2", "eth_signTypedData_v3", "eth_signTypedData_v4", "personal_sign"];
  constants$2.stateMethods = ["eth_accounts", "eth_chainId", "net_version"];
  constants$2.infuraNetworks = {
    1: "mainnet",
    3: "ropsten",
    4: "rinkeby",
    5: "goerli",
    42: "kovan"
  };

  var encoding$5 = {};

  var cjs$3 = {};

  var isTypedarray = isTypedArray$3;
  isTypedArray$3.strict = isStrictTypedArray;
  isTypedArray$3.loose = isLooseTypedArray;
  var toString = Object.prototype.toString;
  var names = {
    '[object Int8Array]': true,
    '[object Int16Array]': true,
    '[object Int32Array]': true,
    '[object Uint8Array]': true,
    '[object Uint8ClampedArray]': true,
    '[object Uint16Array]': true,
    '[object Uint32Array]': true,
    '[object Float32Array]': true,
    '[object Float64Array]': true
  };

  function isTypedArray$3(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
  }

  function isStrictTypedArray(arr) {
    return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
  }

  function isLooseTypedArray(arr) {
    return names[toString.call(arr)];
  }

  /**
   * Convert a typed array to a Buffer without a copy
   *
   * Author:   Feross Aboukhadijeh <https://feross.org>
   * License:  MIT
   *
   * `npm install typedarray-to-buffer`
   */
  var isTypedArray$2 = isTypedarray.strict;

  var typedarrayToBuffer = function typedarrayToBuffer(arr) {
    if (isTypedArray$2(arr)) {
      // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
      var buf = Buffer.from(arr.buffer);

      if (arr.byteLength !== arr.buffer.byteLength) {
        // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
        buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
      }

      return buf;
    } else {
      // Pass through all other types to `Buffer.from`
      return Buffer.from(arr);
    }
  };

  var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(cjs$3, "__esModule", {
    value: true
  });
  cjs$3.removeHexLeadingZeros = cjs$3.sanitizeHex = cjs$3.addHexPrefix = cjs$3.removeHexPrefix = cjs$3.padRight = cjs$3.padLeft = cjs$3.sanitizeBytes = cjs$3.swapHex = cjs$3.swapBytes = cjs$3.splitBytes = cjs$3.calcByteLength = cjs$3.trimRight = cjs$3.trimLeft = cjs$3.concatArrays = cjs$3.concatBuffers = cjs$3.getEncoding = cjs$3.getType = cjs$3.isArrayBuffer = cjs$3.isTypedArray = cjs$3.isBuffer = cjs$3.isHexString = cjs$3.isBinaryString = cjs$3.binaryToNumber = cjs$3.binaryToUtf8 = cjs$3.binaryToHex = cjs$3.binaryToArray = cjs$3.binaryToBuffer = cjs$3.numberToBinary = cjs$3.numberToUtf8 = cjs$3.numberToHex = cjs$3.numberToArray = cjs$3.numberToBuffer = cjs$3.utf8ToBinary = cjs$3.utf8ToNumber = cjs$3.utf8ToHex = cjs$3.utf8ToArray = cjs$3.utf8ToBuffer = cjs$3.hexToBinary = cjs$3.hexToNumber = cjs$3.hexToUtf8 = cjs$3.hexToArray = cjs$3.hexToBuffer = cjs$3.arrayToBinary = cjs$3.arrayToNumber = cjs$3.arrayToUtf8 = cjs$3.arrayToHex = cjs$3.arrayToBuffer = cjs$3.bufferToBinary = cjs$3.bufferToNumber = cjs$3.bufferToUtf8 = cjs$3.bufferToHex = cjs$3.bufferToArray = void 0;

  var is_typedarray_1 = __importDefault$2(isTypedarray);

  var typedarray_to_buffer_1 = __importDefault$2(typedarrayToBuffer);

  var ENC_HEX = "hex";
  var ENC_UTF8 = "utf8";
  var ENC_BIN = "binary";
  var TYPE_BUFFER = "buffer";
  var TYPE_ARRAY = "array";
  var TYPE_TYPED_ARRAY = "typed-array";
  var TYPE_ARRAY_BUFFER = "array-buffer";
  var STRING_ZERO = "0";

  function bufferToArray(buf) {
    return new Uint8Array(buf);
  }

  cjs$3.bufferToArray = bufferToArray;

  function bufferToHex(buf, prefixed) {
    if (prefixed === void 0) {
      prefixed = false;
    }

    var hex = buf.toString(ENC_HEX);
    return prefixed ? addHexPrefix$1(hex) : hex;
  }

  cjs$3.bufferToHex = bufferToHex;

  function bufferToUtf8(buf) {
    return buf.toString(ENC_UTF8);
  }

  cjs$3.bufferToUtf8 = bufferToUtf8;

  function bufferToNumber(buf) {
    return buf.readUIntBE(0, buf.length);
  }

  cjs$3.bufferToNumber = bufferToNumber;

  function bufferToBinary(buf) {
    return arrayToBinary(bufferToArray(buf));
  }

  cjs$3.bufferToBinary = bufferToBinary;

  function arrayToBuffer(arr) {
    return typedarray_to_buffer_1.default(arr);
  }

  cjs$3.arrayToBuffer = arrayToBuffer;

  function arrayToHex(arr, prefixed) {
    if (prefixed === void 0) {
      prefixed = false;
    }

    return bufferToHex(arrayToBuffer(arr), prefixed);
  }

  cjs$3.arrayToHex = arrayToHex;

  function arrayToUtf8(arr) {
    return bufferToUtf8(arrayToBuffer(arr));
  }

  cjs$3.arrayToUtf8 = arrayToUtf8;

  function arrayToNumber(arr) {
    return bufferToNumber(arrayToBuffer(arr));
  }

  cjs$3.arrayToNumber = arrayToNumber;

  function arrayToBinary(arr) {
    return Array.from(arr).map(numberToBinary).join("");
  }

  cjs$3.arrayToBinary = arrayToBinary;

  function hexToBuffer(hex) {
    return Buffer.from(removeHexPrefix$1(hex), ENC_HEX);
  }

  cjs$3.hexToBuffer = hexToBuffer;

  function hexToArray(hex) {
    return bufferToArray(hexToBuffer(hex));
  }

  cjs$3.hexToArray = hexToArray;

  function hexToUtf8(hex) {
    return bufferToUtf8(hexToBuffer(hex));
  }

  cjs$3.hexToUtf8 = hexToUtf8;

  function hexToNumber(hex) {
    return arrayToNumber(hexToArray(hex));
  }

  cjs$3.hexToNumber = hexToNumber;

  function hexToBinary(hex) {
    return arrayToBinary(hexToArray(hex));
  }

  cjs$3.hexToBinary = hexToBinary;

  function utf8ToBuffer(utf8) {
    return Buffer.from(utf8, ENC_UTF8);
  }

  cjs$3.utf8ToBuffer = utf8ToBuffer;

  function utf8ToArray(utf8) {
    return bufferToArray(utf8ToBuffer(utf8));
  }

  cjs$3.utf8ToArray = utf8ToArray;

  function utf8ToHex(utf8, prefixed) {
    if (prefixed === void 0) {
      prefixed = false;
    }

    return bufferToHex(utf8ToBuffer(utf8), prefixed);
  }

  cjs$3.utf8ToHex = utf8ToHex;

  function utf8ToNumber(utf8) {
    var num = parseInt(utf8, 10);
    assert$1(isDefined(num), "Number can only safely store up to 53 bits");
    return num;
  }

  cjs$3.utf8ToNumber = utf8ToNumber;

  function utf8ToBinary(utf8) {
    return arrayToBinary(utf8ToArray(utf8));
  }

  cjs$3.utf8ToBinary = utf8ToBinary;

  function numberToBuffer(num) {
    return binaryToBuffer(numberToBinary(num));
  }

  cjs$3.numberToBuffer = numberToBuffer;

  function numberToArray(num) {
    return binaryToArray(numberToBinary(num));
  }

  cjs$3.numberToArray = numberToArray;

  function numberToHex(num, prefixed) {
    return binaryToHex(numberToBinary(num), prefixed);
  }

  cjs$3.numberToHex = numberToHex;

  function numberToUtf8(num) {
    return "" + num;
  }

  cjs$3.numberToUtf8 = numberToUtf8;

  function numberToBinary(num) {
    var bin = (num >>> 0).toString(2);
    return sanitizeBytes(bin);
  }

  cjs$3.numberToBinary = numberToBinary;

  function binaryToBuffer(bin) {
    return arrayToBuffer(binaryToArray(bin));
  }

  cjs$3.binaryToBuffer = binaryToBuffer;

  function binaryToArray(bin) {
    return new Uint8Array(splitBytes(bin).map(function (x) {
      return parseInt(x, 2);
    }));
  }

  cjs$3.binaryToArray = binaryToArray;

  function binaryToHex(bin, prefixed) {
    return arrayToHex(binaryToArray(bin), prefixed);
  }

  cjs$3.binaryToHex = binaryToHex;

  function binaryToUtf8(bin) {
    return arrayToUtf8(binaryToArray(bin));
  }

  cjs$3.binaryToUtf8 = binaryToUtf8;

  function binaryToNumber(bin) {
    return arrayToNumber(binaryToArray(bin));
  }

  cjs$3.binaryToNumber = binaryToNumber;

  function isBinaryString(str) {
    if (typeof str !== "string" || !new RegExp(/^[01]+$/).test(str)) {
      return false;
    }

    if (str.length % 8 !== 0) {
      return false;
    }

    return true;
  }

  cjs$3.isBinaryString = isBinaryString;

  function isHexString$1(str, length) {
    if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }

    if (length && str.length !== 2 + 2 * length) {
      return false;
    }

    return true;
  }

  cjs$3.isHexString = isHexString$1;

  function isBuffer$1(val) {
    return Buffer.isBuffer(val);
  }

  cjs$3.isBuffer = isBuffer$1;

  function isTypedArray$1(val) {
    return is_typedarray_1.default.strict(val) && !isBuffer$1(val);
  }

  cjs$3.isTypedArray = isTypedArray$1;

  function isArrayBuffer$1(val) {
    return !isTypedArray$1(val) && !isBuffer$1(val) && typeof val.byteLength !== "undefined";
  }

  cjs$3.isArrayBuffer = isArrayBuffer$1;

  function getType$1(val) {
    if (isBuffer$1(val)) {
      return TYPE_BUFFER;
    } else if (isTypedArray$1(val)) {
      return TYPE_TYPED_ARRAY;
    } else if (isArrayBuffer$1(val)) {
      return TYPE_ARRAY_BUFFER;
    } else if (Array.isArray(val)) {
      return TYPE_ARRAY;
    } else {
      return typeof val;
    }
  }

  cjs$3.getType = getType$1;

  function getEncoding$1(str) {
    if (isBinaryString(str)) {
      return ENC_BIN;
    }

    if (isHexString$1(str)) {
      return ENC_HEX;
    }

    return ENC_UTF8;
  }

  cjs$3.getEncoding = getEncoding$1;

  function concatBuffers$1() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var result = Buffer.concat(args);
    return result;
  }

  cjs$3.concatBuffers = concatBuffers$1;

  function concatArrays() {
    var result = [];

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (arg) {
      return result = result.concat(Array.from(arg));
    });
    return new Uint8Array([].concat(result));
  }

  cjs$3.concatArrays = concatArrays;

  function trimLeft(data, length) {
    var diff = data.length - length;

    if (diff > 0) {
      data = data.slice(diff);
    }

    return data;
  }

  cjs$3.trimLeft = trimLeft;

  function trimRight(data, length) {
    return data.slice(0, length);
  }

  cjs$3.trimRight = trimRight;

  function calcByteLength(length, byteSize) {
    if (byteSize === void 0) {
      byteSize = 8;
    }

    var remainder = length % byteSize;
    return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
  }

  cjs$3.calcByteLength = calcByteLength;

  function splitBytes(str, byteSize) {
    if (byteSize === void 0) {
      byteSize = 8;
    }

    var bytes = sanitizeBytes(str).match(new RegExp(".{" + byteSize + "}", "gi"));
    return Array.from(bytes || []);
  }

  cjs$3.splitBytes = splitBytes;

  function swapBytes(str) {
    return splitBytes(str).map(reverseString).join("");
  }

  cjs$3.swapBytes = swapBytes;

  function swapHex(str) {
    return binaryToHex(swapBytes(hexToBinary(str)));
  }

  cjs$3.swapHex = swapHex;

  function sanitizeBytes(str, byteSize, padding) {
    if (byteSize === void 0) {
      byteSize = 8;
    }

    if (padding === void 0) {
      padding = STRING_ZERO;
    }

    return padLeft(str, calcByteLength(str.length, byteSize), padding);
  }

  cjs$3.sanitizeBytes = sanitizeBytes;

  function padLeft(str, length, padding) {
    if (padding === void 0) {
      padding = STRING_ZERO;
    }

    return padString(str, length, true, padding);
  }

  cjs$3.padLeft = padLeft;

  function padRight(str, length, padding) {
    if (padding === void 0) {
      padding = STRING_ZERO;
    }

    return padString(str, length, false, padding);
  }

  cjs$3.padRight = padRight;

  function removeHexPrefix$1(hex) {
    return hex.replace(/^0x/, "");
  }

  cjs$3.removeHexPrefix = removeHexPrefix$1;

  function addHexPrefix$1(hex) {
    return hex.startsWith("0x") ? hex : "0x" + hex;
  }

  cjs$3.addHexPrefix = addHexPrefix$1;

  function sanitizeHex$1(hex) {
    hex = removeHexPrefix$1(hex);
    hex = sanitizeBytes(hex, 2);

    if (hex) {
      hex = addHexPrefix$1(hex);
    }

    return hex;
  }

  cjs$3.sanitizeHex = sanitizeHex$1;

  function removeHexLeadingZeros$1(hex) {
    var prefixed = hex.startsWith("0x");
    hex = removeHexPrefix$1(hex);
    hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
    return prefixed ? addHexPrefix$1(hex) : hex;
  }

  cjs$3.removeHexLeadingZeros = removeHexLeadingZeros$1;

  function isUndefined(value) {
    return typeof value === "undefined";
  }

  function isDefined(value) {
    return !isUndefined(value);
  }

  function assert$1(assertion, errorMessage) {
    if (!assertion) {
      throw new Error(errorMessage);
    }
  }

  function reverseString(str) {
    return str.split("").reverse().join("");
  }

  function padString(str, length, left, padding) {
    if (padding === void 0) {
      padding = STRING_ZERO;
    }

    var diff = length - str.length;
    var result = str;

    if (diff > 0) {
      var pad = padding.repeat(diff);
      result = left ? pad + str : str + pad;
    }

    return result;
  }

  Object.defineProperty(encoding$5, "__esModule", {
    value: true
  });
  encoding$5.convertNumberToHex = encoding$5.convertNumberToUtf8 = encoding$5.convertNumberToArrayBuffer = encoding$5.convertNumberToBuffer = encoding$5.convertHexToNumber = encoding$5.convertHexToUtf8 = encoding$5.convertHexToArrayBuffer = encoding$5.convertHexToBuffer = encoding$5.convertUtf8ToNumber = encoding$5.convertUtf8ToHex = encoding$5.convertUtf8ToBuffer = encoding$5.convertUtf8ToArrayBuffer = encoding$5.concatBuffers = encoding$5.convertBufferToNumber = encoding$5.convertBufferToHex = encoding$5.convertBufferToUtf8 = encoding$5.convertBufferToArrayBuffer = encoding$5.concatArrayBuffers = encoding$5.convertArrayBufferToNumber = encoding$5.convertArrayBufferToHex = encoding$5.convertArrayBufferToUtf8 = encoding$5.convertArrayBufferToBuffer = void 0;
  var tslib_1$7 = require$$0;
  var bn_js_1 = (0, tslib_1$7.__importDefault)(bn$1.exports);
  var encoding$4 = (0, tslib_1$7.__importStar)(cjs$3);

  function convertArrayBufferToBuffer(arrBuf) {
    return encoding$4.arrayToBuffer(new Uint8Array(arrBuf));
  }

  encoding$5.convertArrayBufferToBuffer = convertArrayBufferToBuffer;

  function convertArrayBufferToUtf8(arrBuf) {
    return encoding$4.arrayToUtf8(new Uint8Array(arrBuf));
  }

  encoding$5.convertArrayBufferToUtf8 = convertArrayBufferToUtf8;

  function convertArrayBufferToHex(arrBuf, noPrefix) {
    return encoding$4.arrayToHex(new Uint8Array(arrBuf), !noPrefix);
  }

  encoding$5.convertArrayBufferToHex = convertArrayBufferToHex;

  function convertArrayBufferToNumber(arrBuf) {
    return encoding$4.arrayToNumber(new Uint8Array(arrBuf));
  }

  encoding$5.convertArrayBufferToNumber = convertArrayBufferToNumber;

  function concatArrayBuffers() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return encoding$4.hexToArray(args.map(function (b) {
      return encoding$4.arrayToHex(new Uint8Array(b));
    }).join("")).buffer;
  }

  encoding$5.concatArrayBuffers = concatArrayBuffers;

  function convertBufferToArrayBuffer(buf) {
    return encoding$4.bufferToArray(buf).buffer;
  }

  encoding$5.convertBufferToArrayBuffer = convertBufferToArrayBuffer;

  function convertBufferToUtf8(buf) {
    return encoding$4.bufferToUtf8(buf);
  }

  encoding$5.convertBufferToUtf8 = convertBufferToUtf8;

  function convertBufferToHex(buf, noPrefix) {
    return encoding$4.bufferToHex(buf, !noPrefix);
  }

  encoding$5.convertBufferToHex = convertBufferToHex;

  function convertBufferToNumber(buf) {
    return encoding$4.bufferToNumber(buf);
  }

  encoding$5.convertBufferToNumber = convertBufferToNumber;

  function concatBuffers() {
    return encoding$4.concatBuffers.apply(encoding$4, arguments);
  }

  encoding$5.concatBuffers = concatBuffers;

  function convertUtf8ToArrayBuffer(utf8) {
    return encoding$4.utf8ToArray(utf8).buffer;
  }

  encoding$5.convertUtf8ToArrayBuffer = convertUtf8ToArrayBuffer;

  function convertUtf8ToBuffer(utf8) {
    return encoding$4.utf8ToBuffer(utf8);
  }

  encoding$5.convertUtf8ToBuffer = convertUtf8ToBuffer;

  function convertUtf8ToHex(utf8, noPrefix) {
    return encoding$4.utf8ToHex(utf8, !noPrefix);
  }

  encoding$5.convertUtf8ToHex = convertUtf8ToHex;

  function convertUtf8ToNumber(utf8) {
    return new bn_js_1.default(utf8, 10).toNumber();
  }

  encoding$5.convertUtf8ToNumber = convertUtf8ToNumber;

  function convertHexToBuffer(hex) {
    return encoding$4.hexToBuffer(hex);
  }

  encoding$5.convertHexToBuffer = convertHexToBuffer;

  function convertHexToArrayBuffer(hex) {
    return encoding$4.hexToArray(hex).buffer;
  }

  encoding$5.convertHexToArrayBuffer = convertHexToArrayBuffer;

  function convertHexToUtf8(hex) {
    return encoding$4.hexToUtf8(hex);
  }

  encoding$5.convertHexToUtf8 = convertHexToUtf8;

  function convertHexToNumber(hex) {
    return new bn_js_1.default(encoding$4.removeHexPrefix(hex), "hex").toNumber();
  }

  encoding$5.convertHexToNumber = convertHexToNumber;

  function convertNumberToBuffer(num) {
    return encoding$4.numberToBuffer(num);
  }

  encoding$5.convertNumberToBuffer = convertNumberToBuffer;

  function convertNumberToArrayBuffer(num) {
    return encoding$4.numberToArray(num).buffer;
  }

  encoding$5.convertNumberToArrayBuffer = convertNumberToArrayBuffer;

  function convertNumberToUtf8(num) {
    return new bn_js_1.default(num).toString();
  }

  encoding$5.convertNumberToUtf8 = convertNumberToUtf8;

  function convertNumberToHex(num, noPrefix) {
    var hex = encoding$4.removeHexPrefix(encoding$4.sanitizeHex(new bn_js_1.default(num).toString(16)));
    return noPrefix ? hex : encoding$4.addHexPrefix(hex);
  }

  encoding$5.convertNumberToHex = convertNumberToHex;

  var ethereum = {};

  var sha3 = {exports: {}};

  /**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   */

  (function (module) {
    /*jslint bitwise: true */
    (function () {

      var INPUT_ERROR = 'input is invalid type';
      var FINALIZE_ERROR = 'finalize already called';
      var WINDOW = typeof window === 'object';
      var root = WINDOW ? window : {};

      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }

      var WEB_WORKER = !WINDOW && typeof self === 'object';
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;

      if (NODE_JS) {
        root = commonjsGlobal;
      } else if (WEB_WORKER) {
        root = self;
      }

      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
      var HEX_CHARS = '0123456789abcdef'.split('');
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
      var CSHAKE_BYTEPAD = {
        '128': 168,
        '256': 136
      };

      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function (obj) {
          return Object.prototype.toString.call(obj) === '[object Array]';
        };
      }

      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function (obj) {
          return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }

      var createOutputMethod = function createOutputMethod(bits, padding, outputType) {
        return function (message) {
          return new Keccak(bits, padding, bits).update(message)[outputType]();
        };
      };

      var createShakeOutputMethod = function createShakeOutputMethod(bits, padding, outputType) {
        return function (message, outputBits) {
          return new Keccak(bits, padding, outputBits).update(message)[outputType]();
        };
      };

      var createCshakeOutputMethod = function createCshakeOutputMethod(bits, padding, outputType) {
        return function (message, outputBits, n, s) {
          return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
        };
      };

      var createKmacOutputMethod = function createKmacOutputMethod(bits, padding, outputType) {
        return function (key, message, outputBits, s) {
          return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
        };
      };

      var createOutputMethods = function createOutputMethods(method, createMethod, bits, padding) {
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createMethod(bits, padding, type);
        }

        return method;
      };

      var createMethod = function createMethod(bits, padding) {
        var method = createOutputMethod(bits, padding, 'hex');

        method.create = function () {
          return new Keccak(bits, padding, bits);
        };

        method.update = function (message) {
          return method.create().update(message);
        };

        return createOutputMethods(method, createOutputMethod, bits, padding);
      };

      var createShakeMethod = function createShakeMethod(bits, padding) {
        var method = createShakeOutputMethod(bits, padding, 'hex');

        method.create = function (outputBits) {
          return new Keccak(bits, padding, outputBits);
        };

        method.update = function (message, outputBits) {
          return method.create(outputBits).update(message);
        };

        return createOutputMethods(method, createShakeOutputMethod, bits, padding);
      };

      var createCshakeMethod = function createCshakeMethod(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createCshakeOutputMethod(bits, padding, 'hex');

        method.create = function (outputBits, n, s) {
          if (!n && !s) {
            return methods['shake' + bits].create(outputBits);
          } else {
            return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
          }
        };

        method.update = function (message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };

        return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
      };

      var createKmacMethod = function createKmacMethod(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createKmacOutputMethod(bits, padding, 'hex');

        method.create = function (key, outputBits, s) {
          return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
        };

        method.update = function (key, message, outputBits, s) {
          return method.create(key, outputBits, s).update(message);
        };

        return createOutputMethods(method, createKmacOutputMethod, bits, padding);
      };

      var algorithms = [{
        name: 'keccak',
        padding: KECCAK_PADDING,
        bits: BITS,
        createMethod: createMethod
      }, {
        name: 'sha3',
        padding: PADDING,
        bits: BITS,
        createMethod: createMethod
      }, {
        name: 'shake',
        padding: SHAKE_PADDING,
        bits: SHAKE_BITS,
        createMethod: createShakeMethod
      }, {
        name: 'cshake',
        padding: CSHAKE_PADDING,
        bits: SHAKE_BITS,
        createMethod: createCshakeMethod
      }, {
        name: 'kmac',
        padding: CSHAKE_PADDING,
        bits: SHAKE_BITS,
        createMethod: createKmacMethod
      }];
      var methods = {},
          methodNames = [];

      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;

        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + '_' + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);

          if (algorithm.name !== 'sha3') {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }

      function Keccak(bits, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;

        for (var i = 0; i < 50; ++i) {
          this.s[i] = 0;
        }
      }

      Keccak.prototype.update = function (message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }

        var notString,
            type = typeof message;

        if (type !== 'string') {
          if (type === 'object') {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }

          notString = true;
        }

        var blocks = this.blocks,
            byteCount = this.byteCount,
            length = message.length,
            blockCount = this.blockCount,
            index = 0,
            s = this.s,
            i,
            code;

        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;

            for (i = 1; i < blockCount + 1; ++i) {
              blocks[i] = 0;
            }
          }

          if (notString) {
            for (i = this.start; index < length && i < byteCount; ++index) {
              blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < byteCount; ++index) {
              code = message.charCodeAt(index);

              if (code < 0x80) {
                blocks[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 0x800) {
                blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
              } else if (code < 0xd800 || code >= 0xe000) {
                blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
              } else {
                code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
              }
            }
          }

          this.lastByteIndex = i;

          if (i >= byteCount) {
            this.start = i - byteCount;
            this.block = blocks[blockCount];

            for (i = 0; i < blockCount; ++i) {
              s[i] ^= blocks[i];
            }

            f(s);
            this.reset = true;
          } else {
            this.start = i;
          }
        }

        return this;
      };

      Keccak.prototype.encode = function (x, right) {
        var o = x & 255,
            n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;

        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }

        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }

        this.update(bytes);
        return bytes.length;
      };

      Keccak.prototype.encodeString = function (str) {
        var notString,
            type = typeof str;

        if (type !== 'string') {
          if (type === 'object') {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }

          notString = true;
        }

        var bytes = 0,
            length = str.length;

        if (notString) {
          bytes = length;
        } else {
          for (var i = 0; i < str.length; ++i) {
            var code = str.charCodeAt(i);

            if (code < 0x80) {
              bytes += 1;
            } else if (code < 0x800) {
              bytes += 2;
            } else if (code < 0xd800 || code >= 0xe000) {
              bytes += 3;
            } else {
              code = 0x10000 + ((code & 0x3ff) << 10 | str.charCodeAt(++i) & 0x3ff);
              bytes += 4;
            }
          }
        }

        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };

      Keccak.prototype.bytepad = function (strs, w) {
        var bytes = this.encode(w);

        for (var i = 0; i < strs.length; ++i) {
          bytes += this.encodeString(strs[i]);
        }

        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };

      Keccak.prototype.finalize = function () {
        if (this.finalized) {
          return;
        }

        this.finalized = true;
        var blocks = this.blocks,
            i = this.lastByteIndex,
            blockCount = this.blockCount,
            s = this.s;
        blocks[i >> 2] |= this.padding[i & 3];

        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];

          for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
          }
        }

        blocks[blockCount - 1] |= 0x80000000;

        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }

        f(s);
      };

      Keccak.prototype.toString = Keccak.prototype.hex = function () {
        this.finalize();
        var blockCount = this.blockCount,
            s = this.s,
            outputBlocks = this.outputBlocks,
            extraBytes = this.extraBytes,
            i = 0,
            j = 0;
        var hex = '',
            block;

        while (j < outputBlocks) {
          for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
            block = s[i];
            hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];
          }

          if (j % blockCount === 0) {
            f(s);
            i = 0;
          }
        }

        if (extraBytes) {
          block = s[i];
          hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F];

          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F];
          }

          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F];
          }
        }

        return hex;
      };

      Keccak.prototype.arrayBuffer = function () {
        this.finalize();
        var blockCount = this.blockCount,
            s = this.s,
            outputBlocks = this.outputBlocks,
            extraBytes = this.extraBytes,
            i = 0,
            j = 0;
        var bytes = this.outputBits >> 3;
        var buffer;

        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }

        var array = new Uint32Array(buffer);

        while (j < outputBlocks) {
          for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
            array[j] = s[i];
          }

          if (j % blockCount === 0) {
            f(s);
          }
        }

        if (extraBytes) {
          array[i] = s[i];
          buffer = buffer.slice(0, bytes);
        }

        return buffer;
      };

      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

      Keccak.prototype.digest = Keccak.prototype.array = function () {
        this.finalize();
        var blockCount = this.blockCount,
            s = this.s,
            outputBlocks = this.outputBlocks,
            extraBytes = this.extraBytes,
            i = 0,
            j = 0;
        var array = [],
            offset,
            block;

        while (j < outputBlocks) {
          for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
            offset = j << 2;
            block = s[i];
            array[offset] = block & 0xFF;
            array[offset + 1] = block >> 8 & 0xFF;
            array[offset + 2] = block >> 16 & 0xFF;
            array[offset + 3] = block >> 24 & 0xFF;
          }

          if (j % blockCount === 0) {
            f(s);
          }
        }

        if (extraBytes) {
          offset = j << 2;
          block = s[i];
          array[offset] = block & 0xFF;

          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 0xFF;
          }

          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 0xFF;
          }
        }

        return array;
      };

      function Kmac(bits, padding, outputBits) {
        Keccak.call(this, bits, padding, outputBits);
      }

      Kmac.prototype = new Keccak();

      Kmac.prototype.finalize = function () {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };

      var f = function f(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;

        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };

      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
      }
    })();
  })(sha3);

  var misc = {};

  var _STANDARD_ERROR_MAP;

  var PARSE_ERROR = "PARSE_ERROR";
  var INVALID_REQUEST = "INVALID_REQUEST";
  var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
  var INVALID_PARAMS = "INVALID_PARAMS";
  var INTERNAL_ERROR = "INTERNAL_ERROR";
  var SERVER_ERROR = "SERVER_ERROR";
  var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
  var SERVER_ERROR_CODE_RANGE = [-32000, -32099];
  var STANDARD_ERROR_MAP = (_STANDARD_ERROR_MAP = {}, _STANDARD_ERROR_MAP[PARSE_ERROR] = {
    code: -32700,
    message: "Parse error"
  }, _STANDARD_ERROR_MAP[INVALID_REQUEST] = {
    code: -32600,
    message: "Invalid Request"
  }, _STANDARD_ERROR_MAP[METHOD_NOT_FOUND] = {
    code: -32601,
    message: "Method not found"
  }, _STANDARD_ERROR_MAP[INVALID_PARAMS] = {
    code: -32602,
    message: "Invalid params"
  }, _STANDARD_ERROR_MAP[INTERNAL_ERROR] = {
    code: -32603,
    message: "Internal error"
  }, _STANDARD_ERROR_MAP[SERVER_ERROR] = {
    code: -32000,
    message: "Server error"
  }, _STANDARD_ERROR_MAP);

  function isServerErrorCode(code) {
    return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
  }
  function isReservedErrorCode(code) {
    return RESERVED_ERROR_CODES.includes(code);
  }
  function isValidErrorCode(code) {
    return typeof code === "number";
  }
  function getError(type) {
    if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
      return STANDARD_ERROR_MAP[INTERNAL_ERROR];
    }

    return STANDARD_ERROR_MAP[type];
  }
  function getErrorByCode(code) {
    var match = Object.values(STANDARD_ERROR_MAP).find(function (e) {
      return e.code === code;
    });

    if (!match) {
      return STANDARD_ERROR_MAP[INTERNAL_ERROR];
    }

    return match;
  }
  function validateJsonRpcError(response) {
    if (typeof response.error.code === "undefined") {
      return {
        valid: false,
        error: "Missing code for JSON-RPC error"
      };
    }

    if (typeof response.error.message === "undefined") {
      return {
        valid: false,
        error: "Missing message for JSON-RPC error"
      };
    }

    if (!isValidErrorCode(response.error.code)) {
      return {
        valid: false,
        error: "Invalid error code type for JSON-RPC: " + response.error.code
      };
    }

    if (isReservedErrorCode(response.error.code)) {
      var error = getErrorByCode(response.error.code);

      if (error.message !== STANDARD_ERROR_MAP[INTERNAL_ERROR].message && response.error.message === error.message) {
        return {
          valid: false,
          error: "Invalid error code message for JSON-RPC: " + response.error.code
        };
      }
    }

    return {
      valid: true
    };
  }
  function parseConnectionError(e, url, type) {
    return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error("Unavailable " + type + " RPC url at " + url) : e;
  }

  var cjs$2 = {};

  var crypto$2 = {};

  Object.defineProperty(crypto$2, "__esModule", {
    value: true
  });
  crypto$2.isBrowserCryptoAvailable = crypto$2.getSubtleCrypto = crypto$2.getBrowerCrypto = void 0;

  function getBrowerCrypto() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }

  crypto$2.getBrowerCrypto = getBrowerCrypto;

  function getSubtleCrypto() {
    var browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
  }

  crypto$2.getSubtleCrypto = getSubtleCrypto;

  function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
  }

  crypto$2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;

  var env$1 = {};

  Object.defineProperty(env$1, "__esModule", {
    value: true
  });
  env$1.isBrowser = env$1.isNode = env$1.isReactNative = void 0;

  function isReactNative() {
    return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
  }

  env$1.isReactNative = isReactNative;

  function isNode() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
  }

  env$1.isNode = isNode;

  function isBrowser() {
    return !isReactNative() && !isNode();
  }

  env$1.isBrowser = isBrowser;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(crypto$2, exports);

    __exportStar(env$1, exports);
  })(cjs$2);

  var isNodeJs = cjs$2.isNode;

  function payloadId() {
    var date = Date.now() * Math.pow(10, 3);
    var extra = Math.floor(Math.random() * Math.pow(10, 3));
    return date + extra;
  }
  function formatJsonRpcRequest(method, params, id) {
    return {
      id: id || payloadId(),
      jsonrpc: "2.0",
      method: method,
      params: params
    };
  }
  function formatJsonRpcResult(id, result) {
    return {
      id: id,
      jsonrpc: "2.0",
      result: result
    };
  }
  function formatJsonRpcError(id, error) {
    return {
      id: id,
      jsonrpc: "2.0",
      error: formatErrorMessage(error)
    };
  }
  function formatErrorMessage(error) {
    if (typeof error === "undefined") {
      return getError(INTERNAL_ERROR);
    }

    if (typeof error === "string") {
      error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), {
        message: error
      });
    }

    if (isReservedErrorCode(error.code)) {
      error = getErrorByCode(error.code);
    }

    return error;
  }

  function isValidRoute(route) {
    if (route.includes("*")) {
      return isValidWildcardRoute(route);
    }

    if (/\W/g.test(route)) {
      return false;
    }

    return true;
  }
  function isValidDefaultRoute(route) {
    return route === "*";
  }
  function isValidWildcardRoute(route) {
    if (isValidDefaultRoute(route)) {
      return true;
    }

    if (!route.includes("*")) {
      return false;
    }

    if (route.split("*").length !== 2) {
      return false;
    }

    if (route.split("*").filter(function (x) {
      return x.trim() === "";
    }).length !== 1) {
      return false;
    }

    return true;
  }
  function isValidLeadingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
  }
  function isValidTrailingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
  }

  var IEvents = function IEvents() {};

  var IJsonRpcConnection = /*#__PURE__*/function (_IEvents) {
    _inheritsLoose(IJsonRpcConnection, _IEvents);

    function IJsonRpcConnection(opts) {
      return _IEvents.call(this) || this;
    }

    return IJsonRpcConnection;
  }(IEvents);
  var IBaseJsonRpcProvider = /*#__PURE__*/function (_IEvents2) {
    _inheritsLoose(IBaseJsonRpcProvider, _IEvents2);

    function IBaseJsonRpcProvider() {
      return _IEvents2.call(this) || this;
    }

    return IBaseJsonRpcProvider;
  }(IEvents);
  var IJsonRpcProvider = /*#__PURE__*/function (_IBaseJsonRpcProvider) {
    _inheritsLoose(IJsonRpcProvider, _IBaseJsonRpcProvider);

    function IJsonRpcProvider(connection) {
      return _IBaseJsonRpcProvider.call(this) || this;
    }

    return IJsonRpcProvider;
  }(IBaseJsonRpcProvider);

  var HTTP_REGEX = "^https?:";
  var WS_REGEX = "^wss?:";

  function getUrlProtocol(url) {
    var matches = url.match(new RegExp(/^\w+:/, "gi"));
    if (!matches || !matches.length) return;
    return matches[0];
  }

  function matchRegexProtocol(url, regex) {
    var protocol = getUrlProtocol(url);
    if (typeof protocol === "undefined") return false;
    return new RegExp(regex).test(protocol);
  }

  function isHttpUrl(url) {
    return matchRegexProtocol(url, HTTP_REGEX);
  }
  function isWsUrl(url) {
    return matchRegexProtocol(url, WS_REGEX);
  }
  function isLocalhostUrl(url) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(url);
  }

  function isJsonRpcPayload(payload) {
    return "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
  }
  function isJsonRpcRequest$1(payload) {
    return isJsonRpcPayload(payload) && "method" in payload;
  }
  function isJsonRpcResponse(payload) {
    return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
  }
  function isJsonRpcResult(payload) {
    return "result" in payload;
  }
  function isJsonRpcError(payload) {
    return "error" in payload;
  }
  function isJsonRpcValidationInvalid(validation) {
    return "error" in validation && validation.valid === false;
  }

  var esm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    PARSE_ERROR: PARSE_ERROR,
    INVALID_REQUEST: INVALID_REQUEST,
    METHOD_NOT_FOUND: METHOD_NOT_FOUND,
    INVALID_PARAMS: INVALID_PARAMS,
    INTERNAL_ERROR: INTERNAL_ERROR,
    SERVER_ERROR: SERVER_ERROR,
    RESERVED_ERROR_CODES: RESERVED_ERROR_CODES,
    SERVER_ERROR_CODE_RANGE: SERVER_ERROR_CODE_RANGE,
    STANDARD_ERROR_MAP: STANDARD_ERROR_MAP,
    isServerErrorCode: isServerErrorCode,
    isReservedErrorCode: isReservedErrorCode,
    isValidErrorCode: isValidErrorCode,
    getError: getError,
    getErrorByCode: getErrorByCode,
    validateJsonRpcError: validateJsonRpcError,
    parseConnectionError: parseConnectionError,
    __moduleExports: cjs$2,
    isNodeJs: isNodeJs,
    payloadId: payloadId,
    formatJsonRpcRequest: formatJsonRpcRequest,
    formatJsonRpcResult: formatJsonRpcResult,
    formatJsonRpcError: formatJsonRpcError,
    formatErrorMessage: formatErrorMessage,
    isValidRoute: isValidRoute,
    isValidDefaultRoute: isValidDefaultRoute,
    isValidWildcardRoute: isValidWildcardRoute,
    isValidLeadingWildcardRoute: isValidLeadingWildcardRoute,
    isValidTrailingWildcardRoute: isValidTrailingWildcardRoute,
    IEvents: IEvents,
    IJsonRpcConnection: IJsonRpcConnection,
    IBaseJsonRpcProvider: IBaseJsonRpcProvider,
    IJsonRpcProvider: IJsonRpcProvider,
    isHttpUrl: isHttpUrl,
    isWsUrl: isWsUrl,
    isLocalhostUrl: isLocalhostUrl,
    isJsonRpcPayload: isJsonRpcPayload,
    isJsonRpcRequest: isJsonRpcRequest$1,
    isJsonRpcResponse: isJsonRpcResponse,
    isJsonRpcResult: isJsonRpcResult,
    isJsonRpcError: isJsonRpcError,
    isJsonRpcValidationInvalid: isJsonRpcValidationInvalid
  });

  var require$$2 = /*@__PURE__*/getAugmentedNamespace(esm);

  Object.defineProperty(misc, "__esModule", {
    value: true
  });
  misc.getRpcUrl = misc.getInfuraRpcUrl = misc.logDeprecationWarning = misc.uuid = misc.payloadId = misc.removeHexLeadingZeros = misc.removeHexPrefix = misc.addHexPrefix = misc.sanitizeHex = void 0;
  var tslib_1$6 = require$$0;
  var encoding$3 = (0, tslib_1$6.__importStar)(cjs$3);
  var jsonRpcUtils = (0, tslib_1$6.__importStar)(require$$2);
  var constants_1$2 = constants$2;

  function sanitizeHex(hex) {
    return encoding$3.sanitizeHex(hex);
  }

  misc.sanitizeHex = sanitizeHex;

  function addHexPrefix(hex) {
    return encoding$3.addHexPrefix(hex);
  }

  misc.addHexPrefix = addHexPrefix;

  function removeHexPrefix(hex) {
    return encoding$3.removeHexPrefix(hex);
  }

  misc.removeHexPrefix = removeHexPrefix;

  function removeHexLeadingZeros(hex) {
    return encoding$3.removeHexLeadingZeros(encoding$3.addHexPrefix(hex));
  }

  misc.removeHexLeadingZeros = removeHexLeadingZeros;
  misc.payloadId = jsonRpcUtils.payloadId;

  function uuid() {
    var result = function (a, b) {
      for (b = a = ""; a++ < 36; b += a * 51 & 52 ? (a ^ 15 ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {}

      return b;
    }();

    return result;
  }

  misc.uuid = uuid;

  function logDeprecationWarning() {
    console.warn("DEPRECATION WARNING: This WalletConnect client library will be deprecated in favor of @walletconnect/client. Please check docs.walletconnect.org to learn more about this migration!");
  }

  misc.logDeprecationWarning = logDeprecationWarning;

  function getInfuraRpcUrl(chainId, infuraId) {
    var rpcUrl;
    var network = constants_1$2.infuraNetworks[chainId];

    if (network) {
      rpcUrl = "https://" + network + ".infura.io/v3/" + infuraId;
    }

    return rpcUrl;
  }

  misc.getInfuraRpcUrl = getInfuraRpcUrl;

  function getRpcUrl(chainId, rpc) {
    var rpcUrl;
    var infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);

    if (rpc.custom && rpc.custom[chainId]) {
      rpcUrl = rpc.custom[chainId];
    } else if (infuraUrl) {
      rpcUrl = infuraUrl;
    }

    return rpcUrl;
  }

  misc.getRpcUrl = getRpcUrl;

  var validators$1 = {};

  Object.defineProperty(validators$1, "__esModule", {
    value: true
  });
  validators$1.isSilentPayload = validators$1.isReservedEvent = validators$1.isInternalEvent = validators$1.isJsonRpcResponseError = validators$1.isJsonRpcResponseSuccess = validators$1.isJsonRpcRequest = validators$1.isJsonRpcSubscription = validators$1.isHexString = validators$1.getEncoding = validators$1.getType = validators$1.isArrayBuffer = validators$1.isTypedArray = validators$1.isBuffer = validators$1.isEmptyArray = validators$1.isEmptyString = void 0;
  var tslib_1$5 = require$$0;
  var encoding$2 = (0, tslib_1$5.__importStar)(cjs$3);
  var constants_1$1 = constants$2;

  function isEmptyString(value) {
    return value === "" || typeof value === "string" && value.trim() === "";
  }

  validators$1.isEmptyString = isEmptyString;

  function isEmptyArray(array) {
    return !(array && array.length);
  }

  validators$1.isEmptyArray = isEmptyArray;

  function isBuffer(val) {
    return encoding$2.isBuffer(val);
  }

  validators$1.isBuffer = isBuffer;

  function isTypedArray(val) {
    return encoding$2.isTypedArray(val);
  }

  validators$1.isTypedArray = isTypedArray;

  function isArrayBuffer(val) {
    return encoding$2.isArrayBuffer(val);
  }

  validators$1.isArrayBuffer = isArrayBuffer;

  function getType(val) {
    return encoding$2.getType(val);
  }

  validators$1.getType = getType;

  function getEncoding(val) {
    return encoding$2.getEncoding(val);
  }

  validators$1.getEncoding = getEncoding;

  function isHexString(value, length) {
    return encoding$2.isHexString(value, length);
  }

  validators$1.isHexString = isHexString;

  function isJsonRpcSubscription(object) {
    return typeof object.params === "object";
  }

  validators$1.isJsonRpcSubscription = isJsonRpcSubscription;

  function isJsonRpcRequest(object) {
    return typeof object.method !== "undefined";
  }

  validators$1.isJsonRpcRequest = isJsonRpcRequest;

  function isJsonRpcResponseSuccess(object) {
    return typeof object.result !== "undefined";
  }

  validators$1.isJsonRpcResponseSuccess = isJsonRpcResponseSuccess;

  function isJsonRpcResponseError(object) {
    return typeof object.error !== "undefined";
  }

  validators$1.isJsonRpcResponseError = isJsonRpcResponseError;

  function isInternalEvent(object) {
    return typeof object.event !== "undefined";
  }

  validators$1.isInternalEvent = isInternalEvent;

  function isReservedEvent(event) {
    return constants_1$1.reservedEvents.includes(event) || event.startsWith("wc_");
  }

  validators$1.isReservedEvent = isReservedEvent;

  function isSilentPayload(request) {
    if (request.method.startsWith("wc_")) {
      return true;
    }

    if (constants_1$1.signingMethods.includes(request.method)) {
      return false;
    }

    return true;
  }

  validators$1.isSilentPayload = isSilentPayload;

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseTransactionData = exports.parsePersonalSign = exports.isValidAddress = exports.toChecksumAddress = void 0;
    var js_sha3_1 = sha3.exports;
    var encoding_1 = cjs$3;
    var encoding_2 = encoding$5;
    var misc_1 = misc;
    var validators_1 = validators$1;

    function toChecksumAddress(address) {
      address = (0, encoding_1.removeHexPrefix)(address.toLowerCase());
      var hash = (0, encoding_1.removeHexPrefix)((0, js_sha3_1.keccak_256)((0, encoding_2.convertUtf8ToBuffer)(address)));
      var checksum = "";

      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) > 7) {
          checksum += address[i].toUpperCase();
        } else {
          checksum += address[i];
        }
      }

      return (0, encoding_1.addHexPrefix)(checksum);
    }

    exports.toChecksumAddress = toChecksumAddress;

    var isValidAddress = function isValidAddress(address) {
      if (!address) {
        return false;
      } else if (address.toLowerCase().substring(0, 2) !== "0x") {
        return false;
      } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
        return true;
      } else {
        return address === toChecksumAddress(address);
      }
    };

    exports.isValidAddress = isValidAddress;

    function parsePersonalSign(params) {
      if (!(0, validators_1.isEmptyArray)(params) && !(0, validators_1.isHexString)(params[0])) {
        params[0] = (0, encoding_2.convertUtf8ToHex)(params[0]);
      }

      return params;
    }

    exports.parsePersonalSign = parsePersonalSign;

    function parseTransactionData(txData) {
      if (typeof txData.type !== "undefined" && txData.type !== "0") return txData;

      if (typeof txData.from === "undefined" || !(0, exports.isValidAddress)(txData.from)) {
        throw new Error("Transaction object must include a valid 'from' value.");
      }

      function parseHexValues(value) {
        var result = value;

        if (typeof value === "number" || typeof value === "string" && !(0, validators_1.isEmptyString)(value)) {
          if (!(0, validators_1.isHexString)(value)) {
            result = (0, encoding_2.convertNumberToHex)(value);
          } else if (typeof value === "string") {
            result = (0, misc_1.sanitizeHex)(value);
          }
        }

        if (typeof result === "string") {
          result = (0, misc_1.removeHexLeadingZeros)(result);
        }

        return result;
      }

      var txDataRPC = {
        from: (0, misc_1.sanitizeHex)(txData.from),
        to: typeof txData.to === "undefined" ? "" : (0, misc_1.sanitizeHex)(txData.to),
        gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
        gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
        value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
        nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
        data: typeof txData.data === "undefined" ? "" : (0, misc_1.sanitizeHex)(txData.data) || "0x"
      };
      var prunable = ["gasPrice", "gas", "value", "nonce"];
      Object.keys(txDataRPC).forEach(function (key) {
        if (!txDataRPC[key].trim().length && prunable.includes(key)) {
          delete txDataRPC[key];
        }
      });
      return txDataRPC;
    }

    exports.parseTransactionData = parseTransactionData;
  })(ethereum);

  var payload = {};

  Object.defineProperty(payload, "__esModule", {
    value: true
  });
  payload.formatRpcError = payload.promisify = void 0;
  var tslib_1$4 = require$$0;

  function promisify(originalFn, thisArg) {
    var _this = this;

    var promisifiedFunction = function promisifiedFunction() {
      for (var _len = arguments.length, callArgs = new Array(_len), _key = 0; _key < _len; _key++) {
        callArgs[_key] = arguments[_key];
      }

      return (0, tslib_1$4.__awaiter)(_this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  var callback = function callback(err, data) {
                    if (err === null || typeof err === "undefined") {
                      reject(err);
                    }

                    resolve(data);
                  };

                  originalFn.apply(thisArg, [].concat(callArgs, [callback]));
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
    };

    return promisifiedFunction;
  }

  payload.promisify = promisify;

  function formatRpcError(error) {
    var message = error.message || "Failed or Rejected Request";
    var code = -32000;

    if (error && !error.code) {
      switch (message) {
        case "Parse error":
          code = -32700;
          break;

        case "Invalid request":
          code = -32600;
          break;

        case "Method not found":
          code = -32601;
          break;

        case "Invalid params":
          code = -32602;
          break;

        case "Internal error":
          code = -32603;
          break;

        default:
          code = -32000;
          break;
      }
    }

    var result = {
      code: code,
      message: message
    };
    return result;
  }

  payload.formatRpcError = formatRpcError;

  var session = {};

  var url$1 = {};

  var queryString = {};

  var strictUriEncode = function strictUriEncode(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (x) {
      return "%" + x.charCodeAt(0).toString(16).toUpperCase();
    });
  };

  var token = '%[a-f0-9]{2}';
  var singleMatcher = new RegExp(token, 'gi');
  var multiMatcher = new RegExp('(' + token + ')+', 'gi');

  function decodeComponents(components, split) {
    try {
      // Try to decode the entire string first
      return decodeURIComponent(components.join(''));
    } catch (err) {// Do nothing
    }

    if (components.length === 1) {
      return components;
    }

    split = split || 1; // Split the array in 2 parts

    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }

  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher);

      for (var i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join('');
        tokens = input.match(singleMatcher);
      }

      return input;
    }
  }

  function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
      '%FE%FF': "\uFFFD\uFFFD",
      '%FF%FE': "\uFFFD\uFFFD"
    };
    var match = multiMatcher.exec(input);

    while (match) {
      try {
        // Decode as big chunks as possible
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);

        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }

      match = multiMatcher.exec(input);
    } // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else


    replaceMap['%C2'] = "\uFFFD";
    var entries = Object.keys(replaceMap);

    for (var i = 0; i < entries.length; i++) {
      // Replace all decoded components
      var key = entries[i];
      input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }

    return input;
  }

  var decodeUriComponent = function decodeUriComponent(encodedURI) {
    if (typeof encodedURI !== 'string') {
      throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }

    try {
      encodedURI = encodedURI.replace(/\+/g, ' '); // Try the built in decoder first

      return decodeURIComponent(encodedURI);
    } catch (err) {
      // Fallback to a more advanced decoder
      return customDecodeURIComponent(encodedURI);
    }
  };

  var splitOnFirst = function splitOnFirst(string, separator) {
    if (!(typeof string === 'string' && typeof separator === 'string')) {
      throw new TypeError('Expected the arguments to be of type `string`');
    }

    if (separator === '') {
      return [string];
    }

    var separatorIndex = string.indexOf(separator);

    if (separatorIndex === -1) {
      return [string];
    }

    return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
  };

  function _createForOfIteratorHelperLoose$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  (function (exports) {

    var strictUriEncode$1 = strictUriEncode;
    var decodeComponent = decodeUriComponent;
    var splitOnFirst$1 = splitOnFirst;

    var isNullOrUndefined = function isNullOrUndefined(value) {
      return value === null || value === undefined;
    };

    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case 'index':
          return function (key) {
            return function (result, value) {
              var index = result.length;

              if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                return result;
              }

              if (value === null) {
                return [].concat(result, [[encode(key, options), '[', index, ']'].join('')]);
              }

              return [].concat(result, [[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')]);
            };
          };

        case 'bracket':
          return function (key) {
            return function (result, value) {
              if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                return result;
              }

              if (value === null) {
                return [].concat(result, [[encode(key, options), '[]'].join('')]);
              }

              return [].concat(result, [[encode(key, options), '[]=', encode(value, options)].join('')]);
            };
          };

        case 'comma':
        case 'separator':
          return function (key) {
            return function (result, value) {
              if (value === null || value === undefined || value.length === 0) {
                return result;
              }

              if (result.length === 0) {
                return [[encode(key, options), '=', encode(value, options)].join('')];
              }

              return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
            };
          };

        default:
          return function (key) {
            return function (result, value) {
              if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                return result;
              }

              if (value === null) {
                return [].concat(result, [encode(key, options)]);
              }

              return [].concat(result, [[encode(key, options), '=', encode(value, options)].join('')]);
            };
          };
      }
    }

    function parserForArrayFormat(options) {
      var result;

      switch (options.arrayFormat) {
        case 'index':
          return function (key, value, accumulator) {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, '');

            if (!result) {
              accumulator[key] = value;
              return;
            }

            if (accumulator[key] === undefined) {
              accumulator[key] = {};
            }

            accumulator[key][result[1]] = value;
          };

        case 'bracket':
          return function (key, value, accumulator) {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, '');

            if (!result) {
              accumulator[key] = value;
              return;
            }

            if (accumulator[key] === undefined) {
              accumulator[key] = [value];
              return;
            }

            accumulator[key] = [].concat(accumulator[key], value);
          };

        case 'comma':
        case 'separator':
          return function (key, value, accumulator) {
            var isArray = typeof value === 'string' && value.split('').indexOf(options.arrayFormatSeparator) > -1;
            var newValue = isArray ? value.split(options.arrayFormatSeparator).map(function (item) {
              return decode(item, options);
            }) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };

        default:
          return function (key, value, accumulator) {
            if (accumulator[key] === undefined) {
              accumulator[key] = value;
              return;
            }

            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }

    function validateArrayFormatSeparator(value) {
      if (typeof value !== 'string' || value.length !== 1) {
        throw new TypeError('arrayFormatSeparator must be single character string');
      }
    }

    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
      }

      return value;
    }

    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }

      return value;
    }

    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }

      if (typeof input === 'object') {
        return keysSorter(Object.keys(input)).sort(function (a, b) {
          return Number(a) - Number(b);
        }).map(function (key) {
          return input[key];
        });
      }

      return input;
    }

    function removeHash(input) {
      var hashStart = input.indexOf('#');

      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }

      return input;
    }

    function getHash(url) {
      var hash = '';
      var hashStart = url.indexOf('#');

      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }

      return hash;
    }

    function extract(input) {
      input = removeHash(input);
      var queryStart = input.indexOf('?');

      if (queryStart === -1) {
        return '';
      }

      return input.slice(queryStart + 1);
    }

    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
        value = value.toLowerCase() === 'true';
      }

      return value;
    }

    function parse(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ',',
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      var formatter = parserForArrayFormat(options); // Create an object with no prototype

      var ret = Object.create(null);

      if (typeof input !== 'string') {
        return ret;
      }

      input = input.trim().replace(/^[?#&]/, '');

      if (!input) {
        return ret;
      }

      for (var _iterator = _createForOfIteratorHelperLoose$1(input.split('&')), _step; !(_step = _iterator()).done;) {
        var param = _step.value;

        var _splitOnFirst = splitOnFirst$1(options.decode ? param.replace(/\+/g, ' ') : param, '='),
            _key = _splitOnFirst[0],
            _value = _splitOnFirst[1]; // Missing `=` should be `null`:
        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters


        _value = _value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? _value : decode(_value, options);
        formatter(decode(_key, options), _value, ret);
      }

      for (var _i = 0, _Object$keys = Object.keys(ret); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var value = ret[key];

        if (typeof value === 'object' && value !== null) {
          for (var _i2 = 0, _Object$keys2 = Object.keys(value); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }

      if (options.sort === false) {
        return ret;
      }

      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce(function (result, key) {
        var value = ret[key];

        if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
          // Sort object keys, not values
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }

        return result;
      }, Object.create(null));
    }

    exports.extract = extract;
    exports.parse = parse;

    exports.stringify = function (object, options) {
      if (!object) {
        return '';
      }

      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ','
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);

      var shouldFilter = function shouldFilter(key) {
        return options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
      };

      var formatter = encoderForArrayFormat(options);
      var objectCopy = {};

      for (var _i3 = 0, _Object$keys3 = Object.keys(object); _i3 < _Object$keys3.length; _i3++) {
        var key = _Object$keys3[_i3];

        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }

      var keys = Object.keys(objectCopy);

      if (options.sort !== false) {
        keys.sort(options.sort);
      }

      return keys.map(function (key) {
        var value = object[key];

        if (value === undefined) {
          return '';
        }

        if (value === null) {
          return encode(key, options);
        }

        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join('&');
        }

        return encode(key, options) + '=' + encode(value, options);
      }).filter(function (x) {
        return x.length > 0;
      }).join('&');
    };

    exports.parseUrl = function (input, options) {
      options = Object.assign({
        decode: true
      }, options);

      var _splitOnFirst2 = splitOnFirst$1(input, '#'),
          url = _splitOnFirst2[0],
          hash = _splitOnFirst2[1];

      return Object.assign({
        url: url.split('?')[0] || '',
        query: parse(extract(input), options)
      }, options && options.parseFragmentIdentifier && hash ? {
        fragmentIdentifier: decode(hash, options)
      } : {});
    };

    exports.stringifyUrl = function (input, options) {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      var url = removeHash(input.url).split('?')[0] || '';
      var queryFromUrl = exports.extract(input.url);
      var parsedQueryFromUrl = exports.parse(queryFromUrl, {
        sort: false
      });
      var query = Object.assign(parsedQueryFromUrl, input.query);
      var queryString = exports.stringify(query, options);

      if (queryString) {
        queryString = "?" + queryString;
      }

      var hash = getHash(input.url);

      if (input.fragmentIdentifier) {
        hash = "#" + encode(input.fragmentIdentifier, options);
      }

      return "" + url + queryString + hash;
    };
  })(queryString);

  Object.defineProperty(url$1, "__esModule", {
    value: true
  });
  url$1.formatQueryString = url$1.parseQueryString = url$1.appendToQueryString = url$1.getQueryString = void 0;
  var tslib_1$3 = require$$0;
  var queryStringUtils = (0, tslib_1$3.__importStar)(queryString);

  function getQueryString(url) {
    var pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : undefined;
    var queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
    return queryString;
  }

  url$1.getQueryString = getQueryString;

  function appendToQueryString(queryString, newQueryParams) {
    var queryParams = parseQueryString(queryString);
    queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
    queryString = formatQueryString(queryParams);
    return queryString;
  }

  url$1.appendToQueryString = appendToQueryString;

  function parseQueryString(queryString) {
    return queryStringUtils.parse(queryString);
  }

  url$1.parseQueryString = parseQueryString;

  function formatQueryString(queryParams) {
    return queryStringUtils.stringify(queryParams);
  }

  url$1.formatQueryString = formatQueryString;

  Object.defineProperty(session, "__esModule", {
    value: true
  });
  session.parseWalletConnectUri = session.isWalletConnectSession = void 0;
  var url_1$1 = url$1;

  function isWalletConnectSession(object) {
    return typeof object.bridge !== "undefined";
  }

  session.isWalletConnectSession = isWalletConnectSession;

  function parseWalletConnectUri(str) {
    var pathStart = str.indexOf(":");
    var pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : undefined;
    var protocol = str.substring(0, pathStart);
    var path = str.substring(pathStart + 1, pathEnd);

    function parseRequiredParams(path) {
      var separator = "@";
      var values = path.split(separator);
      var requiredParams = {
        handshakeTopic: values[0],
        version: parseInt(values[1], 10)
      };
      return requiredParams;
    }

    var requiredParams = parseRequiredParams(path);
    var queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";

    function parseQueryParams(queryString) {
      var result = (0, url_1$1.parseQueryString)(queryString);
      var parameters = {
        key: result.key || "",
        bridge: result.bridge || ""
      };
      return parameters;
    }

    var queryParams = parseQueryParams(queryString);
    var result = Object.assign(Object.assign({
      protocol: protocol
    }, requiredParams), queryParams);
    return result;
  }

  session.parseWalletConnectUri = parseWalletConnectUri;

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var tslib_1 = require$$0;
    (0, tslib_1.__exportStar)(cjs$6, exports);
    (0, tslib_1.__exportStar)(constants$2, exports);
    (0, tslib_1.__exportStar)(encoding$5, exports);
    (0, tslib_1.__exportStar)(ethereum, exports);
    (0, tslib_1.__exportStar)(misc, exports);
    (0, tslib_1.__exportStar)(payload, exports);
    (0, tslib_1.__exportStar)(session, exports);
    (0, tslib_1.__exportStar)(url$1, exports);
    (0, tslib_1.__exportStar)(validators$1, exports);
  })(cjs$7);

  var cjs$1 = {};

  var network = {};

  Object.defineProperty(network, "__esModule", {
    value: true
  });

  var NetworkMonitor = /*#__PURE__*/function () {
    function NetworkMonitor() {
      var _this = this;

      this._eventEmitters = [];

      if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
        window.addEventListener("online", function () {
          return _this.trigger("online");
        });
        window.addEventListener("offline", function () {
          return _this.trigger("offline");
        });
      }
    }

    var _proto = NetworkMonitor.prototype;

    _proto.on = function on(event, callback) {
      this._eventEmitters.push({
        event: event,
        callback: callback
      });
    };

    _proto.trigger = function trigger(event) {
      var eventEmitters = [];

      if (event) {
        eventEmitters = this._eventEmitters.filter(function (eventEmitter) {
          return eventEmitter.event === event;
        });
      }

      eventEmitters.forEach(function (eventEmitter) {
        eventEmitter.callback();
      });
    };

    return NetworkMonitor;
  }();

  network.default = NetworkMonitor;

  var bufferUtil$1 = {exports: {}};

  var constants$1 = {
    BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
    GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
    kStatusCode: Symbol('status-code'),
    kWebSocket: Symbol('websocket'),
    EMPTY_BUFFER: Buffer.alloc(0),
    NOOP: function NOOP() {}
  };

  var EMPTY_BUFFER$3 = constants$1.EMPTY_BUFFER;
  /**
   * Merges an array of buffers into a new buffer.
   *
   * @param {Buffer[]} list The array of buffers to concat
   * @param {Number} totalLength The total length of buffers in the list
   * @return {Buffer} The resulting buffer
   * @public
   */

  function concat$1(list, totalLength) {
    if (list.length === 0) return EMPTY_BUFFER$3;
    if (list.length === 1) return list[0];
    var target = Buffer.allocUnsafe(totalLength);
    var offset = 0;

    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }

    if (offset < totalLength) return target.slice(0, offset);
    return target;
  }
  /**
   * Masks a buffer using the given mask.
   *
   * @param {Buffer} source The buffer to mask
   * @param {Buffer} mask The mask to use
   * @param {Buffer} output The buffer where to store the result
   * @param {Number} offset The offset at which to start writing
   * @param {Number} length The number of bytes to mask.
   * @public
   */


  function _mask(source, mask, output, offset, length) {
    for (var i = 0; i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  /**
   * Unmasks a buffer using the given mask.
   *
   * @param {Buffer} buffer The buffer to unmask
   * @param {Buffer} mask The mask to use
   * @public
   */


  function _unmask(buffer, mask) {
    // Required until https://github.com/nodejs/node/issues/9006 is resolved.
    var length = buffer.length;

    for (var i = 0; i < length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  /**
   * Converts a buffer to an `ArrayBuffer`.
   *
   * @param {Buffer} buf The buffer to convert
   * @return {ArrayBuffer} Converted buffer
   * @public
   */


  function toArrayBuffer$1(buf) {
    if (buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    }

    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
  /**
   * Converts `data` to a `Buffer`.
   *
   * @param {*} data The data to convert
   * @return {Buffer} The buffer
   * @throws {TypeError}
   * @public
   */


  function toBuffer$2(data) {
    toBuffer$2.readOnly = true;
    if (Buffer.isBuffer(data)) return data;
    var buf;

    if (data instanceof ArrayBuffer) {
      buf = Buffer.from(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer$2.readOnly = false;
    }

    return buf;
  }

  try {
    var _bufferUtil = bufferutil.exports;
    var bu = _bufferUtil.BufferUtil || _bufferUtil;
    bufferUtil$1.exports = {
      concat: concat$1,
      mask: function mask(source, _mask2, output, offset, length) {
        if (length < 48) _mask(source, _mask2, output, offset, length);else bu.mask(source, _mask2, output, offset, length);
      },
      toArrayBuffer: toArrayBuffer$1,
      toBuffer: toBuffer$2,
      unmask: function unmask(buffer, mask) {
        if (buffer.length < 32) _unmask(buffer, mask);else bu.unmask(buffer, mask);
      }
    };
  } catch (e)
  /* istanbul ignore next */
  {
    bufferUtil$1.exports = {
      concat: concat$1,
      mask: _mask,
      toArrayBuffer: toArrayBuffer$1,
      toBuffer: toBuffer$2,
      unmask: _unmask
    };
  }

  var kDone = Symbol('kDone');
  var kRun = Symbol('kRun');
  /**
   * A very simple job queue with adjustable concurrency. Adapted from
   * https://github.com/STRML/async-limiter
   */

  var Limiter$1 = /*#__PURE__*/function () {
    /**
     * Creates a new `Limiter`.
     *
     * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
     *     to run concurrently
     */
    function Limiter(concurrency) {
      var _this = this;

      this[kDone] = function () {
        _this.pending--;

        _this[kRun]();
      };

      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    /**
     * Adds a job to the queue.
     *
     * @param {Function} job The job to run
     * @public
     */


    var _proto = Limiter.prototype;

    _proto.add = function add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    /**
     * Removes a job from the queue and runs it if possible.
     *
     * @private
     */
    ;

    _proto[kRun] = function () {
      if (this.pending === this.concurrency) return;

      if (this.jobs.length) {
        var job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    };

    return Limiter;
  }();

  var limiter = Limiter$1;

  var zlib = require$$0__default$5["default"];
  var bufferUtil = bufferUtil$1.exports;
  var Limiter = limiter;
  var kStatusCode$2 = constants$1.kStatusCode,
      NOOP$1 = constants$1.NOOP;
  var TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
  var kPerMessageDeflate = Symbol('permessage-deflate');
  var kTotalLength = Symbol('total-length');
  var kCallback = Symbol('callback');
  var kBuffers = Symbol('buffers');
  var kError = Symbol('error'); //
  // We limit zlib concurrency, which prevents severe memory fragmentation
  // as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
  // and https://github.com/websockets/ws/issues/1202
  //
  // Intentionally global; it's the global thread pool that's an issue.
  //

  var zlibLimiter;
  /**
   * permessage-deflate implementation.
   */

  var PerMessageDeflate$4 = /*#__PURE__*/function () {
    /**
     * Creates a PerMessageDeflate instance.
     *
     * @param {Object} [options] Configuration options
     * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
     *     disabling of server context takeover
     * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
     *     acknowledge disabling of client context takeover
     * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
     *     use of a custom server window size
     * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
     *     for, or request, a custom client window size
     * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
     *     deflate
     * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
     *     inflate
     * @param {Number} [options.threshold=1024] Size (in bytes) below which
     *     messages should not be compressed
     * @param {Number} [options.concurrencyLimit=10] The number of concurrent
     *     calls to zlib
     * @param {Boolean} [isServer=false] Create the instance in either server or
     *     client mode
     * @param {Number} [maxPayload=0] The maximum allowed message length
     */
    function PerMessageDeflate(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;

      if (!zlibLimiter) {
        var concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    /**
     * @type {String}
     */


    var _proto = PerMessageDeflate.prototype;

    /**
     * Create an extension negotiation offer.
     *
     * @return {Object} Extension parameters
     * @public
     */
    _proto.offer = function offer() {
      var params = {};

      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }

      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }

      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }

      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }

      return params;
    }
    /**
     * Accept an extension negotiation offer/response.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Object} Accepted configuration
     * @public
     */
    ;

    _proto.accept = function accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    /**
     * Releases all resources used by the extension.
     *
     * @public
     */
    ;

    _proto.cleanup = function cleanup() {
      if (this._inflate) {
        this._inflate.close();

        this._inflate = null;
      }

      if (this._deflate) {
        var callback = this._deflate[kCallback];

        this._deflate.close();

        this._deflate = null;

        if (callback) {
          callback(new Error('The deflate stream was closed while data was being processed'));
        }
      }
    }
    /**
     *  Accept an extension negotiation offer.
     *
     * @param {Array} offers The extension negotiation offers
     * @return {Object} Accepted configuration
     * @private
     */
    ;

    _proto.acceptAsServer = function acceptAsServer(offers) {
      var opts = this._options;
      var accepted = offers.find(function (params) {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {
          return false;
        }

        return true;
      });

      if (!accepted) {
        throw new Error('None of the extension offers can be accepted');
      }

      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }

      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }

      if (typeof opts.serverMaxWindowBits === 'number') {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }

      if (typeof opts.clientMaxWindowBits === 'number') {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }

      return accepted;
    }
    /**
     * Accept the extension negotiation response.
     *
     * @param {Array} response The extension negotiation response
     * @return {Object} Accepted configuration
     * @private
     */
    ;

    _proto.acceptAsClient = function acceptAsClient(response) {
      var params = response[0];

      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }

      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === 'number') {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }

      return params;
    }
    /**
     * Normalize parameters.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Array} The offers/response with normalized parameters
     * @private
     */
    ;

    _proto.normalizeParams = function normalizeParams(configurations) {
      var _this = this;

      configurations.forEach(function (params) {
        Object.keys(params).forEach(function (key) {
          var value = params[key];

          if (value.length > 1) {
            throw new Error("Parameter \"" + key + "\" must have only a single value");
          }

          value = value[0];

          if (key === 'client_max_window_bits') {
            if (value !== true) {
              var num = +value;

              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError("Invalid value for parameter \"" + key + "\": " + value);
              }

              value = num;
            } else if (!_this._isServer) {
              throw new TypeError("Invalid value for parameter \"" + key + "\": " + value);
            }
          } else if (key === 'server_max_window_bits') {
            var _num = +value;

            if (!Number.isInteger(_num) || _num < 8 || _num > 15) {
              throw new TypeError("Invalid value for parameter \"" + key + "\": " + value);
            }

            value = _num;
          } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {
            if (value !== true) {
              throw new TypeError("Invalid value for parameter \"" + key + "\": " + value);
            }
          } else {
            throw new Error("Unknown parameter \"" + key + "\"");
          }

          params[key] = value;
        });
      });
      return configurations;
    }
    /**
     * Decompress data. Concurrency limited.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */
    ;

    _proto.decompress = function decompress(data, fin, callback) {
      var _this2 = this;

      zlibLimiter.add(function (done) {
        _this2._decompress(data, fin, function (err, result) {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Compress data. Concurrency limited.
     *
     * @param {Buffer} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */
    ;

    _proto.compress = function compress(data, fin, callback) {
      var _this3 = this;

      zlibLimiter.add(function (done) {
        _this3._compress(data, fin, function (err, result) {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Decompress data.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */
    ;

    _proto._decompress = function _decompress(data, fin, callback) {
      var _this4 = this;

      var endpoint = this._isServer ? 'client' : 'server';

      if (!this._inflate) {
        var key = endpoint + "_max_window_bits";
        var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw(_extends$1({}, this._options.zlibInflateOptions, {
          windowBits: windowBits
        }));
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        this._inflate.on('error', inflateOnError);

        this._inflate.on('data', inflateOnData);
      }

      this._inflate[kCallback] = callback;

      this._inflate.write(data);

      if (fin) this._inflate.write(TRAILER);

      this._inflate.flush(function () {
        var err = _this4._inflate[kError];

        if (err) {
          _this4._inflate.close();

          _this4._inflate = null;
          callback(err);
          return;
        }

        var data = bufferUtil.concat(_this4._inflate[kBuffers], _this4._inflate[kTotalLength]);

        if (_this4._inflate._readableState.endEmitted) {
          _this4._inflate.close();

          _this4._inflate = null;
        } else {
          _this4._inflate[kTotalLength] = 0;
          _this4._inflate[kBuffers] = [];

          if (fin && _this4.params[endpoint + "_no_context_takeover"]) {
            _this4._inflate.reset();
          }
        }

        callback(null, data);
      });
    }
    /**
     * Compress data.
     *
     * @param {Buffer} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */
    ;

    _proto._compress = function _compress(data, fin, callback) {
      var _this5 = this;

      var endpoint = this._isServer ? 'server' : 'client';

      if (!this._deflate) {
        var key = endpoint + "_max_window_bits";
        var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw(_extends$1({}, this._options.zlibDeflateOptions, {
          windowBits: windowBits
        }));
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = []; //
        // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
        // `zlib.DeflateRaw` instance is closed while data is being processed.
        // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
        // time due to an abnormal WebSocket closure.
        //

        this._deflate.on('error', NOOP$1);

        this._deflate.on('data', deflateOnData);
      }

      this._deflate[kCallback] = callback;

      this._deflate.write(data);

      this._deflate.flush(zlib.Z_SYNC_FLUSH, function () {
        if (!_this5._deflate) {
          //
          // The deflate stream was closed while data was being processed.
          //
          return;
        }

        var data = bufferUtil.concat(_this5._deflate[kBuffers], _this5._deflate[kTotalLength]);
        if (fin) data = data.slice(0, data.length - 4); //
        // Ensure that the callback will not be called again in
        // `PerMessageDeflate#cleanup()`.
        //

        _this5._deflate[kCallback] = null;
        _this5._deflate[kTotalLength] = 0;
        _this5._deflate[kBuffers] = [];

        if (fin && _this5.params[endpoint + "_no_context_takeover"]) {
          _this5._deflate.reset();
        }

        callback(null, data);
      });
    };

    _createClass$2(PerMessageDeflate, null, [{
      key: "extensionName",
      get: function get() {
        return 'permessage-deflate';
      }
    }]);

    return PerMessageDeflate;
  }();

  var permessageDeflate = PerMessageDeflate$4;
  /**
   * The listener of the `zlib.DeflateRaw` stream `'data'` event.
   *
   * @param {Buffer} chunk A chunk of data
   * @private
   */

  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  /**
   * The listener of the `zlib.InflateRaw` stream `'data'` event.
   *
   * @param {Buffer} chunk A chunk of data
   * @private
   */


  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;

    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }

    this[kError] = new RangeError('Max payload size exceeded');
    this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
    this[kError][kStatusCode$2] = 1009;
    this.removeListener('data', inflateOnData);
    this.reset();
  }
  /**
   * The listener of the `zlib.InflateRaw` stream `'error'` event.
   *
   * @param {Error} err The emitted error
   * @private
   */


  function inflateOnError(err) {
    //
    // There is no need to call `Zlib#close()` as the handle is automatically
    // closed when an error is emitted.
    //
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode$2] = 1007;
    this[kCallback](err);
  }

  var validation = {exports: {}};

  /**
   * Checks if a status code is allowed in a close frame.
   *
   * @param {Number} code The status code
   * @return {Boolean} `true` if the status code is valid, else `false`
   * @public
   */


  function isValidStatusCode$2(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  /**
   * Checks if a given buffer contains only correct UTF-8.
   * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
   * Markus Kuhn.
   *
   * @param {Buffer} buf The buffer to check
   * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
   * @public
   */


  function _isValidUTF8(buf) {
    var len = buf.length;
    var i = 0;

    while (i < len) {
      if ((buf[i] & 0x80) === 0) {
        // 0xxxxxxx
        i++;
      } else if ((buf[i] & 0xe0) === 0xc0) {
        // 110xxxxx 10xxxxxx
        if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong
        ) {
          return false;
        }

        i += 2;
      } else if ((buf[i] & 0xf0) === 0xe0) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong
        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)
        ) {
          return false;
        }

        i += 3;
      } else if ((buf[i] & 0xf8) === 0xf0) {
        // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong
        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF
        ) {
          return false;
        }

        i += 4;
      } else {
        return false;
      }
    }

    return true;
  }

  try {
    var _isValidUTF = utf8Validate.exports;
    /* istanbul ignore if */

    if (typeof _isValidUTF === 'object') {
      _isValidUTF = _isValidUTF.Validation.isValidUTF8; // utf-8-validate@<3.0.0
    }

    validation.exports = {
      isValidStatusCode: isValidStatusCode$2,
      isValidUTF8: function isValidUTF8(buf) {
        return buf.length < 150 ? _isValidUTF8(buf) : _isValidUTF(buf);
      }
    };
  } catch (e)
  /* istanbul ignore next */
  {
    validation.exports = {
      isValidStatusCode: isValidStatusCode$2,
      isValidUTF8: _isValidUTF8
    };
  }

  var Writable = require$$0__default$6["default"].Writable;
  var PerMessageDeflate$3 = permessageDeflate;
  var BINARY_TYPES$1 = constants$1.BINARY_TYPES,
      EMPTY_BUFFER$2 = constants$1.EMPTY_BUFFER,
      kStatusCode$1 = constants$1.kStatusCode,
      kWebSocket$2 = constants$1.kWebSocket;
  var concat = bufferUtil$1.exports.concat,
      toArrayBuffer = bufferUtil$1.exports.toArrayBuffer,
      unmask = bufferUtil$1.exports.unmask;
  var isValidStatusCode$1 = validation.exports.isValidStatusCode,
      isValidUTF8 = validation.exports.isValidUTF8;
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  /**
   * HyBi Receiver implementation.
   *
   * @extends Writable
   */

  var Receiver$1 = /*#__PURE__*/function (_Writable) {
    _inheritsLoose(Receiver, _Writable);

    /**
     * Creates a Receiver instance.
     *
     * @param {String} [binaryType=nodebuffer] The type for binary data
     * @param {Object} [extensions] An object containing the negotiated extensions
     * @param {Boolean} [isServer=false] Specifies whether to operate in client or
     *     server mode
     * @param {Number} [maxPayload=0] The maximum allowed message length
     */
    function Receiver(binaryType, extensions, isServer, maxPayload) {
      var _this;

      _this = _Writable.call(this) || this;
      _this._binaryType = binaryType || BINARY_TYPES$1[0];
      _this[kWebSocket$2] = undefined;
      _this._extensions = extensions || {};
      _this._isServer = !!isServer;
      _this._maxPayload = maxPayload | 0;
      _this._bufferedBytes = 0;
      _this._buffers = [];
      _this._compressed = false;
      _this._payloadLength = 0;
      _this._mask = undefined;
      _this._fragmented = 0;
      _this._masked = false;
      _this._fin = false;
      _this._opcode = 0;
      _this._totalPayloadLength = 0;
      _this._messageLength = 0;
      _this._fragments = [];
      _this._state = GET_INFO;
      _this._loop = false;
      return _this;
    }
    /**
     * Implements `Writable.prototype._write()`.
     *
     * @param {Buffer} chunk The chunk of data to write
     * @param {String} encoding The character encoding of `chunk`
     * @param {Function} cb Callback
     * @private
     */


    var _proto = Receiver.prototype;

    _proto._write = function _write(chunk, encoding, cb) {
      if (this._opcode === 0x08 && this._state == GET_INFO) return cb();
      this._bufferedBytes += chunk.length;

      this._buffers.push(chunk);

      this.startLoop(cb);
    }
    /**
     * Consumes `n` bytes from the buffered data.
     *
     * @param {Number} n The number of bytes to consume
     * @return {Buffer} The consumed bytes
     * @private
     */
    ;

    _proto.consume = function consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length) return this._buffers.shift();

      if (n < this._buffers[0].length) {
        var buf = this._buffers[0];
        this._buffers[0] = buf.slice(n);
        return buf.slice(0, n);
      }

      var dst = Buffer.allocUnsafe(n);

      do {
        var _buf = this._buffers[0];
        var offset = dst.length - n;

        if (n >= _buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(_buf.buffer, _buf.byteOffset, n), offset);
          this._buffers[0] = _buf.slice(n);
        }

        n -= _buf.length;
      } while (n > 0);

      return dst;
    }
    /**
     * Starts the parsing loop.
     *
     * @param {Function} cb Callback
     * @private
     */
    ;

    _proto.startLoop = function startLoop(cb) {
      var err;
      this._loop = true;

      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;

          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;

          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;

          case GET_MASK:
            this.getMask();
            break;

          case GET_DATA:
            err = this.getData(cb);
            break;

          default:
            // `INFLATING`
            this._loop = false;
            return;
        }
      } while (this._loop);

      cb(err);
    }
    /**
     * Reads the first two bytes of a frame.
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.getInfo = function getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      var buf = this.consume(2);

      if ((buf[0] & 0x30) !== 0x00) {
        this._loop = false;
        return error$1(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
      }

      var compressed = (buf[0] & 0x40) === 0x40;

      if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
        this._loop = false;
        return error$1(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
      }

      this._fin = (buf[0] & 0x80) === 0x80;
      this._opcode = buf[0] & 0x0f;
      this._payloadLength = buf[1] & 0x7f;

      if (this._opcode === 0x00) {
        if (compressed) {
          this._loop = false;
          return error$1(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
        }

        if (!this._fragmented) {
          this._loop = false;
          return error$1(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');
        }

        this._opcode = this._fragmented;
      } else if (this._opcode === 0x01 || this._opcode === 0x02) {
        if (this._fragmented) {
          this._loop = false;
          return error$1(RangeError, "invalid opcode " + this._opcode, true, 1002, 'WS_ERR_INVALID_OPCODE');
        }

        this._compressed = compressed;
      } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
        if (!this._fin) {
          this._loop = false;
          return error$1(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');
        }

        if (compressed) {
          this._loop = false;
          return error$1(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
        }

        if (this._payloadLength > 0x7d) {
          this._loop = false;
          return error$1(RangeError, "invalid payload length " + this._payloadLength, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
        }
      } else {
        this._loop = false;
        return error$1(RangeError, "invalid opcode " + this._opcode, true, 1002, 'WS_ERR_INVALID_OPCODE');
      }

      if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
      this._masked = (buf[1] & 0x80) === 0x80;

      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error$1(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');
        }
      } else if (this._masked) {
        this._loop = false;
        return error$1(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');
      }

      if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else return this.haveLength();
    }
    /**
     * Gets extended payload length (7+16).
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.getPayloadLength16 = function getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    /**
     * Gets extended payload length (7+64).
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.getPayloadLength64 = function getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }

      var buf = this.consume(8);
      var num = buf.readUInt32BE(0); //
      // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
      // if payload length is greater than this number.
      //

      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error$1(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
      }

      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    /**
     * Payload length has been read.
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.haveLength = function haveLength() {
      if (this._payloadLength && this._opcode < 0x08) {
        this._totalPayloadLength += this._payloadLength;

        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error$1(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
        }
      }

      if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;
    }
    /**
     * Reads mask bytes.
     *
     * @private
     */
    ;

    _proto.getMask = function getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }

      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    /**
     * Reads data bytes.
     *
     * @param {Function} cb Callback
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.getData = function getData(cb) {
      var data = EMPTY_BUFFER$2;

      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }

        data = this.consume(this._payloadLength);
        if (this._masked) unmask(data, this._mask);
      }

      if (this._opcode > 0x07) return this.controlMessage(data);

      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }

      if (data.length) {
        //
        // This message is not compressed so its lenght is the sum of the payload
        // length of all fragments.
        //
        this._messageLength = this._totalPayloadLength;

        this._fragments.push(data);
      }

      return this.dataMessage();
    }
    /**
     * Decompresses data.
     *
     * @param {Buffer} data Compressed data
     * @param {Function} cb Callback
     * @private
     */
    ;

    _proto.decompress = function decompress(data, cb) {
      var _this2 = this;

      var perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
      perMessageDeflate.decompress(data, this._fin, function (err, buf) {
        if (err) return cb(err);

        if (buf.length) {
          _this2._messageLength += buf.length;

          if (_this2._messageLength > _this2._maxPayload && _this2._maxPayload > 0) {
            return cb(error$1(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'));
          }

          _this2._fragments.push(buf);
        }

        var er = _this2.dataMessage();

        if (er) return cb(er);

        _this2.startLoop(cb);
      });
    }
    /**
     * Handles a data message.
     *
     * @return {(Error|undefined)} A possible error
     * @private
     */
    ;

    _proto.dataMessage = function dataMessage() {
      if (this._fin) {
        var messageLength = this._messageLength;
        var fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];

        if (this._opcode === 2) {
          var data;

          if (this._binaryType === 'nodebuffer') {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === 'arraybuffer') {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }

          this.emit('message', data);
        } else {
          var buf = concat(fragments, messageLength);

          if (!isValidUTF8(buf)) {
            this._loop = false;
            return error$1(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
          }

          this.emit('message', buf.toString());
        }
      }

      this._state = GET_INFO;
    }
    /**
     * Handles a control message.
     *
     * @param {Buffer} data Data to handle
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */
    ;

    _proto.controlMessage = function controlMessage(data) {
      if (this._opcode === 0x08) {
        this._loop = false;

        if (data.length === 0) {
          this.emit('conclude', 1005, '');
          this.end();
        } else if (data.length === 1) {
          return error$1(RangeError, 'invalid payload length 1', true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
        } else {
          var code = data.readUInt16BE(0);

          if (!isValidStatusCode$1(code)) {
            return error$1(RangeError, "invalid status code " + code, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
          }

          var buf = data.slice(2);

          if (!isValidUTF8(buf)) {
            return error$1(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
          }

          this.emit('conclude', code, buf.toString());
          this.end();
        }
      } else if (this._opcode === 0x09) {
        this.emit('ping', data);
      } else {
        this.emit('pong', data);
      }

      this._state = GET_INFO;
    };

    return Receiver;
  }(Writable);

  var receiver = Receiver$1;
  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */

  function error$1(ErrorCtor, message, prefix, statusCode, errorCode) {
    var err = new ErrorCtor(prefix ? "Invalid WebSocket frame: " + message : message);
    Error.captureStackTrace(err, error$1);
    err.code = errorCode;
    err[kStatusCode$1] = statusCode;
    return err;
  }

  /* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls$" }] */
  var randomFillSync = require$$0__default["default"].randomFillSync;
  var PerMessageDeflate$2 = permessageDeflate;
  var EMPTY_BUFFER$1 = constants$1.EMPTY_BUFFER;
  var isValidStatusCode = validation.exports.isValidStatusCode;
  var applyMask = bufferUtil$1.exports.mask,
      toBuffer$1 = bufferUtil$1.exports.toBuffer;
  var mask = Buffer.alloc(4);
  /**
   * HyBi Sender implementation.
   */

  var Sender$1 = /*#__PURE__*/function () {
    /**
     * Creates a Sender instance.
     *
     * @param {(net.Socket|tls.Socket)} socket The connection socket
     * @param {Object} [extensions] An object containing the negotiated extensions
     */
    function Sender(socket, extensions) {
      this._extensions = extensions || {};
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    /**
     * Frames a piece of data according to the HyBi WebSocket protocol.
     *
     * @param {Buffer} data The data to frame
     * @param {Object} options Options object
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @return {Buffer[]} The framed data as a list of `Buffer` instances
     * @public
     */


    Sender.frame = function frame(data, options) {
      var merge = options.mask && options.readOnly;
      var offset = options.mask ? 6 : 2;
      var payloadLength = data.length;

      if (data.length >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (data.length > 125) {
        offset += 2;
        payloadLength = 126;
      }

      var target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
      target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
      if (options.rsv1) target[0] |= 0x40;
      target[1] = payloadLength;

      if (payloadLength === 126) {
        target.writeUInt16BE(data.length, 2);
      } else if (payloadLength === 127) {
        target.writeUInt32BE(0, 2);
        target.writeUInt32BE(data.length, 6);
      }

      if (!options.mask) return [target, data];
      randomFillSync(mask, 0, 4);
      target[1] |= 0x80;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];

      if (merge) {
        applyMask(data, mask, target, offset, data.length);
        return [target];
      }

      applyMask(data, mask, data, 0, data.length);
      return [target, data];
    }
    /**
     * Sends a close message to the other peer.
     *
     * @param {Number} [code] The status code component of the body
     * @param {String} [data] The message component of the body
     * @param {Boolean} [mask=false] Specifies whether or not to mask the message
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    var _proto = Sender.prototype;

    _proto.close = function close(code, data, mask, cb) {
      var buf;

      if (code === undefined) {
        buf = EMPTY_BUFFER$1;
      } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
        throw new TypeError('First argument must be a valid error code number');
      } else if (data === undefined || data === '') {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        var length = Buffer.byteLength(data);

        if (length > 123) {
          throw new RangeError('The message must not be greater than 123 bytes');
        }

        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        buf.write(data, 2);
      }

      if (this._deflating) {
        this.enqueue([this.doClose, buf, mask, cb]);
      } else {
        this.doClose(buf, mask, cb);
      }
    }
    /**
     * Frames and sends a close message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.doClose = function doClose(data, mask, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask: mask,
        readOnly: false
      }), cb);
    }
    /**
     * Sends a ping message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    _proto.ping = function ping(data, mask, cb) {
      var buf = toBuffer$1(data);

      if (buf.length > 125) {
        throw new RangeError('The data size must not be greater than 125 bytes');
      }

      if (this._deflating) {
        this.enqueue([this.doPing, buf, mask, toBuffer$1.readOnly, cb]);
      } else {
        this.doPing(buf, mask, toBuffer$1.readOnly, cb);
      }
    }
    /**
     * Frames and sends a ping message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.doPing = function doPing(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask: mask,
        readOnly: readOnly
      }), cb);
    }
    /**
     * Sends a pong message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    _proto.pong = function pong(data, mask, cb) {
      var buf = toBuffer$1(data);

      if (buf.length > 125) {
        throw new RangeError('The data size must not be greater than 125 bytes');
      }

      if (this._deflating) {
        this.enqueue([this.doPong, buf, mask, toBuffer$1.readOnly, cb]);
      } else {
        this.doPong(buf, mask, toBuffer$1.readOnly, cb);
      }
    }
    /**
     * Frames and sends a pong message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.doPong = function doPong(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask: mask,
        readOnly: readOnly
      }), cb);
    }
    /**
     * Sends a data message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Object} options Options object
     * @param {Boolean} [options.compress=false] Specifies whether or not to
     *     compress `data`
     * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
     *     or text
     * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    _proto.send = function send(data, options, cb) {
      var buf = toBuffer$1(data);
      var perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
      var opcode = options.binary ? 2 : 1;
      var rsv1 = options.compress;

      if (this._firstFragment) {
        this._firstFragment = false;

        if (rsv1 && perMessageDeflate) {
          rsv1 = buf.length >= perMessageDeflate._threshold;
        }

        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }

      if (options.fin) this._firstFragment = true;

      if (perMessageDeflate) {
        var opts = {
          fin: options.fin,
          rsv1: rsv1,
          opcode: opcode,
          mask: options.mask,
          readOnly: toBuffer$1.readOnly
        };

        if (this._deflating) {
          this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
        } else {
          this.dispatch(buf, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode: opcode,
          mask: options.mask,
          readOnly: toBuffer$1.readOnly
        }), cb);
      }
    }
    /**
     * Dispatches a data message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [compress=false] Specifies whether or not to compress
     *     `data`
     * @param {Object} options Options object
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.dispatch = function dispatch(data, compress, options, cb) {
      var _this = this;

      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }

      var perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
      this._bufferedBytes += data.length;
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, function (_, buf) {
        if (_this._socket.destroyed) {
          var err = new Error('The socket was closed while data was being compressed');
          if (typeof cb === 'function') cb(err);

          for (var i = 0; i < _this._queue.length; i++) {
            var callback = _this._queue[i][4];
            if (typeof callback === 'function') callback(err);
          }

          return;
        }

        _this._bufferedBytes -= data.length;
        _this._deflating = false;
        options.readOnly = false;

        _this.sendFrame(Sender.frame(buf, options), cb);

        _this.dequeue();
      });
    }
    /**
     * Executes queued send operations.
     *
     * @private
     */
    ;

    _proto.dequeue = function dequeue() {
      while (!this._deflating && this._queue.length) {
        var params = this._queue.shift();

        this._bufferedBytes -= params[1].length;
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    /**
     * Enqueues a send operation.
     *
     * @param {Array} params Send operation parameters.
     * @private
     */
    ;

    _proto.enqueue = function enqueue(params) {
      this._bufferedBytes += params[1].length;

      this._queue.push(params);
    }
    /**
     * Sends a frame.
     *
     * @param {Buffer[]} list The frame to send
     * @param {Function} [cb] Callback
     * @private
     */
    ;

    _proto.sendFrame = function sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();

        this._socket.write(list[0]);

        this._socket.write(list[1], cb);

        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    };

    return Sender;
  }();

  var sender = Sender$1;

  /**
   * Class representing an event.
   *
   * @private
   */


  var Event =
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was
   *     dispatched
   */
  function Event(type, target) {
    this.target = target;
    this.type = type;
  };
  /**
   * Class representing a message event.
   *
   * @extends Event
   * @private
   */


  var MessageEvent = /*#__PURE__*/function (_Event) {
    _inheritsLoose(MessageEvent, _Event);

    /**
     * Create a new `MessageEvent`.
     *
     * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
     * @param {WebSocket} target A reference to the target to which the event was
     *     dispatched
     */
    function MessageEvent(data, target) {
      var _this;

      _this = _Event.call(this, 'message', target) || this;
      _this.data = data;
      return _this;
    }

    return MessageEvent;
  }(Event);
  /**
   * Class representing a close event.
   *
   * @extends Event
   * @private
   */


  var CloseEvent = /*#__PURE__*/function (_Event2) {
    _inheritsLoose(CloseEvent, _Event2);

    /**
     * Create a new `CloseEvent`.
     *
     * @param {Number} code The status code explaining why the connection is being
     *     closed
     * @param {String} reason A human-readable string explaining why the
     *     connection is closing
     * @param {WebSocket} target A reference to the target to which the event was
     *     dispatched
     */
    function CloseEvent(code, reason, target) {
      var _this2;

      _this2 = _Event2.call(this, 'close', target) || this;
      _this2.wasClean = target._closeFrameReceived && target._closeFrameSent;
      _this2.reason = reason;
      _this2.code = code;
      return _this2;
    }

    return CloseEvent;
  }(Event);
  /**
   * Class representing an open event.
   *
   * @extends Event
   * @private
   */


  var OpenEvent = /*#__PURE__*/function (_Event3) {
    _inheritsLoose(OpenEvent, _Event3);

    /**
     * Create a new `OpenEvent`.
     *
     * @param {WebSocket} target A reference to the target to which the event was
     *     dispatched
     */
    function OpenEvent(target) {
      return _Event3.call(this, 'open', target) || this;
    }

    return OpenEvent;
  }(Event);
  /**
   * Class representing an error event.
   *
   * @extends Event
   * @private
   */


  var ErrorEvent = /*#__PURE__*/function (_Event4) {
    _inheritsLoose(ErrorEvent, _Event4);

    /**
     * Create a new `ErrorEvent`.
     *
     * @param {Object} error The error that generated this event
     * @param {WebSocket} target A reference to the target to which the event was
     *     dispatched
     */
    function ErrorEvent(error, target) {
      var _this3;

      _this3 = _Event4.call(this, 'error', target) || this;
      _this3.message = error.message;
      _this3.error = error;
      return _this3;
    }

    return ErrorEvent;
  }(Event);
  /**
   * This provides methods for emulating the `EventTarget` interface. It's not
   * meant to be used directly.
   *
   * @mixin
   */


  var EventTarget = {
    /**
     * Register an event listener.
     *
     * @param {String} type A string representing the event type to listen for
     * @param {Function} listener The listener to add
     * @param {Object} [options] An options object specifies characteristics about
     *     the event listener
     * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
     *     listener should be invoked at most once after being added. If `true`,
     *     the listener would be automatically removed when invoked.
     * @public
     */
    addEventListener: function addEventListener(type, listener, options) {
      if (typeof listener !== 'function') return;

      function onMessage(data) {
        listener.call(this, new MessageEvent(data, this));
      }

      function onClose(code, message) {
        listener.call(this, new CloseEvent(code, message, this));
      }

      function onError(error) {
        listener.call(this, new ErrorEvent(error, this));
      }

      function onOpen() {
        listener.call(this, new OpenEvent(this));
      }

      var method = options && options.once ? 'once' : 'on';

      if (type === 'message') {
        onMessage._listener = listener;
        this[method](type, onMessage);
      } else if (type === 'close') {
        onClose._listener = listener;
        this[method](type, onClose);
      } else if (type === 'error') {
        onError._listener = listener;
        this[method](type, onError);
      } else if (type === 'open') {
        onOpen._listener = listener;
        this[method](type, onOpen);
      } else {
        this[method](type, listener);
      }
    },

    /**
     * Remove an event listener.
     *
     * @param {String} type A string representing the event type to remove
     * @param {Function} listener The listener to remove
     * @public
     */
    removeEventListener: function removeEventListener(type, listener) {
      var listeners = this.listeners(type);

      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i] === listener || listeners[i]._listener === listener) {
          this.removeListener(type, listeners[i]);
        }
      }
    }
  };
  var eventTarget = EventTarget;

  // Allowed token characters:
  //
  // '!', '#', '$', '%', '&', ''', '*', '+', '-',
  // '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
  //
  // tokenChars[32] === 0 // ' '
  // tokenChars[33] === 1 // '!'
  // tokenChars[34] === 0 // '"'
  // ...
  //
  // prettier-ignore


  var tokenChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
  ];
  /**
   * Adds an offer to the map of extension offers or a parameter to the map of
   * parameters.
   *
   * @param {Object} dest The map of extension offers or parameters
   * @param {String} name The extension or parameter name
   * @param {(Object|Boolean|String)} elem The extension parameters or the
   *     parameter value
   * @private
   */

  function push(dest, name, elem) {
    if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);
  }
  /**
   * Parses the `Sec-WebSocket-Extensions` header into an object.
   *
   * @param {String} header The field value of the header
   * @return {Object} The parsed object
   * @public
   */


  function parse$2(header) {
    var offers = Object.create(null);
    if (header === undefined || header === '') return offers;
    var params = Object.create(null);
    var mustUnescape = false;
    var isEscaping = false;
    var inQuotes = false;
    var extensionName;
    var paramName;
    var start = -1;
    var end = -1;
    var i = 0;

    for (; i < header.length; i++) {
      var code = header.charCodeAt(i);

      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x20
        /* ' ' */
        || code === 0x09
        /* '\t' */
        ) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 0x3b
        /* ';' */
        || code === 0x2c
        /* ',' */
        ) {
          if (start === -1) {
            throw new SyntaxError("Unexpected character at index " + i);
          }

          if (end === -1) end = i;
          var name = header.slice(start, end);

          if (code === 0x2c) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }

          start = end = -1;
        } else {
          throw new SyntaxError("Unexpected character at index " + i);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x20 || code === 0x09) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 0x3b || code === 0x2c) {
          if (start === -1) {
            throw new SyntaxError("Unexpected character at index " + i);
          }

          if (end === -1) end = i;
          push(params, header.slice(start, end), true);

          if (code === 0x2c) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }

          start = end = -1;
        } else if (code === 0x3d
        /* '=' */
        && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError("Unexpected character at index " + i);
        }
      } else {
        //
        // The value of a quoted-string after unescaping must conform to the
        // token ABNF, so only token characters are valid.
        // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
        //
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError("Unexpected character at index " + i);
          }

          if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 0x22
          /* '"' */
          && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 0x5c
          /* '\' */
          ) {
            isEscaping = true;
          } else {
            throw new SyntaxError("Unexpected character at index " + i);
          }
        } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
          if (end === -1) end = i;
        } else if (code === 0x3b || code === 0x2c) {
          if (start === -1) {
            throw new SyntaxError("Unexpected character at index " + i);
          }

          if (end === -1) end = i;
          var value = header.slice(start, end);

          if (mustUnescape) {
            value = value.replace(/\\/g, '');
            mustUnescape = false;
          }

          push(params, paramName, value);

          if (code === 0x2c) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }

          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError("Unexpected character at index " + i);
        }
      }
    }

    if (start === -1 || inQuotes) {
      throw new SyntaxError('Unexpected end of input');
    }

    if (end === -1) end = i;
    var token = header.slice(start, end);

    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ''));
      } else {
        push(params, paramName, token);
      }

      push(offers, extensionName, params);
    }

    return offers;
  }
  /**
   * Builds the `Sec-WebSocket-Extensions` header field value.
   *
   * @param {Object} extensions The map of extensions and parameters to format
   * @return {String} A string representing the given object
   * @public
   */


  function format$2(extensions) {
    return Object.keys(extensions).map(function (extension) {
      var configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations.map(function (params) {
        return [extension].concat(Object.keys(params).map(function (k) {
          var values = params[k];
          if (!Array.isArray(values)) values = [values];
          return values.map(function (v) {
            return v === true ? k : k + "=" + v;
          }).join('; ');
        })).join('; ');
      }).join(', ');
    }).join(', ');
  }

  var extension = {
    format: format$2,
    parse: parse$2
  };

  var EventEmitter$1 = require$$0__default$3["default"];
  var https = require$$1__default$1["default"];
  var http$1 = require$$2__default$1["default"];
  var net = require$$3__default["default"];
  var tls = require$$4__default["default"];
  var randomBytes$1 = require$$0__default["default"].randomBytes,
      createHash$1 = require$$0__default["default"].createHash;
  var URL = require$$7__default["default"].URL;
  var PerMessageDeflate$1 = permessageDeflate;
  var Receiver = receiver;
  var Sender = sender;
  var BINARY_TYPES = constants$1.BINARY_TYPES,
      EMPTY_BUFFER = constants$1.EMPTY_BUFFER,
      GUID$1 = constants$1.GUID,
      kStatusCode = constants$1.kStatusCode,
      kWebSocket$1 = constants$1.kWebSocket,
      NOOP = constants$1.NOOP;
  var addEventListener = eventTarget.addEventListener,
      removeEventListener = eventTarget.removeEventListener;
  var format$1 = extension.format,
      parse$1 = extension.parse;
  var toBuffer = bufferUtil$1.exports.toBuffer;
  var readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
  var protocolVersions = [8, 13];
  var closeTimeout = 30 * 1000;
  /**
   * Class representing a WebSocket.
   *
   * @extends EventEmitter
   */

  var WebSocket$2 = /*#__PURE__*/function (_EventEmitter) {
    _inheritsLoose(WebSocket, _EventEmitter);

    /**
     * Create a new `WebSocket`.
     *
     * @param {(String|URL)} address The URL to which to connect
     * @param {(String|String[])} [protocols] The subprotocols
     * @param {Object} [options] Connection options
     */
    function WebSocket(address, protocols, options) {
      var _this;

      _this = _EventEmitter.call(this) || this;
      _this._binaryType = BINARY_TYPES[0];
      _this._closeCode = 1006;
      _this._closeFrameReceived = false;
      _this._closeFrameSent = false;
      _this._closeMessage = '';
      _this._closeTimer = null;
      _this._extensions = {};
      _this._protocol = '';
      _this._readyState = WebSocket.CONNECTING;
      _this._receiver = null;
      _this._sender = null;
      _this._socket = null;

      if (address !== null) {
        _this._bufferedAmount = 0;
        _this._isServer = false;
        _this._redirects = 0;

        if (Array.isArray(protocols)) {
          protocols = protocols.join(', ');
        } else if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = undefined;
        }

        initAsClient(_assertThisInitialized$1(_this), address, protocols, options);
      } else {
        _this._isServer = true;
      }

      return _this;
    }
    /**
     * This deviates from the WHATWG interface since ws doesn't support the
     * required default "blob" type (instead we define a custom "nodebuffer"
     * type).
     *
     * @type {String}
     */


    var _proto = WebSocket.prototype;

    /**
     * Set up the socket and the internal resources.
     *
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Number} [maxPayload=0] The maximum allowed message size
     * @private
     */
    _proto.setSocket = function setSocket(socket, head, maxPayload) {
      var receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);
      this._sender = new Sender(socket, this._extensions);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket$1] = this;
      socket[kWebSocket$1] = this;
      receiver.on('conclude', receiverOnConclude);
      receiver.on('drain', receiverOnDrain);
      receiver.on('error', receiverOnError);
      receiver.on('message', receiverOnMessage);
      receiver.on('ping', receiverOnPing);
      receiver.on('pong', receiverOnPong);
      socket.setTimeout(0);
      socket.setNoDelay();
      if (head.length > 0) socket.unshift(head);
      socket.on('close', socketOnClose);
      socket.on('data', socketOnData);
      socket.on('end', socketOnEnd);
      socket.on('error', socketOnError$1);
      this._readyState = WebSocket.OPEN;
      this.emit('open');
    }
    /**
     * Emit the `'close'` event.
     *
     * @private
     */
    ;

    _proto.emitClose = function emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit('close', this._closeCode, this._closeMessage);
        return;
      }

      if (this._extensions[PerMessageDeflate$1.extensionName]) {
        this._extensions[PerMessageDeflate$1.extensionName].cleanup();
      }

      this._receiver.removeAllListeners();

      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
    }
    /**
     * Start a closing handshake.
     *
     *          +----------+   +-----------+   +----------+
     *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
     *    |     +----------+   +-----------+   +----------+     |
     *          +----------+   +-----------+         |
     * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
     *          +----------+   +-----------+   |
     *    |           |                        |   +---+        |
     *                +------------------------+-->|fin| - - - -
     *    |         +---+                      |   +---+
     *     - - - - -|fin|<---------------------+
     *              +---+
     *
     * @param {Number} [code] Status code explaining why the connection is closing
     * @param {String} [data] A string explaining why the connection is closing
     * @public
     */
    ;

    _proto.close = function close(code, data) {
      var _this2 = this;

      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        var msg = 'WebSocket was closed before the connection was established';
        return abortHandshake$1(this, this._req, msg);
      }

      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }

        return;
      }

      this._readyState = WebSocket.CLOSING;

      this._sender.close(code, data, !this._isServer, function (err) {
        //
        // This error is handled by the `'error'` listener on the socket. We only
        // want to know if the close frame has been sent here.
        //
        if (err) return;
        _this2._closeFrameSent = true;

        if (_this2._closeFrameReceived || _this2._receiver._writableState.errorEmitted) {
          _this2._socket.end();
        }
      }); //
      // Specify a timeout for the closing handshake to complete.
      //


      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    /**
     * Send a ping.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the ping is sent
     * @public
     */
    ;

    _proto.ping = function ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }

      if (mask === undefined) mask = !this._isServer;

      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    /**
     * Send a pong.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the pong is sent
     * @public
     */
    ;

    _proto.pong = function pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }

      if (mask === undefined) mask = !this._isServer;

      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    /**
     * Send a data message.
     *
     * @param {*} data The message to send
     * @param {Object} [options] Options object
     * @param {Boolean} [options.compress] Specifies whether or not to compress
     *     `data`
     * @param {Boolean} [options.binary] Specifies whether `data` is binary or
     *     text
     * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when data is written out
     * @public
     */
    ;

    _proto.send = function send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }

      var opts = _extends$1({
        binary: typeof data !== 'string',
        mask: !this._isServer,
        compress: true,
        fin: true
      }, options);

      if (!this._extensions[PerMessageDeflate$1.extensionName]) {
        opts.compress = false;
      }

      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    /**
     * Forcibly close the connection.
     *
     * @public
     */
    ;

    _proto.terminate = function terminate() {
      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        var msg = 'WebSocket was closed before the connection was established';
        return abortHandshake$1(this, this._req, msg);
      }

      if (this._socket) {
        this._readyState = WebSocket.CLOSING;

        this._socket.destroy();
      }
    };

    _createClass$2(WebSocket, [{
      key: "binaryType",
      get: function get() {
        return this._binaryType;
      },
      set: function set(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type; //
        // Allow to change `binaryType` on the fly.
        //

        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */

    }, {
      key: "bufferedAmount",
      get: function get() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */

    }, {
      key: "extensions",
      get: function get() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Function}
       */

      /* istanbul ignore next */

    }, {
      key: "onclose",
      get: function get() {
        return undefined;
      }
      /* istanbul ignore next */
      ,
      set: function set(listener) {}
      /**
       * @type {Function}
       */

      /* istanbul ignore next */

    }, {
      key: "onerror",
      get: function get() {
        return undefined;
      }
      /* istanbul ignore next */
      ,
      set: function set(listener) {}
      /**
       * @type {Function}
       */

      /* istanbul ignore next */

    }, {
      key: "onopen",
      get: function get() {
        return undefined;
      }
      /* istanbul ignore next */
      ,
      set: function set(listener) {}
      /**
       * @type {Function}
       */

      /* istanbul ignore next */

    }, {
      key: "onmessage",
      get: function get() {
        return undefined;
      }
      /* istanbul ignore next */
      ,
      set: function set(listener) {}
      /**
       * @type {String}
       */

    }, {
      key: "protocol",
      get: function get() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */

    }, {
      key: "readyState",
      get: function get() {
        return this._readyState;
      }
      /**
       * @type {String}
       */

    }, {
      key: "url",
      get: function get() {
        return this._url;
      }
    }]);

    return WebSocket;
  }(EventEmitter$1);
  /**
   * @constant {Number} CONNECTING
   * @memberof WebSocket
   */


  Object.defineProperty(WebSocket$2, 'CONNECTING', {
    enumerable: true,
    value: readyStates.indexOf('CONNECTING')
  });
  /**
   * @constant {Number} CONNECTING
   * @memberof WebSocket.prototype
   */

  Object.defineProperty(WebSocket$2.prototype, 'CONNECTING', {
    enumerable: true,
    value: readyStates.indexOf('CONNECTING')
  });
  /**
   * @constant {Number} OPEN
   * @memberof WebSocket
   */

  Object.defineProperty(WebSocket$2, 'OPEN', {
    enumerable: true,
    value: readyStates.indexOf('OPEN')
  });
  /**
   * @constant {Number} OPEN
   * @memberof WebSocket.prototype
   */

  Object.defineProperty(WebSocket$2.prototype, 'OPEN', {
    enumerable: true,
    value: readyStates.indexOf('OPEN')
  });
  /**
   * @constant {Number} CLOSING
   * @memberof WebSocket
   */

  Object.defineProperty(WebSocket$2, 'CLOSING', {
    enumerable: true,
    value: readyStates.indexOf('CLOSING')
  });
  /**
   * @constant {Number} CLOSING
   * @memberof WebSocket.prototype
   */

  Object.defineProperty(WebSocket$2.prototype, 'CLOSING', {
    enumerable: true,
    value: readyStates.indexOf('CLOSING')
  });
  /**
   * @constant {Number} CLOSED
   * @memberof WebSocket
   */

  Object.defineProperty(WebSocket$2, 'CLOSED', {
    enumerable: true,
    value: readyStates.indexOf('CLOSED')
  });
  /**
   * @constant {Number} CLOSED
   * @memberof WebSocket.prototype
   */

  Object.defineProperty(WebSocket$2.prototype, 'CLOSED', {
    enumerable: true,
    value: readyStates.indexOf('CLOSED')
  });
  ['binaryType', 'bufferedAmount', 'extensions', 'protocol', 'readyState', 'url'].forEach(function (property) {
    Object.defineProperty(WebSocket$2.prototype, property, {
      enumerable: true
    });
  }); //
  // Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
  // See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
  //

  ['open', 'error', 'close', 'message'].forEach(function (method) {
    Object.defineProperty(WebSocket$2.prototype, "on" + method, {
      enumerable: true,
      get: function get() {
        var listeners = this.listeners(method);

        for (var i = 0; i < listeners.length; i++) {
          if (listeners[i]._listener) return listeners[i]._listener;
        }

        return undefined;
      },
      set: function set(listener) {
        var listeners = this.listeners(method);

        for (var i = 0; i < listeners.length; i++) {
          //
          // Remove only the listeners added via `addEventListener`.
          //
          if (listeners[i]._listener) this.removeListener(method, listeners[i]);
        }

        this.addEventListener(method, listener);
      }
    });
  });
  WebSocket$2.prototype.addEventListener = addEventListener;
  WebSocket$2.prototype.removeEventListener = removeEventListener;
  var websocket = WebSocket$2;
  /**
   * Initialize a WebSocket client.
   *
   * @param {WebSocket} websocket The client to initialize
   * @param {(String|URL)} address The URL to which to connect
   * @param {String} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
   *     handshake request
   * @param {Number} [options.protocolVersion=13] Value of the
   *     `Sec-WebSocket-Version` header
   * @param {String} [options.origin] Value of the `Origin` or
   *     `Sec-WebSocket-Origin` header
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.followRedirects=false] Whether or not to follow
   *     redirects
   * @param {Number} [options.maxRedirects=10] The maximum number of redirects
   *     allowed
   * @private
   */

  function initAsClient(websocket, address, protocols, options) {
    var opts = _extends$1({
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10
    }, options, {
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: undefined,
      host: undefined,
      path: undefined,
      port: undefined
    });

    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError("Unsupported protocol version: " + opts.protocolVersion + " " + ("(supported versions: " + protocolVersions.join(', ') + ")"));
    }

    var parsedUrl;

    if (address instanceof URL) {
      parsedUrl = address;
      websocket._url = address.href;
    } else {
      parsedUrl = new URL(address);
      websocket._url = address;
    }

    var isUnixSocket = parsedUrl.protocol === 'ws+unix:';

    if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
      throw new Error("Invalid URL: " + websocket.url);
    }

    var isSecure = parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
    var defaultPort = isSecure ? 443 : 80;
    var key = randomBytes$1(16).toString('base64');
    var get = isSecure ? https.get : http$1.get;
    var perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = _extends$1({
      'Sec-WebSocket-Version': opts.protocolVersion,
      'Sec-WebSocket-Key': key,
      Connection: 'Upgrade',
      Upgrade: 'websocket'
    }, opts.headers);
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;

    if (opts.perMessageDeflate) {
      var _format;

      perMessageDeflate = new PerMessageDeflate$1(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers['Sec-WebSocket-Extensions'] = format$1((_format = {}, _format[PerMessageDeflate$1.extensionName] = perMessageDeflate.offer(), _format));
    }

    if (protocols) {
      opts.headers['Sec-WebSocket-Protocol'] = protocols;
    }

    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers['Sec-WebSocket-Origin'] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }

    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = parsedUrl.username + ":" + parsedUrl.password;
    }

    if (isUnixSocket) {
      var parts = opts.path.split(':');
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }

    var req = websocket._req = get(opts);

    if (opts.timeout) {
      req.on('timeout', function () {
        abortHandshake$1(websocket, req, 'Opening handshake has timed out');
      });
    }

    req.on('error', function (err) {
      if (req === null || req.aborted) return;
      req = websocket._req = null;
      websocket._readyState = WebSocket$2.CLOSING;
      websocket.emit('error', err);
      websocket.emitClose();
    });
    req.on('response', function (res) {
      var location = res.headers.location;
      var statusCode = res.statusCode;

      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake$1(websocket, req, 'Maximum redirects exceeded');
          return;
        }

        req.abort();
        var addr = new URL(location, address);
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit('unexpected-response', req, res)) {
        abortHandshake$1(websocket, req, "Unexpected server response: " + res.statusCode);
      }
    });
    req.on('upgrade', function (res, socket, head) {
      websocket.emit('upgrade', res); //
      // The user may have closed the connection from a listener of the `upgrade`
      // event.
      //

      if (websocket.readyState !== WebSocket$2.CONNECTING) return;
      req = websocket._req = null;
      var digest = createHash$1('sha1').update(key + GUID$1).digest('base64');

      if (res.headers['sec-websocket-accept'] !== digest) {
        abortHandshake$1(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
        return;
      }

      var serverProt = res.headers['sec-websocket-protocol'];
      var protList = (protocols || '').split(/, */);
      var protError;

      if (!protocols && serverProt) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (protocols && !serverProt) {
        protError = 'Server sent no subprotocol';
      } else if (serverProt && !protList.includes(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }

      if (protError) {
        abortHandshake$1(websocket, socket, protError);
        return;
      }

      if (serverProt) websocket._protocol = serverProt;
      var secWebSocketExtensions = res.headers['sec-websocket-extensions'];

      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          var message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';
          abortHandshake$1(websocket, socket, message);
          return;
        }

        var extensions;

        try {
          extensions = parse$1(secWebSocketExtensions);
        } catch (err) {
          var _message = 'Invalid Sec-WebSocket-Extensions header';
          abortHandshake$1(websocket, socket, _message);
          return;
        }

        var extensionNames = Object.keys(extensions);

        if (extensionNames.length) {
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
            var _message2 = 'Server indicated an extension that was not requested';
            abortHandshake$1(websocket, socket, _message2);
            return;
          }

          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);
          } catch (err) {
            var _message3 = 'Invalid Sec-WebSocket-Extensions header';
            abortHandshake$1(websocket, socket, _message3);
            return;
          }

          websocket._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
        }
      }

      websocket.setSocket(socket, head, opts.maxPayload);
    });
  }
  /**
   * Create a `net.Socket` and initiate a connection.
   *
   * @param {Object} options Connection options
   * @return {net.Socket} The newly created socket used to start the connection
   * @private
   */


  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }
  /**
   * Create a `tls.TLSSocket` and initiate a connection.
   *
   * @param {Object} options Connection options
   * @return {tls.TLSSocket} The newly created socket used to start the connection
   * @private
   */


  function tlsConnect(options) {
    options.path = undefined;

    if (!options.servername && options.servername !== '') {
      options.servername = net.isIP(options.host) ? '' : options.host;
    }

    return tls.connect(options);
  }
  /**
   * Abort the handshake and emit an error.
   *
   * @param {WebSocket} websocket The WebSocket instance
   * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
   *     abort or the socket to destroy
   * @param {String} message The error message
   * @private
   */


  function abortHandshake$1(websocket, stream, message) {
    websocket._readyState = WebSocket$2.CLOSING;
    var err = new Error(message);
    Error.captureStackTrace(err, abortHandshake$1);

    if (stream.setHeader) {
      stream.abort();

      if (stream.socket && !stream.socket.destroyed) {
        //
        // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
        // called after the request completed. See
        // https://github.com/websockets/ws/issues/1869.
        //
        stream.socket.destroy();
      }

      stream.once('abort', websocket.emitClose.bind(websocket));
      websocket.emit('error', err);
    } else {
      stream.destroy(err);
      stream.once('error', websocket.emit.bind(websocket, 'error'));
      stream.once('close', websocket.emitClose.bind(websocket));
    }
  }
  /**
   * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
   * when the `readyState` attribute is `CLOSING` or `CLOSED`.
   *
   * @param {WebSocket} websocket The WebSocket instance
   * @param {*} [data] The data to send
   * @param {Function} [cb] Callback
   * @private
   */


  function sendAfterClose(websocket, data, cb) {
    if (data) {
      var length = toBuffer(data).length; //
      // The `_bufferedAmount` property is used only when the peer is a client and
      // the opening handshake fails. Under these circumstances, in fact, the
      // `setSocket()` method is not called, so the `_socket` and `_sender`
      // properties are set to `null`.
      //

      if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;
    }

    if (cb) {
      var err = new Error("WebSocket is not open: readyState " + websocket.readyState + " " + ("(" + readyStates[websocket.readyState] + ")"));
      cb(err);
    }
  }
  /**
   * The listener of the `Receiver` `'conclude'` event.
   *
   * @param {Number} code The status code
   * @param {String} reason The reason for closing
   * @private
   */


  function receiverOnConclude(code, reason) {
    var websocket = this[kWebSocket$1];

    websocket._socket.removeListener('data', socketOnData);

    websocket._socket.resume();

    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (code === 1005) websocket.close();else websocket.close(code, reason);
  }
  /**
   * The listener of the `Receiver` `'drain'` event.
   *
   * @private
   */


  function receiverOnDrain() {
    this[kWebSocket$1]._socket.resume();
  }
  /**
   * The listener of the `Receiver` `'error'` event.
   *
   * @param {(RangeError|Error)} err The emitted error
   * @private
   */


  function receiverOnError(err) {
    var websocket = this[kWebSocket$1];

    websocket._socket.removeListener('data', socketOnData);

    websocket._socket.resume();

    websocket.close(err[kStatusCode]);
    websocket.emit('error', err);
  }
  /**
   * The listener of the `Receiver` `'finish'` event.
   *
   * @private
   */


  function receiverOnFinish() {
    this[kWebSocket$1].emitClose();
  }
  /**
   * The listener of the `Receiver` `'message'` event.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
   * @private
   */


  function receiverOnMessage(data) {
    this[kWebSocket$1].emit('message', data);
  }
  /**
   * The listener of the `Receiver` `'ping'` event.
   *
   * @param {Buffer} data The data included in the ping frame
   * @private
   */


  function receiverOnPing(data) {
    var websocket = this[kWebSocket$1];
    websocket.pong(data, !websocket._isServer, NOOP);
    websocket.emit('ping', data);
  }
  /**
   * The listener of the `Receiver` `'pong'` event.
   *
   * @param {Buffer} data The data included in the pong frame
   * @private
   */


  function receiverOnPong(data) {
    this[kWebSocket$1].emit('pong', data);
  }
  /**
   * The listener of the `net.Socket` `'close'` event.
   *
   * @private
   */


  function socketOnClose() {
    var websocket = this[kWebSocket$1];
    this.removeListener('close', socketOnClose);
    this.removeListener('end', socketOnEnd);
    websocket._readyState = WebSocket$2.CLOSING; //
    // The close frame might not have been received or the `'end'` event emitted,
    // for example, if the socket was destroyed due to an error. Ensure that the
    // `receiver` stream is closed after writing any remaining buffered data to
    // it. If the readable side of the socket is in flowing mode then there is no
    // buffered data as everything has been already written and `readable.read()`
    // will return `null`. If instead, the socket is paused, any possible buffered
    // data will be read as a single chunk and emitted synchronously in a single
    // `'data'` event.
    //

    websocket._socket.read();

    websocket._receiver.end();

    this.removeListener('data', socketOnData);
    this[kWebSocket$1] = undefined;
    clearTimeout(websocket._closeTimer);

    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on('error', receiverOnFinish);

      websocket._receiver.on('finish', receiverOnFinish);
    }
  }
  /**
   * The listener of the `net.Socket` `'data'` event.
   *
   * @param {Buffer} chunk A chunk of data
   * @private
   */


  function socketOnData(chunk) {
    if (!this[kWebSocket$1]._receiver.write(chunk)) {
      this.pause();
    }
  }
  /**
   * The listener of the `net.Socket` `'end'` event.
   *
   * @private
   */


  function socketOnEnd() {
    var websocket = this[kWebSocket$1];
    websocket._readyState = WebSocket$2.CLOSING;

    websocket._receiver.end();

    this.end();
  }
  /**
   * The listener of the `net.Socket` `'error'` event.
   *
   * @private
   */


  function socketOnError$1() {
    var websocket = this[kWebSocket$1];
    this.removeListener('error', socketOnError$1);
    this.on('error', NOOP);

    if (websocket) {
      websocket._readyState = WebSocket$2.CLOSING;
      this.destroy();
    }
  }

  var Duplex = require$$0__default$6["default"].Duplex;
  /**
   * Emits the `'close'` event on a stream.
   *
   * @param {Duplex} stream The stream.
   * @private
   */

  function emitClose$1(stream) {
    stream.emit('close');
  }
  /**
   * The listener of the `'end'` event.
   *
   * @private
   */


  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  /**
   * The listener of the `'error'` event.
   *
   * @param {Error} err The error
   * @private
   */


  function duplexOnError(err) {
    this.removeListener('error', duplexOnError);
    this.destroy();

    if (this.listenerCount('error') === 0) {
      // Do not suppress the throwing behavior.
      this.emit('error', err);
    }
  }
  /**
   * Wraps a `WebSocket` in a duplex stream.
   *
   * @param {WebSocket} ws The `WebSocket` to wrap
   * @param {Object} [options] The options for the `Duplex` constructor
   * @return {Duplex} The duplex stream
   * @public
   */


  function createWebSocketStream(ws, options) {
    var resumeOnReceiverDrain = true;
    var terminateOnDestroy = true;

    function receiverOnDrain() {
      if (resumeOnReceiverDrain) ws._socket.resume();
    }

    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        ws._receiver.removeAllListeners('drain');

        ws._receiver.on('drain', receiverOnDrain);
      });
    } else {
      ws._receiver.removeAllListeners('drain');

      ws._receiver.on('drain', receiverOnDrain);
    }

    var duplex = new Duplex(_extends$1({}, options, {
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    }));
    ws.on('message', function message(msg) {
      if (!duplex.push(msg)) {
        resumeOnReceiverDrain = false;

        ws._socket.pause();
      }
    });
    ws.once('error', function error(err) {
      if (duplex.destroyed) return; // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
      //
      // - If the `'error'` event is emitted before the `'open'` event, then
      //   `ws.terminate()` is a noop as no socket is assigned.
      // - Otherwise, the error is re-emitted by the listener of the `'error'`
      //   event of the `Receiver` object. The listener already closes the
      //   connection by calling `ws.close()`. This allows a close frame to be
      //   sent to the other peer. If `ws.terminate()` is called right after this,
      //   then the close frame might not be sent.

      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once('close', function close() {
      if (duplex.destroyed) return;
      duplex.push(null);
    });

    duplex._destroy = function (err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose$1, duplex);
        return;
      }

      var called = false;
      ws.once('error', function error(err) {
        called = true;
        callback(err);
      });
      ws.once('close', function close() {
        if (!called) callback(err);
        process.nextTick(emitClose$1, duplex);
      });
      if (terminateOnDestroy) ws.terminate();
    };

    duplex._final = function (callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once('open', function open() {
          duplex._final(callback);
        });
        return;
      } // If the value of the `_socket` property is `null` it means that `ws` is a
      // client websocket and the handshake failed. In fact, when this happens, a
      // socket is never assigned to the websocket. Wait for the `'error'` event
      // that will be emitted by the websocket.


      if (ws._socket === null) return;

      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted) duplex.destroy();
      } else {
        ws._socket.once('finish', function finish() {
          // `duplex` is not destroyed here because the `'end'` event will be
          // emitted on `duplex` after this `'finish'` event. The EOF signaling
          // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
          callback();
        });

        ws.close();
      }
    };

    duplex._read = function () {
      if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
        resumeOnReceiverDrain = true;
        if (!ws._receiver._writableState.needDrain) ws._socket.resume();
      }
    };

    duplex._write = function (chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once('open', function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }

      ws.send(chunk, callback);
    };

    duplex.on('end', duplexOnEnd);
    duplex.on('error', duplexOnError);
    return duplex;
  }

  var stream = createWebSocketStream;

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var EventEmitter = require$$0__default$3["default"];
  var http = require$$2__default$1["default"];
  var createHash = require$$0__default["default"].createHash;
  var PerMessageDeflate = permessageDeflate;
  var WebSocket$1 = websocket;
  var format = extension.format,
      parse = extension.parse;
  var GUID = constants$1.GUID,
      kWebSocket = constants$1.kWebSocket;
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;
  /**
   * Class representing a WebSocket server.
   *
   * @extends EventEmitter
   */

  var WebSocketServer = /*#__PURE__*/function (_EventEmitter) {
    _inheritsLoose(WebSocketServer, _EventEmitter);

    /**
     * Create a `WebSocketServer` instance.
     *
     * @param {Object} options Configuration options
     * @param {Number} [options.backlog=511] The maximum length of the queue of
     *     pending connections
     * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
     *     track clients
     * @param {Function} [options.handleProtocols] A hook to handle protocols
     * @param {String} [options.host] The hostname where to bind the server
     * @param {Number} [options.maxPayload=104857600] The maximum allowed message
     *     size
     * @param {Boolean} [options.noServer=false] Enable no server mode
     * @param {String} [options.path] Accept only connections matching this path
     * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
     *     permessage-deflate
     * @param {Number} [options.port] The port where to bind the server
     * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
     *     server to use
     * @param {Function} [options.verifyClient] A hook to reject connections
     * @param {Function} [callback] A listener for the `listening` event
     */
    function WebSocketServer(options, callback) {
      var _this;

      _this = _EventEmitter.call(this) || this;
      options = _extends$1({
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        // use default (511 as implemented in net.js)
        server: null,
        host: null,
        path: null,
        port: null
      }, options);

      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + 'must be specified');
      }

      if (options.port != null) {
        _this._server = http.createServer(function (req, res) {
          var body = http.STATUS_CODES[426];
          res.writeHead(426, {
            'Content-Length': body.length,
            'Content-Type': 'text/plain'
          });
          res.end(body);
        });

        _this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        _this._server = options.server;
      }

      if (_this._server) {
        var emitConnection = _this.emit.bind(_assertThisInitialized$1(_this), 'connection');

        _this._removeListeners = addListeners(_this._server, {
          listening: _this.emit.bind(_assertThisInitialized$1(_this), 'listening'),
          error: _this.emit.bind(_assertThisInitialized$1(_this), 'error'),
          upgrade: function upgrade(req, socket, head) {
            _this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }

      if (options.perMessageDeflate === true) options.perMessageDeflate = {};
      if (options.clientTracking) _this.clients = new Set();
      _this.options = options;
      _this._state = RUNNING;
      return _this;
    }
    /**
     * Returns the bound address, the address family name, and port of the server
     * as reported by the operating system if listening on an IP socket.
     * If the server is listening on a pipe or UNIX domain socket, the name is
     * returned as a string.
     *
     * @return {(Object|String|null)} The address of the server
     * @public
     */


    var _proto = WebSocketServer.prototype;

    _proto.address = function address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }

      if (!this._server) return null;
      return this._server.address();
    }
    /**
     * Close the server.
     *
     * @param {Function} [cb] Callback
     * @public
     */
    ;

    _proto.close = function close(cb) {
      if (cb) this.once('close', cb);

      if (this._state === CLOSED) {
        process.nextTick(emitClose, this);
        return;
      }

      if (this._state === CLOSING) return;
      this._state = CLOSING; //
      // Terminate all associated clients.
      //

      if (this.clients) {
        for (var _iterator = _createForOfIteratorHelperLoose(this.clients), _step; !(_step = _iterator()).done;) {
          var client = _step.value;
          client.terminate();
        }
      }

      var server = this._server;

      if (server) {
        this._removeListeners();

        this._removeListeners = this._server = null; //
        // Close the http server if it was internally created.
        //

        if (this.options.port != null) {
          server.close(emitClose.bind(undefined, this));
          return;
        }
      }

      process.nextTick(emitClose, this);
    }
    /**
     * See if a given request should be handled by this server instance.
     *
     * @param {http.IncomingMessage} req Request object to inspect
     * @return {Boolean} `true` if the request is valid, else `false`
     * @public
     */
    ;

    _proto.shouldHandle = function shouldHandle(req) {
      if (this.options.path) {
        var index = req.url.indexOf('?');
        var pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path) return false;
      }

      return true;
    }
    /**
     * Handle a HTTP Upgrade request.
     *
     * @param {http.IncomingMessage} req The request object
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @public
     */
    ;

    _proto.handleUpgrade = function handleUpgrade(req, socket, head, cb) {
      var _this2 = this;

      socket.on('error', socketOnError);
      var key = req.headers['sec-websocket-key'] !== undefined ? req.headers['sec-websocket-key'].trim() : false;
      var version = +req.headers['sec-websocket-version'];
      var extensions = {};

      if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
        return abortHandshake(socket, 400);
      }

      if (this.options.perMessageDeflate) {
        var perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);

        try {
          var offers = parse(req.headers['sec-websocket-extensions']);

          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          return abortHandshake(socket, 400);
        }
      } //
      // Optionally call external client verification handler.
      //


      if (this.options.verifyClient) {
        var info = {
          origin: req.headers["" + (version === 8 ? 'sec-websocket-origin' : 'origin')],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req: req
        };

        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, function (verified, code, message, headers) {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }

            _this2.completeUpgrade(key, extensions, req, socket, head, cb);
          });
          return;
        }

        if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
      }

      this.completeUpgrade(key, extensions, req, socket, head, cb);
    }
    /**
     * Upgrade the connection to WebSocket.
     *
     * @param {String} key The value of the `Sec-WebSocket-Key` header
     * @param {Object} extensions The accepted extensions
     * @param {http.IncomingMessage} req The request object
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @throws {Error} If called more than once with the same socket
     * @private
     */
    ;

    _proto.completeUpgrade = function completeUpgrade(key, extensions, req, socket, head, cb) {
      var _this3 = this;

      //
      // Destroy the socket if the client has already sent a FIN packet.
      //
      if (!socket.readable || !socket.writable) return socket.destroy();

      if (socket[kWebSocket]) {
        throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');
      }

      if (this._state > RUNNING) return abortHandshake(socket, 503);
      var digest = createHash('sha1').update(key + GUID).digest('base64');
      var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', "Sec-WebSocket-Accept: " + digest];
      var ws = new WebSocket$1(null);
      var protocol = req.headers['sec-websocket-protocol'];

      if (protocol) {
        protocol = protocol.split(',').map(trim); //
        // Optionally call external protocol selection handler.
        //

        if (this.options.handleProtocols) {
          protocol = this.options.handleProtocols(protocol, req);
        } else {
          protocol = protocol[0];
        }

        if (protocol) {
          headers.push("Sec-WebSocket-Protocol: " + protocol);
          ws._protocol = protocol;
        }
      }

      if (extensions[PerMessageDeflate.extensionName]) {
        var _format;

        var params = extensions[PerMessageDeflate.extensionName].params;
        var value = format((_format = {}, _format[PerMessageDeflate.extensionName] = [params], _format));
        headers.push("Sec-WebSocket-Extensions: " + value);
        ws._extensions = extensions;
      } //
      // Allow external modification/inspection of handshake headers.
      //


      this.emit('headers', headers, req);
      socket.write(headers.concat('\r\n').join('\r\n'));
      socket.removeListener('error', socketOnError);
      ws.setSocket(socket, head, this.options.maxPayload);

      if (this.clients) {
        this.clients.add(ws);
        ws.on('close', function () {
          return _this3.clients.delete(ws);
        });
      }

      cb(ws, req);
    };

    return WebSocketServer;
  }(EventEmitter);

  var websocketServer = WebSocketServer;
  /**
   * Add event listeners on an `EventEmitter` using a map of <event, listener>
   * pairs.
   *
   * @param {EventEmitter} server The event emitter
   * @param {Object.<String, Function>} map The listeners to add
   * @return {Function} A function that will remove the added listeners when
   *     called
   * @private
   */

  function addListeners(server, map) {
    for (var _i = 0, _Object$keys = Object.keys(map); _i < _Object$keys.length; _i++) {
      var event = _Object$keys[_i];
      server.on(event, map[event]);
    }

    return function removeListeners() {
      for (var _i2 = 0, _Object$keys2 = Object.keys(map); _i2 < _Object$keys2.length; _i2++) {
        var _event = _Object$keys2[_i2];
        server.removeListener(_event, map[_event]);
      }
    };
  }
  /**
   * Emit a `'close'` event on an `EventEmitter`.
   *
   * @param {EventEmitter} server The event emitter
   * @private
   */


  function emitClose(server) {
    server._state = CLOSED;
    server.emit('close');
  }
  /**
   * Handle premature socket errors.
   *
   * @private
   */


  function socketOnError() {
    this.destroy();
  }
  /**
   * Close the connection when preconditions are not fulfilled.
   *
   * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
   * @param {Number} code The HTTP response status code
   * @param {String} [message] The HTTP response body
   * @param {Object} [headers] Additional HTTP response headers
   * @private
   */


  function abortHandshake(socket, code, message, headers) {
    if (socket.writable) {
      message = message || http.STATUS_CODES[code];
      headers = _extends$1({
        Connection: 'close',
        'Content-Type': 'text/html',
        'Content-Length': Buffer.byteLength(message)
      }, headers);
      socket.write("HTTP/1.1 " + code + " " + http.STATUS_CODES[code] + "\r\n" + Object.keys(headers).map(function (h) {
        return h + ": " + headers[h];
      }).join('\r\n') + '\r\n\r\n' + message);
    }

    socket.removeListener('error', socketOnError);
    socket.destroy();
  }
  /**
   * Remove whitespace characters from both ends of a string.
   *
   * @param {String} str The string
   * @return {String} A new string representing `str` stripped of whitespace
   *     characters from both its beginning and end
   * @private
   */


  function trim(str) {
    return str.trim();
  }

  var WebSocket = websocket;
  WebSocket.createWebSocketStream = stream;
  WebSocket.Server = websocketServer;
  WebSocket.Receiver = receiver;
  WebSocket.Sender = sender;
  var ws = WebSocket;

  Object.defineProperty(cjs$1, "__esModule", {
    value: true
  });
  var tslib_1$2 = require$$0;
  var utils_1$4 = cjs$7;
  var network_1 = (0, tslib_1$2.__importDefault)(network);
  var WS = typeof commonjsGlobal.WebSocket !== "undefined" ? commonjsGlobal.WebSocket : ws;

  var SocketTransport = /*#__PURE__*/function () {
    function SocketTransport(opts) {
      var _this = this;

      this.opts = opts;
      this._queue = [];
      this._events = [];
      this._subscriptions = [];
      this._protocol = opts.protocol;
      this._version = opts.version;
      this._url = "";
      this._netMonitor = null;
      this._socket = null;
      this._nextSocket = null;
      this._subscriptions = opts.subscriptions || [];
      this._netMonitor = opts.netMonitor || new network_1.default();

      if (!opts.url || typeof opts.url !== "string") {
        throw new Error("Missing or invalid WebSocket url");
      }

      this._url = opts.url;

      this._netMonitor.on("online", function () {
        return _this._socketCreate();
      });
    }

    var _proto = SocketTransport.prototype;

    _proto.open = function open() {
      this._socketCreate();
    };

    _proto.close = function close() {
      this._socketClose();
    };

    _proto.send = function send(message, topic, silent) {
      if (!topic || typeof topic !== "string") {
        throw new Error("Missing or invalid topic field");
      }

      this._socketSend({
        topic: topic,
        type: "pub",
        payload: message,
        silent: !!silent
      });
    };

    _proto.subscribe = function subscribe(topic) {
      this._socketSend({
        topic: topic,
        type: "sub",
        payload: "",
        silent: true
      });
    };

    _proto.on = function on(event, callback) {
      this._events.push({
        event: event,
        callback: callback
      });
    };

    _proto._socketCreate = function _socketCreate() {
      var _this2 = this;

      if (this._nextSocket) {
        return;
      }

      var url = getWebSocketUrl(this._url, this._protocol, this._version);
      this._nextSocket = new WS(url);

      if (!this._nextSocket) {
        throw new Error("Failed to create socket");
      }

      this._nextSocket.onmessage = function (event) {
        return _this2._socketReceive(event);
      };

      this._nextSocket.onopen = function () {
        return _this2._socketOpen();
      };

      this._nextSocket.onerror = function (event) {
        return _this2._socketError(event);
      };

      this._nextSocket.onclose = function () {
        setTimeout(function () {
          _this2._nextSocket = null;

          _this2._socketCreate();
        }, 1000);
      };
    };

    _proto._socketOpen = function _socketOpen() {
      this._socketClose();

      this._socket = this._nextSocket;
      this._nextSocket = null;

      this._queueSubscriptions();

      this._pushQueue();
    };

    _proto._socketClose = function _socketClose() {
      if (this._socket) {
        this._socket.onclose = function () {};

        this._socket.close();
      }
    };

    _proto._socketSend = function _socketSend(socketMessage) {
      var message = JSON.stringify(socketMessage);

      if (this._socket && this._socket.readyState === 1) {
        this._socket.send(message);
      } else {
        this._setToQueue(socketMessage);

        this._socketCreate();
      }
    };

    _proto._socketReceive = function _socketReceive(event) {
      return (0, tslib_1$2.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
        var socketMessage, events;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                socketMessage = JSON.parse(event.data);
                _context.next = 7;
                break;

              case 4:
                _context.prev = 4;
                _context.t0 = _context["catch"](0);
                return _context.abrupt("return");

              case 7:
                this._socketSend({
                  topic: socketMessage.topic,
                  type: "ack",
                  payload: "",
                  silent: true
                });

                if (this._socket && this._socket.readyState === 1) {
                  events = this._events.filter(function (event) {
                    return event.event === "message";
                  });

                  if (events && events.length) {
                    events.forEach(function (event) {
                      return event.callback(socketMessage);
                    });
                  }
                }

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 4]]);
      }));
    };

    _proto._socketError = function _socketError(e) {
      var events = this._events.filter(function (event) {
        return event.event === "error";
      });

      if (events && events.length) {
        events.forEach(function (event) {
          return event.callback(e);
        });
      }
    };

    _proto._queueSubscriptions = function _queueSubscriptions() {
      var _this3 = this;

      var subscriptions = this._subscriptions;
      subscriptions.forEach(function (topic) {
        return _this3._queue.push({
          topic: topic,
          type: "sub",
          payload: "",
          silent: true
        });
      });
      this._subscriptions = this.opts.subscriptions || [];
    };

    _proto._setToQueue = function _setToQueue(socketMessage) {
      this._queue.push(socketMessage);
    };

    _proto._pushQueue = function _pushQueue() {
      var _this4 = this;

      var queue = this._queue;
      queue.forEach(function (socketMessage) {
        return _this4._socketSend(socketMessage);
      });
      this._queue = [];
    };

    _createClass$2(SocketTransport, [{
      key: "readyState",
      get: function get() {
        return this._socket ? this._socket.readyState : -1;
      },
      set: function set(value) {}
    }, {
      key: "connecting",
      get: function get() {
        return this.readyState === 0;
      },
      set: function set(value) {}
    }, {
      key: "connected",
      get: function get() {
        return this.readyState === 1;
      },
      set: function set(value) {}
    }, {
      key: "closing",
      get: function get() {
        return this.readyState === 2;
      },
      set: function set(value) {}
    }, {
      key: "closed",
      get: function get() {
        return this.readyState === 3;
      },
      set: function set(value) {}
    }]);

    return SocketTransport;
  }();

  function getWebSocketUrl(_url, protocol, version) {
    var _a, _b;

    var url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
    var splitUrl = url.split("?");
    var params = (0, utils_1$4.isBrowser)() ? {
      protocol: protocol,
      version: version,
      env: "browser",
      host: ((_a = (0, utils_1$4.getLocation)()) === null || _a === void 0 ? void 0 : _a.host) || ""
    } : {
      protocol: protocol,
      version: version,
      env: ((_b = (0, utils_1$4.detectEnv)()) === null || _b === void 0 ? void 0 : _b.name) || ""
    };
    var queryString = (0, utils_1$4.appendToQueryString)((0, utils_1$4.getQueryString)(splitUrl[1] || ""), params);
    return splitUrl[0] + "?" + queryString;
  }

  cjs$1.default = SocketTransport;

  var errors = {};

  Object.defineProperty(errors, "__esModule", {
    value: true
  });
  errors.ERROR_QRCODE_MODAL_USER_CLOSED = errors.ERROR_QRCODE_MODAL_NOT_PROVIDED = errors.ERROR_INVALID_URI = errors.ERROR_INVALID_RESPONSE = errors.ERROR_MISSING_REQUIRED = errors.ERROR_MISSING_ID = errors.ERROR_MISSING_METHOD = errors.ERROR_MISSING_ERROR = errors.ERROR_MISSING_RESULT = errors.ERROR_MISSING_JSON_RPC = errors.ERROR_SESSION_REJECTED = errors.ERROR_SESSION_DISCONNECTED = errors.ERROR_SESSION_CONNECTED = void 0;
  errors.ERROR_SESSION_CONNECTED = "Session currently connected";
  errors.ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
  errors.ERROR_SESSION_REJECTED = "Session Rejected";
  errors.ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
  errors.ERROR_MISSING_RESULT = "JSON-RPC success response must include \"result\" field";
  errors.ERROR_MISSING_ERROR = "JSON-RPC error response must include \"error\" field";
  errors.ERROR_MISSING_METHOD = "JSON RPC request must have valid \"method\" value";
  errors.ERROR_MISSING_ID = "JSON RPC request must have valid \"id\" value";
  errors.ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
  errors.ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
  errors.ERROR_INVALID_URI = "URI format is invalid";
  errors.ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
  errors.ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

  var events = {};

  Object.defineProperty(events, "__esModule", {
    value: true
  });
  var utils_1$3 = cjs$7;

  var EventManager = /*#__PURE__*/function () {
    function EventManager() {
      this._eventEmitters = [];
    }

    var _proto = EventManager.prototype;

    _proto.subscribe = function subscribe(eventEmitter) {
      this._eventEmitters.push(eventEmitter);
    };

    _proto.unsubscribe = function unsubscribe(event) {
      this._eventEmitters = this._eventEmitters.filter(function (x) {
        return x.event !== event;
      });
    };

    _proto.trigger = function trigger(payload) {
      var eventEmitters = [];
      var event;

      if ((0, utils_1$3.isJsonRpcRequest)(payload)) {
        event = payload.method;
      } else if ((0, utils_1$3.isJsonRpcResponseSuccess)(payload) || (0, utils_1$3.isJsonRpcResponseError)(payload)) {
        event = "response:" + payload.id;
      } else if ((0, utils_1$3.isInternalEvent)(payload)) {
        event = payload.event;
      } else {
        event = "";
      }

      if (event) {
        eventEmitters = this._eventEmitters.filter(function (eventEmitter) {
          return eventEmitter.event === event;
        });
      }

      if ((!eventEmitters || !eventEmitters.length) && !(0, utils_1$3.isReservedEvent)(event) && !(0, utils_1$3.isInternalEvent)(event)) {
        eventEmitters = this._eventEmitters.filter(function (eventEmitter) {
          return eventEmitter.event === "call_request";
        });
      }

      eventEmitters.forEach(function (eventEmitter) {
        if ((0, utils_1$3.isJsonRpcResponseError)(payload)) {
          var error = new Error(payload.error.message);
          eventEmitter.callback(error, null);
        } else {
          eventEmitter.callback(null, payload);
        }
      });
    };

    return EventManager;
  }();

  events.default = EventManager;

  var storage = {};

  Object.defineProperty(storage, "__esModule", {
    value: true
  });
  var utils_1$2 = cjs$7;

  var SessionStorage = /*#__PURE__*/function () {
    function SessionStorage(storageId) {
      if (storageId === void 0) {
        storageId = "walletconnect";
      }

      this.storageId = storageId;
    }

    var _proto = SessionStorage.prototype;

    _proto.getSession = function getSession() {
      var session = null;
      var json = (0, utils_1$2.getLocal)(this.storageId);

      if (json && (0, utils_1$2.isWalletConnectSession)(json)) {
        session = json;
      }

      return session;
    };

    _proto.setSession = function setSession(session) {
      (0, utils_1$2.setLocal)(this.storageId, session);
      return session;
    };

    _proto.removeSession = function removeSession() {
      (0, utils_1$2.removeLocal)(this.storageId);
    };

    return SessionStorage;
  }();

  storage.default = SessionStorage;

  var url = {};

  Object.defineProperty(url, "__esModule", {
    value: true
  });
  url.getBridgeUrl = url.shouldSelectRandomly = url.selectRandomBridgeUrl = url.randomBridgeIndex = url.extractRootDomain = url.extractHostname = void 0;
  var domain = "walletconnect.org";
  var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
  var bridges = alphanumerical.split("").map(function (char) {
    return "https://" + char + ".bridge.walletconnect.org";
  });

  function extractHostname(url) {
    var hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
    hostname = hostname.split(":")[0];
    hostname = hostname.split("?")[0];
    return hostname;
  }

  url.extractHostname = extractHostname;

  function extractRootDomain(url) {
    return extractHostname(url).split(".").slice(-2).join(".");
  }

  url.extractRootDomain = extractRootDomain;

  function randomBridgeIndex() {
    return Math.floor(Math.random() * bridges.length);
  }

  url.randomBridgeIndex = randomBridgeIndex;

  function selectRandomBridgeUrl() {
    return bridges[randomBridgeIndex()];
  }

  url.selectRandomBridgeUrl = selectRandomBridgeUrl;

  function shouldSelectRandomly(url) {
    return extractRootDomain(url) === domain;
  }

  url.shouldSelectRandomly = shouldSelectRandomly;

  function getBridgeUrl(url) {
    if (shouldSelectRandomly(url)) {
      return selectRandomBridgeUrl();
    }

    return url;
  }

  url.getBridgeUrl = getBridgeUrl;

  Object.defineProperty(cjs$8, "__esModule", {
    value: true
  });
  var tslib_1$1 = require$$0;
  var utils_1$1 = cjs$7;
  var socket_transport_1 = (0, tslib_1$1.__importDefault)(cjs$1);
  var errors_1 = errors;
  var events_1 = (0, tslib_1$1.__importDefault)(events);
  var storage_1 = (0, tslib_1$1.__importDefault)(storage);
  var url_1 = url;

  var Connector = /*#__PURE__*/function () {
    function Connector(opts) {
      this.protocol = "wc";
      this.version = 1;
      this._bridge = "";
      this._key = null;
      this._clientId = "";
      this._clientMeta = null;
      this._peerId = "";
      this._peerMeta = null;
      this._handshakeId = 0;
      this._handshakeTopic = "";
      this._connected = false;
      this._accounts = [];
      this._chainId = 0;
      this._networkId = 0;
      this._rpcUrl = "";
      this._eventManager = new events_1.default();
      this._clientMeta = (0, utils_1$1.getClientMeta)() || opts.connectorOpts.clientMeta || null;
      this._cryptoLib = opts.cryptoLib;
      this._sessionStorage = opts.sessionStorage || new storage_1.default(opts.connectorOpts.storageId);
      this._qrcodeModal = opts.connectorOpts.qrcodeModal;
      this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
      this._signingMethods = [].concat(utils_1$1.signingMethods, opts.connectorOpts.signingMethods || []);

      if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
        throw new Error(errors_1.ERROR_MISSING_REQUIRED);
      }

      if (opts.connectorOpts.bridge) {
        this.bridge = (0, url_1.getBridgeUrl)(opts.connectorOpts.bridge);
      }

      if (opts.connectorOpts.uri) {
        this.uri = opts.connectorOpts.uri;
      }

      var session = opts.connectorOpts.session || this._getStorageSession();

      if (session) {
        this.session = session;
      }

      if (this.handshakeId) {
        this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
      }

      this._transport = opts.transport || new socket_transport_1.default({
        protocol: this.protocol,
        version: this.version,
        url: this.bridge,
        subscriptions: [this.clientId]
      });

      this._subscribeToInternalEvents();

      this._initTransport();

      if (opts.connectorOpts.uri) {
        this._subscribeToSessionRequest();
      }

      if (opts.pushServerOpts) {
        this._registerPushServer(opts.pushServerOpts);
      }
    }

    var _proto = Connector.prototype;

    _proto.on = function on(event, callback) {
      var eventEmitter = {
        event: event,
        callback: callback
      };

      this._eventManager.subscribe(eventEmitter);
    };

    _proto.off = function off(event) {
      this._eventManager.unsubscribe(event);
    };

    _proto.createInstantRequest = function createInstantRequest(instantRequest) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
        var _this = this;

        var request, endInstantRequest, result;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._generateKey();

              case 2:
                this._key = _context.sent;
                request = this._formatRequest({
                  method: "wc_instantRequest",
                  params: [{
                    peerId: this.clientId,
                    peerMeta: this.clientMeta,
                    request: this._formatRequest(instantRequest)
                  }]
                });
                this.handshakeId = request.id;
                this.handshakeTopic = (0, utils_1$1.uuid)();

                this._eventManager.trigger({
                  event: "display_uri",
                  params: [this.uri]
                });

                this.on("modal_closed", function () {
                  throw new Error(errors_1.ERROR_QRCODE_MODAL_USER_CLOSED);
                });

                endInstantRequest = function endInstantRequest() {
                  _this.killSession();
                };

                _context.prev = 9;
                _context.next = 12;
                return this._sendCallRequest(request);

              case 12:
                result = _context.sent;

                if (result) {
                  endInstantRequest();
                }

                return _context.abrupt("return", result);

              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](9);
                endInstantRequest();
                throw _context.t0;

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[9, 17]]);
      }));
    };

    _proto.connect = function connect(opts) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee3() {
        var _this2 = this;

        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this._qrcodeModal) {
                  _context3.next = 2;
                  break;
                }

                throw new Error(errors_1.ERROR_QRCODE_MODAL_NOT_PROVIDED);

              case 2:
                if (!this.connected) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", {
                  chainId: this.chainId,
                  accounts: this.accounts
                });

              case 4:
                _context3.next = 6;
                return this.createSession(opts);

              case 6:
                return _context3.abrupt("return", new Promise(function (resolve, reject) {
                  return (0, tslib_1$1.__awaiter)(_this2, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee2() {
                    return regenerator.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            this.on("modal_closed", function () {
                              return reject(new Error(errors_1.ERROR_QRCODE_MODAL_USER_CLOSED));
                            });
                            this.on("connect", function (error, payload) {
                              if (error) {
                                return reject(error);
                              }

                              resolve(payload.params[0]);
                            });

                          case 2:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                }));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
    };

    _proto.createSession = function createSession(opts) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee4() {
        var request;
        return regenerator.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this._connected) {
                  _context4.next = 2;
                  break;
                }

                throw new Error(errors_1.ERROR_SESSION_CONNECTED);

              case 2:
                if (!this.pending) {
                  _context4.next = 4;
                  break;
                }

                return _context4.abrupt("return");

              case 4:
                _context4.next = 6;
                return this._generateKey();

              case 6:
                this._key = _context4.sent;
                request = this._formatRequest({
                  method: "wc_sessionRequest",
                  params: [{
                    peerId: this.clientId,
                    peerMeta: this.clientMeta,
                    chainId: opts && opts.chainId ? opts.chainId : null
                  }]
                });
                this.handshakeId = request.id;
                this.handshakeTopic = (0, utils_1$1.uuid)();

                this._sendSessionRequest(request, "Session update rejected", {
                  topic: this.handshakeTopic
                });

                this._eventManager.trigger({
                  event: "display_uri",
                  params: [this.uri]
                });

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
    };

    _proto.approveSession = function approveSession(sessionStatus) {
      if (this._connected) {
        throw new Error(errors_1.ERROR_SESSION_CONNECTED);
      }

      this.chainId = sessionStatus.chainId;
      this.accounts = sessionStatus.accounts;
      this.networkId = sessionStatus.networkId || 0;
      this.rpcUrl = sessionStatus.rpcUrl || "";
      var sessionParams = {
        approved: true,
        chainId: this.chainId,
        networkId: this.networkId,
        accounts: this.accounts,
        rpcUrl: this.rpcUrl,
        peerId: this.clientId,
        peerMeta: this.clientMeta
      };
      var response = {
        id: this.handshakeId,
        jsonrpc: "2.0",
        result: sessionParams
      };

      this._sendResponse(response);

      this._connected = true;

      this._setStorageSession();

      this._eventManager.trigger({
        event: "connect",
        params: [{
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }]
      });
    };

    _proto.rejectSession = function rejectSession(sessionError) {
      if (this._connected) {
        throw new Error(errors_1.ERROR_SESSION_CONNECTED);
      }

      var message = sessionError && sessionError.message ? sessionError.message : errors_1.ERROR_SESSION_REJECTED;

      var response = this._formatResponse({
        id: this.handshakeId,
        error: {
          message: message
        }
      });

      this._sendResponse(response);

      this._connected = false;

      this._eventManager.trigger({
        event: "disconnect",
        params: [{
          message: message
        }]
      });

      this._removeStorageSession();
    };

    _proto.updateSession = function updateSession(sessionStatus) {
      if (!this._connected) {
        throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);
      }

      this.chainId = sessionStatus.chainId;
      this.accounts = sessionStatus.accounts;
      this.networkId = sessionStatus.networkId || 0;
      this.rpcUrl = sessionStatus.rpcUrl || "";
      var sessionParams = {
        approved: true,
        chainId: this.chainId,
        networkId: this.networkId,
        accounts: this.accounts,
        rpcUrl: this.rpcUrl
      };

      var request = this._formatRequest({
        method: "wc_sessionUpdate",
        params: [sessionParams]
      });

      this._sendSessionRequest(request, "Session update rejected");

      this._eventManager.trigger({
        event: "session_update",
        params: [{
          chainId: this.chainId,
          accounts: this.accounts
        }]
      });

      this._manageStorageSession();
    };

    _proto.killSession = function killSession(sessionError) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee5() {
        var message, sessionParams, request;
        return regenerator.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                message = sessionError ? sessionError.message : "Session Disconnected";
                sessionParams = {
                  approved: false,
                  chainId: null,
                  networkId: null,
                  accounts: null
                };
                request = this._formatRequest({
                  method: "wc_sessionUpdate",
                  params: [sessionParams]
                });
                _context5.next = 5;
                return this._sendRequest(request);

              case 5:
                this._handleSessionDisconnect(message);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
    };

    _proto.sendTransaction = function sendTransaction(tx) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee6() {
        var parsedTx, request, result;
        return regenerator.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this._connected) {
                  _context6.next = 2;
                  break;
                }

                throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);

              case 2:
                parsedTx = (0, utils_1$1.parseTransactionData)(tx);
                request = this._formatRequest({
                  method: "eth_sendTransaction",
                  params: [parsedTx]
                });
                _context6.next = 6;
                return this._sendCallRequest(request);

              case 6:
                result = _context6.sent;
                return _context6.abrupt("return", result);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
    };

    _proto.signTransaction = function signTransaction(tx) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee7() {
        var parsedTx, request, result;
        return regenerator.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this._connected) {
                  _context7.next = 2;
                  break;
                }

                throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);

              case 2:
                parsedTx = (0, utils_1$1.parseTransactionData)(tx);
                request = this._formatRequest({
                  method: "eth_signTransaction",
                  params: [parsedTx]
                });
                _context7.next = 6;
                return this._sendCallRequest(request);

              case 6:
                result = _context7.sent;
                return _context7.abrupt("return", result);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));
    };

    _proto.signMessage = function signMessage(params) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee8() {
        var request, result;
        return regenerator.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this._connected) {
                  _context8.next = 2;
                  break;
                }

                throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);

              case 2:
                request = this._formatRequest({
                  method: "eth_sign",
                  params: params
                });
                _context8.next = 5;
                return this._sendCallRequest(request);

              case 5:
                result = _context8.sent;
                return _context8.abrupt("return", result);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
    };

    _proto.signPersonalMessage = function signPersonalMessage(params) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee9() {
        var request, result;
        return regenerator.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (this._connected) {
                  _context9.next = 2;
                  break;
                }

                throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);

              case 2:
                params = (0, utils_1$1.parsePersonalSign)(params);
                request = this._formatRequest({
                  method: "personal_sign",
                  params: params
                });
                _context9.next = 6;
                return this._sendCallRequest(request);

              case 6:
                result = _context9.sent;
                return _context9.abrupt("return", result);

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));
    };

    _proto.signTypedData = function signTypedData(params) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee10() {
        var request, result;
        return regenerator.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (this._connected) {
                  _context10.next = 2;
                  break;
                }

                throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);

              case 2:
                request = this._formatRequest({
                  method: "eth_signTypedData",
                  params: params
                });
                _context10.next = 5;
                return this._sendCallRequest(request);

              case 5:
                result = _context10.sent;
                return _context10.abrupt("return", result);

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));
    };

    _proto.updateChain = function updateChain(chainParams) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee11() {
        var request, result;
        return regenerator.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (this._connected) {
                  _context11.next = 2;
                  break;
                }

                throw new Error("Session currently disconnected");

              case 2:
                request = this._formatRequest({
                  method: "wallet_updateChain",
                  params: [chainParams]
                });
                _context11.next = 5;
                return this._sendCallRequest(request);

              case 5:
                result = _context11.sent;
                return _context11.abrupt("return", result);

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));
    };

    _proto.unsafeSend = function unsafeSend(request, options) {
      var _this3 = this;

      this._sendRequest(request, options);

      this._eventManager.trigger({
        event: "call_request_sent",
        params: [{
          request: request,
          options: options
        }]
      });

      return new Promise(function (resolve, reject) {
        _this3._subscribeToResponse(request.id, function (error, payload) {
          if (error) {
            reject(error);
            return;
          }

          if (!payload) {
            throw new Error(errors_1.ERROR_MISSING_JSON_RPC);
          }

          resolve(payload);
        });
      });
    };

    _proto.sendCustomRequest = function sendCustomRequest(request, options) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee12() {
        var formattedRequest, result;
        return regenerator.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (this._connected) {
                  _context12.next = 2;
                  break;
                }

                throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);

              case 2:
                _context12.t0 = request.method;
                _context12.next = _context12.t0 === "eth_accounts" ? 5 : _context12.t0 === "eth_chainId" ? 6 : _context12.t0 === "eth_sendTransaction" ? 7 : _context12.t0 === "eth_signTransaction" ? 7 : _context12.t0 === "personal_sign" ? 9 : 11;
                break;

              case 5:
                return _context12.abrupt("return", this.accounts);

              case 6:
                return _context12.abrupt("return", (0, utils_1$1.convertNumberToHex)(this.chainId));

              case 7:
                if (request.params) {
                  request.params[0] = (0, utils_1$1.parseTransactionData)(request.params[0]);
                }

                return _context12.abrupt("break", 12);

              case 9:
                if (request.params) {
                  request.params = (0, utils_1$1.parsePersonalSign)(request.params);
                }

                return _context12.abrupt("break", 12);

              case 11:
                return _context12.abrupt("break", 12);

              case 12:
                formattedRequest = this._formatRequest(request);
                _context12.next = 15;
                return this._sendCallRequest(formattedRequest, options);

              case 15:
                result = _context12.sent;
                return _context12.abrupt("return", result);

              case 17:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));
    };

    _proto.approveRequest = function approveRequest(response) {
      if ((0, utils_1$1.isJsonRpcResponseSuccess)(response)) {
        var formattedResponse = this._formatResponse(response);

        this._sendResponse(formattedResponse);
      } else {
        throw new Error(errors_1.ERROR_MISSING_RESULT);
      }
    };

    _proto.rejectRequest = function rejectRequest(response) {
      if ((0, utils_1$1.isJsonRpcResponseError)(response)) {
        var formattedResponse = this._formatResponse(response);

        this._sendResponse(formattedResponse);
      } else {
        throw new Error(errors_1.ERROR_MISSING_ERROR);
      }
    };

    _proto.transportClose = function transportClose() {
      this._transport.close();
    };

    _proto._sendRequest = function _sendRequest(request, options) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee13() {
        var callRequest, encryptionPayload, topic, payload, silent;
        return regenerator.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                callRequest = this._formatRequest(request);
                _context13.next = 3;
                return this._encrypt(callRequest);

              case 3:
                encryptionPayload = _context13.sent;
                topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
                payload = JSON.stringify(encryptionPayload);
                silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : (0, utils_1$1.isSilentPayload)(callRequest);

                this._transport.send(payload, topic, silent);

              case 8:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));
    };

    _proto._sendResponse = function _sendResponse(response) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee14() {
        var encryptionPayload, topic, payload, silent;
        return regenerator.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this._encrypt(response);

              case 2:
                encryptionPayload = _context14.sent;
                topic = this.peerId;
                payload = JSON.stringify(encryptionPayload);
                silent = true;

                this._transport.send(payload, topic, silent);

              case 7:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));
    };

    _proto._sendSessionRequest = function _sendSessionRequest(request, errorMsg, options) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee15() {
        return regenerator.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                this._sendRequest(request, options);

                this._subscribeToSessionResponse(request.id, errorMsg);

              case 2:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));
    };

    _proto._sendCallRequest = function _sendCallRequest(request, options) {
      this._sendRequest(request, options);

      this._eventManager.trigger({
        event: "call_request_sent",
        params: [{
          request: request,
          options: options
        }]
      });

      return this._subscribeToCallResponse(request.id);
    };

    _proto._formatRequest = function _formatRequest(request) {
      if (typeof request.method === "undefined") {
        throw new Error(errors_1.ERROR_MISSING_METHOD);
      }

      var formattedRequest = {
        id: typeof request.id === "undefined" ? (0, utils_1$1.payloadId)() : request.id,
        jsonrpc: "2.0",
        method: request.method,
        params: typeof request.params === "undefined" ? [] : request.params
      };
      return formattedRequest;
    };

    _proto._formatResponse = function _formatResponse(response) {
      if (typeof response.id === "undefined") {
        throw new Error(errors_1.ERROR_MISSING_ID);
      }

      var baseResponse = {
        id: response.id,
        jsonrpc: "2.0"
      };

      if ((0, utils_1$1.isJsonRpcResponseError)(response)) {
        var error = (0, utils_1$1.formatRpcError)(response.error);
        var errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), {
          error: error
        });
        return errorResponse;
      } else if ((0, utils_1$1.isJsonRpcResponseSuccess)(response)) {
        var successResponse = Object.assign(Object.assign({}, baseResponse), response);
        return successResponse;
      }

      throw new Error(errors_1.ERROR_INVALID_RESPONSE);
    };

    _proto._handleSessionDisconnect = function _handleSessionDisconnect(errorMsg) {
      var message = errorMsg || "Session Disconnected";

      if (!this._connected) {
        if (this._qrcodeModal) {
          this._qrcodeModal.close();
        }

        (0, utils_1$1.removeLocal)(utils_1$1.mobileLinkChoiceKey);
      }

      if (this._connected) {
        this._connected = false;
      }

      if (this._handshakeId) {
        this._handshakeId = 0;
      }

      if (this._handshakeTopic) {
        this._handshakeTopic = "";
      }

      this._eventManager.trigger({
        event: "disconnect",
        params: [{
          message: message
        }]
      });

      this._removeStorageSession();

      this.transportClose();
    };

    _proto._handleSessionResponse = function _handleSessionResponse(errorMsg, sessionParams) {
      if (sessionParams) {
        if (sessionParams.approved) {
          if (!this._connected) {
            this._connected = true;

            if (sessionParams.chainId) {
              this.chainId = sessionParams.chainId;
            }

            if (sessionParams.accounts) {
              this.accounts = sessionParams.accounts;
            }

            if (sessionParams.peerId && !this.peerId) {
              this.peerId = sessionParams.peerId;
            }

            if (sessionParams.peerMeta && !this.peerMeta) {
              this.peerMeta = sessionParams.peerMeta;
            }

            this._eventManager.trigger({
              event: "connect",
              params: [{
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }]
            });
          } else {
            if (sessionParams.chainId) {
              this.chainId = sessionParams.chainId;
            }

            if (sessionParams.accounts) {
              this.accounts = sessionParams.accounts;
            }

            this._eventManager.trigger({
              event: "session_update",
              params: [{
                chainId: this.chainId,
                accounts: this.accounts
              }]
            });
          }

          this._manageStorageSession();
        } else {
          this._handleSessionDisconnect(errorMsg);
        }
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    };

    _proto._handleIncomingMessages = function _handleIncomingMessages(socketMessage) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee16() {
        var activeTopics, encryptionPayload, payload;
        return regenerator.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                activeTopics = [this.clientId, this.handshakeTopic];

                if (activeTopics.includes(socketMessage.topic)) {
                  _context16.next = 3;
                  break;
                }

                return _context16.abrupt("return");

              case 3:
                _context16.prev = 3;
                encryptionPayload = JSON.parse(socketMessage.payload);
                _context16.next = 10;
                break;

              case 7:
                _context16.prev = 7;
                _context16.t0 = _context16["catch"](3);
                return _context16.abrupt("return");

              case 10:
                _context16.next = 12;
                return this._decrypt(encryptionPayload);

              case 12:
                payload = _context16.sent;

                if (payload) {
                  this._eventManager.trigger(payload);
                }

              case 14:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[3, 7]]);
      }));
    };

    _proto._subscribeToSessionRequest = function _subscribeToSessionRequest() {
      this._transport.subscribe(this.handshakeTopic);
    };

    _proto._subscribeToResponse = function _subscribeToResponse(id, callback) {
      this.on("response:" + id, callback);
    };

    _proto._subscribeToSessionResponse = function _subscribeToSessionResponse(id, errorMsg) {
      var _this4 = this;

      this._subscribeToResponse(id, function (error, payload) {
        if (error) {
          _this4._handleSessionResponse(error.message);

          return;
        }

        if (payload.result) {
          _this4._handleSessionResponse(errorMsg, payload.result);
        } else if (payload.error && payload.error.message) {
          _this4._handleSessionResponse(payload.error.message);
        } else {
          _this4._handleSessionResponse(errorMsg);
        }
      });
    };

    _proto._subscribeToCallResponse = function _subscribeToCallResponse(id) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        _this5._subscribeToResponse(id, function (error, payload) {
          if (error) {
            reject(error);
            return;
          }

          if (payload.result) {
            resolve(payload.result);
          } else if (payload.error && payload.error.message) {
            reject(new Error(payload.error.message));
          } else {
            reject(new Error(errors_1.ERROR_INVALID_RESPONSE));
          }
        });
      });
    };

    _proto._subscribeToInternalEvents = function _subscribeToInternalEvents() {
      var _this6 = this;

      this.on("display_uri", function () {
        if (_this6._qrcodeModal) {
          _this6._qrcodeModal.open(_this6.uri, function () {
            _this6._eventManager.trigger({
              event: "modal_closed",
              params: []
            });
          }, _this6._qrcodeModalOptions);
        }
      });
      this.on("connect", function () {
        if (_this6._qrcodeModal) {
          _this6._qrcodeModal.close();
        }
      });
      this.on("call_request_sent", function (error, payload) {
        var request = payload.params[0].request;

        if ((0, utils_1$1.isMobile)() && _this6._signingMethods.includes(request.method)) {
          var mobileLinkUrl = (0, utils_1$1.getLocal)(utils_1$1.mobileLinkChoiceKey);

          if (mobileLinkUrl) {
            window.location.href = mobileLinkUrl.href;
          }
        }
      });
      this.on("wc_sessionRequest", function (error, payload) {
        if (error) {
          _this6._eventManager.trigger({
            event: "error",
            params: [{
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }]
          });
        }

        _this6.handshakeId = payload.id;
        _this6.peerId = payload.params[0].peerId;
        _this6.peerMeta = payload.params[0].peerMeta;
        var internalPayload = Object.assign(Object.assign({}, payload), {
          method: "session_request"
        });

        _this6._eventManager.trigger(internalPayload);
      });
      this.on("wc_sessionUpdate", function (error, payload) {
        if (error) {
          _this6._handleSessionResponse(error.message);
        }

        _this6._handleSessionResponse("Session disconnected", payload.params[0]);
      });
    };

    _proto._initTransport = function _initTransport() {
      var _this7 = this;

      this._transport.on("message", function (socketMessage) {
        return _this7._handleIncomingMessages(socketMessage);
      });

      this._transport.on("open", function () {
        return _this7._eventManager.trigger({
          event: "transport_open",
          params: []
        });
      });

      this._transport.on("close", function () {
        return _this7._eventManager.trigger({
          event: "transport_close",
          params: []
        });
      });

      this._transport.on("error", function () {
        return _this7._eventManager.trigger({
          event: "transport_error",
          params: ["Websocket connection failed"]
        });
      });

      this._transport.open();
    };

    _proto._formatUri = function _formatUri() {
      var protocol = this.protocol;
      var handshakeTopic = this.handshakeTopic;
      var version = this.version;
      var bridge = encodeURIComponent(this.bridge);
      var key = this.key;
      var uri = protocol + ":" + handshakeTopic + "@" + version + "?bridge=" + bridge + "&key=" + key;
      return uri;
    };

    _proto._parseUri = function _parseUri(uri) {
      var result = (0, utils_1$1.parseWalletConnectUri)(uri);

      if (result.protocol === this.protocol) {
        if (!result.handshakeTopic) {
          throw Error("Invalid or missing handshakeTopic parameter value");
        }

        var handshakeTopic = result.handshakeTopic;

        if (!result.bridge) {
          throw Error("Invalid or missing bridge url parameter value");
        }

        var bridge = decodeURIComponent(result.bridge);

        if (!result.key) {
          throw Error("Invalid or missing key parameter value");
        }

        var key = result.key;
        return {
          handshakeTopic: handshakeTopic,
          bridge: bridge,
          key: key
        };
      } else {
        throw new Error(errors_1.ERROR_INVALID_URI);
      }
    };

    _proto._generateKey = function _generateKey() {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee17() {
        var result;
        return regenerator.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!this._cryptoLib) {
                  _context17.next = 5;
                  break;
                }

                _context17.next = 3;
                return this._cryptoLib.generateKey();

              case 3:
                result = _context17.sent;
                return _context17.abrupt("return", result);

              case 5:
                return _context17.abrupt("return", null);

              case 6:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));
    };

    _proto._encrypt = function _encrypt(data) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee18() {
        var key, result;
        return regenerator.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                key = this._key;

                if (!(this._cryptoLib && key)) {
                  _context18.next = 6;
                  break;
                }

                _context18.next = 4;
                return this._cryptoLib.encrypt(data, key);

              case 4:
                result = _context18.sent;
                return _context18.abrupt("return", result);

              case 6:
                return _context18.abrupt("return", null);

              case 7:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));
    };

    _proto._decrypt = function _decrypt(payload) {
      return (0, tslib_1$1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee19() {
        var key, result;
        return regenerator.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                key = this._key;

                if (!(this._cryptoLib && key)) {
                  _context19.next = 6;
                  break;
                }

                _context19.next = 4;
                return this._cryptoLib.decrypt(payload, key);

              case 4:
                result = _context19.sent;
                return _context19.abrupt("return", result);

              case 6:
                return _context19.abrupt("return", null);

              case 7:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));
    };

    _proto._getStorageSession = function _getStorageSession() {
      var result = null;

      if (this._sessionStorage) {
        result = this._sessionStorage.getSession();
      }

      return result;
    };

    _proto._setStorageSession = function _setStorageSession() {
      if (this._sessionStorage) {
        this._sessionStorage.setSession(this.session);
      }
    };

    _proto._removeStorageSession = function _removeStorageSession() {
      if (this._sessionStorage) {
        this._sessionStorage.removeSession();
      }
    };

    _proto._manageStorageSession = function _manageStorageSession() {
      if (this._connected) {
        this._setStorageSession();
      } else {
        this._removeStorageSession();
      }
    };

    _proto._registerPushServer = function _registerPushServer(pushServerOpts) {
      var _this8 = this;

      if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
        throw Error("Invalid or missing pushServerOpts.url parameter value");
      }

      if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
        throw Error("Invalid or missing pushServerOpts.type parameter value");
      }

      if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
        throw Error("Invalid or missing pushServerOpts.token parameter value");
      }

      var pushSubscription = {
        bridge: this.bridge,
        topic: this.clientId,
        type: pushServerOpts.type,
        token: pushServerOpts.token,
        peerName: "",
        language: pushServerOpts.language || ""
      };
      this.on("connect", function (error, payload) {
        return (0, tslib_1$1.__awaiter)(_this8, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee20() {
          var peerName, response, json;
          return regenerator.wrap(function _callee20$(_context20) {
            while (1) {
              switch (_context20.prev = _context20.next) {
                case 0:
                  if (!error) {
                    _context20.next = 2;
                    break;
                  }

                  throw error;

                case 2:
                  if (pushServerOpts.peerMeta) {
                    peerName = payload.params[0].peerMeta.name;
                    pushSubscription.peerName = peerName;
                  }

                  _context20.prev = 3;
                  _context20.next = 6;
                  return fetch(pushServerOpts.url + "/new", {
                    method: "POST",
                    headers: {
                      Accept: "application/json",
                      "Content-Type": "application/json"
                    },
                    body: JSON.stringify(pushSubscription)
                  });

                case 6:
                  response = _context20.sent;
                  _context20.next = 9;
                  return response.json();

                case 9:
                  json = _context20.sent;

                  if (json.success) {
                    _context20.next = 12;
                    break;
                  }

                  throw Error("Failed to register in Push Server");

                case 12:
                  _context20.next = 17;
                  break;

                case 14:
                  _context20.prev = 14;
                  _context20.t0 = _context20["catch"](3);
                  throw Error("Failed to register in Push Server");

                case 17:
                case "end":
                  return _context20.stop();
              }
            }
          }, _callee20, null, [[3, 14]]);
        }));
      });
    };

    _createClass$2(Connector, [{
      key: "bridge",
      get: function get() {
        return this._bridge;
      },
      set: function set(value) {
        if (!value) {
          return;
        }

        this._bridge = value;
      }
    }, {
      key: "key",
      get: function get() {
        if (this._key) {
          var key = (0, utils_1$1.convertArrayBufferToHex)(this._key, true);
          return key;
        }

        return "";
      },
      set: function set(value) {
        if (!value) {
          return;
        }

        var key = (0, utils_1$1.convertHexToArrayBuffer)(value);
        this._key = key;
      }
    }, {
      key: "clientId",
      get: function get() {
        var clientId = this._clientId;

        if (!clientId) {
          clientId = this._clientId = (0, utils_1$1.uuid)();
        }

        return this._clientId;
      },
      set: function set(value) {
        if (!value) {
          return;
        }

        this._clientId = value;
      }
    }, {
      key: "peerId",
      get: function get() {
        return this._peerId;
      },
      set: function set(value) {
        if (!value) {
          return;
        }

        this._peerId = value;
      }
    }, {
      key: "clientMeta",
      get: function get() {
        var clientMeta = this._clientMeta;

        if (!clientMeta) {
          clientMeta = this._clientMeta = (0, utils_1$1.getClientMeta)();
        }

        return clientMeta;
      },
      set: function set(value) {}
    }, {
      key: "peerMeta",
      get: function get() {
        var peerMeta = this._peerMeta;
        return peerMeta;
      },
      set: function set(value) {
        this._peerMeta = value;
      }
    }, {
      key: "handshakeTopic",
      get: function get() {
        return this._handshakeTopic;
      },
      set: function set(value) {
        if (!value) {
          return;
        }

        this._handshakeTopic = value;
      }
    }, {
      key: "handshakeId",
      get: function get() {
        return this._handshakeId;
      },
      set: function set(value) {
        if (!value) {
          return;
        }

        this._handshakeId = value;
      }
    }, {
      key: "uri",
      get: function get() {
        var _uri = this._formatUri();

        return _uri;
      },
      set: function set(value) {
        if (!value) {
          return;
        }

        var _this$_parseUri = this._parseUri(value),
            handshakeTopic = _this$_parseUri.handshakeTopic,
            bridge = _this$_parseUri.bridge,
            key = _this$_parseUri.key;

        this.handshakeTopic = handshakeTopic;
        this.bridge = bridge;
        this.key = key;
      }
    }, {
      key: "chainId",
      get: function get() {
        var chainId = this._chainId;
        return chainId;
      },
      set: function set(value) {
        this._chainId = value;
      }
    }, {
      key: "networkId",
      get: function get() {
        var networkId = this._networkId;
        return networkId;
      },
      set: function set(value) {
        this._networkId = value;
      }
    }, {
      key: "accounts",
      get: function get() {
        var accounts = this._accounts;
        return accounts;
      },
      set: function set(value) {
        this._accounts = value;
      }
    }, {
      key: "rpcUrl",
      get: function get() {
        var rpcUrl = this._rpcUrl;
        return rpcUrl;
      },
      set: function set(value) {
        this._rpcUrl = value;
      }
    }, {
      key: "connected",
      get: function get() {
        return this._connected;
      },
      set: function set(value) {}
    }, {
      key: "pending",
      get: function get() {
        return !!this._handshakeTopic;
      },
      set: function set(value) {}
    }, {
      key: "session",
      get: function get() {
        return {
          connected: this.connected,
          accounts: this.accounts,
          chainId: this.chainId,
          bridge: this.bridge,
          key: this.key,
          clientId: this.clientId,
          clientMeta: this.clientMeta,
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          handshakeId: this.handshakeId,
          handshakeTopic: this.handshakeTopic
        };
      },
      set: function set(value) {
        if (!value) {
          return;
        }

        this._connected = value.connected;
        this.accounts = value.accounts;
        this.chainId = value.chainId;
        this.bridge = value.bridge;
        this.key = value.key;
        this.clientId = value.clientId;
        this.clientMeta = value.clientMeta;
        this.peerId = value.peerId;
        this.peerMeta = value.peerMeta;
        this.handshakeId = value.handshakeId;
        this.handshakeTopic = value.handshakeTopic;
      }
    }]);

    return Connector;
  }();

  cjs$8.default = Connector;

  var cjs = {};

  var node$2 = {};

  var node$1 = {};

  var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(node$1, "__esModule", {
    value: true
  });
  node$1.randomBytes = void 0;

  var crypto_1$1 = __importDefault$1(require$$0__default["default"]);

  var encoding_1$1 = cjs$3;

  function randomBytes(length) {
    var buf = crypto_1$1.default.randomBytes(length);
    return encoding_1$1.bufferToArray(buf);
  }

  node$1.randomBytes = randomBytes;

  var aes = {};

  var node = {};

  var constants = {};

  var _default = {};

  var length = {};

  Object.defineProperty(length, "__esModule", {
    value: true
  });
  length.LENGTH_1024 = length.LENGTH_512 = length.LENGTH_256 = length.LENGTH_128 = length.LENGTH_64 = length.LENGTH_32 = length.LENGTH_16 = length.LENGTH_1 = length.LENGTH_0 = void 0;
  length.LENGTH_0 = 0;
  length.LENGTH_1 = 1;
  length.LENGTH_16 = 16;
  length.LENGTH_32 = 32;
  length.LENGTH_64 = 64;
  length.LENGTH_128 = 128;
  length.LENGTH_256 = 256;
  length.LENGTH_512 = 512;
  length.LENGTH_1024 = 1024;

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MAC_LENGTH = exports.IV_LENGTH = exports.KEY_LENGTH = exports.PREFIX_LENGTH = exports.RIPEMD160_NODE_ALGO = exports.SHA512_NODE_ALGO = exports.SHA256_NODE_ALGO = exports.HMAC_NODE_ALGO = exports.AES_NODE_ALGO = exports.SHA512_BROWSER_ALGO = exports.SHA256_BROWSER_ALGO = exports.HMAC_BROWSER = exports.HMAC_BROWSER_ALGO = exports.AES_BROWSER_ALGO = exports.HMAC_LENGTH = exports.AES_LENGTH = void 0;
    var length_1 = length;
    exports.AES_LENGTH = length_1.LENGTH_256;
    exports.HMAC_LENGTH = length_1.LENGTH_256;
    exports.AES_BROWSER_ALGO = "AES-CBC";
    exports.HMAC_BROWSER_ALGO = "SHA-" + exports.AES_LENGTH;
    exports.HMAC_BROWSER = "HMAC";
    exports.SHA256_BROWSER_ALGO = "SHA-256";
    exports.SHA512_BROWSER_ALGO = "SHA-512";
    exports.AES_NODE_ALGO = "aes-" + exports.AES_LENGTH + "-cbc";
    exports.HMAC_NODE_ALGO = "sha" + exports.HMAC_LENGTH;
    exports.SHA256_NODE_ALGO = "sha256";
    exports.SHA512_NODE_ALGO = "sha512";
    exports.RIPEMD160_NODE_ALGO = "ripemd160";
    exports.PREFIX_LENGTH = length_1.LENGTH_1;
    exports.KEY_LENGTH = length_1.LENGTH_32;
    exports.IV_LENGTH = length_1.LENGTH_16;
    exports.MAC_LENGTH = length_1.LENGTH_32;
  })(_default);

  var encoding$1 = {};

  Object.defineProperty(encoding$1, "__esModule", {
    value: true
  });
  encoding$1.UTF8_ENC = encoding$1.HEX_ENC = void 0;
  encoding$1.HEX_ENC = "hex";
  encoding$1.UTF8_ENC = "utf8";

  var error = {};

  Object.defineProperty(error, "__esModule", {
    value: true
  });
  error.ERROR_BAD_MAC = void 0;
  error.ERROR_BAD_MAC = "Bad MAC";

  var operations = {};

  Object.defineProperty(operations, "__esModule", {
    value: true
  });
  operations.VERIFY_OP = operations.SIGN_OP = operations.DECRYPT_OP = operations.ENCRYPT_OP = void 0;
  operations.ENCRYPT_OP = "encrypt";
  operations.DECRYPT_OP = "decrypt";
  operations.SIGN_OP = "sign";
  operations.VERIFY_OP = "verify";

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(_default, exports);

    __exportStar(encoding$1, exports);

    __exportStar(error, exports);

    __exportStar(length, exports);

    __exportStar(operations, exports);
  })(constants);

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(node, "__esModule", {
    value: true
  });
  node.nodeRipemd160 = node.nodeSha512 = node.nodeSha256 = node.nodeHmacSha512Sign = node.nodeHmacSha256Sign = node.nodeAesDecrypt = node.nodeAesEncrypt = void 0;

  var crypto_1 = __importDefault(require$$0__default["default"]);

  var encoding_1 = cjs$3;
  var constants_1 = constants;

  function nodeAesEncrypt(iv, key, data) {
    var cipher = crypto_1.default.createCipheriv(constants_1.AES_NODE_ALGO, Buffer.from(key), Buffer.from(iv));
    return encoding_1.bufferToArray(encoding_1.concatBuffers(cipher.update(Buffer.from(data)), cipher.final()));
  }

  node.nodeAesEncrypt = nodeAesEncrypt;

  function nodeAesDecrypt(iv, key, data) {
    var decipher = crypto_1.default.createDecipheriv(constants_1.AES_NODE_ALGO, Buffer.from(key), Buffer.from(iv));
    return encoding_1.bufferToArray(encoding_1.concatBuffers(decipher.update(Buffer.from(data)), decipher.final()));
  }

  node.nodeAesDecrypt = nodeAesDecrypt;

  function nodeHmacSha256Sign(key, data) {
    var buf = crypto_1.default.createHmac(constants_1.HMAC_NODE_ALGO, Buffer.from(key)).update(Buffer.from(data)).digest();
    return encoding_1.bufferToArray(buf);
  }

  node.nodeHmacSha256Sign = nodeHmacSha256Sign;

  function nodeHmacSha512Sign(key, data) {
    var buf = crypto_1.default.createHmac(constants_1.SHA512_NODE_ALGO, Buffer.from(key)).update(Buffer.from(data)).digest();
    return encoding_1.bufferToArray(buf);
  }

  node.nodeHmacSha512Sign = nodeHmacSha512Sign;

  function nodeSha256(data) {
    var buf = crypto_1.default.createHash(constants_1.SHA256_NODE_ALGO).update(Buffer.from(data)).digest();
    return encoding_1.bufferToArray(buf);
  }

  node.nodeSha256 = nodeSha256;

  function nodeSha512(data) {
    var buf = crypto_1.default.createHash(constants_1.SHA512_NODE_ALGO).update(Buffer.from(data)).digest();
    return encoding_1.bufferToArray(buf);
  }

  node.nodeSha512 = nodeSha512;

  function nodeRipemd160(data) {
    var buf = crypto_1.default.createHash(constants_1.RIPEMD160_NODE_ALGO).update(Buffer.from(data)).digest();
    return encoding_1.bufferToArray(buf);
  }

  node.nodeRipemd160 = nodeRipemd160;

  var __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  Object.defineProperty(aes, "__esModule", {
    value: true
  });
  aes.aesCbcDecrypt = aes.aesCbcEncrypt = void 0;
  var node_1$2 = node;

  function aesCbcEncrypt(iv, key, data) {
    return __awaiter$2(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
      var result;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              result = node_1$2.nodeAesEncrypt(iv, key, data);
              return _context.abrupt("return", result);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
  }

  aes.aesCbcEncrypt = aesCbcEncrypt;

  function aesCbcDecrypt(iv, key, data) {
    return __awaiter$2(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee2() {
      var result;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              result = node_1$2.nodeAesDecrypt(iv, key, data);
              return _context2.abrupt("return", result);

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  }

  aes.aesCbcDecrypt = aesCbcDecrypt;

  var hmac = {};

  var helpers = {};

  var env = {};

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(cjs$2, exports);
  })(env);

  var pkcs7 = {};

  Object.defineProperty(pkcs7, "__esModule", {
    value: true
  });
  pkcs7.pkcs7 = void 0;
  var PADDING = [[16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16], [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14], [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13], [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12], [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11], [10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [9, 9, 9, 9, 9, 9, 9, 9, 9], [8, 8, 8, 8, 8, 8, 8, 8], [7, 7, 7, 7, 7, 7, 7], [6, 6, 6, 6, 6, 6], [5, 5, 5, 5, 5], [4, 4, 4, 4], [3, 3, 3], [2, 2], [1]];
  pkcs7.pkcs7 = {
    pad: function pad(plaintext) {
      var padding = PADDING[plaintext.byteLength % 16 || 0];
      var result = new Uint8Array(plaintext.byteLength + padding.length);
      result.set(plaintext);
      result.set(padding, plaintext.byteLength);
      return result;
    },
    unpad: function unpad(padded) {
      return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
    }
  };

  var types = {};

  Object.defineProperty(types, "__esModule", {
    value: true
  });

  var validators = {};

  Object.defineProperty(validators, "__esModule", {
    value: true
  });
  validators.isConstantTime = validators.assert = void 0;

  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  validators.assert = assert;

  function isConstantTime(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }

    var res = 0;

    for (var i = 0; i < arr1.length; i++) {
      res |= arr1[i] ^ arr2[i];
    }

    return res === 0;
  }

  validators.isConstantTime = isConstantTime;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(env, exports);

    __exportStar(pkcs7, exports);

    __exportStar(types, exports);

    __exportStar(validators, exports);
  })(helpers);

  var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  Object.defineProperty(hmac, "__esModule", {
    value: true
  });
  hmac.hmacSha512Verify = hmac.hmacSha512Sign = hmac.hmacSha256Verify = hmac.hmacSha256Sign = void 0;
  var helpers_1 = helpers;
  var node_1$1 = node;

  function hmacSha256Sign(key, msg) {
    return __awaiter$1(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
      var result;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              result = node_1$1.nodeHmacSha256Sign(key, msg);
              return _context.abrupt("return", result);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
  }

  hmac.hmacSha256Sign = hmacSha256Sign;

  function hmacSha256Verify(key, msg, sig) {
    return __awaiter$1(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee2() {
      var expectedSig, result;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              expectedSig = node_1$1.nodeHmacSha256Sign(key, msg);
              result = helpers_1.isConstantTime(expectedSig, sig);
              return _context2.abrupt("return", result);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  }

  hmac.hmacSha256Verify = hmacSha256Verify;

  function hmacSha512Sign(key, msg) {
    return __awaiter$1(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee3() {
      var result;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              result = node_1$1.nodeHmacSha512Sign(key, msg);
              return _context3.abrupt("return", result);

            case 2:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
  }

  hmac.hmacSha512Sign = hmacSha512Sign;

  function hmacSha512Verify(key, msg, sig) {
    return __awaiter$1(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee4() {
      var expectedSig, result;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              expectedSig = node_1$1.nodeHmacSha512Sign(key, msg);
              result = helpers_1.isConstantTime(expectedSig, sig);
              return _context4.abrupt("return", result);

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
  }

  hmac.hmacSha512Verify = hmacSha512Verify;

  var sha2 = {};

  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  Object.defineProperty(sha2, "__esModule", {
    value: true
  });
  sha2.ripemd160 = sha2.sha512 = sha2.sha256 = void 0;
  var node_1 = node;

  function sha256(msg) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
      var result;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              result = node_1.nodeSha256(msg);
              return _context.abrupt("return", result);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
  }

  sha2.sha256 = sha256;

  function sha512(msg) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee2() {
      var result;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              result = node_1.nodeSha512(msg);
              return _context2.abrupt("return", result);

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  }

  sha2.sha512 = sha512;

  function ripemd160(msg) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee3() {
      var result;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              result = node_1.nodeRipemd160(msg);
              return _context3.abrupt("return", result);

            case 2:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
  }

  sha2.ripemd160 = ripemd160;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(node$1, exports);

    __exportStar(aes, exports);

    __exportStar(hmac, exports);

    __exportStar(sha2, exports);

    __exportStar(helpers, exports);

    __exportStar(constants, exports);
  })(node$2);

  Object.defineProperty(cjs, "__esModule", {
    value: true
  });
  cjs.decrypt = cjs.encrypt = cjs.verifyHmac = cjs.generateKey = void 0;
  var tslib_1 = require$$0;
  var crypto$1 = (0, tslib_1.__importStar)(node$2);
  var encoding = (0, tslib_1.__importStar)(cjs$3);
  var utils_1 = cjs$7;

  function generateKey(length) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
      var _length, bytes, result;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _length = (length || 256) / 8;
              bytes = crypto$1.randomBytes(_length);
              result = (0, utils_1.convertBufferToArrayBuffer)(encoding.arrayToBuffer(bytes));
              return _context.abrupt("return", result);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
  }

  cjs.generateKey = generateKey;

  function verifyHmac(payload, key) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee2() {
      var cipherText, iv, hmac, hmacHex, unsigned, chmac, chmacHex;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              cipherText = encoding.hexToArray(payload.data);
              iv = encoding.hexToArray(payload.iv);
              hmac = encoding.hexToArray(payload.hmac);
              hmacHex = encoding.arrayToHex(hmac, false);
              unsigned = encoding.concatArrays(cipherText, iv);
              _context2.next = 7;
              return crypto$1.hmacSha256Sign(key, unsigned);

            case 7:
              chmac = _context2.sent;
              chmacHex = encoding.arrayToHex(chmac, false);

              if (!(encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex))) {
                _context2.next = 11;
                break;
              }

              return _context2.abrupt("return", true);

            case 11:
              return _context2.abrupt("return", false);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  }

  cjs.verifyHmac = verifyHmac;

  function encrypt(data, key, providedIv) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee3() {
      var _key, ivArrayBuffer, iv, ivHex, contentString, content, cipherText, cipherTextHex, unsigned, hmac, hmacHex;

      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _key = encoding.bufferToArray((0, utils_1.convertArrayBufferToBuffer)(key));
              _context3.t0 = providedIv;

              if (_context3.t0) {
                _context3.next = 6;
                break;
              }

              _context3.next = 5;
              return generateKey(128);

            case 5:
              _context3.t0 = _context3.sent;

            case 6:
              ivArrayBuffer = _context3.t0;
              iv = encoding.bufferToArray((0, utils_1.convertArrayBufferToBuffer)(ivArrayBuffer));
              ivHex = encoding.arrayToHex(iv, false);
              contentString = JSON.stringify(data);
              content = encoding.utf8ToArray(contentString);
              _context3.next = 13;
              return crypto$1.aesCbcEncrypt(iv, _key, content);

            case 13:
              cipherText = _context3.sent;
              cipherTextHex = encoding.arrayToHex(cipherText, false);
              unsigned = encoding.concatArrays(cipherText, iv);
              _context3.next = 18;
              return crypto$1.hmacSha256Sign(_key, unsigned);

            case 18:
              hmac = _context3.sent;
              hmacHex = encoding.arrayToHex(hmac, false);
              return _context3.abrupt("return", {
                data: cipherTextHex,
                hmac: hmacHex,
                iv: ivHex
              });

            case 21:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
  }

  cjs.encrypt = encrypt;

  function decrypt(payload, key) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee4() {
      var _key, verified, cipherText, iv, buffer, utf8, data;

      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _key = encoding.bufferToArray((0, utils_1.convertArrayBufferToBuffer)(key));

              if (_key) {
                _context4.next = 3;
                break;
              }

              throw new Error("Missing key: required for decryption");

            case 3:
              _context4.next = 5;
              return verifyHmac(payload, _key);

            case 5:
              verified = _context4.sent;

              if (verified) {
                _context4.next = 8;
                break;
              }

              return _context4.abrupt("return", null);

            case 8:
              cipherText = encoding.hexToArray(payload.data);
              iv = encoding.hexToArray(payload.iv);
              _context4.next = 12;
              return crypto$1.aesCbcDecrypt(iv, _key, cipherText);

            case 12:
              buffer = _context4.sent;
              utf8 = encoding.arrayToUtf8(buffer);
              _context4.prev = 14;
              data = JSON.parse(utf8);
              _context4.next = 21;
              break;

            case 18:
              _context4.prev = 18;
              _context4.t0 = _context4["catch"](14);
              return _context4.abrupt("return", null);

            case 21:
              return _context4.abrupt("return", data);

            case 22:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, null, [[14, 18]]);
    }));
  }

  cjs.decrypt = decrypt;

  typeof global.WebSocket !== 'undefined' ? global.WebSocket : require('ws'); // -- SocketTransport ------------------------------------------------------ //

  // ---------------------------------------------
  // session
  // ---------------------------------------------
  var WalletConnectSessionStatus;

  (function (WalletConnectSessionStatus) {
    WalletConnectSessionStatus["REQUESTED"] = "REQUESTED";
    WalletConnectSessionStatus["CONNECTED"] = "CONNECTED";
    WalletConnectSessionStatus["DISCONNECTED"] = "DISCONNECTED";
  })(WalletConnectSessionStatus || (WalletConnectSessionStatus = {}));

  var Subscribable = /*#__PURE__*/function () {
    function Subscribable() {
      this.listeners = [];
    }

    var _proto = Subscribable.prototype;

    _proto.subscribe = function subscribe(listener) {
      var _this = this;

      var callback = listener || function () {
        return undefined;
      };

      this.listeners.push(callback);
      this.onSubscribe();
      return function () {
        _this.listeners = _this.listeners.filter(function (x) {
          return x !== callback;
        });

        _this.onUnsubscribe();
      };
    };

    _proto.hasListeners = function hasListeners() {
      return this.listeners.length > 0;
    };

    _proto.onSubscribe = function onSubscribe() {// Do nothing
    };

    _proto.onUnsubscribe = function onUnsubscribe() {// Do nothing
    };

    return Subscribable;
  }();

  // UTILS

  var isServer = typeof window === 'undefined';
  function noop() {
    return undefined;
  }
  function isValidTimeout(value) {
    return typeof value === 'number' && value >= 0 && value !== Infinity;
  }
  function timeUntilStale(updatedAt, staleTime) {
    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
  }
  function parseQueryArgs(arg1, arg2, arg3) {
    if (!isQueryKey(arg1)) {
      return arg1;
    }

    if (typeof arg2 === 'function') {
      return _extends$1({}, arg3, {
        queryKey: arg1,
        queryFn: arg2
      });
    }

    return _extends$1({}, arg2, {
      queryKey: arg1
    });
  }
  function parseMutationArgs(arg1, arg2, arg3) {
    if (isQueryKey(arg1)) {
      if (typeof arg2 === 'function') {
        return _extends$1({}, arg3, {
          mutationKey: arg1,
          mutationFn: arg2
        });
      }

      return _extends$1({}, arg2, {
        mutationKey: arg1
      });
    }

    if (typeof arg1 === 'function') {
      return _extends$1({}, arg2, {
        mutationFn: arg1
      });
    }

    return _extends$1({}, arg1);
  }
  /**
   * This function returns `a` if `b` is deeply equal.
   * If not, it will replace any deeply equal children of `b` with those of `a`.
   * This can be used for structural sharing between JSON values for example.
   */

  function replaceEqualDeep(a, b) {
    if (a === b) {
      return a;
    }

    var array = Array.isArray(a) && Array.isArray(b);

    if (array || isPlainObject(a) && isPlainObject(b)) {
      var aSize = array ? a.length : Object.keys(a).length;
      var bItems = array ? b : Object.keys(b);
      var bSize = bItems.length;
      var copy = array ? [] : {};
      var equalItems = 0;

      for (var i = 0; i < bSize; i++) {
        var key = array ? i : bItems[i];
        copy[key] = replaceEqualDeep(a[key], b[key]);

        if (copy[key] === a[key]) {
          equalItems++;
        }
      }

      return aSize === bSize && equalItems === aSize ? a : copy;
    }

    return b;
  }
  /**
   * Shallow compare objects. Only works with objects that always have the same properties.
   */

  function shallowEqualObjects(a, b) {
    if (a && !b || b && !a) {
      return false;
    }

    for (var key in a) {
      if (a[key] !== b[key]) {
        return false;
      }
    }

    return true;
  } // Copied from: https://github.com/jonschlinkert/is-plain-object

  function isPlainObject(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    } // If has modified constructor


    var ctor = o.constructor;

    if (typeof ctor === 'undefined') {
      return true;
    } // If has modified prototype


    var prot = ctor.prototype;

    if (!hasObjectPrototype(prot)) {
      return false;
    } // If constructor does not have an Object-specific method


    if (!prot.hasOwnProperty('isPrototypeOf')) {
      return false;
    } // Most likely a plain Object


    return true;
  }

  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  }

  function isQueryKey(value) {
    return typeof value === 'string' || Array.isArray(value);
  }
  /**
   * Schedules a microtask.
   * This can be useful to schedule state updates after rendering.
   */

  function scheduleMicrotask(callback) {
    Promise.resolve().then(callback).catch(function (error) {
      return setTimeout(function () {
        throw error;
      });
    });
  }

  var FocusManager = /*#__PURE__*/function (_Subscribable) {
    _inheritsLoose(FocusManager, _Subscribable);

    function FocusManager() {
      return _Subscribable.apply(this, arguments) || this;
    }

    var _proto = FocusManager.prototype;

    _proto.onSubscribe = function onSubscribe() {
      if (!this.removeEventListener) {
        this.setDefaultEventListener();
      }
    };

    _proto.setEventListener = function setEventListener(setup) {
      var _this = this;

      if (this.removeEventListener) {
        this.removeEventListener();
      }

      this.removeEventListener = setup(function (focused) {
        if (typeof focused === 'boolean') {
          _this.setFocused(focused);
        } else {
          _this.onFocus();
        }
      });
    };

    _proto.setFocused = function setFocused(focused) {
      this.focused = focused;

      if (focused) {
        this.onFocus();
      }
    };

    _proto.onFocus = function onFocus() {
      this.listeners.forEach(function (listener) {
        listener();
      });
    };

    _proto.isFocused = function isFocused() {
      if (typeof this.focused === 'boolean') {
        return this.focused;
      } // document global can be unavailable in react native


      if (typeof document === 'undefined') {
        return true;
      }

      return [undefined, 'visible', 'prerender'].includes(document.visibilityState);
    };

    _proto.setDefaultEventListener = function setDefaultEventListener() {
      var _window;

      if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {
        this.setEventListener(function (onFocus) {
          var listener = function listener() {
            return onFocus();
          }; // Listen to visibillitychange and focus


          window.addEventListener('visibilitychange', listener, false);
          window.addEventListener('focus', listener, false);
          return function () {
            // Be sure to unsubscribe if a new handler is set
            window.removeEventListener('visibilitychange', listener);
            window.removeEventListener('focus', listener);
          };
        });
      }
    };

    return FocusManager;
  }(Subscribable);

  var focusManager = new FocusManager();

  var CancelledError = function CancelledError(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  };
  function isCancelledError(value) {
    return value instanceof CancelledError;
  } // CLASS

  // CLASS

  var NotifyManager = /*#__PURE__*/function () {
    function NotifyManager() {
      this.queue = [];
      this.transactions = 0;

      this.notifyFn = function (callback) {
        callback();
      };

      this.batchNotifyFn = function (callback) {
        callback();
      };
    }

    var _proto = NotifyManager.prototype;

    _proto.batch = function batch(callback) {
      this.transactions++;
      var result = callback();
      this.transactions--;

      if (!this.transactions) {
        this.flush();
      }

      return result;
    };

    _proto.schedule = function schedule(callback) {
      var _this = this;

      if (this.transactions) {
        this.queue.push(callback);
      } else {
        scheduleMicrotask(function () {
          _this.notifyFn(callback);
        });
      }
    }
    /**
     * All calls to the wrapped function will be batched.
     */
    ;

    _proto.batchCalls = function batchCalls(callback) {
      var _this2 = this;

      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this2.schedule(function () {
          callback.apply(void 0, args);
        });
      };
    };

    _proto.flush = function flush() {
      var _this3 = this;

      var queue = this.queue;
      this.queue = [];

      if (queue.length) {
        scheduleMicrotask(function () {
          _this3.batchNotifyFn(function () {
            queue.forEach(function (callback) {
              _this3.notifyFn(callback);
            });
          });
        });
      }
    }
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    ;

    _proto.setNotifyFunction = function setNotifyFunction(fn) {
      this.notifyFn = fn;
    }
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    ;

    _proto.setBatchNotifyFunction = function setBatchNotifyFunction(fn) {
      this.batchNotifyFn = fn;
    };

    return NotifyManager;
  }(); // SINGLETON


  var notifyManager = new NotifyManager();

  // FUNCTIONS

  var logger$1 = console || {
    error: noop,
    warn: noop,
    log: noop
  };
  function getLogger() {
    return logger$1;
  }
  function setLogger(newLogger) {
    logger$1 = newLogger;
  }

  function getDefaultState() {
    return {
      context: undefined,
      data: undefined,
      error: null,
      failureCount: 0,
      isPaused: false,
      status: 'idle',
      variables: undefined
    };
  }

  var QueryObserver = /*#__PURE__*/function (_Subscribable) {
    _inheritsLoose(QueryObserver, _Subscribable);

    function QueryObserver(client, options) {
      var _this;

      _this = _Subscribable.call(this) || this;
      _this.client = client;
      _this.options = options;
      _this.trackedProps = [];
      _this.previousSelectError = null;

      _this.bindMethods();

      _this.setOptions(options);

      return _this;
    }

    var _proto = QueryObserver.prototype;

    _proto.bindMethods = function bindMethods() {
      this.remove = this.remove.bind(this);
      this.refetch = this.refetch.bind(this);
    };

    _proto.onSubscribe = function onSubscribe() {
      if (this.listeners.length === 1) {
        this.currentQuery.addObserver(this);

        if (shouldFetchOnMount(this.currentQuery, this.options)) {
          this.executeFetch();
        }

        this.updateTimers();
      }
    };

    _proto.onUnsubscribe = function onUnsubscribe() {
      if (!this.listeners.length) {
        this.destroy();
      }
    };

    _proto.shouldFetchOnReconnect = function shouldFetchOnReconnect() {
      return _shouldFetchOnReconnect(this.currentQuery, this.options);
    };

    _proto.shouldFetchOnWindowFocus = function shouldFetchOnWindowFocus() {
      return _shouldFetchOnWindowFocus(this.currentQuery, this.options);
    };

    _proto.destroy = function destroy() {
      this.listeners = [];
      this.clearTimers();
      this.currentQuery.removeObserver(this);
    };

    _proto.setOptions = function setOptions(options, notifyOptions) {
      var prevOptions = this.options;
      var prevQuery = this.currentQuery;
      this.options = this.client.defaultQueryObserverOptions(options);

      if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {
        throw new Error('Expected enabled to be a boolean');
      } // Keep previous query key if the user does not supply one


      if (!this.options.queryKey) {
        this.options.queryKey = prevOptions.queryKey;
      }

      this.updateQuery();
      var mounted = this.hasListeners(); // Fetch if there are subscribers

      if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
        this.executeFetch();
      } // Update result


      this.updateResult(notifyOptions); // Update stale interval if needed

      if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
        this.updateStaleTimeout();
      }

      var nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed

      if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
        this.updateRefetchInterval(nextRefetchInterval);
      }
    };

    _proto.getOptimisticResult = function getOptimisticResult(options) {
      var defaultedOptions = this.client.defaultQueryObserverOptions(options);
      var query = this.client.getQueryCache().build(this.client, defaultedOptions);
      return this.createResult(query, defaultedOptions);
    };

    _proto.getCurrentResult = function getCurrentResult() {
      return this.currentResult;
    };

    _proto.trackResult = function trackResult(result) {
      var _this2 = this;

      var trackedResult = {};
      Object.keys(result).forEach(function (key) {
        Object.defineProperty(trackedResult, key, {
          configurable: false,
          enumerable: true,
          get: function get() {
            var typedKey = key;

            if (!_this2.trackedProps.includes(typedKey)) {
              _this2.trackedProps.push(typedKey);
            }

            return result[typedKey];
          }
        });
      });
      return trackedResult;
    };

    _proto.getNextResult = function getNextResult(options) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var unsubscribe = _this3.subscribe(function (result) {
          if (!result.isFetching) {
            unsubscribe();

            if (result.isError && (options == null ? void 0 : options.throwOnError)) {
              reject(result.error);
            } else {
              resolve(result);
            }
          }
        });
      });
    };

    _proto.getCurrentQuery = function getCurrentQuery() {
      return this.currentQuery;
    };

    _proto.remove = function remove() {
      this.client.getQueryCache().remove(this.currentQuery);
    };

    _proto.refetch = function refetch(options) {
      return this.fetch(_extends$1({}, options, {
        meta: {
          refetchPage: options == null ? void 0 : options.refetchPage
        }
      }));
    };

    _proto.fetchOptimistic = function fetchOptimistic(options) {
      var _this4 = this;

      var defaultedOptions = this.client.defaultQueryObserverOptions(options);
      var query = this.client.getQueryCache().build(this.client, defaultedOptions);
      return query.fetch().then(function () {
        return _this4.createResult(query, defaultedOptions);
      });
    };

    _proto.fetch = function fetch(fetchOptions) {
      var _this5 = this;

      return this.executeFetch(fetchOptions).then(function () {
        _this5.updateResult();

        return _this5.currentResult;
      });
    };

    _proto.executeFetch = function executeFetch(fetchOptions) {
      // Make sure we reference the latest query as the current one might have been removed
      this.updateQuery(); // Fetch

      var promise = this.currentQuery.fetch(this.options, fetchOptions);

      if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
        promise = promise.catch(noop);
      }

      return promise;
    };

    _proto.updateStaleTimeout = function updateStaleTimeout() {
      var _this6 = this;

      this.clearStaleTimeout();

      if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
        return;
      }

      var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.
      // To mitigate this issue we always add 1 ms to the timeout.

      var timeout = time + 1;
      this.staleTimeoutId = setTimeout(function () {
        if (!_this6.currentResult.isStale) {
          _this6.updateResult();
        }
      }, timeout);
    };

    _proto.computeRefetchInterval = function computeRefetchInterval() {
      var _this$options$refetch;

      return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
    };

    _proto.updateRefetchInterval = function updateRefetchInterval(nextInterval) {
      var _this7 = this;

      this.clearRefetchInterval();
      this.currentRefetchInterval = nextInterval;

      if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
        return;
      }

      this.refetchIntervalId = setInterval(function () {
        if (_this7.options.refetchIntervalInBackground || focusManager.isFocused()) {
          _this7.executeFetch();
        }
      }, this.currentRefetchInterval);
    };

    _proto.updateTimers = function updateTimers() {
      this.updateStaleTimeout();
      this.updateRefetchInterval(this.computeRefetchInterval());
    };

    _proto.clearTimers = function clearTimers() {
      this.clearStaleTimeout();
      this.clearRefetchInterval();
    };

    _proto.clearStaleTimeout = function clearStaleTimeout() {
      clearTimeout(this.staleTimeoutId);
      this.staleTimeoutId = undefined;
    };

    _proto.clearRefetchInterval = function clearRefetchInterval() {
      clearInterval(this.refetchIntervalId);
      this.refetchIntervalId = undefined;
    };

    _proto.createResult = function createResult(query, options) {
      var prevQuery = this.currentQuery;
      var prevOptions = this.options;
      var prevResult = this.currentResult;
      var prevResultState = this.currentResultState;
      var prevResultOptions = this.currentResultOptions;
      var queryChange = query !== prevQuery;
      var queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
      var prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
      var state = query.state;
      var dataUpdatedAt = state.dataUpdatedAt,
          error = state.error,
          errorUpdatedAt = state.errorUpdatedAt,
          isFetching = state.isFetching,
          status = state.status;
      var isPreviousData = false;
      var isPlaceholderData = false;
      var data; // Optimistically set result in fetching state if needed

      if (options.optimisticResults) {
        var mounted = this.hasListeners();
        var fetchOnMount = !mounted && shouldFetchOnMount(query, options);
        var fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);

        if (fetchOnMount || fetchOptionally) {
          isFetching = true;

          if (!dataUpdatedAt) {
            status = 'loading';
          }
        }
      } // Keep previous data if needed


      if (options.keepPreviousData && !state.dataUpdateCount && (prevQueryResult == null ? void 0 : prevQueryResult.isSuccess) && status !== 'error') {
        data = prevQueryResult.data;
        dataUpdatedAt = prevQueryResult.dataUpdatedAt;
        status = prevQueryResult.status;
        isPreviousData = true;
      } // Select data if needed
      else if (options.select && typeof state.data !== 'undefined') {
        // Memoize select result
        if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === (prevResultOptions == null ? void 0 : prevResultOptions.select) && !this.previousSelectError) {
          data = prevResult.data;
        } else {
          try {
            data = options.select(state.data);

            if (options.structuralSharing !== false) {
              data = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, data);
            }

            this.previousSelectError = null;
          } catch (selectError) {
            getLogger().error(selectError);
            error = selectError;
            this.previousSelectError = selectError;
            errorUpdatedAt = Date.now();
            status = 'error';
          }
        }
      } // Use query data
      else {
        data = state.data;
      } // Show placeholder data if needed


      if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && (status === 'loading' || status === 'idle')) {
        var placeholderData; // Memoize placeholder data

        if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
          placeholderData = prevResult.data;
        } else {
          placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;

          if (options.select && typeof placeholderData !== 'undefined') {
            try {
              placeholderData = options.select(placeholderData);

              if (options.structuralSharing !== false) {
                placeholderData = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, placeholderData);
              }

              this.previousSelectError = null;
            } catch (selectError) {
              getLogger().error(selectError);
              error = selectError;
              this.previousSelectError = selectError;
              errorUpdatedAt = Date.now();
              status = 'error';
            }
          }
        }

        if (typeof placeholderData !== 'undefined') {
          status = 'success';
          data = placeholderData;
          isPlaceholderData = true;
        }
      }

      var result = {
        status: status,
        isLoading: status === 'loading',
        isSuccess: status === 'success',
        isError: status === 'error',
        isIdle: status === 'idle',
        data: data,
        dataUpdatedAt: dataUpdatedAt,
        error: error,
        errorUpdatedAt: errorUpdatedAt,
        failureCount: state.fetchFailureCount,
        isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
        isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
        isFetching: isFetching,
        isRefetching: isFetching && status !== 'loading',
        isLoadingError: status === 'error' && state.dataUpdatedAt === 0,
        isPlaceholderData: isPlaceholderData,
        isPreviousData: isPreviousData,
        isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,
        isStale: isStale(query, options),
        refetch: this.refetch,
        remove: this.remove
      };
      return result;
    };

    _proto.shouldNotifyListeners = function shouldNotifyListeners(result, prevResult) {
      if (!prevResult) {
        return true;
      }

      if (result === prevResult) {
        return false;
      }

      var _this$options = this.options,
          notifyOnChangeProps = _this$options.notifyOnChangeProps,
          notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;

      if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {
        return true;
      }

      if (notifyOnChangeProps === 'tracked' && !this.trackedProps.length) {
        return true;
      }

      var includedProps = notifyOnChangeProps === 'tracked' ? this.trackedProps : notifyOnChangeProps;
      return Object.keys(result).some(function (key) {
        var typedKey = key;
        var changed = result[typedKey] !== prevResult[typedKey];
        var isIncluded = includedProps == null ? void 0 : includedProps.some(function (x) {
          return x === key;
        });
        var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function (x) {
          return x === key;
        });
        return changed && !isExcluded && (!includedProps || isIncluded);
      });
    };

    _proto.updateResult = function updateResult(notifyOptions) {
      var prevResult = this.currentResult;
      this.currentResult = this.createResult(this.currentQuery, this.options);
      this.currentResultState = this.currentQuery.state;
      this.currentResultOptions = this.options; // Only notify if something has changed

      if (shallowEqualObjects(this.currentResult, prevResult)) {
        return;
      } // Determine which callbacks to trigger


      var defaultNotifyOptions = {
        cache: true
      };

      if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && this.shouldNotifyListeners(this.currentResult, prevResult)) {
        defaultNotifyOptions.listeners = true;
      }

      this.notify(_extends$1({}, defaultNotifyOptions, notifyOptions));
    };

    _proto.updateQuery = function updateQuery() {
      var query = this.client.getQueryCache().build(this.client, this.options);

      if (query === this.currentQuery) {
        return;
      }

      var prevQuery = this.currentQuery;
      this.currentQuery = query;
      this.currentQueryInitialState = query.state;
      this.previousQueryResult = this.currentResult;

      if (this.hasListeners()) {
        prevQuery == null ? void 0 : prevQuery.removeObserver(this);
        query.addObserver(this);
      }
    };

    _proto.onQueryUpdate = function onQueryUpdate(action) {
      var notifyOptions = {};

      if (action.type === 'success') {
        notifyOptions.onSuccess = true;
      } else if (action.type === 'error' && !isCancelledError(action.error)) {
        notifyOptions.onError = true;
      }

      this.updateResult(notifyOptions);

      if (this.hasListeners()) {
        this.updateTimers();
      }
    };

    _proto.notify = function notify(notifyOptions) {
      var _this8 = this;

      notifyManager.batch(function () {
        // First trigger the configuration callbacks
        if (notifyOptions.onSuccess) {
          _this8.options.onSuccess == null ? void 0 : _this8.options.onSuccess(_this8.currentResult.data);
          _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(_this8.currentResult.data, null);
        } else if (notifyOptions.onError) {
          _this8.options.onError == null ? void 0 : _this8.options.onError(_this8.currentResult.error);
          _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(undefined, _this8.currentResult.error);
        } // Then trigger the listeners


        if (notifyOptions.listeners) {
          _this8.listeners.forEach(function (listener) {
            listener(_this8.currentResult);
          });
        } // Then the cache listeners


        if (notifyOptions.cache) {
          _this8.client.getQueryCache().notify({
            query: _this8.currentQuery,
            type: 'observerResultsUpdated'
          });
        }
      });
    };

    return QueryObserver;
  }(Subscribable);

  function shouldLoadOnMount(query, options) {
    return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);
  }

  function shouldRefetchOnMount(query, options) {
    return options.enabled !== false && query.state.dataUpdatedAt > 0 && (options.refetchOnMount === 'always' || options.refetchOnMount !== false && isStale(query, options));
  }

  function shouldFetchOnMount(query, options) {
    return shouldLoadOnMount(query, options) || shouldRefetchOnMount(query, options);
  }

  function _shouldFetchOnReconnect(query, options) {
    return options.enabled !== false && (options.refetchOnReconnect === 'always' || options.refetchOnReconnect !== false && isStale(query, options));
  }

  function _shouldFetchOnWindowFocus(query, options) {
    return options.enabled !== false && (options.refetchOnWindowFocus === 'always' || options.refetchOnWindowFocus !== false && isStale(query, options));
  }

  function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
    return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error' || prevOptions.enabled === false) && isStale(query, options);
  }

  function isStale(query, options) {
    return query.isStaleByTime(options.staleTime);
  }

  var MutationObserver = /*#__PURE__*/function (_Subscribable) {
    _inheritsLoose(MutationObserver, _Subscribable);

    function MutationObserver(client, options) {
      var _this;

      _this = _Subscribable.call(this) || this;
      _this.client = client;

      _this.setOptions(options);

      _this.bindMethods();

      _this.updateResult();

      return _this;
    }

    var _proto = MutationObserver.prototype;

    _proto.bindMethods = function bindMethods() {
      this.mutate = this.mutate.bind(this);
      this.reset = this.reset.bind(this);
    };

    _proto.setOptions = function setOptions(options) {
      this.options = this.client.defaultMutationOptions(options);
    };

    _proto.onUnsubscribe = function onUnsubscribe() {
      if (!this.listeners.length) {
        var _this$currentMutation;

        (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);
      }
    };

    _proto.onMutationUpdate = function onMutationUpdate(action) {
      this.updateResult(); // Determine which callbacks to trigger

      var notifyOptions = {
        listeners: true
      };

      if (action.type === 'success') {
        notifyOptions.onSuccess = true;
      } else if (action.type === 'error') {
        notifyOptions.onError = true;
      }

      this.notify(notifyOptions);
    };

    _proto.getCurrentResult = function getCurrentResult() {
      return this.currentResult;
    };

    _proto.reset = function reset() {
      this.currentMutation = undefined;
      this.updateResult();
      this.notify({
        listeners: true
      });
    };

    _proto.mutate = function mutate(variables, options) {
      this.mutateOptions = options;

      if (this.currentMutation) {
        this.currentMutation.removeObserver(this);
      }

      this.currentMutation = this.client.getMutationCache().build(this.client, _extends$1({}, this.options, {
        variables: typeof variables !== 'undefined' ? variables : this.options.variables
      }));
      this.currentMutation.addObserver(this);
      return this.currentMutation.execute();
    };

    _proto.updateResult = function updateResult() {
      var state = this.currentMutation ? this.currentMutation.state : getDefaultState();

      var result = _extends$1({}, state, {
        isLoading: state.status === 'loading',
        isSuccess: state.status === 'success',
        isError: state.status === 'error',
        isIdle: state.status === 'idle',
        mutate: this.mutate,
        reset: this.reset
      });

      this.currentResult = result;
    };

    _proto.notify = function notify(options) {
      var _this2 = this;

      notifyManager.batch(function () {
        // First trigger the mutate callbacks
        if (_this2.mutateOptions) {
          if (options.onSuccess) {
            _this2.mutateOptions.onSuccess == null ? void 0 : _this2.mutateOptions.onSuccess(_this2.currentResult.data, _this2.currentResult.variables, _this2.currentResult.context);
            _this2.mutateOptions.onSettled == null ? void 0 : _this2.mutateOptions.onSettled(_this2.currentResult.data, null, _this2.currentResult.variables, _this2.currentResult.context);
          } else if (options.onError) {
            _this2.mutateOptions.onError == null ? void 0 : _this2.mutateOptions.onError(_this2.currentResult.error, _this2.currentResult.variables, _this2.currentResult.context);
            _this2.mutateOptions.onSettled == null ? void 0 : _this2.mutateOptions.onSettled(undefined, _this2.currentResult.error, _this2.currentResult.variables, _this2.currentResult.context);
          }
        } // Then trigger the listeners


        if (options.listeners) {
          _this2.listeners.forEach(function (listener) {
            listener(_this2.currentResult);
          });
        }
      });
    };

    return MutationObserver;
  }(Subscribable);

  var unstable_batchedUpdates = ReactDOM__default["default"].unstable_batchedUpdates;

  notifyManager.setBatchNotifyFunction(unstable_batchedUpdates);

  var logger = console;

  setLogger(logger);

  var defaultContext = /*#__PURE__*/React__default["default"].createContext(undefined);
  var QueryClientSharingContext = /*#__PURE__*/React__default["default"].createContext(false); // if contextSharing is on, we share the first and at least one
  // instance of the context across the window
  // to ensure that if React Query is used across
  // different bundles or microfrontends they will
  // all use the same **instance** of context, regardless
  // of module scoping.

  function getQueryClientContext(contextSharing) {
    if (contextSharing && typeof window !== 'undefined') {
      if (!window.ReactQueryClientContext) {
        window.ReactQueryClientContext = defaultContext;
      }

      return window.ReactQueryClientContext;
    }

    return defaultContext;
  }

  var useQueryClient = function useQueryClient() {
    var queryClient = React__default["default"].useContext(getQueryClientContext(React__default["default"].useContext(QueryClientSharingContext)));

    if (!queryClient) {
      throw new Error('No QueryClient set, use QueryClientProvider to set one');
    }

    return queryClient;
  };

  function createValue() {
    var _isReset = false;
    return {
      clearReset: function clearReset() {
        _isReset = false;
      },
      reset: function reset() {
        _isReset = true;
      },
      isReset: function isReset() {
        return _isReset;
      }
    };
  }

  var QueryErrorResetBoundaryContext = /*#__PURE__*/React__default["default"].createContext(createValue()); // HOOK

  var useQueryErrorResetBoundary = function useQueryErrorResetBoundary() {
    return React__default["default"].useContext(QueryErrorResetBoundaryContext);
  }; // COMPONENT

  function shouldThrowError(suspense, _useErrorBoundary, error) {
    // Allow useErrorBoundary function to override throwing behavior on a per-error basis
    if (typeof _useErrorBoundary === 'function') {
      return _useErrorBoundary(error);
    } // Allow useErrorBoundary to override suspense's throwing behaviour


    if (typeof _useErrorBoundary === 'boolean') return _useErrorBoundary; // If suspense is enabled default to throwing errors

    return !!suspense;
  }

  function useMutation(arg1, arg2, arg3) {
    var mountedRef = React__default["default"].useRef(false);

    var _React$useState = React__default["default"].useState(0),
        forceUpdate = _React$useState[1];

    var options = parseMutationArgs(arg1, arg2, arg3);
    var queryClient = useQueryClient();
    var obsRef = React__default["default"].useRef();

    if (!obsRef.current) {
      obsRef.current = new MutationObserver(queryClient, options);
    } else {
      obsRef.current.setOptions(options);
    }

    var currentResult = obsRef.current.getCurrentResult();
    React__default["default"].useEffect(function () {
      mountedRef.current = true;
      var unsubscribe = obsRef.current.subscribe(notifyManager.batchCalls(function () {
        if (mountedRef.current) {
          forceUpdate(function (x) {
            return x + 1;
          });
        }
      }));
      return function () {
        mountedRef.current = false;
        unsubscribe();
      };
    }, []);
    var mutate = React__default["default"].useCallback(function (variables, mutateOptions) {
      obsRef.current.mutate(variables, mutateOptions).catch(noop);
    }, []);

    if (currentResult.error && shouldThrowError(undefined, obsRef.current.options.useErrorBoundary, currentResult.error)) {
      throw currentResult.error;
    }

    return _extends$1({}, currentResult, {
      mutate: mutate,
      mutateAsync: currentResult.mutate
    });
  }

  function useBaseQuery(options, Observer) {
    var mountedRef = React__default["default"].useRef(false);

    var _React$useState = React__default["default"].useState(0),
        forceUpdate = _React$useState[1];

    var queryClient = useQueryClient();
    var errorResetBoundary = useQueryErrorResetBoundary();
    var defaultedOptions = queryClient.defaultQueryObserverOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options

    defaultedOptions.optimisticResults = true; // Include callbacks in batch renders

    if (defaultedOptions.onError) {
      defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
    }

    if (defaultedOptions.onSuccess) {
      defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
    }

    if (defaultedOptions.onSettled) {
      defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
    }

    if (defaultedOptions.suspense) {
      // Always set stale time when using suspense to prevent
      // fetching again when directly mounting after suspending
      if (typeof defaultedOptions.staleTime !== 'number') {
        defaultedOptions.staleTime = 1000;
      } // Set cache time to 1 if the option has been set to 0
      // when using suspense to prevent infinite loop of fetches


      if (defaultedOptions.cacheTime === 0) {
        defaultedOptions.cacheTime = 1;
      }
    }

    if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {
      // Prevent retrying failed query if the error boundary has not been reset yet
      if (!errorResetBoundary.isReset()) {
        defaultedOptions.retryOnMount = false;
      }
    }

    var _React$useState2 = React__default["default"].useState(function () {
      return new Observer(queryClient, defaultedOptions);
    }),
        observer = _React$useState2[0];

    var result = observer.getOptimisticResult(defaultedOptions);
    React__default["default"].useEffect(function () {
      mountedRef.current = true;
      errorResetBoundary.clearReset();
      var unsubscribe = observer.subscribe(notifyManager.batchCalls(function () {
        if (mountedRef.current) {
          forceUpdate(function (x) {
            return x + 1;
          });
        }
      })); // Update result to make sure we did not miss any query updates
      // between creating the observer and subscribing to it.

      observer.updateResult();
      return function () {
        mountedRef.current = false;
        unsubscribe();
      };
    }, [errorResetBoundary, observer]);
    React__default["default"].useEffect(function () {
      // Do not notify on updates because of changes in the options because
      // these changes should already be reflected in the optimistic result.
      observer.setOptions(defaultedOptions, {
        listeners: false
      });
    }, [defaultedOptions, observer]); // Handle suspense

    if (defaultedOptions.suspense && result.isLoading) {
      throw observer.fetchOptimistic(defaultedOptions).then(function (_ref) {
        var data = _ref.data;
        defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
        defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
      }).catch(function (error) {
        errorResetBoundary.clearReset();
        defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
        defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);
      });
    } // Handle error boundary


    if (result.isError && !result.isFetching && shouldThrowError(defaultedOptions.suspense, defaultedOptions.useErrorBoundary, result.error)) {
      throw result.error;
    } // Handle result property usage tracking


    if (defaultedOptions.notifyOnChangeProps === 'tracked') {
      result = observer.trackResult(result);
    }

    return result;
  }

  function useQuery(arg1, arg2, arg3) {
    var parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    return useBaseQuery(parsedOptions, QueryObserver);
  }

  var toBase64 = function toBase64(obj) {
    return Buffer.from(JSON.stringify(obj)).toString('base64');
  };
  BigNumber.config({
    ROUNDING_MODE: BigNumber.ROUND_DOWN,
    EXPONENTIAL_AT: [-10, 20]
  });

  var num = function num(value) {
    if (value === void 0) {
      value = '0';
    }

    return new BigNumber(value);
  };

  var DEFAULT_NETWORK = {
    name: 'mainnet',
    chainID: 'colombus-5',
    lcd: 'https://lcd.terra.dev'
  };
  var TerraWebappContext = /*#__PURE__*/React$1.createContext({
    network: DEFAULT_NETWORK,
    client: new dist$1.LCDClient({
      URL: DEFAULT_NETWORK.lcd,
      chainID: DEFAULT_NETWORK.chainID
    }),
    taxCap: undefined,
    taxRate: undefined
  });

  function useTerraWebapp() {
    return React$1.useContext(TerraWebappContext);
  }

  TerraWebappContext.Consumer;
  /**
   * Wallet address of connected wallet
   * @returns string;
   */

  var useAddress = function useAddress() {
    var _connectedWallet$terr;

    var connectedWallet = useConnectedWallet();
    return (_connectedWallet$terr = connectedWallet == null ? void 0 : connectedWallet.terraAddress) != null ? _connectedWallet$terr : '';
  };

  var useDebounceValue = function useDebounceValue(value, delay) {
    // State and setters for debounced value
    var _useState = React$1.useState(value),
        debouncedValue = _useState[0],
        setDebouncedValue = _useState[1];

    React$1.useEffect(function () {
      // Update debounced value after delay
      var handler = setTimeout(function () {
        setDebouncedValue(value);
      }, delay); // Cancel the timeout if value changes (also on delay change or unmount)
      // This is how we prevent debounced value from updating if value is changed ...
      // .. within the delay period. Timeout gets cleared and restarted.

      return function () {
        clearTimeout(handler);
      };
    }, [value, delay] // Only re-call effect if value or delay changes
    );
    return debouncedValue;
  };

  var TxStep;

  (function (TxStep) {
    TxStep[TxStep["Idle"] = 0] = "Idle";
    TxStep[TxStep["Estimating"] = 1] = "Estimating";
    TxStep[TxStep["Ready"] = 2] = "Ready";
    TxStep[TxStep["Posting"] = 3] = "Posting";
    TxStep[TxStep["Broadcasting"] = 4] = "Broadcasting";
    TxStep[TxStep["Success"] = 5] = "Success";
    TxStep[TxStep["Failed"] = 6] = "Failed";
  })(TxStep || (TxStep = {}));

  var useTransaction = function useTransaction(_ref) {
    var msgs = _ref.msgs,
        onSuccess = _ref.onSuccess,
        _onError = _ref.onError;

    var _useTerraWebapp = useTerraWebapp(),
        client = _useTerraWebapp.client;

    var _useWallet = useWallet(),
        post = _useWallet.post;

    var address = useAddress();
    var debouncedMsgs = useDebounceValue(msgs, 200);

    var _useState = React$1.useState(TxStep.Idle),
        txStep = _useState[0],
        setTxStep = _useState[1];

    var _useState2 = React$1.useState(undefined),
        txHash = _useState2[0],
        setTxHash = _useState2[1];

    var _useState3 = React$1.useState(null),
        error = _useState3[0],
        setError = _useState3[1];

    var _useQuery = useQuery(['fee', debouncedMsgs, error], function () {
      if (debouncedMsgs == null || txStep != TxStep.Idle || error != null) {
        throw new Error('Error in estimaging fee');
      }

      setError(null);
      setTxStep(TxStep.Estimating);
      return client.tx.estimateFee(address, debouncedMsgs, {
        gasPrices: new dist$1.Coins([new dist$1.Coin('uusd', 0.15)]),
        gasAdjustment: 1.2,
        feeDenoms: ['uusd']
      });
    }, {
      enabled: debouncedMsgs != null && txStep == TxStep.Idle && error == null,
      refetchOnWindowFocus: false,
      retry: false,
      onSuccess: function onSuccess() {
        setTxStep(TxStep.Ready);
      },
      onError: function onError(e) {
        var _e$response, _e$response$data; // @ts-expect-error - don't know anything about error
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access


        if (e != null && (_e$response = e.response) != null && (_e$response$data = _e$response.data) != null && _e$response$data.error) {
          // @ts-expect-error - don't know anything about error
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          setError(e.response.data.error);
        } else {
          setError('Something went wrong');
        }

        setTxStep(TxStep.Idle);
      }
    }),
        fee = _useQuery.data;

    var _useMutation = useMutation(function (data) {
      return post(data);
    }, {
      onMutate: function onMutate() {
        setTxStep(TxStep.Posting);
      },
      onError: function onError(e) {
        if (e instanceof UserDenied) {
          setError('User Denied');
        } else if (e instanceof CreateTxFailed) {
          setError("Create Tx Failed: " + e.message);
        } else if (e instanceof TxFailed) {
          setError("Tx Failed: " + e.message);
        } else if (e instanceof Timeout) {
          setError('Timeout');
        } else if (e instanceof TxUnspecifiedError) {
          setError("Unspecified Error: " + e.message);
        } else {
          setError("Unknown Error: " + (e instanceof Error ? e.message : String(e)));
        }

        setTxStep(TxStep.Failed);
        _onError == null ? void 0 : _onError();
      },
      onSuccess: function onSuccess(data) {
        setTxStep(TxStep.Broadcasting);
        setTxHash(data.result.txhash);
      }
    }),
        mutate = _useMutation.mutate;

    var _useQuery2 = useQuery(['txInfo', txHash], function () {
      if (txHash == null) {
        return;
      }

      return client.tx.txInfo(txHash);
    }, {
      enabled: txHash != null,
      retry: true
    }),
        txInfo = _useQuery2.data;

    var reset = function reset() {
      setError(null);
      setTxHash(undefined);
      setTxStep(TxStep.Idle);
    };

    var submit = React$1.useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(fee == null || msgs == null || msgs.length < 1)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              mutate({
                msgs: msgs,
                fee: fee
              });

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })), [msgs, fee, mutate]);
    React$1.useEffect(function () {
      if (txInfo != null && txHash != null) {
        if (txInfo.code) {
          setTxStep(TxStep.Failed);
          _onError == null ? void 0 : _onError(txHash);
        } else {
          setTxStep(TxStep.Success);
          onSuccess == null ? void 0 : onSuccess(txHash);
        }
      }
    }, [txInfo, _onError, onSuccess, txHash]);
    React$1.useEffect(function () {
      if (error) {
        setError(null);
      }

      if (txStep != TxStep.Idle && txStep != TxStep.Success && txStep != TxStep.Failed && txHash == null) {
        setTxStep(TxStep.Idle);
      } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [debouncedMsgs]);
    return {
      fee: fee,
      submit: submit,
      txStep: txStep,
      txInfo: txInfo,
      txHash: txHash,
      error: error,
      reset: reset
    };
  };

  var minAmountReceive = function minAmountReceive(_ref) {
    var amount = _ref.amount,
        maxSpread = _ref.maxSpread;
    var rate1 = num("1").minus(maxSpread);
    return num(amount).times(rate1).toString();
  };
  var priceImpact = function priceImpact(_ref2) {
    var offerAmount = _ref2.offerAmount,
        maxSpread = _ref2.maxSpread;
    var amount = num(offerAmount);
    var spread = num(maxSpread);
    return spread.div(amount.plus(spread)).times("100").toString();
  };

  var simulate$1 = function simulate(_ref) {
    var client = _ref.client,
        swapRoute = _ref.swapRoute,
        token = _ref.token,
        amount = _ref.amount,
        _ref$reverse = _ref.reverse,
        reverse = _ref$reverse === void 0 ? false : _ref$reverse;

    if (swapRoute[0] == null) {
      return null;
    }

    var contract_addr = swapRoute[0].contract_addr;

    if (reverse) {
      return client.wasm.contractQuery(contract_addr, {
        reverse_simulation: {
          ask_asset: toAsset({
            token: token,
            amount: amount
          })
        }
      });
    }

    return client.wasm.contractQuery(contract_addr, {
      simulation: {
        offer_asset: toAsset({
          token: token,
          amount: amount
        })
      }
    });
  };
  var createSwapMsgs = function createSwapMsgs(_ref2, sender) {
    var swapRoute = _ref2.swapRoute,
        token = _ref2.token,
        amount = _ref2.amount,
        slippage = _ref2.slippage,
        price = _ref2.price;
    var contract_addr = swapRoute[0].contract_addr;
    var offerAsset = createAsset(amount, swapRoute);
    var isNative = isNativeAsset(offerAsset.info);

    if (isNative) {
      return [new dist$1.MsgExecuteContract(sender, contract_addr, {
        swap: {
          offer_asset: offerAsset,
          max_spread: slippage,
          belief_price: price
        }
      }, [new dist$1.Coin(token, amount)])];
    }

    return [new dist$1.MsgExecuteContract(sender, token, {
      send: {
        amount: amount,
        contract: contract_addr,
        msg: toBase64({
          swap: {
            max_spread: slippage,
            belief_price: price
          }
        })
      }
    })];
  };

  // const formatPair = (
  //   routes: Routes,
  //   pair: PairResponse,
  //   from: AssetInfo,
  //   to: AssetInfo,
  // ) => {
  //   const [tokenFrom, tokenTo] = getTokenDenoms([from, to]);
  //   const prevPairs = routes[tokenFrom] || {};
  //   return {
  //     [tokenFrom]: {
  //       ...prevPairs,
  //       [tokenTo]: pair,
  //     },
  //   };
  // };
  // export const formatPairsToRoutes = (pairs: PairResponse[]): Routes => {
  //   return pairs.reduce((routes, pair) => {
  //     const [tokenFirst, tokenSecond] = pair.asset_infos;
  //     return {
  //       ...routes,
  //       ...formatPair(routes, pair, tokenFirst, tokenSecond),
  //       ...formatPair(routes, pair, tokenSecond, tokenFirst),
  //     };
  //   }, {});
  // };
  var toRoutes = function toRoutes(allPairs, r, parentFrom, parentTo, parentContracts, index) {
    return r.map(function (v) {
      var contract_addr = v.contract_addr,
          asset_infos = v.asset_infos;

      var _getTokenDenoms = getTokenDenoms(asset_infos),
          token1 = _getTokenDenoms[0],
          token2 = _getTokenDenoms[1];

      var newParentContracts = [].concat(parentContracts, [contract_addr]);
      var from = parentTo ? parentTo : index == 0 ? token1 : token2;
      var to = from === token1 ? token2 : token1;
      var children = allPairs.filter(function (pair) {
        return findAsset(pair.asset_infos, to);
      }).filter(function (pair) {
        return pair.asset_infos.find(function (asset) {
          return getTokenDenom(asset) !== parentFrom && getTokenDenom(asset) !== parentTo;
        });
      }).filter(function (pair) {
        return pair.contract_addr !== contract_addr && !newParentContracts.includes(pair.contract_addr);
      });
      return {
        contract_addr: contract_addr,
        from: from,
        to: to,
        children: toRoutes(allPairs, children, from, to, newParentContracts)
      };
    });
  };
  var formatPairsToRoutes = function formatPairsToRoutes(pairs) {
    return [].concat(toRoutes(pairs, pairs, null, null, [], 0), toRoutes(pairs, pairs, null, null, [], 1));
  };

  var TerraswapContext = /*#__PURE__*/React$1.createContext({
    pairs: [],
    routes: null,
    tokens: null,
    data: null
  });
  var TerraswapProvider = function TerraswapProvider(_ref) {
    var children = _ref.children,
        data = _ref.data;

    var _useTerraWebapp = useTerraWebapp(),
        name = _useTerraWebapp.network.name;

    var pairs = React$1.useMemo(function () {
      return data[name].pairs;
    }, [data, name]);
    var tokens = React$1.useMemo(function () {
      return data[name].tokens;
    }, [data, name]);
    var routes = React$1.useMemo(function () {
      if (pairs.length == 0) {
        return null;
      }

      return formatPairsToRoutes(pairs);
    }, [pairs]);
    return /*#__PURE__*/React__default["default"].createElement(TerraswapContext.Provider, {
      value: {
        pairs: pairs,
        routes: routes,
        tokens: tokens,
        data: data
      }
    }, children);
  };
  function useTerraswap() {
    return React$1.useContext(TerraswapContext);
  }
  var TerraswapConsumer = TerraswapContext.Consumer;

  var useSwapRoute = function useSwapRoute(_ref) {
    var routes = _ref.routes,
        from = _ref.from,
        to = _ref.to;
    return React$1.useMemo(function () {
      var result = [];
      var done = false;
      var path = {};

      if (routes == null || from == null || to == null) {
        return null;
      }

      function traverse(route, key) {
        route.children.forEach(function (child) {
          if (!done) {
            if (child.to === to) {
              //if we found our target push it to the path
              path[key].push(child); //set result to the completed path

              result = path[key]; //set done to true to exit the search

              done = true;
            } else {
              path[key].push(child);
              return traverse(child, key);
            }
          }
        }); //if we leave our for loop but we are not done that means we failed to find our target
        //in this branch, as a result we need to pop each node out of our path before we return

        if (!done) {
          path[key].pop();
        }
      } //set an array of the root nodes of our product tree. These are super-categories that are
      //not saved in the item schema, possibly representing types of items, i.e. different schemas.


      var filteredRoutes = routes.filter(function (route) {
        return route.from === from;
      });
      filteredRoutes.forEach(function (child) {
        path[child.to] = [child];

        if (child.to === to) {
          //set result to the completed path
          result = path[child.to]; //set done to true to exit the search

          done = true;
          return;
        }

        traverse(child, child.to);
      });
      return result;
    }, [routes, from, to]);
  };

  var defaultContracts = {
    mainnet: {
      factory: "terra1fnywlw4edny3vw44x04xd67uzkdqluymgreu7g",
      router: "terra16t7dpwwgx9n3lq6l6te3753lsjqwhxwpday9zx"
    },
    testnet: {
      factory: "terra15jsahkaf9p0qu8ye873p0u5z6g07wdad0tdq43",
      router: "terra13wf295fj9u209nknz2cgqmmna7ry3d3j5kv7t4"
    }
  };
  var useContracts = function useContracts(initial) {
    var _useTerraWebapp = useTerraWebapp(),
        name = _useTerraWebapp.network.name;

    var contracts = initial != null ? initial : defaultContracts;
    return React$1.useMemo(function () {
      return contracts[name];
    }, [contracts, name]);
  };

  var getSwapOperations = function getSwapOperations(_ref) {
    var swapRoute = _ref.swapRoute,
        _ref$operations = _ref.operations,
        operations = _ref$operations === void 0 ? [] : _ref$operations;

    if (swapRoute == null || swapRoute.length === 0) {
      return operations;
    }

    var _swapRoute$ = swapRoute[0],
        from = _swapRoute$.from,
        to = _swapRoute$.to;
    var operation = {
      terra_swap: {
        offer_asset_info: toAssetInfo(from),
        ask_asset_info: toAssetInfo(to)
      }
    };

    if ([toAssetInfo(from), toAssetInfo(to)].every(isNativeAssetInfo)) {
      operation = {
        native_swap: {
          offer_denom: from,
          ask_denom: to
        }
      };
    }

    return getSwapOperations({
      swapRoute: swapRoute.slice(1),
      operations: [].concat(operations, [operation])
    });
  };
  var simulate = function simulate(_ref2) {
    var client = _ref2.client,
        swapRoute = _ref2.swapRoute,
        router = _ref2.router,
        amount = _ref2.amount;
    var operations = getSwapOperations({
      swapRoute: swapRoute
    });
    return client.wasm.contractQuery(router, {
      simulate_swap_operations: {
        offer_amount: amount,
        operations: operations
      }
    });
  };

  function isMultiSimulation(value) {
    return value.hasOwnProperty("amount");
  }

  function isReverseSimulation(value) {
    return value.hasOwnProperty("offer_amount");
  }

  var useSwapSimulate = function useSwapSimulate(_ref) {
    var swapRoute = _ref.swapRoute,
        token = _ref.token,
        amount = _ref.amount,
        reverse = _ref.reverse;

    var _useTerraWebapp = useTerraWebapp(),
        client = _useTerraWebapp.client;

    var _useContracts = useContracts(),
        router = _useContracts.router;

    var _useQuery = useQuery(["simulation", swapRoute, router, token, amount, reverse], function () {
      if (swapRoute == null || token == null || amount == null || swapRoute.length == 0) {
        return;
      }

      if (swapRoute.length > 1) {
        return simulate({
          client: client,
          swapRoute: swapRoute,
          router: router,
          token: token,
          amount: amount
        });
      }

      return simulate$1({
        client: client,
        swapRoute: swapRoute,
        token: token,
        amount: amount,
        reverse: reverse
      });
    }, {
      enabled: swapRoute != null
    }),
        data = _useQuery.data,
        isLoading = _useQuery.isLoading;

    return React$1.useMemo(function () {
      if (data == null || amount == null || isLoading) {
        return null;
      }

      if (isMultiSimulation(data)) {
        return {
          amount: data.amount,
          spread: "0",
          commission: "0",
          price: num(amount).div(data.amount).toFixed(18)
        };
      }

      var spread = data.spread_amount;
      var commission = data.commission_amount;

      if (isReverseSimulation(data)) {
        return {
          amount: data.offer_amount,
          spread: spread,
          commission: commission,
          price: num(data.offer_amount).div(amount).toFixed(18)
        };
      }

      return {
        amount: data.return_amount,
        spread: spread,
        commission: commission,
        price: num(amount).div(data.return_amount).toFixed(18)
      };
    }, [amount, data, isLoading]);
  };

  var _excluded = ["submit"];
  var useSwap = function useSwap(_ref) {
    var token1 = _ref.token1,
        token2 = _ref.token2,
        amount1 = _ref.amount1,
        amount2 = _ref.amount2,
        slippage = _ref.slippage,
        _ref$reverse = _ref.reverse,
        reverse = _ref$reverse === void 0 ? false : _ref$reverse,
        onSuccess = _ref.onSuccess,
        onError = _ref.onError;

    var _useTerraswap = useTerraswap(),
        routes = _useTerraswap.routes;

    var address = useAddress();
    var swapRoute = useSwapRoute({
      routes: routes,
      from: token1,
      to: token2
    });
    var simulated = useSwapSimulate({
      swapRoute: swapRoute,
      amount: reverse ? amount2 : amount1,
      token: reverse ? token2 : token1,
      reverse: reverse
    });
    var minReceive = React$1.useMemo(function () {
      if (simulated == null || amount2 == null) {
        return null;
      }

      return minAmountReceive({
        amount: reverse ? amount2 : simulated.amount,
        maxSpread: slippage
      });
    }, [simulated, slippage, amount2, reverse]);
    var msgs = React$1.useMemo(function () {
      if (swapRoute == null || token1 == null || amount1 == null || simulated == null) {
        return null;
      }

      if (swapRoute.length > 1) {
        return null;
      }

      return createSwapMsgs({
        token: token1,
        swapRoute: swapRoute,
        amount: amount1,
        slippage: slippage,
        price: simulated.price
      }, address);
    }, [address, token1, amount1, simulated, slippage, swapRoute]);

    var _useTransaction = useTransaction({
      msgs: msgs,
      onSuccess: onSuccess,
      onError: onError
    }),
        submit = _useTransaction.submit,
        rest = _objectWithoutPropertiesLoose$1(_useTransaction, _excluded);

    return _extends$1({}, rest, {
      simulated: simulated,
      minReceive: minReceive,
      swap: submit
    });
  };

  var useShareOfPool = function useShareOfPool(_ref) {
    var pool = _ref.pool,
        amount1 = _ref.amount1;
    return React$1.useMemo(function () {
      if (pool == null || amount1 == null || num(pool.total_share).isEqualTo(0)) {
        return null;
      }

      var token1Amount = pool.assets[0].amount;
      return num(amount1).div(token1Amount).toFixed(2);
    }, [pool, amount1]);
  };

  var useTokensToLp = function useTokensToLp(_ref) {
    var pool = _ref.pool,
        amount1 = _ref.amount1;
    var shareOfPool = useShareOfPool({
      pool: pool,
      amount1: amount1
    });
    return React$1.useMemo(function () {
      if (pool == null || amount1 == null || shareOfPool == null || num(amount1).isEqualTo(0)) {
        return null;
      }

      return num(shareOfPool).times(pool.total_share).toFixed();
    }, [pool, shareOfPool, amount1]);
  };

  var useLpToTokens = function useLpToTokens(_ref) {
    var pool = _ref.pool,
        amount = _ref.amount;
    return React$1.useMemo(function () {
      if (pool == null || amount == null || num(amount).isEqualTo(0)) {
        return null;
      }

      var assets = pool.assets,
          total_share = pool.total_share;
      return assets.reduce(function (acc, asset) {
        var _extends2;

        return _extends$1({}, acc, (_extends2 = {}, _extends2[getTokenDenom(asset.info)] = num(amount).times(asset.amount).div(total_share).toFixed(), _extends2));
      }, {});
    }, [pool, amount]);
  };

  var ONE_TOKEN = 1000000;
  var ESTIMATE_TOKEN = "uusd";

  var useTokenPriceInUst = function useTokenPriceInUst(token) {
    var _useTerraswap = useTerraswap(),
        routes = _useTerraswap.routes;

    var swapRoute = useSwapRoute({
      routes: routes,
      from: token,
      to: ESTIMATE_TOKEN
    });
    var data = useSwapSimulate({
      swapRoute: swapRoute,
      amount: String(ONE_TOKEN),
      token: token,
      reverse: false
    });

    if (token == "uusd") {
      return String(ONE_TOKEN);
    }

    if (data == null) {
      return null;
    }

    return num("1").div(data.price).times(ONE_TOKEN).toFixed();
  };

  var useTotalShareInUst = function useTotalShareInUst(_ref) {
    var pool = _ref.pool;
    var token1 = pool && getTokenDenom(pool.assets[0].info);
    var token2 = pool && getTokenDenom(pool.assets[1].info);
    var token1Price = useTokenPriceInUst(token1);
    var token2Price = useTokenPriceInUst(token2);
    var tokenAmounts = React$1.useMemo(function () {
      var _ref2;

      if (pool == null) {
        return null;
      }

      return _ref2 = {}, _ref2[getTokenDenom(pool.assets[0].info)] = pool.assets[0].amount, _ref2[getTokenDenom(pool.assets[1].info)] = pool.assets[1].amount, _ref2;
    }, [pool]);
    return React$1.useMemo(function () {
      if (pool == null || token1 == null || token2 == null || token1Price == null || token2Price == null || tokenAmounts == null || num(pool.total_share).isEqualTo(0)) {
        return null;
      }

      var totalPrice1 = num(tokenAmounts[token1]).times(token1Price).div(ONE_TOKEN);
      var totalPrice2 = num(tokenAmounts[token2]).times(token2Price).div(ONE_TOKEN);
      return totalPrice1.plus(totalPrice2).toFixed();
    }, [pool, token1, token2, token1Price, token2Price, tokenAmounts]);
  };

  var useTokenInfo = function useTokenInfo() {
    var _useTerraWebapp = useTerraWebapp(),
        name = _useTerraWebapp.network.name;

    var _useTerraswap = useTerraswap(),
        data = _useTerraswap.data;

    var getSymbol = React$1.useCallback(function (token) {
      if (data == null || token == null) {
        return null;
      }

      return data[name].tokens[token].symbol || token;
    }, [name, data]);
    var getIcon = React$1.useCallback(function (token) {
      if (data == null || token == null) {
        return null;
      }

      var info = data[name].tokens[token];
      return info.icon || null;
    }, [name, data]);
    return {
      getSymbol: getSymbol,
      getIcon: getIcon
    };
  };

  exports.TerraswapConsumer = TerraswapConsumer;
  exports.TerraswapContext = TerraswapContext;
  exports.TerraswapProvider = TerraswapProvider;
  exports.createAsset = createAsset;
  exports.findAsset = findAsset;
  exports.getTokenDenom = getTokenDenom;
  exports.getTokenDenoms = getTokenDenoms;
  exports.isNativeAsset = isNativeAsset;
  exports.isNativeAssetInfo = isNativeAssetInfo;
  exports.isNativeToken = isNativeToken;
  exports.minAmountReceive = minAmountReceive;
  exports.priceImpact = priceImpact;
  exports.toAsset = toAsset;
  exports.toAssetInfo = toAssetInfo;
  exports.useContracts = useContracts;
  exports.useLpToTokens = useLpToTokens;
  exports.useShareOfPool = useShareOfPool;
  exports.useSwap = useSwap;
  exports.useSwapRoute = useSwapRoute;
  exports.useSwapSimulate = useSwapSimulate;
  exports.useTerraswap = useTerraswap;
  exports.useTokenInfo = useTokenInfo;
  exports.useTokenPriceInUst = useTokenPriceInUst;
  exports.useTokensToLp = useTokensToLp;
  exports.useTotalShareInUst = useTotalShareInUst;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=terraswap.umd.js.map
